<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="403111ea96a944cbf2b6adc84b6c3caf3ed6e344" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58686820" /></Metadata><TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <TypeSignature Language="F#" Value="type DynamicObject = class&#xA;    interface IDynamicMetaObjectProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет базовый класс для указания динамического поведения во время выполнения. Этот класс должен наследоваться; непосредственно создавать его экземпляры нельзя.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DynamicObject` Класс позволяет определить, какие операции могут быть выполнены с динамическими объектами и как выполнять эти операции. Например можно определить, что происходит при попытке получить или задать свойства объекта, вызовите метод или выполнить стандартные операции, такие как сложение и умножение.  
  
 Этот класс можно использовать в том случае, если вы хотите создать более удобный протокол для библиотеки. Например, если пользователи библиотеки должны использовать синтаксис, как `Scriptobj.SetProperty("Count", 1)`, дает возможность использовать гораздо более простой синтаксис, например `scriptobj.Count = 1`.  
  
 Невозможно непосредственно создать экземпляр `DynamicObject` класса. Чтобы реализовать динамическое поведение, можно наследовать от `DynamicObject` класса и переопределять необходимые методы. Например, если вам требуется только операции для задания и получения свойства, можно переопределить только <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы.  
  
 В C#, чтобы включить динамическое поведение для экземпляров классов, производных от `DynamicObject` , необходимо использовать `dynamic` ключевое слово. Дополнительные сведения см. в разделе [Использование типа dynamic](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 В Visual Basic динамических операций поддерживаются с помощью позднего связывания. Дополнительные сведения см. в разделе [раннее и позднее связывание](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
 В следующем примере кода показано, как создать экземпляр класса, который является производным от `DynamicObject` класса.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 Можно также добавить собственные члены для классов, производных от `DynamicObject` класса. Если ваш класс определяет свойства, а также переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> метод, среда выполнения динамического языка (DLR) сначала используется связыватель языка для поиска статическое определение свойства в классе. Если такого свойства нет, среда DLR вызывает <xref:System.Dynamic.DynamicObject.TrySetMember%2A> метод.  
  
 `DynamicObject` Класс реализует интерфейс DLR <xref:System.Dynamic.IDynamicMetaObjectProvider>, которая позволяет совместно использовать экземпляры `DynamicObject` класса между языками, поддерживающими DLR-моделью взаимодействия. Например, можно создать экземпляр `DynamicObject` класса в C#, а затем передать его функции IronPython. Дополнительные сведения см. в разделе [Обзор среды выполнения динамического языка](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md).  
  
> [!NOTE]
>  Если у вас есть простой сценарий, в котором нужен объект, можно только добавлять и удалять членов во время выполнения, но, не нужно определять конкретные операции и не имеет статические члены, используйте <xref:System.Dynamic.ExpandoObject> класса.  
>   
>  Если у вас есть более сложным сценарием, в котором необходимо определить как динамические объекты участвовать в протоколе взаимодействия, или вам нужно управлять кэшированием быструю динамическую диспетчеризацию DLR, создайте собственную реализацию <xref:System.Dynamic.IDynamicMetaObjectProvider> интерфейс.  
  
   
  
## Examples  
 Предположим, что для обеспечения доступа к значениям в словаре, так, чтобы вместо написания альтернативный синтаксис `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` в Visual Basic), можно написать `sampleDictionary.Text = "Sample text"`. Кроме того, требуется следующий синтаксис, без учета регистра, таким образом, чтобы `sampleDictionary.Text` эквивалентен `sampleDictionary.text`.  
  
 В следующем примере кода показано `DynamicDictionary` класс, который является производным от `DynamicObject` класса. `DynamicDictionary` Класс содержит объект `Dictionary<string, object>` тип (`Dictionary(Of String, Object)` в Visual Basic) для хранения пар "ключ значение" и переопределения <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для поддержки нового синтаксиса. Он также предоставляет `Count` содержит свойство, которое показывает количество динамические свойства словаря.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 Дополнительные примеры см. в разделе [создание оберток с DynamicObject](https://devblogs.microsoft.com/csharpfaq/dynamic-in-c-4-0-creating-wrappers-with-dynamicobject/) в блоге C# часто задаваемые вопросы.  
 
 
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Позволяет производным типам инициализировать новый экземпляр типа <see cref="T:System.Dynamic.DynamicObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Невозможно непосредственно создать экземпляр <xref:System.Dynamic.DynamicObject> класса. Чтобы реализовать динамическое поведение, необходимо наследовать от <xref:System.Dynamic.DynamicObject> класса и переопределять необходимые методы.  
  
 В C#, чтобы включить динамическое поведение для экземпляров классов, производных от <xref:System.Dynamic.DynamicObject> , необходимо использовать `dynamic` ключевое слово. Дополнительные сведения см. в разделе [Использование типа dynamic](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 В Visual Basic динамических операций поддерживаются с помощью позднего связывания. Дополнительные сведения см. в разделе [раннее и позднее связывание](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
   
  
## Examples  
 В следующем примере кода показано, как создавать экземпляры классов, которые являются производными от <xref:System.Dynamic.DynamicObject> класса.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberSignature Language="F#" Value="abstract member GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;&#xA;override this.GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;" Usage="dynamicObject.GetDynamicMemberNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечисление имен всех динамических членов.</summary>
        <returns>Последовательность, содержащая имена динамических членов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен только для отладки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject&#xA;override this.GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject" Usage="dynamicObject.GetMetaObject parameter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">Выражение, представляющее объект <see cref="T:System.Dynamic.DynamicMetaObject" />, вызывающий динамические виртуальные методы.</param>
        <summary>Предоставляет объект <see cref="T:System.Dynamic.DynamicMetaObject" />, вызывающий динамические виртуальные методы. Объект можно инкапсулировать в другой объект <see cref="T:System.Dynamic.DynamicMetaObject" />, чтобы обеспечить пользовательское поведение для отдельных действий. Данный метод поддерживает инфраструктуру среды DLR для разработчиков языков и не предназначен для непосредственного использования из кода.</summary>
        <returns>Объект типа <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool&#xA;override this.TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool" Usage="dynamicObject.TryBinaryOperation (binder, arg, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения о двоичной операции. Свойство <c>binder.Operation</c> возвращает объект <see cref="T:System.Linq.Expressions.ExpressionType" />. Например, для оператора <c>sum = аргумент1 + аргумент2</c>, в котором <c>аргумент1</c> и <c>аргумент2</c> являются производными от класса <see langword="DynamicObject" />, <c>binder.Operation</c> возвращает <c>ExpressionType.Add</c>.</param>
        <param name="arg">Правый операнд для двоичной операции. Например, для оператора <c>sum = аргумент1 + аргумент2</c>, в котором <c>аргумент1</c> и <c>аргумент2</c> являются производными от класса <see langword="DynamicObject" />, <paramref name="arg" /> равно <c>аргумент2</c>.</param>
        <param name="result">Результат двоичной операции.</param>
        <summary>Предоставляет реализацию для двоичных операций. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для таких операций, как сложение и умножение.</summary>
        <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять бинарные операции для динамического объекта. Если метод не переопределен, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 Этот метод вызывается, когда у вас есть двоичные операции, такие как сложение или умножение. Например если <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> переопределяется метод, он автоматически вызывается для инструкций, например `sum = first + second` или `multiply = first*second`, где `first` является производным от `DynamicObject` класса.  
  
 Сведения о типе бинарной операции можно получить с помощью `Operation` свойство `binder` параметр.  
  
 Если ваш динамический объект используется только в C# и Visual Basic, `binder.Operation` свойство может принимать одно из следующих значений из <xref:System.Linq.Expressions.ExpressionType> перечисления. Однако в других языках, таких как IronPython или IronRuby, может иметь другие значения.
  
|Значение|Описание|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|Операции сложения без проверки переполнения для числовых операндов.|`a + b`|`a + b`|  
|`AddAssign`|Операция составного присваивания сложения без проверки переполнения для числовых операндов.|`a += b`|Не поддерживается.|  
|`And`|Побитовый `AND` операции.|`a & b`|`a And b`|  
|`AndAssign`|Побитовый `AND` Операция составного присваивания.|`a &= b`|Не поддерживается.|  
|`Divide`|Операция арифметического деления.|`a / b`|`a / b`|  
|`DivideAssign`|Операция составного присваивания арифметического деления.|`a /= b`|Не поддерживается.|  
|`ExclusiveOr`|Побитовый `XOR` операции.|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|Побитовый `XOR` Операция составного присваивания.|`a ^= b`|Не поддерживается.|  
|`GreaterThan`|Сравнение «больше».|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|Сравнение «больше или равно».|`a >= b`|Не поддерживается.|  
|`LeftShift`|Побитовая операция сдвига влево.|`a << b`|`a << b`|  
|`LeftShiftAssign`|Операция составного присваивания побитового сдвига влево.|`a <<= b`|Не поддерживается.|  
|`LessThan`|Сравнение «меньше».|`a < b`|`a < b`|  
|`LessThanOrEqual`|«Меньше или равно» сравнение.|`a <= b`|Не поддерживается.|  
|`Modulo`|Операция арифметического остатка.|`a % b`|`a Mod b`|  
|`ModuloAssign`|Операция составного присваивания арифметического остатка.|`a %= b`|Не поддерживается.|  
|`Multiply`|Операция арифметического умножения без проверки переполнения для числовых операндов.|`a * b`|`a * b`|  
|`MultiplyAssign`|Операция составного присваивания умножения без проверки переполнения для числовых операндов.|`a *= b`|Не поддерживается.|  
|`NotEqual`|Сравнение неравенства.|`a != b`|`a <> b`|  
|`Or`|Побитовая или логическая `OR` операции.|`a &#124; b`|`a Or b`|  
|`OrAssign`|Побитовая или логическая `OR` составного присваивания.|`a &#124;= b`|Не поддерживается.|  
|`Power`|Математическая операция возведения числа в степень.|Не поддерживается.|`a ^ b`|  
|`RightShift`|Побитовая операция сдвига вправо.|`a >> b`|`a >> b`|  
|`RightShiftAssign`|Операция составного присваивания побитового сдвига вправо.|`a >>= b`|Не поддерживается.|  
|`Subtract`|Операция арифметического вычитания без проверки переполнения для числовых операндов.|`a - b`|`a - b`|  
|`SubtractAssign`|Операция составного присваивания арифметического вычитания без проверки переполнения для числовых операндов.|`a -= b`|Не поддерживается.|  
  
> [!NOTE]
>  Для реализации `OrElse` (`a || b`) и `AndAlso` (`a && b`) операций для динамические объекты в C#, может потребоваться реализовать оба <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> метод и <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> метод.  
>   
>  `OrElse` Операция состоит из унарный `IsTrue` операции и двоичный `Or` операции. `Or` Операция выполняется только в том случае, если результат `IsTrue` операции `false`.  
>   
>  `AndAlso` Операция состоит из унарный `IsFalse` операции и двоичный `And` операции. `And` Операция выполняется только в том случае, если результат `IsFalse` операции `false`.  
  
   
  
## Examples  
 Предположим, что структура данных для хранения числовых и текстовых представлений чисел, и вы хотите определить основные операции, такие как сложение и вычитание для таких данных.  
  
 В следующем примере кода показано `DynamicNumber` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicNumber` переопределяет <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> способ включения математических операций. Оно также переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для доступа к элементам.  
  
 В этом примере поддерживаются только операции сложения и вычитания. Если попытаться написать инструкцию как `resultNumber = firstNumber*secondNumber`, создается исключение времени выполнения.  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool&#xA;override this.TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool" Usage="dynamicObject.TryConvert (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об операции преобразования. Свойство <c>binder.Type</c> предоставляет тип, в который должен быть преобразован объект. Например, для оператора <c>(String)sampleObject</c> в C# (<c>CType(sampleObject, Type)</c> в Visual Basic), в котором <c>sampleObject</c> является экземпляром класса, производного от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> возвращает тип <see cref="T:System.String" />. Свойство <c>binder.Explicit</c> предоставляет сведения о виде преобразования, который имеет место. Для явного преобразования возвращается значение <see langword="true" />, для неявного — значение <see langword="false" />.</param>
        <param name="result">Результат операции преобразования типа.</param>
        <summary>Предоставляет реализацию для операций преобразования типа. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для операций, преобразующих объект из одного типа в другой.</summary>
        <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять преобразование типа для динамического объекта. Если метод не переопределен, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 В C# Если этот метод переопределен, он автоматически вызывается при наличии явного или неявного преобразования, как показано в следующем примере кода.  
  
 В Visual Basic поддерживается только явное преобразование. Если вы Переопределите этот метод, он вызывается с помощью <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> или <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> функции.  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 Предположим, что структура данных для хранения числовых и текстовых представлений чисел, и вы хотите определить преобразования этой структуры данных в строки и целые числа.  
  
 В следующем примере кода показано `DynamicNumber` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicNumber` переопределяет <xref:System.Dynamic.DynamicObject.TryConvert%2A> способ включения преобразование типов. Оно также переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для доступа к элементам данных.  
  
 В этом примере поддерживается только преобразование в строки и целые числа. При попытке преобразовать объект любого другого типа, создается исключение времени выполнения.  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool&#xA;override this.TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryCreateInstance (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об операции инициализации.</param>
        <param name="args">Аргументы, переданные объекту во время инициализации. Например, для операции <c>new SampleType(100)</c>, в которой <c>SampleType</c> является типом, производным от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> равно 100.</param>
        <param name="result">Результат инициализации.</param>
        <summary>Предоставляет реализацию для операций, инициализирующих новый экземпляр динамического объекта. Этот метод не предназначен для использования в C# или Visual Basic.</summary>
        <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, каким образом следует инициализировать новый экземпляр динамического объекта. Если метод не переопределен, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 C# и Visual Basic компиляторы никогда не выпускают код для использования этого метода, поскольку они не поддерживают типы первого класса. Этот метод предназначен для языков, поддерживающих инициализацию динамических объектов, используя следующий синтаксис `dynamic new`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool&#xA;override this.TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool" Usage="dynamicObject.TryDeleteIndex (binder, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об удалении.</param>
        <param name="indexes">Удаляемые индексы.</param>
        <summary>Предоставляет реализацию для операций, удаляющих объект по индексу. Этот метод не предназначен для использования в C# или Visual Basic.</summary>
        <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, каким образом следует удалять значение с указанным индексом. Если метод не переопределен, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 C# и Visual Basic компиляторы никогда не выпускают код для использования этого метода, поскольку они не поддерживают операции такого типа. Этот метод предназначен для языков, которые поддерживают синтаксис для удаления объектов по индексу, такие как `del sampleObject[1,2]` в Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool&#xA;override this.TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool" Usage="dynamicObject.TryDeleteMember binder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об удалении.</param>
        <summary>Предоставляет реализацию для операций, удаляющих элемент объекта. Этот метод не предназначен для использования в C# или Visual Basic.</summary>
        <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, каким образом должен быть удален элемент объекта. Если этот метод не переопределен, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 C# и Visual Basic компиляторы никогда не выпускают код для использования этого метода, поскольку они не поддерживают операции такого типа. Этот метод предназначен для языков, которые поддерживают синтаксис для удаления элементов, таких как `del sampleObject.SampleMember` в Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool&#xA;override this.TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryGetIndex (binder, indexes, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об операции.</param>
        <param name="indexes">Индексы, которые используются в операции. Например, для операции <c>sampleObject[3]</c> в C# (<c>sampleObject(3)</c> в Visual Basic), в которой <c>sampleObject</c> является производным от класса <see langword="DynamicObject" />, <c>indexes[0]</c> равно 3.</param>
        <param name="result">Результат операции индексации.</param>
        <summary>Предоставляет реализацию для операций, получающих значение по индексу. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для операций индексации.</summary>
        <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как получение значения по индексу должно выполняться для динамического объекта. Если метод не переопределен, поведение определяется связывателем среды языка. (В большинстве случаев создается исключение во время выполнения).  
  
 Если этот метод переопределен, он автоматически вызывается при наличии такой операции, как `sampleObject[3]` в C# или `sampleObject(3)` в Visual Basic, где `sampleObject` является производным от <xref:System.Dynamic.DynamicObject> класса.  
  
   
  
## Examples  
 Предполагается, что вы хотите создать объект, в котором свойства могут быть доступ к по именам например `Property0`, `Property1`, и т. д., или по индексу, таким образом, чтобы, например `sampleObject.Property0` эквивалентен `sampleObject[0]` в C# или `sampleObject(0)` в Visual Basic.  
  
 В следующем примере кода показано `SampleDynamicObject` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `SampleDynamicObject` Класс содержит объект `Dictionary<string, object>` тип (`Dictionary(Of String, Object)` в Visual Basic) для хранения пар "ключ значение". `SampleDynamicObject` переопределяет <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> и <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> методы для доступа с помощью индекса. Этот параметр переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методов, чтобы включить доступ по имени свойства.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool&#xA;override this.TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool" Usage="dynamicObject.TryGetMember (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об объекте, вызвавшем динамическую операцию. Свойство <c>binder.Name</c> предоставляет имя члена, с которым выполняется динамическая операция. Например, для оператора <c>Console.WriteLine(sampleObject.SampleProperty)</c>, в котором <c>sampleObject</c> является экземпляром класса, производного от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> возвращает "SampleProperty". Свойство <c>binder.IgnoreCase</c> задает, учитывается ли регистр в имени члена.</param>
        <param name="result">Результат операции получения. Например, если для свойства вызывается метод, можно присвоить свойству значение <paramref name="result" />.</param>
        <summary>Предоставляет реализацию для операций, получающих значения членов. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для таких операций, как получение значения свойства.</summary>
        <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять операции, которые получают значения членов, для динамического объекта. Если метод не переопределен, поведение определяется связывателем среды языка. (В большинстве случаев создается исключение во время выполнения).  
  
 Этот метод вызывается при наличии таких инструкциях, как `Console.WriteLine(sampleObject.SampleProperty)`, где `sampleObject` является экземпляром класса, производного от <xref:System.Dynamic.DynamicObject> класса.  
  
 Можно также добавить собственные члены для классов, производных от `DynamicObject` класса. Если ваш класс определяет свойства, а также переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> метод, среда выполнения динамического языка (DLR) сначала используется связыватель языка для поиска статическое определение свойства в классе. Если такого свойства нет, среда DLR вызывает <xref:System.Dynamic.DynamicObject.TrySetMember%2A> метод.  
  
   
  
## Examples  
 Предположим, что для обеспечения доступа к значениям в словаре, так, чтобы вместо написания альтернативный синтаксис `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` в Visual Basic), можно написать `sampleDictionary.Text = "Sample text"`. Кроме того, этот синтаксис должен быть без учета регистра, таким образом, чтобы `sampleDictionary.Text` эквивалентен `sampleDictionary.text`.  
  
 В следующем примере кода показано `DynamicDictionary` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicDictionary` Класс содержит объект `Dictionary<string, object>` тип (`Dictionary(Of String, Object)` в Visual Basic) для хранения пар "ключ значение" и переопределения <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для поддержки нового синтаксиса. Он также предоставляет `Count` содержит свойство, которое показывает количество динамические свойства словаря.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool&#xA;override this.TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvoke (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об операции вызова.</param>
        <param name="args">Аргументы, переданные объекту во время операции вызова. Например, для операции <c>sampleObject(100)</c>, в которой <c>sampleObject</c> является производным от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> равно 100.</param>
        <param name="result">Результат вызова объекта.</param>
        <summary>Предоставляет реализацию для операций, вызывающих объект. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для таких операций, как вызов объекта или делегата.</summary>
        <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять операции, вызывающие объект для динамического объекта. Если метод не переопределен, поведение определяется связывателем среды языка. (В большинстве случаев создается исключение во время выполнения).  
  
 Если этот метод переопределен, он автоматически вызывается при наличии такой операции, как `sampleObject(100)`, где `sampleObject` является производным от <xref:System.Dynamic.DynamicObject> класса.  
  
 Операция для вызова объекта поддерживается в C#, но не в Visual Basic. Компилятор Visual Basic не выдает код для использования этого метода, и язык Visual Basic не поддерживает синтаксис, как `sampleObject(100)`.  
  
   
  
## Examples  
 Предположим, что структура данных для хранения числовых и текстовых представлений чисел. Вы хотите иметь возможность для указания значения для каждого свойства по отдельности и иметь возможность инициализировать все свойства в одной инструкции.  
  
 В следующем примере кода показано `DynamicNumber` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicNumber` переопределяет <xref:System.Dynamic.DynamicObject.TryInvoke%2A> метод, чтобы включить инициализацию всех свойств за один раз. Оно также переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для доступа к свойствам отдельного объекта.  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool&#xA;override this.TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvokeMember (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения о динамической операции. Свойство <c>binder.Name</c> предоставляет имя члена, с которым выполняется динамическая операция. Например, для оператора <c>sampleObject.SampleMethod(100)</c>, в котором <c>sampleObject</c> является экземпляром класса, производного от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> возвращает "SampleMethod". Свойство <c>binder.IgnoreCase</c> задает, учитывается ли регистр в имени члена.</param>
        <param name="args">Аргументы, переданные члену объекта во время операции вызова. Например, для оператора <c>sampleObject.SampleMethod(100)</c>, в котором <c>sampleObject</c> является производным от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> равно 100.</param>
        <param name="result">Результат вызова члена.</param>
        <summary>Предоставляет реализацию для операций, вызывающих член. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для таких операций, как вызов метода.</summary>
        <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять операции, которые вызывают член объекта, для динамического объекта. Если метод не переопределен, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 Если этот метод переопределен, он вызывается автоматически при выполнении операции, такие как `sampleObject.SampleMethod(100)`, где `sampleObject` является производным от `DynamicObject` класса.  
  
 Можно также добавить собственные методы для классов, которые являются производными от <xref:System.Dynamic.DynamicObject> класса. Например, если вы Переопределите <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> метод, динамическую диспетчеризацию система сначала пытается определить, существует ли указанный метод в классе. Если не удается найти метод, он использует <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> реализации.  
  
 Этот метод не поддерживает `ref` и `out` параметров. Все параметры в `args` массива, передаются по значению.  
  
   
  
## Examples  
 Предположим, что для обеспечения доступа к значениям в словаре, так, чтобы вместо написания альтернативный синтаксис `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` в Visual Basic), можно написать `sampleDictionary.Text = "Sample text"`. Кроме того вы хотите иметь возможность вызывать все методы стандартного словаря для данного словаря.  
  
 В следующем примере кода показано `DynamicDictionary` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicDictionary` Класс содержит объект `Dictionary<string, object>` тип (`Dictionary(Of String, Object)` в Visual Basic) для хранения пар "ключ значение". Этот параметр переопределяет <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> метод для поддержки методов <xref:System.Collections.Generic.Dictionary%602> класс и переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для поддержки нового синтаксиса. Он также предоставляет `Print` метод, который выводит на экран все словарь ключей и значений.  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool&#xA;override this.TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TrySetIndex (binder, indexes, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об операции.</param>
        <param name="indexes">Индексы, которые используются в операции. Например, для операции <c>sampleObject[3] = 10</c> в C# (<c>sampleObject(3) = 10</c> в Visual Basic), в которой <c>sampleObject</c> является производным от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>indexes[0]</c> равно 3.</param>
        <param name="value">Значение, которое необходимо задать для объекта с заданным индексом. Например, для операции <c>sampleObject[3] = 10</c> в C# (<c>sampleObject(3) = 10</c> в Visual Basic), в которой <c>sampleObject</c> является производным от класса <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> равно 10.</param>
        <summary>Предоставляет реализацию для операций, задающих значение по индексу. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для операций, осуществляющих доступ к объектам по заданному индексу.</summary>
        <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять операции, которые обращаются к объекта по индексу для динамического объекта. Если метод не переопределен, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 Если этот метод переопределен, он автоматически вызывается при наличии такой операции, как `sampleObject[3] = 10` в C# или `sampleObject(3) = 10` в Visual Basic, где `sampleObject` является производным от <xref:System.Dynamic.DynamicObject> класса.  
  
   
  
## Examples  
 Предполагается, что вы хотите создать объект, в котором свойства могут быть доступ к по именам например `Property0`, `Property1`, и т. д., или по индексу, таким образом, чтобы, например `sampleObject.Property0` эквивалентен `sampleObject[0]` в C# или `sampleObject(0)` в Visual Basic.  
  
 В следующем примере кода показано `SampleDynamicObject` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `SampleDynamicObject` Класс содержит объект `Dictionary<string, object>` тип (`Dictionary(Of String, Object)` в Visual Basic) для хранения пар "ключ значение". `SampleDynamicObject` переопределяет <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> и <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> методы для доступа с помощью индекса. Этот параметр переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методов, чтобы включить доступ по имени свойства.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool&#xA;override this.TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool" Usage="dynamicObject.TrySetMember (binder, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об объекте, вызвавшем динамическую операцию. Свойство <c>binder.Name</c> предоставляет имя члена, которому присваивается значение. Например, для оператора <c>sampleObject.SampleProperty = "Test"</c>, в котором <c>sampleObject</c> является экземпляром класса, производного от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> возвращает "SampleProperty". Свойство <c>binder.IgnoreCase</c> задает, учитывается ли регистр в имени члена.</param>
        <param name="value">Значение, задаваемое для члена. Например, для оператора <c>sampleObject.SampleProperty = "Test"</c>, в котором <c>sampleObject</c> является экземпляром класса, производного от класса <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> равно "Test".</param>
        <summary>Предоставляет реализацию для операций, задающих значения членов. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для таких операций, как задание значения свойства.</summary>
        <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять операции, задайте значение для члена для динамического объекта. Если метод не переопределен, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 Этот метод вызывается при наличии таких инструкциях, как `sampleObject.SampleProperty = "Test"`, где `sampleObject` является экземпляром класса, который является производным от <xref:System.Dynamic.DynamicObject> класса.  
  
 Можно также добавить собственные члены для классов, производных от `DynamicObject` класса. Если ваш класс определяет свойства, а также переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> метод, среда выполнения динамического языка (DLR) сначала используется связыватель языка для поиска статическое определение свойства в классе. Если такого свойства нет, среда DLR вызывает <xref:System.Dynamic.DynamicObject.TrySetMember%2A> метод.  
  
   
  
## Examples  
 Предположим, что для обеспечения доступа к значениям в словаре, так, чтобы вместо написания альтернативный синтаксис `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` в Visual Basic), можно написать `sampleDictionary.Text = "Sample text"`. Кроме того, этот синтаксис должен быть без учета регистра, таким образом, чтобы `sampleDictionary.Text` эквивалентен `sampleDictionary.text`.  
  
 В следующем примере кода показано `DynamicDictionary` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicDictionary` Класс содержит объект `Dictionary<string, object>` тип (`Dictionary(Of String, Object)` в Visual Basic) для хранения пар "ключ значение" и переопределения <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для поддержки нового синтаксиса. Он также предоставляет `Count` содержит свойство, которое показывает количество динамические свойства словаря.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool&#xA;override this.TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool" Usage="dynamicObject.TryUnaryOperation (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об унарной операции. Свойство <c>binder.Operation</c> возвращает объект <see cref="T:System.Linq.Expressions.ExpressionType" />. Например, для оператора <c>negativeNumber = -number</c>, в котором <c>number</c> является производным от класса <see langword="DynamicObject" />, <c>binder.Operation</c> возвращает "Negate".</param>
        <param name="result">Результат унарной операции.</param>
        <summary>Предоставляет реализацию для унарных операций. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для таких операций, как вычитание, увеличение или уменьшение.</summary>
        <returns>Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять унарные операции для динамического объекта. Если метод не переопределен, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 Этот метод вызывается, когда у вас унарные операции, такие как вычитание, увеличение или уменьшение. Например если <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> переопределяется метод, этот метод автоматически вызывается для инструкций, например `negativeNumber = -number`, где `number` является производным от <xref:System.Dynamic.DynamicObject> класса.  
  
 Сведения о типе унарной операции можно получить с помощью `Operation` свойство `binder` параметр.  
  
 Если ваш динамический объект используется только в C# и Visual Basic, `binder.Operation` свойство может принимать одно из следующих значений из <xref:System.Linq.Expressions.ExpressionType> перечисления. Однако в других языках, таких как IronPython или IronRuby, может иметь другие значения.
  
|Значение|Описание|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|Унарная операция декремента.|`a--`|Не поддерживается.|  
|`Increment`|Унарная операция инкремента.|`a++`|Не поддерживается.|  
|`Negate`|Арифметического изменения знака.|`-a`|`-a`|  
|`Not`|Логическое отрицание.|`!a`|`Not a`|  
|`OnesComplement`|Единицы дополнения до единицы.|`~a`|Не поддерживается.|  
|`IsFalse`|Значение false условие.|`a && b`|Не поддерживается.|  
|`IsTrue`|Значение true, условие.|`a &#124;&#124; b`|Не поддерживается.|  
|`UnaryPlus`|Оператор унарного сложения.|`+a`|`+a`|  
  
> [!NOTE]
>  Для реализации `OrElse` (`a || b`) и `AndAlso` (`a && b`) операций для динамические объекты в C#, может потребоваться реализовать оба <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> метод и <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> метод.  
>   
>  `OrElse` Операция состоит из унарный `IsTrue` операции и двоичный `Or` операции. `Or` Операция выполняется только в том случае, если результат `IsTrue` операции `false`.  
>   
>  `AndAlso` Операция состоит из унарный `IsFalse` операции и двоичный `And` операции. `And` Операция выполняется только в том случае, если результат `IsFalse` операции `false`.  
  
   
  
## Examples  
 Предположим, что структура данных для хранения числовых и текстовых представлений чисел, и вы хотите определить операцию математического отрицания для таких данных.  
  
 В следующем примере кода показано `DynamicNumber` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicNumber` переопределяет <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> способ включения математическую операцию. Также является переопределения <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для доступа к элементам.  
  
 В этом примере поддерживается только операция математического отрицания. Если попытаться написать инструкцию как `negativeNumber = +number`, возникает исключение времени выполнения.  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
