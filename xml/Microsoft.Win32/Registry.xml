<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fbb10cf1ae1ba178f358249995f8fab8a47fa85b" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56776331" /></Metadata><TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет объекты <see cref="T:Microsoft.Win32.RegistryKey" />, представляющие корневые разделы в реестре Windows, и методы <see langword="static" /> для доступа к парам "раздел-значение".</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс предоставляет набор стандартных корневых ключей, найден в реестре на компьютерах под управлением Windows. Реестр является блоком памяти, сведения о приложениях, пользователях и системных настройках по умолчанию. Например приложения можно использовать реестр для хранения сведений, которые необходимо сохранить после закрытия приложения и получить доступ к этой информации после перезагрузки приложения. Например можно хранить параметры цвета, положение и размер окна. Вы можете управлять эти данные для каждого пользователя, сохраняя данные в другое расположение в реестре.  
  
 Базовое или корневое <xref:Microsoft.Win32.RegistryKey> экземпляров, предоставляемые `Registry` класс захватывают базового механизма хранения для подразделы и значения в реестре. Все ключи доступны только для чтения, так как реестр зависит от их существования. Ключи, предоставляемые `Registry` являются:  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 Хранит сведения о настройках пользователя.  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 Сохраняет сведения о конфигурации для локального компьютера.  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 Хранит сведения о типах (и классы) и их свойства.  
  
 <xref:Microsoft.Win32.Registry.Users>  
 Хранит сведения о стандартной пользовательской конфигурации.  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 Хранит сведения о производительности для компонентов программного обеспечения.  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 Хранит сведения пользователя конкретного оборудования.  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 Сохранение динамических данных.  
  
 После определения корневого ключа, с которой требуется для хранения или извлечения информации из реестра, можно использовать <xref:Microsoft.Win32.RegistryKey> класса, чтобы добавить или удалить подразделы и обработки значений для заданного ключа.  
  
 Устройства можно поместить сведения в реестре, автоматически с помощью интерфейса Plug and Play. Программное обеспечение для установки драйверов устройств можно поместить сведения в реестре, записывая стандартные API-интерфейсы.  
  
## <a name="static-methods-for-getting-and-setting-values"></a>Статические методы для получения и задания значений  
 В .NET Framework версии 2.0 <xref:Microsoft.Win32.Registry> класс также содержит `static` <xref:Microsoft.Win32.Registry.GetValue%2A> и <xref:Microsoft.Win32.Registry.SetValue%2A> методы для задания и получения значений разделов реестра. Эти методы открыть и закрыть параметры реестра каждый раз, они используются, поэтому они не выполняют, а также аналогичные методы в <xref:Microsoft.Win32.RegistryKey> класса, при доступе к большое количество значений.  
  
 <xref:Microsoft.Win32.RegistryKey> Класс также предоставляет методы, которые можно было задать безопасность управления доступом Windows для разделов реестра, чтобы проверить тип данных значения перед его возвращением и удалить ключи.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере показано корневые ключи, а во втором примере показывается `static` <xref:Microsoft.Win32.Registry.GetValue%2A> и <xref:Microsoft.Win32.Registry.SetValue%2A> методы.  
  
 Пример 1  
  
 В следующем примере кода показано, как получить подразделов для раздела реестра HKEY_USERS и печатать их имена на экран. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод, чтобы создать экземпляр ключа. Затем можно использовать другие операции в `RegistryKey` для работы с этим ключом.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода сохраняет значения из нескольких типов данных реестра, создание ключа, так как он делает это, а затем извлекает и отображает значения. В примере показано, хранения и извлечения пары (номерами безымянные) имя значение по умолчанию, а также использование `defaultValue` при пару имя значение не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет типы (или классы) документов и свойства, связанные с этими типами. Это поле считывает базовый раздел реестра Windows HKEY_CLASSES_ROOT.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В стандартных приложениях и OLE-приложения используйте данные, хранящиеся в этом разделе. Этот ключ также обеспечивает обратную совместимость с базой данных регистрации Windows 3.1, сохраняя информацию для поддержки DDE и OLE. Программы просмотра файлов и расширения пользовательского интерфейса сохраняют свои идентификаторы класса OLE в этот ключ и регистрации серверов обработки в этом разделе.  
  
   
  
## Examples  
 Следующий пример демонстрирует извлечение подразделов этого раздела и выводит их имена на экран. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод, чтобы создать экземпляр ключа. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для работы с этим ключом.  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит сведения о конфигурации, относящиеся к оборудованию, не связанному с конкретным пользователем. Это поле считывает базовый раздел реестра Windows HKEY_CURRENT_CONFIG.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член сопоставляется подраздел в <xref:Microsoft.Win32.Registry.LocalMachine>.  
  
 Пример использования этого элемента — это приложение, которое сохраняет другое имя сервера для своих данных в зависимости от того, прикреплено ли система к сети.  
  
   
  
## Examples  
 Следующий пример демонстрирует извлечение подразделов этого раздела и выводит их имена на экран. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод, чтобы создать экземпляр ключа. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для работы с этим ключом.  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит сведения о текущих пользовательских параметрах. Это поле считывает базовый раздел реестра Windows HKEY_CURRENT_USER.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения, сохраненные в этом разделе относятся настройки переменных среды и данные о группы программ, цвета, принтеры, сетевые подключения и настройки приложений. Этот ключ упрощает для установки параметров текущего пользователя. В этом разделе поставщики программного обеспечения хранения текущей пользовательские параметры, которые будут использоваться в свои приложения. Microsoft, например, создает приведенный ключ для своих приложений для использования, причем каждое приложение создает свой собственный подраздел в разделе Microsoft.  
  
   
  
## Examples  
 Следующий пример демонстрирует извлечение подразделов этого раздела и выводит их имена на экран. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод, чтобы создать экземпляр ключа. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для работы с этим ключом.  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит динамические данные реестра. Это поле считывает базовый раздел реестра Windows HKEY_DYN_DATA.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реестр Windows 98/Windows Me поддерживает статические данные (который хранится на диске в реестре) и динамических данных (которые часто изменяются, например Статистика производительности). Эта область динамических данных — это механизм, позволяющий драйверами виртуальных устройств (VxD) для предоставления данных в реальном времени для приложений Win32, которые могут выполняться удаленно, как и локально. Он также позволяет системному монитору предоставлять статистику производительности для удаленных систем Windows 98/Windows Me.  
  
 Vxd не ограничены данными о производительности. Они могут предоставить все данные, которые они хотят эффективно передать из Ring 0 в кольцо 3 без монополизации ресурсов ЦП. Реестр поддерживает динамические данные, сохраняя указатель на функцию, возвращающую значение (или много значений). Если вызов реестра запрашивает значения, связанные с динамическим ключом, эта функция вызывается для возврата необходимого значения или значения.  
  
> [!NOTE]
>  Динамические ключи были введены в Microsoft Windows 95 для обработки динамических данных реестра. Они поддерживаются только в Windows 98 и Windows Me.  
  
   
  
## Examples  
 Следующий пример демонстрирует извлечение подразделов этого раздела и выводит их имена на экран. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод, чтобы создать экземпляр ключа. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для работы с этим ключом. Обратите внимание, что в этом примере может возвращать результаты отсутствуют, поскольку там могут быть динамические данные недоступны, или вам может не работать под управлением Windows 98 / ME. С помощью этого ключа может вызвать ошибку в других системах.  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Операционная система не поддерживает платформу динамических данных, то есть она не может быть Windows 98, Windows 98 Second Edition или Windows Millennium Edition (Windows Me).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">Полный путь к разделу реестра, начинающийся с правильного корневого раздела реестра, такого как HKEY_CURRENT_USER.</param>
        <param name="valueName">Имя в паре "имя-значение".</param>
        <param name="defaultValue">Возвращаемое значение, если параметр <paramref name="valueName" /> не существует.</param>
        <summary>Извлекает значение, связанное с указанным именем, в указанном разделе реестра. Если имя не найдено в указанном разделе, возвращает предоставленное значение по умолчанию или значение <see langword="null" />, если указанный раздел не существует.</summary>
        <returns>Значение <see langword="null" />, если вложенный раздел, заданный параметром <paramref name="keyName" />, не существует; в противном случае — значение, связанное с параметром <paramref name="valueName" />, или <paramref name="defaultValue" />, если значение параметра <paramref name="valueName" /> не найдено.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строка `valueName` не учитывает регистр.  
  
> [!NOTE]
>  Раздел реестра может содержать одно значение, которое не связан с любым именем. Когда это безымянное значение отображается в редакторе реестра, строка «(по умолчанию)» отображается вместо имени. Чтобы получить это безымянное значение, укажите `null` или является пустой строкой ("») для `valuName`.  
  
 Действительный корневой имена являются HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG и HKEY_DYN_DATA. Например в Visual Basic строка «HKEY_CURRENT_USER\MyTestKey» обращается к пар ключ/значение для подраздела «MyTestKey» в корневом каталоге HKEY_CURRENT_USER.  
  
 Когда <xref:Microsoft.Win32.RegistryKey.GetValue%2A> метод извлекает значения Расширяемая строка (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), он расширяет среду строки, используя данные из локальной среды. Если значение, содержащее расширяемый ссылки на переменные среды, сохраненный в виде строки (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), а не как Расширяемая строка (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> не развертывает его. Вы можете развернуть строки после их получения, вызвав <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> метод.  
  
> [!NOTE]
>  Для получения данных из HKEY_PERFORMANCE_DATA рекомендуется использовать <xref:System.Diagnostics.PerformanceCounter> класса, а не <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> метод.  
  
 <xref:Microsoft.Win32.Registry.GetValue%2A> И <xref:Microsoft.Win32.Registry.SetValue%2A> методы открыть и закрыть параметры реестра каждый раз, они используются, поэтому они не выполняют, а также методы <xref:Microsoft.Win32.RegistryKey> класса при доступе к большое количество значений.  
  
 <xref:Microsoft.Win32.RegistryKey> также предоставляет методы, позволяющие добавить список управления доступом (ACL) в раздел реестра, чтобы проверить тип данных значения перед его возвращением и удалить ключи.  
  
   
  
## Examples  
 В следующем примере кода сохраняет значения из нескольких типов данных реестра, создание ключа, так как он делает это, а затем извлекает и отображает значения. В примере показано, хранения и извлечения пары (номерами безымянные) имя значение по умолчанию, а также использование `defaultValue` при пару имя значение не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют разрешения, необходимые для чтения из раздела реестра.</exception>
        <exception cref="T:System.IO.IOException">Раздел <see cref="T:Microsoft.Win32.RegistryKey" />, содержащий заданное значение, был помечен для удаления.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="keyName" /> не начинается с правильного корневого раздела реестра.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">для чтения из реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Чтобы прочитать параметр реестра типа REG_EXPAND_SZ. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит данные о конфигурации для локального компьютера. Это поле считывает базовый раздел реестра Windows HKEY_LOCAL_MACHINE.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` содержит пять ключей:  
  
 Оборудование  
 Описывает физическое оборудование компьютера, способ оборудования и сопоставления и связанные данные, соединяющие драйверы режима ядра с кодом пользовательского режима использовать драйверы устройств. Все данные в этот ключ создается заново каждый раз при запуске системы. Описание подраздел описывает фактические аппаратные. Раздел DeviceMap содержит различные данные в форматах конкретных классов драйверов. ResourceMap подраздел описывает, какие драйверы устройств аппаратным ресурсам. Программа диагностики Windows NT (Winmsdp.exe) можно передать сведения о его содержимое в удобной для чтения форме.  
  
 SAM  
 Базы данных служб каталогов, сведения о безопасности для пользователей учетных записей и групп, а также для доменов в Windows 2000 Server (SAM — диспетчер учетных записей безопасности, известные как база данных службы каталогов).  
  
 Безопасность  
 Содержит локальную политику безопасности, например особые права пользователя. Этот ключ используется только подсистемой безопасности Windows 2000.  
  
 Программное обеспечение  
 База данных, программного обеспечения на компьютере. Этот ключ содержит данные о программах, установленных на локальном компьютере, а также различные элементы конфигурации данных.  
  
 Система  
 Управляет запуска системы, загрузкой драйвера устройств, службы Windows 2000 и поведение операционной системы.  
  
 По соглашению, если существуют аналогичные данные в разделе <xref:Microsoft.Win32.Registry.CurrentUser> и в разделе <xref:Microsoft.Win32.Registry.LocalMachine>, данные в <xref:Microsoft.Win32.Registry.CurrentUser> имеет более высокий приоритет. Тем не менее значения в этом разделе можно также расширить (а не заменить) данные в Registry.LocalMachine. Кроме того некоторые элементы (например, элементы загрузки драйвера устройства) бессмысленны, если они встречаются вне Registry.LocalMachine.  
  
   
  
## Examples  
 Следующий пример демонстрирует извлечение подразделов этого раздела и выводит их имена на экран. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод, чтобы создать экземпляр ключа. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для работы с этим ключом.  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит сведения о производительности для компонентов программного обеспечения. Это поле считывает базовый раздел реестра Windows HKEY_PERFORMANCE_DATA.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый программный компонент создает ключи для своих объектов и счетчиков при установке и записывает данные счетчиков при выполнении. Эти данные доступны, как и к другим данным реестра, с помощью <xref:Microsoft.Win32.RegistryKey> функции.  
  
 Несмотря на то, что реестр используется для сбора данных о производительности, данные не хранятся в базе данных реестра. Вместо этого при доступе к реестру с помощью этого ключа система для сбора данных из соответствующих системных диспетчеров объектов.  
  
 Чтобы получить данные о производительности из локальной системы, используйте <xref:Microsoft.Win32.RegistryKey.GetValue%2A> метода с ключом Registry.PerformanceData. Первый вызов открывает ключ (не требуется явным образом сначала открыть раздел). Тем не менее, обязательно используйте <xref:Microsoft.Win32.RegistryKey.Close%2A> метод, чтобы закрыть дескриптор ключа, когда вы закончите, получение данных о производительности. Пользователь не может устанавливать и удалять программный компонент, данные о производительности во время работы.  
  
 Чтобы получить данные о производительности из удаленной системы, необходимо использовать <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> метод с именем компьютера из удаленной системы и ключом Registry.PerformanceData. Этот вызов извлекает ключ, представляющий данные о производительности для удаленной системе. Чтобы получить данные, вызовите <xref:Microsoft.Win32.RegistryKey.GetValue%2A> с помощью этого ключа, а не ключом Registry.PerformanceData.  
  
> [!NOTE]
>  В Windows Server 2003, пользователь должен по крайней мере принадлежать к группе пользователей системного монитора для доступа к базовым подразделы.  
  
   
  
## Examples  
 Следующий пример демонстрирует извлечение подразделов этого раздела и выводит их имена на экран. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод, чтобы создать экземпляр ключа. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для работы с этим ключом. Обратите внимание на то, что в этом примере можно результаты не возвращаются, поскольку данные о производительности не могут использоваться.  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает значение пары "имя-значение" в разделе реестра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода сохраняет значения из нескольких типов данных реестра, создание ключа, так как он делает это, а затем извлекает и отображает значения. В примере показано, хранения и извлечения пары (номерами безымянные) имя значение по умолчанию, а также использование `defaultValue` при пару имя значение не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">Полный путь к разделу реестра, начинающийся с правильного корневого раздела реестра, такого как HKEY_CURRENT_USER.</param>
        <param name="valueName">Имя в паре "имя-значение".</param>
        <param name="value">Сохраняемое значение.</param>
        <summary>Задает указанное значение пары "имя-значение" для указанного раздела реестра. Если указанный раздел не существует, он будет создан.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], `valueName` параметр больше не отображает не более 255 символов; Однако `keyName` параметр по-прежнему имеется ограничение длиной в 255 символов.  
  
 Поскольку многие значения можно хранить в каждый ключ в реестре, необходимо использовать `valueName` параметр, чтобы указать конкретное значение, вы хотите установить.  
  
> [!NOTE]
>  Раздел реестра может содержать одно значение, которое не связан с любым именем. Когда это безымянное значение отображается в редакторе реестра, строка «(по умолчанию)» отображается вместо имени. Чтобы задать это безымянное значение, укажите `null` или является пустой строкой ("») для `valueName`.  
  
 Если `valueName` не существует в ключе, оно создается и связанное значение присваивается `value`.  
  
 Если `keyName` указывает подраздела, который не существует, раздел создается в указанном корневом каталоге. Например в Visual Basic строка «HKEY_CURRENT_USER\MyTestKey» создает подраздел «MyTestKey» в корневом каталоге HKEY_CURRENT_USER. Строка «HKEY_CURRENT_USER\MyTestKey\Key2\Key3» создает вложенных раздела «MyTestKey», «MyTestKey\Key2» и «MyTestKey\Key2\Key3».  
  
 Действительный корневой имена включают HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG и HKEY_DYN_DATA.  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> Метод открывает раздел реестра, устанавливает значение и закрывает ключ каждый раз, он вызывается. Если вам нужно изменить большое количество значений, <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> метод может обеспечивать более высокую производительность. <xref:Microsoft.Win32.RegistryKey> Класс также предоставляет методы, позволяющие добавить список управления доступом (ACL) в раздел реестра, чтобы проверить тип данных значения перед его возвращением и удалить ключи.  
  
 Эта перегрузка <xref:Microsoft.Win32.Registry.SetValue%2A> хранит 64-разрядных целых чисел в виде строки (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Для хранения 64-разрядные числа как <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> значения, используйте <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> перегрузки метода.  
  
 Эта перегрузка <xref:Microsoft.Win32.Registry.SetValue%2A> хранятся все строковые значения как <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> объектов, даже если они содержат расширяемый ссылки на переменные среды. Сохранять строковые значения как раскрывающиеся строки (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), используйте <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> перегрузки метода.  
  
 Эта перегрузка эквивалентно вызову <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> перегрузку метода с <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.  
  
> [!NOTE]
>  В Windows 98 и Windows Millennium Edition (Windows Me) реестра, не имеет кодировки Юникод и не все символы Юникода допустимы для всех кодовых страниц. Знак Юникода, который является недопустимым для текущей кодовой странице заменяется наиболее подходящим соответствием. Исключение не возникает.  
  
   
  
## Examples  
 В следующем примере кода сохраняет значения из нескольких типов данных реестра, создание ключа, так как он делает это, а затем извлекает и отображает значения. В примере показано, хранения и извлечения пары (номерами безымянные) имя значение по умолчанию, а также использование `defaultValue` при пару имя значение не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="keyName" /> не начинается с правильного корневого раздела реестра.  
  
-или- 
 Значение параметра <paramref name="keyName" /> длиннее максимально допустимой длины (255 знаков).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Раздел <see cref="T:Microsoft.Win32.RegistryKey" /> является разделом только для чтения и запись в него невозможна, например, если это узел корневого уровня.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют разрешения, необходимые для изменения разделов реестра.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Изменение указанного раздела реестра, если он существует, или создайте раздел реестра, если он еще не существует. Связанное перечисление: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">Полный путь к разделу реестра, начинающийся с правильного корневого раздела реестра, такого как HKEY_CURRENT_USER.</param>
        <param name="valueName">Имя в паре "имя-значение".</param>
        <param name="value">Сохраняемое значение.</param>
        <param name="valueKind">Тип данных реестра, используемый при сохранении данных.</param>
        <summary>Задает пару "имя-значение" для указанного раздела реестра, используя указанный тип данных реестра. Если указанный раздел не существует, он будет создан.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], `valueName` параметр больше не отображает не более 255 символов; Однако `keyName` параметр по-прежнему имеют ограничения длиной в 255 символов.  
  
 Поскольку многие значения можно хранить в каждый ключ в реестре, необходимо использовать `valueName` параметр, чтобы указать конкретное значение, вы хотите установить.  
  
> [!NOTE]
>  Раздел реестра может содержать одно значение, которое не связан с любым именем. Когда это безымянное значение отображается в редакторе реестра, строка «(по умолчанию)» отображается вместо имени. Чтобы задать это безымянное значение, укажите `null` или является пустой строкой ("») для `valueName`.  
  
 Если `valueName` не существует в ключе, оно создается и связанное значение присваивается `value`.  
  
 Если `keyName` указывает подраздела, который не существует, раздел создается в указанном корневом каталоге. Например в Visual Basic строка «HKEY_CURRENT_USER\MyTestKey» создает подраздел «MyTestKey» в корневом каталоге HKEY_CURRENT_USER. Строка «HKEY_CURRENT_USER\MyTestKey\Key2\Key3» создает вложенных раздела «MyTestKey», «MyTestKey\Key2» и «MyTestKey\Key2\Key3».  
  
 Действительный корневой имена включают HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG и HKEY_DYN_DATA.  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> Метод открывает раздел реестра, устанавливает значение и закрывает ключ каждый раз, он вызывается. Если вам нужно изменить большое количество значений, <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> метод может обеспечивать более высокую производительность. <xref:Microsoft.Win32.RegistryKey> Класс также предоставляет методы, позволяющие добавить список управления доступом (ACL) в раздел реестра, чтобы проверить тип данных значения перед его возвращением и удалить ключи.  
  
 Если тип указанного объекта `value` не соответствует указанным `valueKind`, и данные не могут быть преобразованы, <xref:System.ArgumentException> возникает исключение. Например, можно хранить <xref:System.Int64?displayProperty=nameWithType> как <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, но только в том случае, если его значение меньше, чем максимальное значение <xref:System.Int32?displayProperty=nameWithType>. Не удается сохранить одно строковое значение как <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Если упакованного значения передаются <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> или <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, преобразование осуществляется с помощью инвариантного языка и региональных параметров.  
  
> [!NOTE]
>  В Windows 98 и Windows Millennium Edition (Windows Me) реестра, не имеет кодировки Юникод и не все символы Юникода допустимы для всех кодовых страниц. Знак Юникода, который является недопустимым для текущей кодовой странице заменяется наиболее подходящим соответствием. Исключение не возникает.  
  
   
  
## Examples  
 В следующем примере кода сохраняет значения из нескольких типов данных реестра, создание ключа, так как он делает это, а затем извлекает и отображает значения. В примере показано, хранения и извлечения пары (номерами безымянные) имя значение по умолчанию, а также использование `defaultValue` при пару имя значение не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="keyName" /> не начинается с правильного корневого раздела реестра.  
  
-или- 
 Значение параметра <paramref name="keyName" /> длиннее максимально допустимой длины (255 знаков).  
  
-или- 
Тип параметра <paramref name="value" /> не соответствует типу данных реестра, заданному параметром <paramref name="valueKind" />, поэтому данные не удалось правильно преобразовать.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Раздел <see cref="T:Microsoft.Win32.RegistryKey" /> доступен только для чтения, и, следовательно, запись в него невозможна (например, это узел корневого уровня или раздел не был открыт с доступом для записи).</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют разрешения, необходимые для изменения разделов реестра.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Изменение указанного раздела реестра, если он существует, или создайте раздел реестра, если он еще не существует. Связанное перечисление: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит сведения о стандартной пользовательской конфигурации. Это поле считывает базовый раздел реестра Windows HKEY_USERS.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот ключ содержит ветвь для каждого пользователя компьютера. Конфигурация по умолчанию предоставляется для новых пользователей на локальном компьютере, а также для текущего пользователя по умолчанию, если пользователь не изменил параметры. Поскольку Windows 98 / ME также поддерживает Registry.Users, приложения могут обращаться к сведения о пользователе так же, как в среде Windows 2000. Сведения о каждом пользователе хранятся в отдельном файле, который можно сохранить локально или на сетевом сервере. Windows 98 / ME можно скопировать этот файл в системе текущего пользователя, таким образом, чтобы параметры можно переместить с одного компьютера на другой с пользователем.  
  
   
  
## Examples  
 Следующий пример демонстрирует извлечение подразделов этого раздела и выводит их имена на экран. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод, чтобы создать экземпляр ключа. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для работы с этим ключом.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>