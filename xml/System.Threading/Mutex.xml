<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="75309784a7f2ba45e91d42b9f73bf62285725b43" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52200784" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="78f3a-101">Примитив синхронизации, который также может использоваться в межпроцессорной синхронизации.</span>
      <span class="sxs-lookup">
        <span data-stu-id="78f3a-101">A synchronization primitive that can also be used for interprocess synchronization.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f3a-102">Когда два или больше потоков требуется доступ к общему ресурсу одновременно, системе необходим механизм синхронизации, чтобы убедиться, что только один поток за раз использует ресурс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-102">When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</span></span> <span data-ttu-id="78f3a-103"><xref:System.Threading.Mutex> — Это синхронизации примитив, который предоставляет эксклюзивный доступ к общему ресурсу, чтобы только один поток.</span><span class="sxs-lookup"><span data-stu-id="78f3a-103"><xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</span></span> <span data-ttu-id="78f3a-104">Если поток получает семафор, второй поток, желающий получить этот мьютекс приостанавливается, пока первый поток освобождает мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-104">If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="78f3a-105">Этот тип реализует <xref:System.IDisposable> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-105">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="78f3a-106">Когда вы закончите, используя тип, следует освободить его прямо или косвенно.</span><span class="sxs-lookup"><span data-stu-id="78f3a-106">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="78f3a-107">Чтобы удалить тип напрямую, вызовите его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока.</span><span class="sxs-lookup"><span data-stu-id="78f3a-107">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="78f3a-108">Чтобы избавиться от его косвенно, используйте языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="78f3a-108">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="78f3a-109">Дополнительные сведения см. в разделе «С помощью объекта, реализует IDisposable» <xref:System.IDisposable> разделу интерфейса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-109">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="78f3a-110">Можно использовать <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> метод, который запросит владение мьютексом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-110">You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method to request ownership of a mutex.</span></span> <span data-ttu-id="78f3a-111">Вызывающий поток блокируется, пока не произойдет одно из следующих событий:</span><span class="sxs-lookup"><span data-stu-id="78f3a-111">The calling thread blocks until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="78f3a-112">Чтобы указать, что он не принадлежит получает сигнал мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-112">The mutex is signaled to indicate that it is not owned.</span></span> <span data-ttu-id="78f3a-113">В этом случае <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `true`, и вызывающий поток принимает на себя владение мьютексом и получает доступ к ресурсу, защищенные объектом mutex.</span><span class="sxs-lookup"><span data-stu-id="78f3a-113">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</span></span> <span data-ttu-id="78f3a-114">После завершения доступ к ресурсу, поток должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод для освобождения владения мьютексом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-114">When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex.</span></span> <span data-ttu-id="78f3a-115">В первом примере в разделе «примеры» показан этот шаблон.</span><span class="sxs-lookup"><span data-stu-id="78f3a-115">The first example in the Examples section illustrates this pattern.</span></span>  
  
-   <span data-ttu-id="78f3a-116">Интервал времени ожидания, указанное в вызове <xref:System.Threading.WaitHandle.WaitOne%2A> метод, который имеет `millisecondsTimeout` или `timeout` параметре.</span><span class="sxs-lookup"><span data-stu-id="78f3a-116">The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed.</span></span> <span data-ttu-id="78f3a-117">В этом случае <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает метод `false`, и вызывающий поток не предпринимает дальнейших получить права владельца мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-117">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex.</span></span> <span data-ttu-id="78f3a-118">В этом случае следует структурировать код таким образом, чтобы доступ к ресурсу, защищенные объектом mutex запрещен в вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="78f3a-118">In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</span></span> <span data-ttu-id="78f3a-119">Так как поток никогда не получить права владельца мьютекса, он не должен вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="78f3a-119">Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span> <span data-ttu-id="78f3a-120">В разделе «примеры» во втором примере показана схема работы.</span><span class="sxs-lookup"><span data-stu-id="78f3a-120">The second example in the Examples section illustrates this pattern.</span></span>  
  
 <span data-ttu-id="78f3a-121"><xref:System.Threading.Mutex> Класс выполняет идентификацию потоков, поэтому мьютекс может быть освобожден только тем потоком, который получил его.</span><span class="sxs-lookup"><span data-stu-id="78f3a-121">The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</span></span> <span data-ttu-id="78f3a-122">Напротив <xref:System.Threading.Semaphore> класса не обеспечивают идентификацию потоков.</span><span class="sxs-lookup"><span data-stu-id="78f3a-122">By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity.</span></span> <span data-ttu-id="78f3a-123">Мьютекс также могут передаваться через границы домена приложения.</span><span class="sxs-lookup"><span data-stu-id="78f3a-123">A mutex can also be passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="78f3a-124">Поток, который владеет мьютекс может запросить его в повторные вызовы <xref:System.Threading.WaitHandle.WaitOne%2A> не прерывая выполнение.</span><span class="sxs-lookup"><span data-stu-id="78f3a-124">The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution.</span></span> <span data-ttu-id="78f3a-125">Тем не менее, необходимо вызвать поток <xref:System.Threading.Mutex.ReleaseMutex%2A> метод такое же количество раз, чтобы освободить права владения мьютексом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-125">However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="78f3a-126">Так как <xref:System.Threading.Mutex> класс наследует от <xref:System.Threading.WaitHandle>, также можно вызвать статический <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> и <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> методы для синхронизации доступа к защищенному ресурсу.</span><span class="sxs-lookup"><span data-stu-id="78f3a-126">Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods to synchronize access to a protected resource.</span></span>  
  
 <span data-ttu-id="78f3a-127">Если поток завершается владея мьютексом, мьютекс считается брошенным.</span><span class="sxs-lookup"><span data-stu-id="78f3a-127">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="78f3a-128">Состояние мьютекса задается сигнальным и получает следующий ожидающий поток.</span><span class="sxs-lookup"><span data-stu-id="78f3a-128">The state of the mutex is set to signaled, and the next waiting thread gets ownership.</span></span> <span data-ttu-id="78f3a-129">Начиная с версии 2.0 платформы .NET Framework, <xref:System.Threading.AbandonedMutexException> создается в следующем потоке, который получает Брошенный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-129">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex.</span></span> <span data-ttu-id="78f3a-130">До версии 2.0 платформы .NET Framework исключение не создано.</span><span class="sxs-lookup"><span data-stu-id="78f3a-130">Before version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="78f3a-131">Брошенный мьютекс часто является признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="78f3a-131">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="78f3a-132">Когда поток завершает работу без освобождения объекта mutex, структуры данных, защищенные объектом mutex, возможно в согласованном состоянии.</span><span class="sxs-lookup"><span data-stu-id="78f3a-132">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="78f3a-133">Следующий поток, который запросит владение мьютексом может обработать это исключение и продолжить работу, если можно удостовериться в целостности структуры данных.</span><span class="sxs-lookup"><span data-stu-id="78f3a-133">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="78f3a-134">В случае системного мьютекса брошенный мьютекс может указывать на то, что работа приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="78f3a-134">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
 <span data-ttu-id="78f3a-135">Мьютексы бывают двух типов: локальные мьютексы неименованные и именованные системные мьютексы.</span><span class="sxs-lookup"><span data-stu-id="78f3a-135">Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</span></span> <span data-ttu-id="78f3a-136">Локальный мьютекс существует только в вашем процессе.</span><span class="sxs-lookup"><span data-stu-id="78f3a-136">A local mutex exists only within your process.</span></span> <span data-ttu-id="78f3a-137">Он может использоваться любой поток в вашем процессе, имеющий ссылку на <xref:System.Threading.Mutex> объект, представляющий мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-137">It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex.</span></span> <span data-ttu-id="78f3a-138">Каждый неименованный <xref:System.Threading.Mutex> объект представляет собой отдельный Локальный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-138">Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.</span></span>  
  
 <span data-ttu-id="78f3a-139">Именованные системные мьютексы доступны во всей операционной системы и может использоваться для синхронизации действий процессов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-139">Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="78f3a-140">Можно создать <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс с помощью конструктора, который принимает имя.</span><span class="sxs-lookup"><span data-stu-id="78f3a-140">You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name.</span></span> <span data-ttu-id="78f3a-141">Объект операционной системы может быть создан в то же время, или он может существовать до создания <xref:System.Threading.Mutex> объекта.</span><span class="sxs-lookup"><span data-stu-id="78f3a-141">The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object.</span></span> <span data-ttu-id="78f3a-142">Вы можете создать сразу несколько объектов <xref:System.Threading.Mutex>, представляющих один и тот именованный системный мьютекс, а также открывать именованный системный мьютекс с помощью метода <xref:System.Threading.Mutex.OpenExisting%2A>.</span><span class="sxs-lookup"><span data-stu-id="78f3a-142">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f3a-143">На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости.</span><span class="sxs-lookup"><span data-stu-id="78f3a-143">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="78f3a-144">Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-144">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="78f3a-145">Если его имя начинается с префикса «локальный\\«, мьютекс отображается только в сеанса сервера терминалов, в котором он был создан.</span><span class="sxs-lookup"><span data-stu-id="78f3a-145">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="78f3a-146">В этом случае в каждой из других сеансов сервера терминалов на сервере может существовать отдельный мьютекс с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="78f3a-146">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="78f3a-147">Если при создании именованного мьютекса префикс не указан, функция принимает префикс «локальный\\«.</span><span class="sxs-lookup"><span data-stu-id="78f3a-147">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="78f3a-148">В рамках сеанса сервера терминалов два мьютекса, имена которых отличаются только по их префиксы являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-148">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="78f3a-149">То есть имена префикс «Global\\"и «локальные\\" описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-149">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 <span data-ttu-id="78f3a-150">В этом примере показано, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу.</span><span class="sxs-lookup"><span data-stu-id="78f3a-150">This example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="78f3a-151">Поскольку каждый вызывающий поток блокируется, пока не получит права владельца мьютекса, он должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод для освобождения владения потока.</span><span class="sxs-lookup"><span data-stu-id="78f3a-151">Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the thread.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="78f3a-152">В следующем примере каждый поток вызывает <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> способ занять объект взаимного исключения.</span><span class="sxs-lookup"><span data-stu-id="78f3a-152">In the following example, each thread calls the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> method to acquire the mutex.</span></span> <span data-ttu-id="78f3a-153">Если по истечении интервала времени ожидания, метод возвращает `false`, и поток не завладеет этим мьютексом и не получает доступ к ресурсу, позволяет защитить мьютексом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-153">If the time-out interval elapses, the method returns `false`, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</span></span> <span data-ttu-id="78f3a-154"><xref:System.Threading.Mutex.ReleaseMutex%2A> Метод вызывается только тем потоком, который получает мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-154">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is called only by the thread that acquires the mutex.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="78f3a-155">Данный тип потокобезопасен.</span>
      <span class="sxs-lookup">
        <span data-stu-id="78f3a-155">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="78f3a-156">Управляемая поточность</span>
      <span class="sxs-lookup">
        <span data-stu-id="78f3a-156">Managed Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">
      <span data-ttu-id="78f3a-157">Mutexes</span>
      <span class="sxs-lookup">
        <span data-stu-id="78f3a-157">Mutexes</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="78f3a-158">Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-158">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="78f3a-159">Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> стандартными свойствами.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-159">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f3a-160">Вызов этого перегруженного конструктора — равносилен вызову метода <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> перегрузку конструктора и указав `false` для изначальным владельцем мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-160">Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex.</span></span> <span data-ttu-id="78f3a-161">То есть вызывающий поток не имеет собственного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-161">That is, the calling thread does not own the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f3a-162">В следующем коде показано в примере, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу.</span><span class="sxs-lookup"><span data-stu-id="78f3a-162">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="78f3a-163">Поток, создающий мьютексом не владеет его изначально.</span><span class="sxs-lookup"><span data-stu-id="78f3a-163">The thread that creates the mutex does not own it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="78f3a-164">Управляемая поточность</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-164">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">
          <span data-ttu-id="78f3a-165">Mutexes</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-165">Mutexes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="78f3a-166">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения мьютексом; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-166">
              <see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78f3a-167">Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-167">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="78f3a-168">В следующем коде показано в примере, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу.</span><span class="sxs-lookup"><span data-stu-id="78f3a-168">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="78f3a-169">Поток, создающий <xref:System.Threading.Mutex> изначально им владеет.</span><span class="sxs-lookup"><span data-stu-id="78f3a-169">The thread that creates the <xref:System.Threading.Mutex> owns it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="78f3a-170">Управляемая поточность</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-170">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">
          <span data-ttu-id="78f3a-171">Mutexes</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-171">Mutexes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="78f3a-172">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-172">
              <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="78f3a-173">Имя <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-173">The name of the <see cref="T:System.Threading.Mutex" />.</span>
          </span>
          <span data-ttu-id="78f3a-174">Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-174">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78f3a-175">Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, а также иметь строку, являющуюся именем мьютекса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-175">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f3a-176">Если `name` не `null` и `initiallyOwned` является `true`, вызывающий поток является владельцем мьютекса только в том случае, если именованный системный мьютекс был создан в результате этого вызова.</span><span class="sxs-lookup"><span data-stu-id="78f3a-176">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</span></span> <span data-ttu-id="78f3a-177">Так как отсутствует механизм для определения, был ли создан именованный системный мьютекс, рекомендуется указать `false` для `initiallyOwned` при вызове перегрузки конструктора.</span><span class="sxs-lookup"><span data-stu-id="78f3a-177">Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload.</span></span> <span data-ttu-id="78f3a-178">Можно использовать <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> конструктор, если вам нужно определить изначальным владельцем.</span><span class="sxs-lookup"><span data-stu-id="78f3a-178">You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership.</span></span>  
  
 <span data-ttu-id="78f3a-179">Этот конструктор инициализирует <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-179">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="78f3a-180">Вы можете создать несколько <xref:System.Threading.Mutex> объекты, которые представляют одинаковую меру именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-180">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="78f3a-181">Если именованный мьютекс уже создан с помощью управления доступом, а вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="78f3a-181">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="78f3a-182">Чтобы открыть существующий именованный мьютекс с помощью только те разрешения, необходимые для синхронизации потоков, см. в разделе <xref:System.Threading.Mutex.OpenExisting%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="78f3a-182">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="78f3a-183">Если указать `null` или пустую строку для `name`, создан локальный мьютекс, как если бы Вы вызвали <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> конструктор.</span><span class="sxs-lookup"><span data-stu-id="78f3a-183">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="78f3a-184">В этом случае `createdNew` всегда `true`.</span><span class="sxs-lookup"><span data-stu-id="78f3a-184">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="78f3a-185">Так как они системные именованными мьютексами может использоваться для координирования использования ресурсов через границы процессов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-185">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f3a-186">На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости.</span><span class="sxs-lookup"><span data-stu-id="78f3a-186">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="78f3a-187">Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-187">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="78f3a-188">Если его имя начинается с префикса «локальный\\«, мьютекс отображается только в сеанса сервера терминалов, в котором он был создан.</span><span class="sxs-lookup"><span data-stu-id="78f3a-188">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="78f3a-189">В этом случае в каждой из других сеансов сервера терминалов на сервере может существовать отдельный мьютекс с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="78f3a-189">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="78f3a-190">Если при создании именованного мьютекса префикс не указан, функция принимает префикс «локальный\\«.</span><span class="sxs-lookup"><span data-stu-id="78f3a-190">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="78f3a-191">В рамках сеанса сервера терминалов два мьютекса, имена которых отличаются только по их префиксы являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-191">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="78f3a-192">То есть имена префикс «Global\\"и «локальные\\" описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-192">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 <span data-ttu-id="78f3a-193">Следующий пример показывает использование именованного мьютекса для передачи сигналов между потоками, выполняющимися в два отдельных процесса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-193">The following example shows how a named mutex is used to signal between threads running in two separate processes.</span></span>  
  
 <span data-ttu-id="78f3a-194">Запустите эту программу из двух или нескольких команд windows.</span><span class="sxs-lookup"><span data-stu-id="78f3a-194">Run this program from two or more command windows.</span></span> <span data-ttu-id="78f3a-195">Каждый процесс создает <xref:System.Threading.Mutex> , представляющий именованный мьютекс `MyMutex`.</span><span class="sxs-lookup"><span data-stu-id="78f3a-195">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex `MyMutex`.</span></span> <span data-ttu-id="78f3a-196">Именованный мьютекс является системным объектом, время существования которых ограничивается временем жизни <xref:System.Threading.Mutex> объекты, представляющие его.</span><span class="sxs-lookup"><span data-stu-id="78f3a-196">The named mutex is a system object whose lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="78f3a-197">Именованный мьютекс создается в том случае, когда первый процесс создает его <xref:System.Threading.Mutex> объект; в этом примере мьютексом владеет первый процесс, выполняющий программу.</span><span class="sxs-lookup"><span data-stu-id="78f3a-197">The named mutex is created when the first process creates its <xref:System.Threading.Mutex> object; in this example, the named mutex is owned by the first process that runs the program.</span></span> <span data-ttu-id="78f3a-198">Именованный мьютекс уничтожается при всех <xref:System.Threading.Mutex> объекты, представляющие его были выпущены.</span><span class="sxs-lookup"><span data-stu-id="78f3a-198">The named mutex is destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span>  
  
 <span data-ttu-id="78f3a-199">Перегрузку конструктора, используемый в этом примере не может определить вызывающий поток, предоставлен ли изначальное владение мьютексом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-199">The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</span></span> <span data-ttu-id="78f3a-200">Этот конструктор не следует использовать для запроса изначальным владельцем, если только вы можете быть уверены, что поток будет создавать именованный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-200">You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="78f3a-201">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-201">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="78f3a-202">Произошла ошибка Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-202">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="78f3a-203">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-203">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="78f3a-204">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-204">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="78f3a-205">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-205">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="78f3a-206">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-206">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="78f3a-207">Управляемая поточность</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-207">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">
          <span data-ttu-id="78f3a-208">Mutexes</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-208">Mutexes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="78f3a-209">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-209">
              <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="78f3a-210">Имя <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-210">The name of the <see cref="T:System.Threading.Mutex" />.</span>
          </span>
          <span data-ttu-id="78f3a-211">Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-211">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="78f3a-212">При возврате из метода содержит логическое значение <see langword="true" />, если был создан локальный мьютекс (то есть, если параметр <paramref name="name" /> имеет значение <see langword="null" /> или содержит пустую строку) или был создан именованный системный мьютекс; значение <see langword="false" />, если указанный именованный системный мьютекс уже существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-212">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span>
          </span>
          <span data-ttu-id="78f3a-213">Этот параметр передается неинициализированным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-213">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78f3a-214">Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, иметь строку, являющуюся именем мьютекса, и логическое значение, которое при возврате метода показывает, предоставлено ли вызывающему потоку изначальное владение мьютексом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-214">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f3a-215">Если `name` не `null` и `initiallyOwned` — `true`, только если именованный мьютекс, которому принадлежит вызывающий поток `createdNew` является `true` после вызова метода.</span><span class="sxs-lookup"><span data-stu-id="78f3a-215">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="78f3a-216">В противном случае поток может запросить мьютексом, вызвав <xref:System.Threading.WaitHandle.WaitOne%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="78f3a-216">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="78f3a-217">Этот конструктор инициализирует <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-217">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="78f3a-218">Вы можете создать несколько <xref:System.Threading.Mutex> объекты, которые представляют одинаковую меру именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-218">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="78f3a-219">Если именованный мьютекс уже создан с помощью управления доступом, а вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> прав, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="78f3a-219">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> rights, an exception is thrown.</span></span> <span data-ttu-id="78f3a-220">Чтобы открыть существующий именованный мьютекс с помощью только те разрешения, необходимые для синхронизации потоков, см. в разделе <xref:System.Threading.Mutex.OpenExisting%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="78f3a-220">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="78f3a-221">Если указать `null` или пустую строку для `name`, создан локальный мьютекс, как если бы Вы вызвали <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> конструктор.</span><span class="sxs-lookup"><span data-stu-id="78f3a-221">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="78f3a-222">В этом случае `createdNew` всегда `true`.</span><span class="sxs-lookup"><span data-stu-id="78f3a-222">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="78f3a-223">Так как они системные именованными мьютексами может использоваться для координирования использования ресурсов через границы процессов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-223">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f3a-224">На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости.</span><span class="sxs-lookup"><span data-stu-id="78f3a-224">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="78f3a-225">Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-225">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="78f3a-226">Если его имя начинается с префикса «локальный\\«, мьютекс отображается только в сеанса сервера терминалов, в котором он был создан.</span><span class="sxs-lookup"><span data-stu-id="78f3a-226">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="78f3a-227">В этом случае в каждой из других сеансов сервера терминалов на сервере может существовать отдельный мьютекс с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="78f3a-227">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="78f3a-228">Если при создании именованного мьютекса префикс не указан, функция принимает префикс «локальный\\«.</span><span class="sxs-lookup"><span data-stu-id="78f3a-228">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="78f3a-229">В рамках сеанса сервера терминалов два мьютекса, имена которых отличаются только по их префиксы являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-229">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="78f3a-230">То есть имена префикс «Global\\"и «локальные\\" описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-230">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 <span data-ttu-id="78f3a-231">В следующем примере кода показано использование именованного мьютекса для сигнала между потоками или процессами.</span><span class="sxs-lookup"><span data-stu-id="78f3a-231">The following code example shows how a named mutex is used to signal between processes or threads.</span></span> <span data-ttu-id="78f3a-232">Запустите эту программу из двух или нескольких команд windows.</span><span class="sxs-lookup"><span data-stu-id="78f3a-232">Run this program from two or more command windows.</span></span> <span data-ttu-id="78f3a-233">Каждый процесс создает <xref:System.Threading.Mutex> , представляющий именованный мьютекс «MyMutex».</span><span class="sxs-lookup"><span data-stu-id="78f3a-233">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex "MyMutex".</span></span> <span data-ttu-id="78f3a-234">Именованный мьютекс является системным объектом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-234">The named mutex is a system object.</span></span> <span data-ttu-id="78f3a-235">В этом примере его время жизни ограничено временем жизни <xref:System.Threading.Mutex> объекты, представляющие его.</span><span class="sxs-lookup"><span data-stu-id="78f3a-235">In this example, its lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="78f3a-236">Именованный мьютекс создается в том случае, когда первый процесс создает ее локальных <xref:System.Threading.Mutex> объекта и уничтожается при всех <xref:System.Threading.Mutex> объекты, представляющие его были выпущены.</span><span class="sxs-lookup"><span data-stu-id="78f3a-236">The named mutex is created when the first process creates its local <xref:System.Threading.Mutex> object, and destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span> <span data-ttu-id="78f3a-237">Именованный мьютекс изначально принадлежит первый процесс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-237">The named mutex is initially owned by the first process.</span></span> <span data-ttu-id="78f3a-238">Второй и все последующие процессы ожидания для более ранних процессов для освобождения именованного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-238">The second process and any subsequent processes wait for earlier processes to release the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="78f3a-239">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-239">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="78f3a-240">Произошла ошибка Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-240">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="78f3a-241">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-241">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="78f3a-242">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-242">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="78f3a-243">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-243">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="78f3a-244">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-244">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="78f3a-245">Управляемая поточность</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-245">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">
          <span data-ttu-id="78f3a-246">Mutexes</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-246">Mutexes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="78f3a-247">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-247">
              <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="78f3a-248">Имя системного мьютекса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-248">The name of the system mutex.</span>
          </span>
          <span data-ttu-id="78f3a-249">Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-249">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="78f3a-250">При возврате из метода содержит логическое значение <see langword="true" />, если был создан локальный мьютекс (то есть, если параметр <paramref name="name" /> имеет значение <see langword="null" /> или содержит пустую строку) или был создан именованный системный мьютекс; значение <see langword="false" />, если указанный именованный системный мьютекс уже существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-250">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span>
          </span>
          <span data-ttu-id="78f3a-251">Этот параметр передается неинициализированным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-251">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="mutexSecurity">
          <span data-ttu-id="78f3a-252">Объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для применения к именованному системному мьютексу.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-252">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78f3a-253">Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, иметь строку, являющуюся именем мьютекса, и логическое значение, которое при возврате метода показывает, предоставлено ли вызывающему потоку изначальное владение мьютексом, а также безопасность управления доступом для применения к именованному мьютексу.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-253">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f3a-254">Если `name` не `null` и `initiallyOwned` — `true`, только если именованный мьютекс, которому принадлежит вызывающий поток `createdNew` является `true` после вызова метода.</span><span class="sxs-lookup"><span data-stu-id="78f3a-254">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="78f3a-255">В противном случае поток может запросить мьютексом, вызвав <xref:System.Threading.WaitHandle.WaitOne%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="78f3a-255">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="78f3a-256">Этот конструктор используется для применения управления доступом к именованному системному мьютексу при его создании, чтобы предотвратить возможность управления мьютексом другой код.</span><span class="sxs-lookup"><span data-stu-id="78f3a-256">Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</span></span>  
  
 <span data-ttu-id="78f3a-257">Этот конструктор инициализирует <xref:System.Threading.Mutex> , представляющий именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-257">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="78f3a-258">Вы можете создать несколько <xref:System.Threading.Mutex> объекты, которые представляют одинаковую меру именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-258">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="78f3a-259">Если именованный системный мьютекс не существует, он создается с указанного элемента управления доступом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-259">If the named system mutex does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="78f3a-260">Если именованный мьютекс существует, указанный управления доступом учитывается.</span><span class="sxs-lookup"><span data-stu-id="78f3a-260">If the named mutex exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f3a-261">Вызывающий объект имеет полный контроль над только что созданный <xref:System.Threading.Mutex> объект, даже если `mutexSecurity` запрещает или не удалось предоставить некоторые права доступа для текущего пользователя.</span><span class="sxs-lookup"><span data-stu-id="78f3a-261">The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="78f3a-262">Тем не менее если текущий пользователь пытается получить другой <xref:System.Threading.Mutex> объекта представляют одинаковую меру с именем мьютекса, с помощью конструктора или <xref:System.Threading.Mutex.OpenExisting%2A> метод применения управления доступом Windows.</span><span class="sxs-lookup"><span data-stu-id="78f3a-262">However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="78f3a-263">Если именованный мьютекс уже создан с помощью управления доступом, а вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="78f3a-263">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="78f3a-264">Чтобы открыть существующий именованный мьютекс с помощью только те разрешения, необходимые для синхронизации потоков, см. в разделе <xref:System.Threading.Mutex.OpenExisting%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="78f3a-264">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="78f3a-265">Если указать `null` или пустую строку для `name`, создан локальный мьютекс, как если бы Вы вызвали <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> конструктор.</span><span class="sxs-lookup"><span data-stu-id="78f3a-265">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="78f3a-266">В этом случае `createdNew` всегда `true`.</span><span class="sxs-lookup"><span data-stu-id="78f3a-266">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="78f3a-267">Так как они системные именованными мьютексами может использоваться для координирования использования ресурсов через границы процессов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-267">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f3a-268">На сервере с запущенными службами терминалов именованный системный мьютекс может иметь два уровня видимости.</span><span class="sxs-lookup"><span data-stu-id="78f3a-268">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="78f3a-269">Если его имя начинается с префикса «Global\\«, мьютекс является видимым во всех сеансах сервера терминалов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-269">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="78f3a-270">Если его имя начинается с префикса «локальный\\«, мьютекс отображается только в сеанса сервера терминалов, в котором он был создан.</span><span class="sxs-lookup"><span data-stu-id="78f3a-270">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="78f3a-271">В этом случае в каждой из других сеансов сервера терминалов на сервере может существовать отдельный мьютекс с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="78f3a-271">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="78f3a-272">Если при создании именованного мьютекса префикс не указан, функция принимает префикс «локальный\\«.</span><span class="sxs-lookup"><span data-stu-id="78f3a-272">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="78f3a-273">В рамках сеанса сервера терминалов два мьютекса, имена которых отличаются только по их префиксы являются отдельными мьютексами, и оба являются видимыми для всех процессов в сеансе сервера терминалов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-273">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="78f3a-274">То есть имена префикс «Global\\"и «локальные\\" описывают область видимости мьютексов относительно сеансов сервера терминалов, не являющийся относительным для процессов.</span><span class="sxs-lookup"><span data-stu-id="78f3a-274">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 <span data-ttu-id="78f3a-275">В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-275">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="78f3a-276">В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-276">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="78f3a-277">Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-277">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="78f3a-278">Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="78f3a-278">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="78f3a-279">Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения.</span><span class="sxs-lookup"><span data-stu-id="78f3a-279">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="78f3a-280">После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его.</span><span class="sxs-lookup"><span data-stu-id="78f3a-280">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="78f3a-281">При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.</span><span class="sxs-lookup"><span data-stu-id="78f3a-281">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="78f3a-282">Произошла ошибка Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-282">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="78f3a-283">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-283">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="78f3a-284">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-284">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="78f3a-285">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-285">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="78f3a-286">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-286">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="78f3a-287">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-287">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="78f3a-288">Получает объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для именованного мьютекса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-288">Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="78f3a-289">Объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для именованного мьютекса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-289">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f3a-290"><xref:System.Threading.Mutex.GetAccessControl%2A> Методе используется комбинация флагов (в сочетании с помощью побитовой операции OR) для поиска для разрешения: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, и <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="78f3a-290">The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="78f3a-291">Пользователь должен иметь <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> для вызова этого метода и мьютекс должен быть открыт с <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="78f3a-291">The user must have <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f3a-292">В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-292">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="78f3a-293">В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-293">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="78f3a-294">Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-294">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="78f3a-295">Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="78f3a-295">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="78f3a-296">Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения, с помощью <xref:System.Threading.Mutex.GetAccessControl%2A> и <xref:System.Threading.Mutex.SetAccessControl%2A> методы.</span><span class="sxs-lookup"><span data-stu-id="78f3a-296">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="78f3a-297">После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его.</span><span class="sxs-lookup"><span data-stu-id="78f3a-297">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="78f3a-298">При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.</span><span class="sxs-lookup"><span data-stu-id="78f3a-298">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="78f3a-299">Текущий объект <see cref="T:System.Threading.Mutex" /> представляет именованный системный мьютекс, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-299">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span>
          </span>
          <span data-ttu-id="78f3a-300">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-300">-or-</span>
          </span>
          <span data-ttu-id="78f3a-301">Текущий объект <see cref="T:System.Threading.Mutex" /> представляет именованный системный мьютекс, но он не был открыт с правами <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-301">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="78f3a-302">Не поддерживается для Windows 98 или Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-302">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="78f3a-303">Открывает указанный именованный мьютекс, если он уже существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-303">Opens a specified named mutex, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="78f3a-304">Имя системного мьютекса для открытия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-304">The name of the system mutex to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78f3a-305">Открывает указанный именованный мьютекс, если он уже существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-305">Opens the specified named mutex, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="78f3a-306">Объект, представляющий именованный системный мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-306">An object that represents the named system mutex.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f3a-307"><xref:System.Threading.Mutex.OpenExisting%2A> Метод пытается открыть указанный именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-307">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex.</span></span> <span data-ttu-id="78f3a-308">Если системный мьютекс не существует, этот метод вызывает исключение вместо создания системным объектом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-308">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="78f3a-309">Для создания системного мьютекса, когда он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.</span><span class="sxs-lookup"><span data-stu-id="78f3a-309">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="78f3a-310">Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-310">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="78f3a-311">Эта перегрузка метода эквивалентен вызову <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузку метода с указанием <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> права, объединяются с помощью побитовой операции или.</span><span class="sxs-lookup"><span data-stu-id="78f3a-311">This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="78f3a-312">Указание <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоку ожидать на мьютекс и указав <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг позволяет потоку на вызов метода <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="78f3a-312">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="78f3a-313">Этот метод не требует владения мьютексом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-313">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f3a-314">В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-314">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="78f3a-315">В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-315">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="78f3a-316">Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-316">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="78f3a-317">Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="78f3a-317">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="78f3a-318">Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения.</span><span class="sxs-lookup"><span data-stu-id="78f3a-318">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="78f3a-319">После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его.</span><span class="sxs-lookup"><span data-stu-id="78f3a-319">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="78f3a-320">При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.</span><span class="sxs-lookup"><span data-stu-id="78f3a-320">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="78f3a-321">Параметр <paramref name="name" /> равен пустой строке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-321">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="78f3a-322">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-322">-or-</span>
          </span>
          <span data-ttu-id="78f3a-323">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-323">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="78f3a-324">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-324">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="78f3a-325">Именованный мьютекс не существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-325">The named mutex does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="78f3a-326">Произошла ошибка Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-326">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="78f3a-327">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-327">The named mutex exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="78f3a-328">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-328">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="78f3a-329">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-329">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="78f3a-330">Имя системного мьютекса для открытия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-330">The name of the system mutex to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="78f3a-331">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-331">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78f3a-332">Открывает указанный именованный мьютекс, если он уже существует, с требуемыми правами доступа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-332">Opens the specified named mutex, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="78f3a-333">Объект, представляющий именованный системный мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-333">An object that represents the named system mutex.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f3a-334">`rights` Параметр должен содержать <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков для ожидания семафора и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потокам вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="78f3a-334">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="78f3a-335"><xref:System.Threading.Mutex.OpenExisting%2A> Метод пытается открыть существующий именованный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-335">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex.</span></span> <span data-ttu-id="78f3a-336">Если системный мьютекс не существует, этот метод вызывает исключение вместо создания системным объектом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-336">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="78f3a-337">Для создания системного мьютекса, когда он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.</span><span class="sxs-lookup"><span data-stu-id="78f3a-337">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="78f3a-338">Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-338">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="78f3a-339">Этот метод не требует владения мьютексом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-339">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f3a-340">В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-340">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="78f3a-341">В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-341">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="78f3a-342">Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-342">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="78f3a-343">Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="78f3a-343">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="78f3a-344">Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения.</span><span class="sxs-lookup"><span data-stu-id="78f3a-344">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="78f3a-345">После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его.</span><span class="sxs-lookup"><span data-stu-id="78f3a-345">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="78f3a-346">При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.</span><span class="sxs-lookup"><span data-stu-id="78f3a-346">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="78f3a-347">Параметр <paramref name="name" /> равен пустой строке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-347">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="78f3a-348">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-348">-or-</span>
          </span>
          <span data-ttu-id="78f3a-349">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-349">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="78f3a-350">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-350">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="78f3a-351">Именованный мьютекс не существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-351">The named mutex does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="78f3a-352">Произошла ошибка Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-352">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="78f3a-353">Именованный мьютекс существует, но у пользователя нет необходимой безопасности доступа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-353">The named mutex exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="78f3a-354">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-354">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="78f3a-355">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-355">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="78f3a-356">Освобождает объект <see cref="T:System.Threading.Mutex" /> один раз.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-356">Releases the <see cref="T:System.Threading.Mutex" /> once.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f3a-357">Каждый раз, когда поток получает семафор (например, путем вызова его <xref:System.Threading.WaitHandle.WaitOne%2A> метод), он должен впоследствии вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> передать владение мьютексом и разблокировать другие потоки, которые пытаются получить права владельца мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-357">Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</span></span> <span data-ttu-id="78f3a-358">Если произошел сбой попытки получить права владельца мьютекса (например, когда вызов <xref:System.Threading.WaitHandle.WaitOne%2A> метод с `millisecondsTimeout` или `timeout` параметр возвращает `false` из-за тайм-аута запроса), поток не должен вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A>, в этом регистр, поток также не должны получить доступ к ресурсу, защищенные объектом mutex, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="78f3a-358">If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 <span data-ttu-id="78f3a-359">Поток, который является владельцем мьютекса можно указать его в повторных вызовах функции ожидания, не прерывая выполнение.</span><span class="sxs-lookup"><span data-stu-id="78f3a-359">A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</span></span> <span data-ttu-id="78f3a-360">Число вызовов хранится в среде CLR.</span><span class="sxs-lookup"><span data-stu-id="78f3a-360">The number of calls is kept by the common language runtime.</span></span> <span data-ttu-id="78f3a-361">Поток должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> такое же количество раз, чтобы освободить права владения мьютексом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-361">The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="78f3a-362">Если поток завершается владея мьютексом, мьютекс считается брошенным.</span><span class="sxs-lookup"><span data-stu-id="78f3a-362">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="78f3a-363">Состояние мьютекса задается сигнальным, и получает следующий ожидающий поток.</span><span class="sxs-lookup"><span data-stu-id="78f3a-363">The state of the mutex is set to signaled and the next waiting thread gets ownership.</span></span> <span data-ttu-id="78f3a-364">Если никто не является владельцем мьютекса, состояние мьютекса переводится в сигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="78f3a-364">If no one owns the mutex, the state of the mutex is signaled.</span></span> <span data-ttu-id="78f3a-365">Начиная с версии 2.0 платформы .NET Framework, <xref:System.Threading.AbandonedMutexException> создается в следующем потоке, который завладеет этим мьютексом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-365">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex.</span></span> <span data-ttu-id="78f3a-366">До версии 2.0 платформы .NET Framework исключение не создано.</span><span class="sxs-lookup"><span data-stu-id="78f3a-366">Prior to version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="78f3a-367">Брошенный мьютекс часто является признаком серьезной ошибки в коде.</span><span class="sxs-lookup"><span data-stu-id="78f3a-367">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="78f3a-368">Когда поток завершает работу без освобождения объекта mutex, структуры данных, защищенные объектом mutex, возможно в согласованном состоянии.</span><span class="sxs-lookup"><span data-stu-id="78f3a-368">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="78f3a-369">Следующий поток, который запросит владение мьютексом может обработать это исключение и продолжить работу, если можно удостовериться в целостности структуры данных.</span><span class="sxs-lookup"><span data-stu-id="78f3a-369">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="78f3a-370">В случае системного мьютекса брошенный мьютекс может указывать на то, что работа приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="78f3a-370">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f3a-371">В следующем примере показано, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу.</span><span class="sxs-lookup"><span data-stu-id="78f3a-371">The following example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="78f3a-372">Поток, создающий мьютексом не владеет его изначально.</span><span class="sxs-lookup"><span data-stu-id="78f3a-372">The thread that creates the mutex does not own it initially.</span></span> <span data-ttu-id="78f3a-373"><xref:System.Threading.Mutex.ReleaseMutex%2A> Метод позволяет освободить мьютекс, когда он больше не нужен.</span><span class="sxs-lookup"><span data-stu-id="78f3a-373">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is used to release the mutex when it is no longer needed.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="78f3a-374">Вызывающий поток не является владельцем мьютекса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-374">The calling thread does not own the mutex.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="78f3a-375">Текущий экземпляр уже удален.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-375">The current instance has already been disposed.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="78f3a-376">Управляемая поточность</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-376">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">
          <span data-ttu-id="78f3a-377">Mutexes</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-377">Mutexes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">
          <span data-ttu-id="78f3a-378">Объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для применения к именованному системному мьютексу.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-378">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78f3a-379">Задает безопасность управления доступом для именованного системного мьютекса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-379">Sets the access control security for a named system mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f3a-380">Пользователь должен иметь <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> права для вызова этого метода и мьютекс должен быть открыт с <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="78f3a-380">The user must have <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f3a-381">В следующем примере кода демонстрируется поведение между процессами именованного мьютекса с безопасность управления доступом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-381">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="78f3a-382">В примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегруженный метод для проверки на существование именованного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-382">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="78f3a-383">Если мьютекс не существует, он создается с изначальным владельцем, а также безопасность управления доступом, который запрещает текущий пользователь право на использование мьютексом, но не дает право на чтение и изменение разрешений для мьютекса.</span><span class="sxs-lookup"><span data-stu-id="78f3a-383">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="78f3a-384">Если запустить скомпилированный пример два командных окна, вторую копию вызовет нарушение прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="78f3a-384">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="78f3a-385">Порождено исключение, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегруженный метод, чтобы открыть мьютекс с помощью прав, необходимых для чтения и изменить разрешения, с помощью <xref:System.Threading.Mutex.GetAccessControl%2A> и <xref:System.Threading.Mutex.SetAccessControl%2A> методы.</span><span class="sxs-lookup"><span data-stu-id="78f3a-385">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="78f3a-386">После изменения разрешений, мьютекс открывается с права, необходимые для ввода и освободите его.</span><span class="sxs-lookup"><span data-stu-id="78f3a-386">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="78f3a-387">При запуске скомпилированный пример третий окно командной строки, он выполняется, под новые разрешения.</span><span class="sxs-lookup"><span data-stu-id="78f3a-387">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="78f3a-388">Свойство <paramref name="mutexSecurity" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-388">
              <paramref name="mutexSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="78f3a-389">Пользователь не имеет разрешений <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-389">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span>
          </span>
          <span data-ttu-id="78f3a-390">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-390">-or-</span>
          </span>
          <span data-ttu-id="78f3a-391">Мьютекс не был открыт с <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-391">The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="78f3a-392">Текущий объект <see cref="T:System.Threading.Mutex" /> не представляет именованный системный мьютекс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-392">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="78f3a-393">Открывает указанный именованный мьютекс, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-393">Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="78f3a-394">Имя системного мьютекса для открытия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-394">The name of the system mutex to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="78f3a-395">Когда выполнение этого метода завершается, содержит объект <see cref="T:System.Threading.Mutex" />, представляющий именованный мьютекс, если вызов завершился успешно, или значение <see langword="null" />, если произошел сбой вызова.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-395">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="78f3a-396">Этот параметр обрабатывается как неинициализированный.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-396">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78f3a-397">Открывает указанный именованный мьютекс, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-397">Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="78f3a-398">Значение <see langword="true" />, если именованный мьютекс был успешно открыт; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-398">
              <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f3a-399">Если именованный мьютекс существует, этот метод не создает его.</span><span class="sxs-lookup"><span data-stu-id="78f3a-399">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="78f3a-400">Для создания системного мьютекса, когда он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.</span><span class="sxs-lookup"><span data-stu-id="78f3a-400">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="78f3a-401">Если вы не уверены, является ли именованный мьютекс существует, используйте эту перегрузку метода вместо <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегрузку метода, который создает исключение, если мьютекс не существует.</span><span class="sxs-lookup"><span data-stu-id="78f3a-401">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="78f3a-402">Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-402">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="78f3a-403">Эта перегрузка метода эквивалентен вызову <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> перегрузку метода с указанием <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> права, объединяются с помощью побитовой операции или.</span><span class="sxs-lookup"><span data-stu-id="78f3a-403">This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="78f3a-404">Указание <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг позволяет потоку ожидать на мьютекс и указав <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг позволяет потоку на вызов метода <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="78f3a-404">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="78f3a-405">Этот метод не требует владения мьютексом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-405">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="78f3a-406">Параметр <paramref name="name" /> равен пустой строке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-406">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="78f3a-407">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-407">-or-</span>
          </span>
          <span data-ttu-id="78f3a-408">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-408">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="78f3a-409">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-409">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="78f3a-410">Произошла ошибка Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-410">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="78f3a-411">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-411">The named mutex exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="78f3a-412">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-412">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="78f3a-413">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-413">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="78f3a-414">Имя системного мьютекса для открытия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-414">The name of the system mutex to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="78f3a-415">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-415">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="78f3a-416">Когда выполнение этого метода завершается, содержит объект <see cref="T:System.Threading.Mutex" />, представляющий именованный мьютекс, если вызов завершился успешно, или значение <see langword="null" />, если произошел сбой вызова.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-416">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="78f3a-417">Этот параметр обрабатывается как неинициализированный.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-417">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="78f3a-418">Открывает указанный именованный мьютекс, если он уже существует, с требуемыми правами доступа, и возвращает значение, указывающее, успешно ли выполнена операция.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-418">Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="78f3a-419">Значение <see langword="true" />, если именованный мьютекс был успешно открыт; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-419">
              <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f3a-420">Если именованный мьютекс существует, этот метод не создает его.</span><span class="sxs-lookup"><span data-stu-id="78f3a-420">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="78f3a-421">Для создания системного мьютекса, когда он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторы, которые имеет `name` параметра.</span><span class="sxs-lookup"><span data-stu-id="78f3a-421">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="78f3a-422">Если вы не уверены, является ли именованный мьютекс существует, используйте эту перегрузку метода вместо <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузку метода, который создает исключение, если мьютекс не существует.</span><span class="sxs-lookup"><span data-stu-id="78f3a-422">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="78f3a-423">`rights` Параметр должен содержать <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> флаг, чтобы разрешить потоков для ожидания семафора и <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> флаг, чтобы разрешить потокам вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="78f3a-423">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="78f3a-424">Несколько вызовов этого метода, используйте то же значение для `name` не возвращают обязательно же <xref:System.Threading.Mutex> объекта, несмотря на то, что объекты, возвращаемые представляют один и тот же именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="78f3a-424">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="78f3a-425">Этот метод не требует владения мьютексом.</span><span class="sxs-lookup"><span data-stu-id="78f3a-425">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="78f3a-426">Параметр <paramref name="name" /> равен пустой строке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-426">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="78f3a-427">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-427">-or-</span>
          </span>
          <span data-ttu-id="78f3a-428">Длина значения параметра <paramref name="name" /> превышает 260 символов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-428">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="78f3a-429">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-429">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="78f3a-430">Произошла ошибка Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-430">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="78f3a-431">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-431">The named mutex exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="78f3a-432">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-432">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="78f3a-433">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="78f3a-433">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>