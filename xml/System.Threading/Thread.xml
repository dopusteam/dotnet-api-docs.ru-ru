<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e70f9d20899e16e6e96b4ac5eab474d2e7ee0c94" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58685510" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Создает и контролирует поток, задает приоритет и возвращает статус.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При запуске процесса, среда CLR автоматически создает один основной поток для выполнения кода приложения. Вместе с этой главной основной поток процесс можно создать один или несколько потоков для выполнения частей программного кода, связанный с процессом. Эти потоки могут выполнять на переднем плане или в фоновом режиме. Кроме того, можно использовать <xref:System.Threading.ThreadPool> класса для выполнения кода в рабочих потоках, которыми управляет среда CLR.  
  
 Содержание раздела  
  
 [Запуск потока](#Starting)   
 [Извлечение объектов потоков](#Retrieving)   
 [Основными и фоновыми потоками](#Foreground)   
 [Язык и региональные параметры и потоков](#Culture)   
 [Получение сведений о и управление потоками](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>Запуск потока  
 Запустить поток, указав делегат, который представляет метод, который является поток для выполнения в конструкторе класса. Затем можно вызвать <xref:System.Threading.Thread.Start%2A> метод, чтобы начать выполнение.  
  
 <xref:System.Threading.Thread> Конструкторы могут принимать одно из двух делегатов типов, в зависимости от того, можно ли передать аргумент метода для выполнения:  
  
-   Если метод не имеет аргументов, то можно передать <xref:System.Threading.ThreadStart> делегат в конструктор. Он имеет сигнатуру:  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     В следующем примере создает и запускает поток, который выполняет `ExecuteInForeground` метод. Метод отображает сведения о некоторых свойств потока, а затем исполняет цикл, в котором он приостанавливает полсекунды и отображает прошедшее число секунд. При выполнении потока в течение пяти секунд, цикл завершается и поток завершает выполнение.  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   Если метод имеет аргумента, то можно передать <xref:System.Threading.ParameterizedThreadStart> делегат в конструктор. Он имеет сигнатуру:  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     Метод, выполняемый делегат можно затем приведите (в C#) или преобразуйте (в Visual Basic) параметр к соответствующему типу.  
  
     Следующий пример идентичен предыдущему, за исключением того, чтобы он вызывал <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> конструктор. Эта версия `ExecuteInForeground` метод имеет один параметр, который представляет приблизительное число миллисекунд, является выполнение цикла.  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 Нет необходимости сохранять ссылку на <xref:System.Threading.Thread> объекта после запуска потока. Поток продолжит выполнение до завершения процедуры потока.  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>Извлечение объектов потоков  
 Можно использовать статический (`Shared` в Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> свойства, чтобы получить ссылку на текущий выполняемый поток из кода, который выполняется поток. В следующем примере используется <xref:System.Threading.Thread.CurrentThread%2A> свойство для отображения сведений о основного потока приложения, другой поток переднего плана, в фоновом потоке и поток из пула потоков.  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>Основными и фоновыми потоками  
 Экземпляры <xref:System.Threading.Thread> класс представлять фоновых потоков или потоков переднего плана. Фоновые потоки отличаются основного потока с одним исключением: фоновый поток не сохраняется процесс, выполняемый, если все основные потоки завершены. После всех основных потоков закончена, среда выполнения останавливает все фоновые потоки и завершает работу.  
  
 По умолчанию перечисленных ниже потоков выполняются в фоновом режиме:  
  
-   Основной поток приложения.  
  
-   Все потоки, созданные путем вызова <xref:System.Threading.Thread> конструктора класса.  
  
 По умолчанию в фоновом режиме выполняются следующие потоков:  
  
-   Поток пула потоков, которые являются пул рабочих потоков, которые обслуживаются средой выполнения.  Действия потока пула и расписание можно настроить в потоках пула потоков с помощью <xref:System.Threading.ThreadPool> класса.  
  
    > [!NOTE]
    >  Асинхронные операции на основе задач, автоматическое выполнение в потоках пула потоков. Используйте асинхронные операции на основе задач <xref:System.Threading.Tasks.Task> и <xref:System.Threading.Tasks.Task%601> классы для реализации [асинхронную модель на основе задач](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).  
  
-   Все потоки, которые входят в управляемую среду выполнения из неуправляемого кода.  
  
 Чтобы указать, чтобы выполнить в фоновом режиме, задав <xref:System.Threading.Thread.IsBackground%2A> свойство в любое время.  Фоновые потоки можно использовать для любой операции, следует продолжать до тех пор, пока приложение выполняется, но не предотвращения завершения работы, такие как мониторинг изменений в файловой системе или входящие подключения через сокет приложения.  
  
 В следующем примере показано различие между основными и фоновыми потоками. Это как в первом примере в [запуску потока](#Starting) разделе, за исключением того, что он устанавливает выполнение в фоновом режиме, перед запуском потока. Как показывает вывод, цикл прерывается до его выполнения в течение пяти секунд.  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>Язык и региональные параметры и потоков  
 Каждый поток имеет региональных параметрах, представленное <xref:System.Threading.Thread.CurrentCulture%2A> свойства, а также язык и региональные параметры пользовательского интерфейса, представленного <xref:System.Threading.Thread.CurrentUICulture%2A> свойство.  Текущий язык и региональные параметры поддерживает таких операций с учетом языка и региональных параметров как синтаксического анализа и форматирования, сравнение и сортировка строк, а также определяет систему письма и календарь, используемый потоком. Текущий язык и региональные параметры пользовательского интерфейса предоставляет получение региональных ресурсов в файлах ресурсов.  

> [!IMPORTANT]
> <xref:System.Threading.Thread.CurrentCulture> И <xref:System.Threading.Thread.CurrentUICulture> свойства не работают надежно, при использовании любого потока, отличного от текущего потока. В .NET Framework чтение эти свойства, является надежным, несмотря на то, что задание этих свойств для потока, отличного от текущего потока не является. В .NET Core <xref:System.InvalidOperationException> возникает, если поток пытается читать или записывать эти свойства в другом потоке.
> Мы рекомендуем использовать <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> и <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> свойства, чтобы получить и задать текущего языка и региональных параметров.

 При создании экземпляра нового потока, его язык и региональные параметры пользовательского интерфейса определяются текущий язык и региональные параметры и язык и региональные параметры пользовательского интерфейса, а не языка и региональных параметров пользовательского интерфейса потока, из которого создается новый поток. Таким образом, к примеру, если текущий язык и региональные параметры системы является английский (США) и текущий язык потока основного приложения — французский (Франция), язык и региональные параметры нового потока, созданных вызывающими <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> конструктора из основного потока является английский (США) и французского (Франция). Дополнительные сведения см. в разделе «Язык и региональные параметры и потоки» из <xref:System.Globalization.CultureInfo> разделе, посвященном классу.  
  
> [!IMPORTANT]
>  Это справедливо не для потоков, выполняемых асинхронных операций для приложений, предназначенных [!INCLUDE[net_v46](~/includes/net-v46-md.md)] и более поздних версий, в нашем примере, язык и региональные параметры пользовательского интерфейса является частью асинхронных операций контекста; в поток, в котором асинхронной операции выполняет по умолчанию наследует язык и региональные параметры пользовательского интерфейса потока, из которого была запущена асинхронной операции. Дополнительные сведения см. в подразделе "Язык и региональные параметры в асинхронных операциях на основе задач" раздела, посвященного классу <xref:System.Globalization.CultureInfo>.  
  
 Можно выполнить одно из следующих действий, чтобы убедиться, что все потоки выполнения в приложении совместно использовать же язык и региональные параметры пользовательского интерфейса:  
  
-   Вы можете передать <xref:System.Globalization.CultureInfo> объект, представляющий этот язык для <xref:System.Threading.ParameterizedThreadStart> делегировать или <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> метод.  
  
-   Для приложений, выполняющихся [!INCLUDE[net_v45](~/includes/net-v45-md.md)] и более поздних версиях можно определить язык и региональные параметры пользовательского интерфейса, должно быть присвоено для всех потоков, созданных в домене приложения, задав значение <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> и <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> свойства. Обратите внимание на то, что это параметр на уровне домена приложения.  

 Дополнительные сведения и примеры см. в разделе «Язык и региональные параметры и потоки» из <xref:System.Globalization.CultureInfo> разделе, посвященном классу.

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>Получение сведений о и управление потоками  
 Можно получить несколько значений свойств, которые предоставляют сведения о потоке. В некоторых случаях можно также задать значения этих свойств для управления ее работой потока. Эти свойства потока:  
  
-   Имя. <xref:System.Threading.Thread.Name%2A> выполняет запись — один раз свойство, которое можно использовать для определения потока.  Значение по умолчанию — `null`.  
  
-   Хэш-код, который можно получить, вызвав <xref:System.Threading.Thread.GetHashCode%2A> метод. Хэш-код можно использовать для уникальной идентификации поток; в течение времени существования вашего потока ее хэш-код не будет конфликтовать со значением из любого другого потока, независимо от домена приложения, из которого получается значение.  
  
-   Идентификатор потока. Значение только для чтения <xref:System.Threading.Thread.ManagedThreadId%2A> свойство назначается средой выполнения и уникально идентифицирует поток внутри своего процесса.  
  
    > [!NOTE]
    >  [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) операционной системы не имеет фиксированного отношения с управляемым потоком, так как неуправляемый узел может управлять отношением между управляемым и неуправляемым потоками. В частности, можно использовать более сложный узел [API размещения CLR](https://msdn.microsoft.com/library/ms404385.aspx) спланировать нескольких управляемых потоков на один поток операционной системы или перемещать управляемый поток между различными потоками операционной системы.  
  
-   Текущее состояние потока. В течение своего существования поток всегда находится в одном или нескольких из состояний, определенных с <xref:System.Threading.ThreadState> свойство.  
  
-   Планирование уровня приоритета, который определяется с <xref:System.Threading.ThreadPriority> свойство. Несмотря на то, что это значение для запроса приоритет потока, не гарантируется предоставит операционной системой.  
  
-   Только для чтения <xref:System.Threading.Thread.IsThreadPoolThread%2A> свойство, которое указывает, является ли поток пула потоков.  
  
-   Свойство <xref:System.Threading.Thread.IsBackground%2A>. Дополнительные сведения см. в разделе [переднего плана и фоновыми потоками](#Foreground) раздел.  
  
## Examples  
 Ниже приведен пример простой функции потоков.  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 Этот код создает выходные данные следующего вида:  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Потоки и работа с потоками</related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Использование потоков и работа с потоками</related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96">Ссылки на источник потока</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Thread" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start">Делегат, указывающий на методы, которые вызываются при запуске потока.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Thread" />, при этом указывается делегат, позволяющий объекту быть переданным в поток при запуске потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток не запускается при его создании. Чтобы запланировать этот поток для выполнения, вызовите <xref:System.Threading.Thread.Start%2A> метод. Чтобы передать объект данных в поток, используйте <xref:System.Threading.Thread.Start%28System.Object%29> перегрузки метода.  
  
> [!NOTE]
>  Пользователи Visual Basic могут опускать <xref:System.Threading.ThreadStart> конструктор при создании потока. Используйте `AddressOf` оператор при передаче в метод, например `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic автоматически вызывает <xref:System.Threading.ThreadStart> конструктор.  
  
   
  
## Examples  
 В примере показан синтаксис для создания и использования <xref:System.Threading.ParameterizedThreadStart> делегат со статическим методом и методом экземпляра.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Создание потоков</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Делегат <see cref="T:System.Threading.ThreadStart" />, указывающий на методы, которые вызываются при запуске потока.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Thread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток не запускается при его создании. Чтобы запланировать этот поток для выполнения, вызовите <xref:System.Threading.Thread.Start%2A> метод.  
  
> [!NOTE]
>  Пользователи Visual Basic могут опускать <xref:System.Threading.ThreadStart> конструктор при создании потока. Используйте `AddressOf` оператор при передаче в метод, например `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic автоматически вызывает <xref:System.Threading.ThreadStart> конструктор.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать поток, который выполняет статический метод.  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 В следующем примере кода показано, как создать поток, который выполняется методом экземпляра.  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="start" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Создание потоков</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="start">Делегат <see cref="T:System.Threading.ParameterizedThreadStart" />, указывающий на методы, которые вызываются при запуске потока.</param>
        <param name="maxStackSize">Максимальный размер стека в байтах, используемый потоком, или же 0 для использования максимального размера по умолчанию, указывается в заголовке исполняемого файла.  
  
Внимание! Для частично доверенного кода значение параметра <paramref name="maxStackSize" /> игнорируется, если оно превышает размер стека по умолчанию. Исключение не возникает.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Thread" />, при этом указывается делегат, позволяющий объекту быть переданным в поток при запуске потока с указанием максимального размера стека для потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не используйте эту перегрузку конструктора. Размер стека по умолчанию, используемые <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> перегрузку конструктора — это размер стека, рекомендуемые для потоков. Если поток имеет проблем с памятью, наиболее вероятной причиной является программирования ошибка, например бесконечную рекурсию.  
  
> [!IMPORTANT]
>  Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], только полностью доверенный код может задавать `maxStackSize` которого является значение, больше, чем размер стека по умолчанию (1 МБ). Если указано большее значение для `maxStackSize` при выполнении кода с частичным доверием `maxStackSize` игнорируется и используется размер стека по умолчанию. Исключение не возникает. Код на любом уровне доверия может задавать `maxStackSize` которого является значение, меньше, чем размер стека по умолчанию.  
  
> [!NOTE]
>  Если вы разрабатываете полностью доверяемым библиотекам, который будет использоваться частично доверенным кодом, и вам нужно запустить поток, требует большого стека, необходимо установить полное доверие перед созданием потока или размер стека по умолчанию будет использоваться. Не делайте этого, если вы полностью контролировать код, который выполняется в потоке.  
  
 Если `maxStackSize` меньше, чем минимальный размер стека, используется минимальный размер стека. Если `maxStackSize` не кратному размеру страницы, его значение округляется до следующего размера, кратного большего размера страницы. Например если вы используете .NET Framework версии 2.0 в Windows Vista, 256 КБ (262 144 байт) является минимальным размером стека и размер страницы составляет 64 КБ (65 536 байт).  
  
> [!NOTE]
>  В версиях Microsoft Windows до Windows XP и Windows Server 2003 `maxStackSize` игнорируется, и используется размер стека, заданному в заголовке исполняемого файла.  
  
 При указании очень малого размера стека, может потребоваться отключить проверку переполнения стека. Если стек строго ограничивается, проверка сама может вызвать переполнение стека. Чтобы отключить проверку переполнения стека, добавьте следующий файл конфигурации приложения.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maxStackSize" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="start">Делегат <see cref="T:System.Threading.ThreadStart" />, указывающий на методы, которые вызываются при запуске потока.</param>
        <param name="maxStackSize">Максимальный размер стека в байтах, используемый потоком, или же 0 для использования максимального размера по умолчанию, указывается в заголовке исполняемого файла.  
  
Внимание! Для частично доверенного кода значение параметра <paramref name="maxStackSize" /> игнорируется, если оно превышает размер стека по умолчанию. Исключение не возникает.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Thread" />, указывая максимальный размер стека для потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не используйте эту перегрузку конструктора. Размер стека по умолчанию, используемые <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> перегрузку конструктора — это размер стека, рекомендуемые для потоков. Если поток имеет проблем с памятью, наиболее вероятной причиной является программирования ошибка, например бесконечную рекурсию.  
  
> [!IMPORTANT]
>  Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], только полностью доверенный код может задавать `maxStackSize` которого является значение, больше, чем размер стека по умолчанию (1 МБ). Если указано большее значение для `maxStackSize` при выполнении кода с частичным доверием `maxStackSize` игнорируется и используется размер стека по умолчанию. Исключение не возникает. Код на любом уровне доверия может задавать `maxStackSize` которого является значение, меньше, чем размер стека по умолчанию.  
  
> [!NOTE]
>  Если вы разрабатываете полностью доверяемым библиотекам, который будет использоваться частично доверенным кодом, и вам нужно запустить поток, требует большого стека, необходимо установить полное доверие перед созданием потока или размер стека по умолчанию будет использоваться. Не делайте этого, если вы полностью контролировать код, который выполняется в потоке.  
  
 Если `maxStackSize` меньше, чем минимальный размер стека, используется минимальный размер стека. Если `maxStackSize` не кратному размеру страницы, его значение округляется до следующего размера, кратного большего размера страницы. Например если вы используете .NET Framework версии 2.0 в Windows Vista, 256 КБ (262 144 байт) является минимальным размером стека и размер страницы составляет 64 КБ (65 536 байт).  
  
> [!NOTE]
>  В версиях Microsoft Windows до Windows XP и Windows Server 2003 `maxStackSize` игнорируется, и используется размер стека, заданному в заголовке исполняемого файла.  
  
 При указании очень малого размера стека, может потребоваться отключить проверку переполнения стека. Если стек строго ограничивается, проверка сама может вызвать переполнение стека. Чтобы отключить проверку переполнения стека, добавьте следующий файл конфигурации приложения.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maxStackSize" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывает исключение <see cref="T:System.Threading.ThreadAbortException" /> в вызвавшем его потоке для того, чтобы начать процесс завершения потока. Вызов данного метода обычно завершает поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> `Thread.Abort` Метод должен использоваться с осторожностью. Особенно в том случае, если его вызвать прерывание потока, отличного от текущего потока, вы не знаете какой код выполнен или не удалось выполнить, когда <xref:System.Threading.ThreadAbortException> возникает исключение, а также могут быть определенные состояния приложения или любого приложения и пользовательскими гласят, что ответственность за сохранение. Например, вызов `Thread.Abort` может помешать выполнению статических конструкторов или предотвращения освобождение неуправляемых ресурсов. 
>
> Обратите внимание, что `Thread.Abort` метод не поддерживается в .NET Core.

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает исключение <see cref="T:System.Threading.ThreadAbortException" /> в вызвавшем его потоке для того, чтобы начать процесс завершения потока. Вызов данного метода обычно завершает поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда этот метод вызывается в потоке, система создает <xref:System.Threading.ThreadAbortException> в потоке ее отмены. `ThreadAbortException` — Это специальное исключение, которое может быть перехвачено кодом приложения, но вызывается повторно в конце `catch` блокируется, пока <xref:System.Threading.Thread.ResetAbort%2A> вызывается. `ResetAbort` Отменяет запрос на отмену и предотвращает `ThreadAbortException` от завершения потока. Невыполненные `finally` блоки выполняются в том случае, прежде чем поток прерван.  
  
> [!NOTE]
>  Если поток вызывает `Abort` для себя, аналогично вызову исключения; <xref:System.Threading.ThreadAbortException> происходит немедленно, и результат является предсказуемым. Тем не менее если один поток вызывает `Abort` в другом потоке, аварийное завершение прерывает любой выполняющийся код. Также есть вероятность того, что статический конструктор может быть прервана. В редких случаях это может помешать экземпляры этого класса, создаваемых в этом домене приложения. В .NET Framework версий 1.0 и 1.1, есть вероятность того, удалось прервать поток пока `finally` блок выполняется, в этом случае `finally` блок прерывается.  
  
 Не гарантируется, что поток прервется немедленно или вообще. Эта ситуация может возникнуть, если поток выполняет неограниченное количество вычислений в `finally` блоки, которые вызываются как часть процедуры прерывания, тем самым неограниченное время задержки прерывания. Подождите, пока поток был прерван, можно последовательно вызвать методы <xref:System.Threading.Thread.Join%2A> метод в потоке после вызова метода <xref:System.Threading.Thread.Abort%2A> метод, но нет никакой гарантии, истекает время ожидания.  
  
> [!NOTE]
>  Поток, вызывающий <xref:System.Threading.Thread.Abort%2A> может блокироваться, если поток, который прерывается, находится в защищенной области кода, таких как `catch` блока, `finally` блока или область ограниченного выполнения. Если на поток, который вызывает <xref:System.Threading.Thread.Abort%2A> удерживает блокировку, прерванным потоком, может возникнуть взаимоблокировка.  
  
 Если `Abort` вызывается в потоке, который не был запущен, поток будет прерван, когда <xref:System.Threading.Thread.Start%2A> вызывается. Если `Abort` вызывается в потоке, который заблокирован или в спящем режиме, поток прерван и затем прервана.  
  
 Если `Abort` вызывается в потоке, который был приостановлен, <xref:System.Threading.ThreadStateException> создается в потоке, который вызвал <xref:System.Threading.Thread.Abort%2A>, и <xref:System.Threading.ThreadState.AbortRequested> добавляется <xref:System.Threading.Thread.ThreadState%2A> свойство аварийно завершающимся потоком. Объект <xref:System.Threading.ThreadAbortException> не будет создано в приостановленном потоке до <xref:System.Threading.Thread.Resume%2A> вызывается.  
  
 Если `Abort` вызывается для управляемого потока при выполнении неуправляемого кода, `ThreadAbortException` не генерируется до возврата потока в управляемом коде.  
  
 Если два вызова к `Abort` поступать в то же время, это возможно для одного вызова задать сведения о состоянии и вызов на выполнение `Abort`. Однако приложение не может определить ситуацию.  
  
 После `Abort` вызывается в потоке, состояние потока включает в себя <xref:System.Threading.ThreadState.AbortRequested>. После завершения потока в результате успешного вызова `Abort`, изменения состояния потока на <xref:System.Threading.ThreadState.Stopped>. С достаточными разрешениями поток, который является целевым объектом `Abort` можно отменить аварийное завершение, используя `ResetAbort` метод. Пример, демонстрирующий вызов `ResetAbort` метод, см. в разделе `ThreadAbortException` класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Только в .NET Core: этот элемент не поддерживается.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Поток, который прерывается, в настоящий момент приостановлен.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для дополнительных операций в потоках. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Потоки и работа с потоками</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Использование потоков и работа с потоками</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Удаление потоков</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="stateInfo">Объект, который содержит информацию об определенном приложении, например состояние, которое может использоваться аварийно завершающимся потоком.</param>
        <summary>Вызывает исключение <see cref="T:System.Threading.ThreadAbortException" /> в вызвавшем его потоке для того, чтобы начать процесс завершения потока, в то же время предоставляя сведения об исключении касательно исключения завершения потока. Вызов данного метода обычно завершает поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда этот метод вызывается в потоке, система создает <xref:System.Threading.ThreadAbortException> в потоке ее отмены. `ThreadAbortException` — Это специальное исключение, которое может быть перехвачено кодом приложения, но вызывается повторно в конце `catch` блокируется, пока <xref:System.Threading.Thread.ResetAbort%2A> вызывается. `ResetAbort` Отменяет запрос на отмену и предотвращает `ThreadAbortException` от завершения потока. Невыполненные `finally` блоки выполняются в том случае, прежде чем поток прерван.  
  
> [!NOTE]
>  Если поток вызывает `Abort` для себя, аналогично вызову исключения; <xref:System.Threading.ThreadAbortException> происходит немедленно, и результат является предсказуемым. Тем не менее если один поток вызывает `Abort` в другом потоке, аварийное завершение прерывает любой выполняющийся код. Есть вероятность того, что статический конструктор может быть прервана. В редких случаях это может помешать экземпляры этого класса, создаваемых в этом домене приложения. В .NET Framework версий 1.0 и 1.1, есть вероятность того, удалось прервать поток пока `finally` блок выполняется, в этом случае `finally` блок прерывается.  
  
 Не гарантируется, что поток прервется немедленно или вообще. Эта ситуация может возникнуть, если поток выполняет неограниченное количество вычислений в `finally` блоки, которые вызываются как часть процедуры прерывания, тем самым неограниченное время задержки прерывания. Подождите, пока поток был прерван, можно последовательно вызвать методы <xref:System.Threading.Thread.Join%2A> метод в потоке после вызова метода <xref:System.Threading.Thread.Abort%2A> метод, но нет никакой гарантии, что время ожидания истекает.  
  
> [!NOTE]
>  Поток, вызывающий <xref:System.Threading.Thread.Abort%2A> может блокироваться, если поток, который прерывается, находится в защищенной области кода, таких как `catch` блока, `finally` блока или область ограниченного выполнения. Если на поток, который вызывает <xref:System.Threading.Thread.Abort%2A> удерживает блокировку, прерванным потоком, может возникнуть взаимоблокировка.  
  
 Если `Abort` вызывается в потоке, который не был запущен, поток будет прерван, когда <xref:System.Threading.Thread.Start%2A> вызывается. Если `Abort` вызывается в потоке, который заблокирован или в спящем режиме, поток прерван и затем прервана.  
  
 Если `Abort` вызывается в потоке, который был приостановлен, <xref:System.Threading.ThreadStateException> создается в потоке, который вызвал <xref:System.Threading.Thread.Abort%2A>, и <xref:System.Threading.ThreadState.AbortRequested> добавляется <xref:System.Threading.Thread.ThreadState%2A> свойство аварийно завершающимся потоком. Объект <xref:System.Threading.ThreadAbortException> не будет создано в приостановленном потоке до <xref:System.Threading.Thread.Resume%2A> вызывается.  
  
 Если `Abort` вызывается для управляемого потока при выполнении неуправляемого кода, `ThreadAbortException` не генерируется до возврата потока в управляемом коде.  
  
 Если два вызова к `Abort` поступать в то же время, это возможно для одного вызова задать сведения о состоянии и вызов на выполнение `Abort`. Однако приложение не может определить ситуацию.  
  
 После `Abort` вызывается в потоке, состояние потока включает в себя <xref:System.Threading.ThreadState.AbortRequested>. После завершения потока в результате успешного вызова `Abort`, изменения состояния потока на <xref:System.Threading.ThreadState.Stopped>. С достаточными разрешениями поток, который является целевым объектом `Abort` можно отменить аварийное завершение, используя `ResetAbort` метод. Пример, демонстрирующий вызов `ResetAbort` метод, см. в разделе `ThreadAbortException` класса.  
  
   
  
## Examples  
 В следующем примере кода показано, как осуществлять обмен информацией с потоком, который прерывается.  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Только в .NET Core: этот элемент не поддерживается.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Поток, который прерывается, в настоящий момент приостановлен.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для дополнительных операций в потоках. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Потоки и работа с потоками</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Использование потоков и работа с потоками</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Удаление потоков</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выделяет неименованную область данных всем потокам. Для улучшения производительности используйте поля, отмеченные атрибутом <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Выделенная именованная область данных всем потокам.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Платформа .NET Framework предоставляет два механизма для использования локальной памяти потока (TLS): статические поля потока (то есть поля, помеченные атрибутом <xref:System.ThreadStaticAttribute> атрибут) и области данных. Статические поля потоков обеспечивают более высокую производительность, чем области данных и включите проверку типов во время компиляции. Дополнительные сведения об использовании TLS см. в разделе [локальное хранилище потока: Статические поля потока и области данных](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Область данных выделяется во всех потоках.  
  
 Потоки используют механизм памяти локального хранилища для хранения данных определенного потока. Среда CLR выделяет массив хранения данных несколькими слот каждому процессу при его создании. Поток может выделять область данных в хранилище данных, сохраняйте и загружайте данных значение в слоте и освободить область для повторного использования, после истечения срока действия потока. Области данных уникальны для каждого потока. Ни один поток (даже дочерний поток) может вывести эти данные.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. Первый пример показано, как использовать поле, помечается <xref:System.ThreadStaticAttribute> атрибут для хранения информации о потоках. Во втором примере показано, как использование области данных, чтобы сделать то же самое.  
  
 **В первом примере**  
  
 Приведенный ниже показано, как использовать поле, помечается <xref:System.ThreadStaticAttribute> для хранения информации о потоках. Этот метод обеспечивает более высокую производительность, чем метод, который отображается во втором примере.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Во втором примере**  
  
 В следующем примере кода демонстрируется использование области данных для хранения информации о потоках.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Потоки и работа с потоками</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Локальное хранилище потока: статические поля потока и области данных</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Имя выделяемой области данных.</param>
        <summary>Выделяет именованную область данных всем потокам. Для улучшения производительности используйте поля, отмеченные атрибутом <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Выделенная именованная область данных всем потокам.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Платформа .NET Framework предоставляет два механизма для использования локальной памяти потока (TLS): статические поля потока (то есть поля, помеченные атрибутом <xref:System.ThreadStaticAttribute> атрибут) и области данных. Статические поля потоков обеспечивают более высокую производительность, чем области данных и включите проверку типов во время компиляции. Дополнительные сведения об использовании TLS см. в разделе [локальное хранилище потока: Статические поля потока и области данных](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Потоки используют механизм памяти локального хранилища для хранения данных определенного потока. Среда CLR выделяет массив хранения данных несколькими слот каждому процессу при его создании. Поток может выделять область данных в хранилище данных, сохраняйте и загружайте данных значение в слоте и освободить область для повторного использования, после истечения срока действия потока. Области данных уникальны для каждого потока. Ни один поток (даже дочерний поток) может вывести эти данные.  
  
 Нет необходимости использовать <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> метод, чтобы выделить именованную область данных, так как <xref:System.Threading.Thread.GetNamedDataSlot%2A> метод выделяет область, если он еще не выделен.  
  
> [!NOTE]
>  Если <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> метод используется, она должна вызываться в основном потоке при запуске программы, так как он создает исключение, если слот с указанным именем уже выделено. Нет способа для проверки слот уже выделено.  
  
 Слоты, выделенных с помощью этого метода должны быть высвобождены с <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. Первый пример показано, как использовать поле, помечается <xref:System.ThreadStaticAttribute> атрибут для хранения информации о потоках. Во втором примере показано, как использование области данных, чтобы сделать то же самое.  
  
 **В первом примере**  
  
 Приведенный ниже показано, как использовать поле, помечается <xref:System.ThreadStaticAttribute> для хранения информации о потоках. Этот метод обеспечивает более высокую производительность, чем метод, который отображается во втором примере.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Во втором примере**  
  
 В следующем примере показано, как использовать именованную область данных для хранения информации о потоках.  
  
> [!NOTE]
>  В примере кода не использует <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> метод, так как <xref:System.Threading.Thread.GetNamedDataSlot%2A> метод выделяет область, если он еще не выделен. Если <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> метод используется, она должна вызываться в основном потоке при запуске программы.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Именованная область данных с указанным именем уже существует.</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Потоки и работа с потоками</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Локальное хранилище потока: статические поля потока и области данных</related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает модель "apartment" для данного потока.</summary>
        <value>Одно из значений <see cref="T:System.Threading.ApartmentState" />. Начальное значение — <see langword="Unknown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **<xref:System.Threading.Thread.ApartmentState%2A> Свойство является устаревшим.**  Альтернативы устаревшему <xref:System.Threading.Thread.GetApartmentState%2A> метод для извлечения состояние подразделения и <xref:System.Threading.Thread.SetApartmentState%2A> метод, чтобы задать состояние подразделения.  
  
 В .NET Framework версий 1.0 и 1.1 `ApartmentState` свойство помечает поток, чтобы показать, что он будет выполнен в однопоточных или многопоточных апартаменте. Это свойство можно задать, если поток находится в `Unstarted` или `Running` состоянии; тем не менее, его можно задать только один раз для потока. Если свойство не было задано, будет возвращено `Unknown`.  
  
 Предпринята попытка использования <xref:System.Threading.Thread.ApartmentState%2A> учитывается свойство, чтобы задать состояние подразделения потока, имеющий состояние подразделения уже задан. Тем не менее <xref:System.Threading.Thread.SetApartmentState%2A> вызывает метод <xref:System.InvalidOperationException> в данном случае.  
  
> [!IMPORTANT]
>  В .NET Framework версии 2.0, новые потоки инициализируются как <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> если их состояние подразделения не было задано, прежде чем они запускаются. Основной поток приложения инициализируется <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> по умолчанию. Основной поток приложения могут больше не устанавливаются в <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> , задав <xref:System.Threading.ApartmentState?displayProperty=nameWithType> свойство в первой строке кода. Используйте <xref:System.STAThreadAttribute> вместо этого.  
  
 В .NET Framework версии 2.0, можно указать потоковой моделью COM для приложения C++ с помощью [/CLRTHREADATTRIBUTE (значение атрибута потока среды CLR)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) параметр компоновщика.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать состояние подразделения потока.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Предпринята попытка задать в этом свойстве состояние, которое не является допустимым состоянием подразделения (состояние, отличное от однопотокового подразделения (<see langword="STA" />) или многопотокового подразделения (<see langword="MTA" />)).</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уведомляет узел, что выполнение близится ко входу в область кода, в которой эффекты прерывания выполнения или неуправляемого выполнения могут повлиять на другие задачи в домене приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Узлы среды выполнения (CLR), например Microsoft SQL Server 2005, могут устанавливать различные политики для сбоев в критических и некритических областей кода. Критической области является одним в которой эффекты прерывания потока или необработанного исключения может не ограничиваться текущей задачей. Напротив прерывание или сбой в области кода, не являющиеся критически влияет на только задачи, в котором произошла ошибка.  
  
 Например рассмотрим задачу, которая пытается выделить память при удерживании блокировки. Если происходит сбой выделения памяти, прерывания текущей задачи недостаточно для обеспечения стабильности <xref:System.AppDomain>, так как может существовать другие задачи в домене, Ожидание ту же блокировку. Если текущая задача завершается, может блокироваться другие задачи.  
  
 Если сбой происходит в критической области, узел может потребоваться выгрузить весь <xref:System.AppDomain> вместо рискнуть продолжения выполнения в потенциально нестабильном состоянии. Чтобы сообщить узла, что ваш код переходит в критической области, вызовите <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Вызовите <xref:System.Threading.Thread.EndCriticalRegion%2A> когда выполнение возвращается некритические области кода.  
  
 С помощью этого метода в коде, выполняемом в SQL Server 2005 требуется код для запуска на самый высокий уровень защиты узла.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Threading.Thread.BeginCriticalRegion%2A> и <xref:System.Threading.Thread.EndCriticalRegion%2A> методов для разделения критических и некритических областях блока кода.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уведомляет узел, что управляемый код близок к выполнению инструкций, зависящих от идентификации текущего потока операционной системы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые узлы среда CLR, например Microsoft SQL Server 2005 предоставляют собственное управление потоками. Узел, который предоставляет свой собственный поток управления можно переместить выполняющуюся задачу из одного физического потока операционной системы в другую в любое время. Большинство задач не затрагивает это переключение. Тем не менее некоторые задачи поддерживают сходство потоков, — то есть они зависят от удостоверения потока операционной системы. Эти задачи необходимо проинформировать узел выполняемого кода, который не будет установлено.  
  
 Например, если заблокировать приложение вызывает API системы для получения операционной системы, реализует сходство потоков, таких как Win32 CRITICAL_SECTION, необходимо вызвать <xref:System.Threading.Thread.BeginThreadAffinity%2A> до запроса на блокировку и <xref:System.Threading.Thread.EndThreadAffinity%2A> после освобождения блокировки.  
  
 С помощью этого метода в коде, выполняемом в SQL Server 2005 требуется код для запуска на самый высокий уровень защиты узла.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Threading.Thread.BeginThreadAffinity%2A> и <xref:System.Threading.Thread.EndThreadAffinity%2A> методы для уведомления узла, который зависит от блока кода с удостоверением потока операционной системы.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущий контекст, в котором выполняется поток.</summary>
        <value>Класс <see cref="T:System.Runtime.Remoting.Contexts.Context" />, представляющий текущий контекст потока.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает язык и региональные параметры для текущего потока.</summary>
        <value>Объект, представляющий язык и региональные параметры, используемые текущим потоком.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo> Объект, возвращаемый этим свойством, а также связанных с ним объектов, определить формат по умолчанию для дат, времени, чисел, денежных значений, сортировки порядок текста, регистр соглашения, а операции сравнения строк. См. в разделе <xref:System.Globalization.CultureInfo> класса Дополнительные сведения о языке и региональных параметрах имена и идентификаторы, различия между инвариантные, нейтральные и конкретные языки и региональные параметры, и влияет на способ сведения о культуре, потоков и доменов приложений. См. в разделе <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> свойство, чтобы узнать, как определяется язык и региональные параметры потока по умолчанию, и как пользователи задать сведения о культуре для их компьютеров.  

> [!IMPORTANT]
> <xref:System.Threading.Thread.CurrentCulture> Свойство работает ненадежно при использовании любого потока, отличного от текущего потока. В .NET Framework чтение свойства надежен, несмотря на то, что указывать его для потока, отличного от текущего потока не. В .NET Core <xref:System.InvalidOperationException> возникает, если поток пытается прочитать или записать <xref:System.Threading.Thread.CurrentCulture> свойство в другом потоке.
> Мы рекомендуем использовать <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> свойство для получения и задания текущего языка и региональных параметров.

 Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], можно задать <xref:System.Threading.Thread.CurrentCulture%2A> свойство для нейтрального языка и региональных параметров. Это обусловлено поведением <xref:System.Globalization.CultureInfo> класс был изменен: Если оно представляет нейтрального языка и региональных параметров, значения его свойств (в частности, <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, и <xref:System.Globalization.CultureInfo.TextInfo%2A> свойства) теперь отражают определенного языка и региональных параметров, который связан с нейтральным языком и региональными параметрами. В более ранних версиях .NET Framework <xref:System.Threading.Thread.CurrentCulture%2A> вызвал свойство <xref:System.NotSupportedException> исключение, когда была назначена нейтрального языка и региональных параметров.  
  
## Examples  
 В следующем примере показано потоковый оператор, который позволяет пользовательскому интерфейсу приложения Windows Forms для отображения в языка и региональных параметров, который задается в панели управления. Необходим дополнительный код.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Для свойства задано значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Только в .NET Core: чтение или запись данных о языке и региональных параметрах потока из другого потока не поддерживается.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для задания этого свойства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает текущего участника потока (для безопасности на основе ролей).</summary>
        <value>Значение <see cref="T:System.Security.Principal.IPrincipal" />, представляющее контекст безопасности.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как задание и получение участника потока.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект не имеет разрешений, необходимых для задания участника.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы управлять объектом участника. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает выполняющийся в данный момент поток.</summary>
        <value>Объект <see cref="T:System.Threading.Thread" />, представляющий собой выполняющийся в данный момент поток.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается задача, которая в свою очередь создает 20 дочерних задач. Само приложение, как хорошо каждая задача вызывает `ShowThreadInformation` метод, который использует <xref:System.Threading.Thread.CurrentThread%2A> свойство для отображения сведений о потоке, на котором он выполняется.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 Каждая дочерняя задача создает 1 миллион случайных чисел от 1 до 1 миллиона и возвращает среднего значения. Родительские задачи вызовы <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> метод, чтобы гарантировать, что дочерние задачи выполнены перед отображением среднего значения, возвращаемые каждой задачи и вычисление среднего значения означает, что.  
  
 Обратите внимание на то, что во время выполнения приложения в потоке переднего плана, каждая задача выполняется в потоке пула потоков.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает текущие язык и региональные параметры, используемые диспетчером ресурсов для поиска ресурсов, связанных с языком и региональными параметрами, во время выполнения.</summary>
        <value>Объект, представляющий текущие языковые стандарты.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Язык и региональные параметры пользовательского интерфейса указывает ресурсы, необходимые приложению для поддержки пользовательского ввода и вывода, и по умолчанию является таким же, как язык и региональные параметры операционной системы. См. в разделе <xref:System.Globalization.CultureInfo> класса Дополнительные сведения о языке и региональных параметрах имена и идентификаторы, различия между инвариантные, нейтральные и конкретные языки и региональные параметры, и влияет на способ сведения о культуре, потоков и доменов приложений. См. в разделе <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> свойство, чтобы узнать, как определяется язык и региональные параметры для потока по умолчанию пользовательского интерфейса.  

> [!IMPORTANT]
> <xref:System.Threading.Thread.CurrentUICulture> Свойство работает ненадежно при использовании любого потока, отличного от текущего потока. В .NET Framework чтение свойства надежен, несмотря на то, что указывать его для потока, отличного от текущего потока не. В .NET Core <xref:System.InvalidOperationException> возникает, если поток пытается прочитать или записать <xref:System.Threading.Thread.CurrentUICulture> свойство в другом потоке.
> Мы рекомендуем использовать <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> свойство для получения и задания текущего языка и региональных параметров.

 <xref:System.Globalization.CultureInfo> Возвращаемый этим свойством, может быть нейтрального языка и региональных параметров. Нейтральные языки и региональные параметры не должны использоваться с форматированием методы, такие как <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, и <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>. Используйте <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> метод для получения конкретного языка и региональных параметров, или использовать <xref:System.Threading.Thread.CurrentCulture%2A> свойство.  
  
> [!NOTE]
>  <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> Вызывает метод <xref:System.ArgumentException> для нейтральных языков и региональных параметров «zh-Hant» («zh-CHT») и «zh-Hans» («zh-CHS»).  
  
   
  
## Examples  
 В следующем примере определяется, установлен ли французский язык, языка и региональных параметров текущего потока пользовательского интерфейса. Если это не так, он задает язык и региональные параметры пользовательского интерфейса текущего потока на английский (США).  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 В следующем примере кода показан потоковый оператор, который позволяет пользовательскому интерфейсу Windows Forms для отображения в языка и региональных параметров, который задается в панели управления. Необходим дополнительный код.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Для свойства задано значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству присвоено имя языка и региональных параметров, которое не может использоваться для нахождения файла ресурсов. Имена файлов ресурсов могут содержать только буквы, цифры, дефисы или символы подчеркивания.</exception>
        <exception cref="T:System.InvalidOperationException">Только в .NET Core: чтение или запись данных о языке и региональных параметрах потока из другого потока не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отключает автоматическую очистку вызываемых оболочек времени выполнения (RCW) для текущего потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию среда CLR (CLR) удаляет вызываемых оболочек времени выполнения автоматически. Загружает сообщения во время очистки, что может привести к проблемам повторный вход для нескольких приложений, которые удовлетворяют следующим критериям необычные:  
  
-   Приложение выполняет собственную загрузку сообщения.  
  
-   Приложению для управления точно в том случае, при загрузке сообщения.  
  
 Такие приложения могут использовать <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> метод запрещающих CLR выполнять автоматическое освобождение среды выполнения, вызываемые оболочки.  
  
 Когда этот метод был вызван в потоке, Автоматическая очистка нельзя будет снова включить для этого потока. Когда приложение будет готово для очистки вызываемые оболочки времени выполнения, используйте <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> способ заставить среду выполнения для очистки всех вызываемых оболочек времени выполнения в текущем контексте. Выдачи сообщений происходит во время выполнения метода.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уведомляет узел, что выполнение близится ко входу в область кода, в которой эффекты прерывания выполнения или неуправляемой ошибки ограничены текущей задачей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Узлы среды выполнения (CLR), например Microsoft SQL Server 2005, могут устанавливать различные политики для сбоев в критических и некритических областей кода. Критической области является одним в которой эффекты прерывания потока или необработанного исключения может не ограничиваться текущей задачей. Напротив прерывание или сбой в области кода, не являющиеся критически влияет на только задачи, в котором произошла ошибка.  
  
 Например рассмотрим задачу, которая пытается выделить память при удерживании блокировки. Если происходит сбой выделения памяти, прерывания текущей задачи недостаточно для обеспечения стабильности <xref:System.AppDomain>, так как может существовать другие задачи в домене, Ожидание ту же блокировку. Если текущая задача завершается, может блокироваться другие задачи.  
  
 Если сбой происходит в критической области, узел может потребоваться выгрузить весь <xref:System.AppDomain> вместо рискнуть продолжения выполнения в потенциально нестабильном состоянии. Чтобы сообщить узла, что ваш код переходит в критической области, вызовите <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Вызовите <xref:System.Threading.Thread.EndCriticalRegion%2A> когда выполнение возвращается некритические области кода.  
  
 С помощью этого метода в коде, выполняемом в SQL Server 2005 требуется код для запуска на самый высокий уровень защиты узла.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Threading.Thread.BeginCriticalRegion%2A> и <xref:System.Threading.Thread.EndCriticalRegion%2A> методов для разделения критических и некритических областях блока кода.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уведомляет хост об окончании выполнения кодом инструкций, которые зависят от идентификатора текущего потока в операционной системе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые узлы среда CLR, например Microsoft SQL Server 2005 предоставляют собственное управление потоками. Узел, который предоставляет свой собственный поток управления можно переместить выполняющуюся задачу из одного физического потока операционной системы в другую в любое время. Большинство задач не затрагивает это переключение. Тем не менее некоторые задачи поддерживают сходство потоков, — то есть они зависят от удостоверения потока операционной системы. Эти задачи необходимо проинформировать узел выполняемого кода, который не будет установлено.  
  
 Например, если заблокировать приложение вызывает API системы для получения операционной системы, реализует сходство потоков, таких как Win32 CRITICAL_SECTION, необходимо вызвать <xref:System.Threading.Thread.BeginThreadAffinity%2A> до запроса на блокировку и <xref:System.Threading.Thread.EndThreadAffinity%2A> после освобождения блокировки.  
  
 С помощью этого метода в коде, выполняемом в SQL Server 2005 требуется код для запуска на самый высокий уровень защиты узла.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Threading.Thread.BeginThreadAffinity%2A> и <xref:System.Threading.Thread.EndThreadAffinity%2A> методы для уведомления узла, который зависит от блока кода с удостоверением потока операционной системы.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Threading.ExecutionContext" />, содержащий сведения о различных контекстах текущего потока.</summary>
        <value>Объект <see cref="T:System.Threading.ExecutionContext" />, содержащий консолидированную информацию о контекстах текущего потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ExecutionContext> Класс предоставляет один контейнер для все сведения, относящиеся к логическому потоку выполнения. Это включает в себя контекст безопасности, вызов контекста, контекст синхронизации, контекст локализации и контекст транзакции.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обеспечивает освобождение ресурсов и выполнение других завершающих операций, когда сборщик мусора восстанавливает объект <see cref="T:System.Threading.Thread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборщик мусора вызывает <xref:System.Threading.Thread.Finalize%2A> когда текущий объект готов к завершению.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Имя освобождаемой области данных.</param>
        <summary>Удаляет связь между названием и областью для всех потоков в процессе. Для улучшения производительности используйте поля, отмеченные атрибутом <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Платформа .NET Framework предоставляет два механизма для использования локальной памяти потока (TLS): статические поля потока (то есть поля, помеченные атрибутом <xref:System.ThreadStaticAttribute> атрибут) и области данных. Статические поля потоков обеспечивают более высокую производительность, чем области данных и включите проверку типов во время компиляции. Дополнительные сведения об использовании TLS см. в разделе [локальное хранилище потока: Статические поля потока и области данных](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 После любой поток вызывает метод `FreeNamedDataSlot`, другой поток, который вызывает <xref:System.Threading.Thread.GetNamedDataSlot%2A> с тем же именем будет выделять новый слот, связанный с именем. Последующие вызовы `GetNamedDataSlot` любой поток будет возвращать новую область. Тем не менее, любой поток, по-прежнему имеет <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> возвращенные предыдущими вызовами `GetNamedDataSlot` можно продолжать использовать старую область.  
  
 Слот, в котором была связана с именем освобождается только тогда, когда каждый `LocalDataStoreSlot` , полученные до вызова `FreeNamedDataSlot` будут освобождены и сборщиком мусора.  
  
 Потоки используют механизм памяти локального хранилища для хранения данных определенного потока. Среда CLR выделяет массив хранения данных несколькими слот каждому процессу при его создании. Поток может выделять область данных в хранилище данных, сохраняйте и загружайте данных значение в слоте и освободить область для повторного использования, после истечения срока действия потока. Области данных уникальны для каждого потока. Ни один поток (даже дочерний поток) может вывести эти данные.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. Первый пример показано, как использовать поле, помечается <xref:System.ThreadStaticAttribute> атрибут для хранения информации о потоках. Во втором примере показано, как использование области данных, чтобы сделать то же самое.  
  
 **В первом примере**  
  
 Приведенный ниже показано, как использовать поле, помечается <xref:System.ThreadStaticAttribute> для хранения информации о потоках. Этот метод обеспечивает более высокую производительность, чем метод, который отображается во втором примере.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Во втором примере**  
  
 В следующем примере показано, как использовать именованную область данных для хранения информации о потоках.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Потоки и работа с потоками</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Локальное хранилище потока: статические поля потока и области данных</related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение типа <see cref="T:System.Threading.ApartmentState" />, показывающее состояние апартамента.</summary>
        <returns>Одно из значений <see cref="T:System.Threading.ApartmentState" />, показывающее состояние подразделения управляемого потока. Значение по умолчанию — <see cref="F:System.Threading.ApartmentState.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вместе с <xref:System.Threading.Thread.SetApartmentState%2A> метод и <xref:System.Threading.Thread.TrySetApartmentState%2A> заменяет метод, <xref:System.Threading.Thread.ApartmentState%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, и <xref:System.Threading.Thread.TrySetApartmentState%2A> методы. В примере кода создается поток. До запуска потока, <xref:System.Threading.Thread.GetApartmentState%2A> отображает начальный <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> состояние и <xref:System.Threading.Thread.SetApartmentState%2A> изменяет состояние на <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. <xref:System.Threading.Thread.TrySetApartmentState%2A> Метод затем возвращает `false` при попытке изменить состояние на <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> так, как состояние подразделения уже задано. Если попытке та же операция <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> возвращал исключение.  
  
 После запуска потока, <xref:System.Threading.Thread.TrySetApartmentState%2A> снова используется метод. Это время, возникает исключение <xref:System.Threading.ThreadStateException> поскольку поток уже запущен.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Threading.CompressedStack" />, который может быть использован для записи стека текущего потока.</summary>
        <returns>Отсутствует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод больше не поддерживается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Во всех случаях.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="slot">Объект <see cref="T:System.LocalDataStoreSlot" />, из которого возвращается значение.</param>
        <summary>Извлекает значение из заданной области текущего потока, внутри текущей области текущего потока. Для улучшения производительности используйте поля, отмеченные атрибутом <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Извлекаемое значение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Платформа .NET Framework предоставляет два механизма для использования локальной памяти потока (TLS): статические поля потока (то есть поля, помеченные атрибутом <xref:System.ThreadStaticAttribute> атрибут) и области данных. Статические поля потоков обеспечивают более высокую производительность, чем области данных и включите проверку типов во время компиляции. Дополнительные сведения об использовании TLS см. в разделе [локальное хранилище потока: Статические поля потока и области данных](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Потоки используют механизм памяти локального хранилища для хранения данных определенного потока. Среда CLR выделяет массив хранения данных несколькими слот каждому процессу при его создании. Поток может выделять область данных в хранилище данных, сохраняйте и загружайте данных значение в слоте и освободить область для повторного использования, после истечения срока действия потока. Области данных уникальны для каждого потока. Ни один поток (даже дочерний поток) может вывести эти данные.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> является `Shared` метод, который всегда применяется к текущим выполняемым потоком, даже если вы вызываете его с помощью переменной, которая ссылается на другой поток. Чтобы избежать путаницы, используйте имя класса при вызове `Shared` методы: `Dim test As Object = Thread.GetData(testSlot)`.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. Первый пример показано, как использовать поле, помечается <xref:System.ThreadStaticAttribute> атрибут для хранения информации о потоках. Во втором примере показано, как использование области данных, чтобы сделать то же самое.  
  
 **В первом примере**  
  
 Приведенный ниже показано, как использовать поле, помечается <xref:System.ThreadStaticAttribute> для хранения информации о потоках. Этот метод обеспечивает более высокую производительность, чем метод, который отображается во втором примере.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Во втором примере**  
  
 Следующий пример демонстрирует использование области данных для хранения информации о потоках.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Потоки и работа с потоками</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Локальное хранилище потока: статические поля потока и области данных</related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает текущую область, в которой выполняется текущий поток.</summary>
        <returns>Объект <see cref="T:System.AppDomain" />, представляющий собой текущий домен приложения выполняющегося потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как получить имя и идентификатор `AppDomain` в котором выполняется поток.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает уникальный идентификатор домена приложения.</summary>
        <returns>32-разрядное знаковое целое число, однозначно определяющее домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как получить имя и идентификатор `AppDomain` в котором выполняется поток.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код текущего потока.</summary>
        <returns>Целочисленное значение хэш-кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Хэш-код не обязательно быть уникальным. Используйте <xref:System.Threading.Thread.ManagedThreadId%2A> свойство, если вам требуется уникальный идентификатор управляемого потока.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Имя локальной области данных.</param>
        <summary>Ищет именованную область данных. Для улучшения производительности используйте поля, отмеченные атрибутом <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Объект <see cref="T:System.LocalDataStoreSlot" />, выделенный для данного потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Платформа .NET Framework предоставляет два механизма для использования локальной памяти потока (TLS): статические поля потока (то есть поля, помеченные атрибутом <xref:System.ThreadStaticAttribute> атрибут) и области данных. Статические поля потоков обеспечивают более высокую производительность, чем области данных и включите проверку типов во время компиляции. Дополнительные сведения об использовании TLS см. в разделе [локальное хранилище потока: Статические поля потока и области данных](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Потоки используют механизм памяти локального хранилища для хранения данных определенного потока. Среда CLR выделяет массив хранения данных несколькими слот каждому процессу при его создании. Поток может выделять область данных в хранилище данных, сохраняйте и загружайте данных значение в слоте и освободить область для повторного использования, после истечения срока действия потока. Области данных уникальны для каждого потока. Ни один поток (даже дочерний поток) может вывести эти данные.  
  
 Если Именованная область не существует, выделяется новый слот. Именованные области данных являются открытыми и может использоваться кем.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. Первый пример показано, как использовать поле, помечается <xref:System.ThreadStaticAttribute> атрибут для хранения информации о потоках. Во втором примере показано, как использование области данных, чтобы сделать то же самое.  
  
 **В первом примере**  
  
 Приведенный ниже показано, как использовать поле, помечается <xref:System.ThreadStaticAttribute> для хранения информации о потоках. Этот метод обеспечивает более высокую производительность, чем метод, который отображается во втором примере.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Во втором примере**  
  
 В следующем примере показано, как использовать именованную область данных для хранения информации о потоках.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Потоки и работа с потоками</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Локальное хранилище потока: статические поля потока и области данных</related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Прерывает работу потока, находящегося в состоянии <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот поток не заблокирован в настоящее время ожидания, спящего режима или состояние соединения, он будет прерван, когда он начнет блокировать.  
  
 <xref:System.Threading.ThreadInterruptedException> возникает в прерванного потока, но только поток блокируется. Если поток не блокируется, исключение не создается, и поэтому поток может завершиться, не будучи прерванным.  
  
   
  
## Examples  
 В следующем примере кода показано поведение выполняющийся поток, когда он прерывается и впоследствии блокируется.  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающей стороны отсутствует надлежащий <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для дополнительных операций в потоках. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Приостановка и прерывание потоков</related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее статус выполнения текущего потока.</summary>
        <value>Значение <see langword="true" />, если этот поток был запущен и не был завершен нормально, либо был прерван; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, показывающее, является ли поток фоновым.</summary>
        <value>Значение <see langword="true" />, если этот поток является или станет фоновым потоком; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток — это фоновый поток или поток переднего плана. Фоновые потоки идентичны потокам переднего плана, за исключением того, что фоновые потоки не предотвращают завершение процесса. Когда завершены все основные потоки, принадлежащие процессу, среда CLR завершает процесс. Все оставшиеся фоновые потоки останавливаются и не завершаются.  
  
 По умолчанию, перечисленных ниже потоков выполняются в фоновом режиме (то есть их <xref:System.Threading.Thread.IsBackground%2A> возвращает `false`):  
  
-   Основной поток (или главный поток приложения).  
  
-   Все потоки, созданные путем вызова <xref:System.Threading.Thread> конструктора класса.  
  
 По умолчанию, перечисленных ниже потоков выполняются в фоновом режиме (то есть их <xref:System.Threading.Thread.IsBackground%2A> возвращает `true`):  
  
-   Поток пула потоков, которые являются пул рабочих потоков, которые обслуживаются средой выполнения. Действия потока пула и расписание можно настроить в потоках пула потоков с помощью <xref:System.Threading.ThreadPool> класса.  
  
    > [!NOTE]
    >  Асинхронные операции на основе задач, автоматическое выполнение в потоках пула потоков.  
  
-   Все потоки, которые входят в управляемую среду выполнения из неуправляемого кода.  
  
   
  
## Examples  
 В следующем примере показана работа переднего плана и фоновыми потоками. Он создает поток переднего плана и фонового потока. Основной поток удерживает процесс до завершения его `for` цикл и прекращает работу. Тем не менее как из примера видно, так как поток переднего плана будет завершено выполнение, процесс завершается до завершения выполнения в фоновом потоке.  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Поток не работает.</exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md">Основные и фоновые потоки</related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, принадлежит ли поток к группе управляемых потоков.</summary>
        <value>Значение <see langword="true" />, если этот поток принадлежит группе управляемых потоков; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [пул управляемых потоков](~/docs/standard/threading/the-managed-thread-pool.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как определить, является ли поток из пула потоков.  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Блокирует вызывающий поток до завершения потока, представленного этим экземпляром.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Блокирует вызывающий поток до завершения потока, представленного экземпляром, продолжая отправлять стандартные сообщения COM и <see langword="SendMessage" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> — Это метод синхронизации, который блокирует вызывающий поток (поток, вызывающий метод) до поток которого <xref:System.Threading.Thread.Join%2A> вызывается метод завершения. Используйте этот метод, чтобы убедиться, что поток завершен. Вызывающий объект заблокирует Если поток не завершится. В следующем примере `Thread1` поток вызывает метод <xref:System.Threading.Thread.Join> метод `Thread2`, чего `Thread1` блок до `Thread2` завершения.  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 Если поток завершился уже когда <xref:System.Threading.Thread.Join%2A> вызывается, метод немедленно возвращает.  
  
> [!WARNING]
>  Никогда не следует вызывать <xref:System.Threading.Thread.Join%2A> метод <xref:System.Threading.Thread> объект, представляющий текущий поток из текущего потока. В результате приложение зависает, так как текущий поток ждет от самой себя неопределенно долгое время,  
  
 Этот метод изменяет состояние вызывающего потока для включения <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Не удается вызвать `Join` в потоке, который находится в <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> состояние.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Вызывающая сторона пыталась присоединиться к потоку, который находится в состоянии <see cref="F:System.Threading.ThreadState.Unstarted" />.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Выполнение потока прервано во время ожидания.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Количество миллисекунд ожидания завершения потока.</param>
        <summary>Блокирует вызывающий поток до завершения потока, представленного экземпляром, или истечения указанного времени, продолжая отправлять стандартные сообщения COM и SendMessage.</summary>
        <returns>Значение <see langword="true" />, если поток завершился; значение <see langword="false" />, если поток не завершился по истечении количества времени, заданного параметром <paramref name="millisecondsTimeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> — Это метод синхронизации, который блокирует вызывающий поток (поток, вызывающий метод) до любой поток, <xref:System.Threading.Thread.Join%2A> вызывается метод завершения или истечения заданного интервала времени ожидания. В следующем примере `Thread1` поток вызывает метод <xref:System.Threading.Thread.Join> метод `Thread2`, чего `Thread1` для блокирования с тех пор, пока `Thread2` завершения или по истечении 2 секунды.  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 Если <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> указывается для `millisecondsTimeout` параметра, этот метод работает идентично <xref:System.Threading.Thread.Join> перегрузку метода, за исключением возвращаемого значения.  
  
 Если поток завершился уже когда <xref:System.Threading.Thread.Join%2A> вызывается, метод немедленно возвращает.  
  
 Этот метод изменяет состояние вызывающего потока для включения <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Не удается вызвать `Join` в потоке, который находится в <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> состояние.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="millisecondsTimeout" /> является отрицательным и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (в миллисекундах).</exception>
        <exception cref="T:System.Threading.ThreadStateException">Поток не запущен.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, в качестве значения которого задано время ожидания завершения процесса.</param>
        <summary>Блокирует вызывающий поток до завершения потока, представленного экземпляром, или истечения указанного времени, продолжая отправлять стандартные сообщения COM и SendMessage.</summary>
        <returns>Значение <see langword="true" />, если поток завершился; <see langword="false" />, если поток не завершился по истечении количества времени, заданного параметром <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> — Это метод синхронизации, который блокирует вызывающий поток (поток, вызывающий метод) до любой поток, <xref:System.Threading.Thread.Join%2A> вызывается метод завершения или истечения заданного интервала времени ожидания. В следующем примере `Thread1` поток вызывает метод <xref:System.Threading.Thread.Join> метод `Thread2`, чего `Thread1` для блокирования с тех пор, пока `Thread2` завершения или по истечении 2 секунды.  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 Если <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> указывается для `timeout`, этот метод работает идентично <xref:System.Threading.Thread.Join> перегрузку метода, за исключением возвращаемого значения.  
  
 Если поток завершился уже когда <xref:System.Threading.Thread.Join%2A> вызывается, метод немедленно возвращает.  
  
 Этот метод изменяет состояние текущего потока для включения <xref:System.Threading.ThreadState.WaitSleepJoin>. Не удается вызвать `Join` в потоке, который находится в <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> состояние.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование `TimeSpan` со значением `Join` метод.  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="timeout" /> является отрицательным и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (в миллисекундах) или больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Вызывающая сторона пыталась присоединиться к потоку, который находится в состоянии <see cref="F:System.Threading.ThreadState.Unstarted" />.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает уникальный идентификатор текущего управляемого потока.</summary>
        <value>Целочисленное значение, представляющее уникальный идентификатор для этого управляемого потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Потока <xref:System.Threading.Thread.ManagedThreadId%2A> значение свойства служит для уникальной идентификации этого потока, внутри своего процесса.  
  
 Значение <xref:System.Threading.Thread.ManagedThreadId%2A> свойства не меняется со временем, даже если неуправляемый код, на котором размещена среда CLR реализует поток как волокно.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет синхронизацию доступа к памяти следующим образом: процессор, выполняющий текущий поток, не способен упорядочить инструкции так, чтобы обращения к памяти до вызова метода <see cref="M:System.Threading.Thread.MemoryBarrier" /> выполнялись после обращений к памяти, следующих за вызовом метода <see cref="M:System.Threading.Thread.MemoryBarrier" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> требуется только в многопроцессорных системах со слабой организацией памяти (например, система, использующая несколько процессоров Intel Itanium).  
  
 Для большинства целей, C# `lock` инструкции, Visual Basic `SyncLock` инструкции или <xref:System.Threading.Monitor> класса предоставляют более простые способы синхронизации данных.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя потока.</summary>
        <value>Строка, содержащая имя потока или <see langword="null" />, если имя не задано.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство доступно для записи — после. Так как значение по умолчанию для потока <xref:System.Threading.Thread.Name%2A> свойство `null`, определяется ли имя уже явно присвоен к потоку, сравнивая его с `null`.  
  
 Строкой, назначенной <xref:System.Threading.Thread.Name%2A> свойство может содержать любой символ Юникода.  
  
   
  
## Examples  
 В следующем примере показано, как имя потока.  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрошена операция задания, но свойство <see langword="Name" /> уже задано.</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее на планируемый приоритет потока.</summary>
        <value>Одно из значений <see cref="T:System.Threading.ThreadPriority" />. Значение по умолчанию — <see cref="F:System.Threading.ThreadPriority.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток можно назначить один из следующих приоритет <xref:System.Threading.ThreadPriority> значения:  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 Операционные системы не требуются для предоставления приоритета потока.  
  
   
  
## Examples  
 В следующем примере результат изменения приоритета потока. Создаются три потока, приоритет один поток становится равным <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, и назначается приоритет доли секунды <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>. Каждый поток увеличивает значение переменной в `while` цикла и выполняется в течение заданного времени.  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Поток достиг конечного состояния, например <see cref="F:System.Threading.ThreadState.Aborted" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, указанное для операции задания, не является допустимым значением <see cref="T:System.Threading.ThreadPriority" />.</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md">Планирование потоков</related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет метод <see cref="M:System.Threading.Thread.Abort(System.Object)" />, запрошенный для текущего потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться только кодом с соответствующими разрешениями.  
  
 Когда выполняется вызов для `Abort` завершить поток, система создает <xref:System.Threading.ThreadAbortException>. `ThreadAbortException` — Это специальное исключение, которое может быть перехвачено кодом приложения, но повторно в конце блока catch в том случае, если `ResetAbort` вызывается. `ResetAbort` Отменяет запрос на отмену и предотвращает `ThreadAbortException` от завершения потока.  
  
 См. в разделе <xref:System.Threading.ThreadAbortException> пример, демонстрирующий вызов `ResetAbort` метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Только в .NET Core: этот элемент не поддерживается.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Метод <see langword="Abort" /> не был вызван в текущем потоке.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающая сторона не имеет требуемого разрешения безопасности для текущего потока.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для дополнительных операций в потоках. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Удаление потоков</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возобновляет приостановленную работу потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Не используйте <xref:System.Threading.Thread.Suspend%2A> и <xref:System.Threading.Thread.Resume%2A> методы для синхронизации действий потоков. У вас нет способа узнать, какой код потока выполняется в том случае, когда его приостановки. Если поток приостановлен во время удержания блокировки во время оценки разрешений безопасности, другие потоки в <xref:System.AppDomain> может быть заблокирован. Если поток приостановлен при выполнении конструктора класса, другие потоки в <xref:System.AppDomain> , пытаются использовать, что класс заблокированы. Очень легко могут возникнуть взаимоблокировки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Только в .NET Core: этот элемент не поддерживается.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Поток не был запущен, бездействует или не находится в приостановленном состоянии.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающей стороны отсутствует надлежащий <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для дополнительных операций в потоках. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Приостановка и прерывание потоков</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="state">Новая модель "apartment".</param>
        <summary>Задает модель "apartment" для потока до его запуска.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Новые потоки инициализируются как <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> если их состояние подразделения не было задано, прежде чем они запускаются. Необходимо задать состояние подразделения до запуска потока.  
  
> [!NOTE]
>  Основной поток приложения инициализируется <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> по умолчанию. Единственный способ задать состояние подразделения потока основного приложения для <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> заключается в применении <xref:System.STAThreadAttribute> атрибут к методу точки входа.  
  
 <xref:System.Threading.Thread.SetApartmentState%2A> Метод, вместе с <xref:System.Threading.Thread.GetApartmentState%2A> метод и <xref:System.Threading.Thread.TrySetApartmentState%2A> заменяет метод, <xref:System.Threading.Thread.ApartmentState%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, и <xref:System.Threading.Thread.TrySetApartmentState%2A> методы. В примере кода создается поток. До запуска потока, <xref:System.Threading.Thread.GetApartmentState%2A> отображает начальный <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> состояние и <xref:System.Threading.Thread.SetApartmentState%2A> изменяет состояние на <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. <xref:System.Threading.Thread.TrySetApartmentState%2A> Метод затем возвращает `false` при попытке изменить состояние на <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> так, как состояние подразделения уже задано. Если попытке та же операция <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> возвращал исключение.  
  
 После запуска потока, <xref:System.Threading.Thread.TrySetApartmentState%2A> снова используется метод. Это время, возникает исключение <xref:System.Threading.ThreadStateException> поскольку поток уже запущен.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Только в .NET Core: этот элемент не поддерживается на платформах Linux и macOS.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="state" /> не является допустимым состоянием подразделения.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Поток уже запущен.</exception>
        <exception cref="T:System.InvalidOperationException">Состояние подразделения уже инициализировано.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="stack">Объект <see cref="T:System.Threading.CompressedStack" />, который будет применен к текущему потоку.</param>
        <summary>Применяет записанное значение <see cref="T:System.Threading.CompressedStack" /> к текущему потоку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод больше не поддерживается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Во всех случаях.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="slot">Объект <see cref="T:System.LocalDataStoreSlot" />, для которого задается значение.</param>
        <param name="data">Задаваемое значение.</param>
        <summary>Задает данные в указанной области для текущей области потока, выполняющегося в данный момент. Для улучшения производительности используйте поля, отмеченные атрибутом <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Платформа .NET Framework предоставляет два механизма для использования локальной памяти потока (TLS): статические поля потока (то есть поля, помеченные атрибутом <xref:System.ThreadStaticAttribute> атрибут) и области данных. Статические поля потоков обеспечивают более высокую производительность, чем области данных и включите проверку типов во время компиляции. Дополнительные сведения об использовании TLS см. в разделе [локальное хранилище потока: Статические поля потока и области данных](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Потоки используют механизм памяти локального хранилища для хранения данных определенного потока. Среда CLR выделяет массив хранения данных несколькими слот каждому процессу при его создании. Поток может выделять область данных в хранилище данных, сохраняйте и загружайте данных значение в слоте и освободить эту область для повторного использования после завершения процедуры потока и <xref:System.Threading.Thread> объект уничтожен сборщиком мусора. Области данных уникальны для каждого потока. Ни один поток (даже дочерний поток) может вывести эти данные.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> является `Shared` метод, который всегда применяется к текущим выполняемым потоком, даже если вы вызываете его с помощью переменной, которая ссылается на другой поток. Чтобы избежать путаницы, используйте имя класса при вызове `Shared` методы: `Thread.SetData(testSlot, "test data")`.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. Первый пример показано, как использовать поле, помечается <xref:System.ThreadStaticAttribute> атрибут для хранения информации о потоках. Во втором примере показано, как использование области данных, чтобы сделать то же самое.  
  
 **В первом примере**  
  
 Приведенный ниже показано, как использовать поле, помечается <xref:System.ThreadStaticAttribute> для хранения информации о потоках. Этот метод обеспечивает более высокую производительность, чем метод, который отображается во втором примере.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Во втором примере**  
  
 В следующем примере показано, как использовать именованную область данных для хранения информации о потоках.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Потоки и работа с потоками</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Локальное хранилище потока: статические поля потока и области данных</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Приостанавливает текущий поток на заданное время.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Количество миллисекунд, на которое приостанавливается поток. Если значение аргумента <paramref name="millisecondsTimeout" /> равно нулю, поток освобождает оставшуюся часть своего интервала времени для любого потока с таким же приоритетом, готовым к выполнению. Если других готовых к выполнению потоков с таким же приоритетом нет, выполнение текущего потока не приостанавливается.</param>
        <summary>Приостанавливает текущий поток на заданное количество миллисекунд.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток не планируется для выполнения в операционной системе на указанный период времени. Этот метод изменяет состояние потока для включения <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Можно указать <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> для `millisecondsTimeout` параметр на приостановку потока неопределенное время. Тем не менее, мы рекомендуем использовать другие <xref:System.Threading?displayProperty=nameWithType> классы, такие как <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, или <xref:System.Threading.Semaphore> вместо этого для синхронизации потоков или управления ресурсами.  
  
 Тактов системы конкретного скоростью вызывается временное разрешение. Фактическое время ожидания может быть точно заданного времени ожидания, так как заданное время ожидания будет впоследствии скорректирована совпадают с тактов. Дополнительные сведения на временное разрешение и времени ожидания см. в разделе [спящий режим функция](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) раздела. Этот метод вызывает метод [спящий режим функция](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) из системы Windows API-интерфейсы.  
  
 Этот метод не выполняет стандартный COM и SendMessage.  
  
> [!NOTE]
>  Необходимости в спящий режим в потоке, который имеет <xref:System.STAThreadAttribute>, но вы хотите выполнить стандартный COM и SendMessage, рассмотрите возможность использования одной из перегрузок <xref:System.Threading.Thread.Join%2A> метод, задающий интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Threading.Thread.Sleep%2A> метод для блокирования основного потока приложения.  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение времени ожидания является отрицательной величиной и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Время, на которое приостанавливается поток. Если значение аргумента <paramref name="millisecondsTimeout" /> равно <see cref="F:System.TimeSpan.Zero" />, поток освобождает оставшуюся часть своего интервала времени для любого потока с таким же приоритетом, готовым к выполнению. Если других готовых к выполнению потоков с таким же приоритетом нет, выполнение текущего потока не приостанавливается.</param>
        <summary>Приостанавливает текущий поток на заданное время.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток не планируется для выполнения в операционной системе на указанный период времени. Этот метод изменяет состояние потока для включения <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Можно указать <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> для `timeout` параметр на приостановку потока неопределенное время. Тем не менее, мы рекомендуем использовать другие <xref:System.Threading?displayProperty=nameWithType> классы, такие как <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, или <xref:System.Threading.Semaphore> вместо этого для синхронизации потоков или управления ресурсами.  
  
 Эта перегрузка <xref:System.Threading.Thread.Sleep%2A> использует общее количество миллисекунд в `timeout`. Дробное количество миллисекунд, отбрасываются.  
  
 Этот метод не выполняет стандартный COM и SendMessage.  
  
> [!NOTE]
>  Необходимости в спящий режим в потоке, который имеет <xref:System.STAThreadAttribute>, но вы хотите выполнить стандартный COM и SendMessage, рассмотрите возможность использования одной из перегрузок <xref:System.Threading.Thread.Join%2A> метод, задающий интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> перегрузку метода для блокирования основного потока приложения пять раз на две секунды каждый раз.  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="timeout" /> является отрицательным и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (в миллисекундах) или больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="iterations">32-разрядное знаковое целое число, определяющее, как долго потоку ожидать.</param>
        <summary>Вынуждает поток выполнять ожидание столько раз, сколько определено параметром <paramref name="iterations" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.SpinWait%2A> Метод полезен для реализации блокировки. Классы в .NET Framework, такие как <xref:System.Threading.Monitor> и <xref:System.Threading.ReaderWriterLock>, этот метод используется внутренне. <xref:System.Threading.Thread.SpinWait%2A> по сути помещает процессора в очень непрерывном цикле, с помощью счетчика цикла `iterations` параметра. Длительность ожидания таким образом, зависит от скорости процессора.  
  
 Сравните это с <xref:System.Threading.Thread.Sleep%2A> метод. Поток, который вызывает <xref:System.Threading.Thread.Sleep%2A> дает до конца своего текущего интервала процессорного времени, даже если указанный интервал равен нулю. Ненулевое значение интервалом для <xref:System.Threading.Thread.Sleep%2A> удаляет поток из рассмотрения планировщиком потоков до истечения интервала времени.  
  
 <xref:System.Threading.Thread.SpinWait%2A> обычно не имеет смысла для обычных приложений. В большинстве случаев следует использовать классы синхронизации, предоставляемые платформой .NET Framework; Например, вызвать <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> или оператор, который заключает в оболочку <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` в C# или `SyncLock` в Visual Basic).  
  
> [!CAUTION]
>  В тех редких случаях, где имеет смысл избегать переключение контекста, например, если известно, что изменение состояния является неизбежной, сделать вызов к <xref:System.Threading.Thread.SpinWait%2A> метод в цикле. Код <xref:System.Threading.Thread.SpinWait%2A> выполняет предназначен для предотвращения проблем, возникающих на компьютерах с несколькими процессорами. Например, на компьютерах с несколькими процессорами Intel, применение технологии Hyper-Threading <xref:System.Threading.Thread.SpinWait%2A> предотвращает истощения ресурсов процессора в определенных ситуациях.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Позволяет планировать выполнение потока.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вынуждает операционную систему изменить состояние текущего экземпляра на <see cref="F:System.Threading.ThreadState.Running" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда поток находится в <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, операционная система может запланировать его выполнение. Поток начинает выполнение на первой строке метода, представленного <xref:System.Threading.ThreadStart> или <xref:System.Threading.ParameterizedThreadStart> делегат, переданное в конструктор потока. Обратите внимание, что вызов <xref:System.Threading.Thread.Start%2A> не блокирует вызывающий поток.  
  
> [!NOTE]
>  Если эта перегрузка используется с потоком, созданных с помощью <xref:System.Threading.ParameterizedThreadStart> делегировать, `null` передается в метод, выполняемый в потоке.  
  
 После завершения потока, его невозможно перезапустить другим вызовом `Start`.  
  
   
  
## Examples  
 Следующий пример создает и запускает поток.  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Поток уже запущен.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти для запуска этого потока.</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Потоки и работа с потоками</related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Создание потоков и передача данных во время запуска</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="parameter">Объект, содержащий данные, используемые методом, который выполняется потоком.</param>
        <summary>Заставляет операционную систему изменить состояние текущего экземпляра на <see cref="F:System.Threading.ThreadState.Running" />, а также (необязательно) передает объект с данными, используемыми методом в потоке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда поток находится в <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, операционная система может запланировать его выполнение. Поток начинает выполнение на первой строке метода, представленного <xref:System.Threading.ThreadStart> или <xref:System.Threading.ParameterizedThreadStart> делегат, переданное в конструктор потока. Обратите внимание, что вызов <xref:System.Threading.Thread.Start%2A> не блокирует вызывающий поток.  
  
 После завершения потока, его невозможно перезапустить другим вызовом `Start`.  
  
 Эта перегрузка и <xref:System.Threading.ParameterizedThreadStart> делегат упростить процесс для передачи данных в процедуру потока, но метод не является типобезопасным, так как любой объект может быть передан этой перегрузки. Для размещения процедуры потока и полей данных в рабочий объект является более надежным способом для передачи данных в процедуру потока. Дополнительные сведения см. в разделе [создание потоков и передача данных во время запуска](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Threading.ParameterizedThreadStart> делегат со статическим методом и методом экземпляра.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Поток уже запущен.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти для запуска этого потока.</exception>
        <exception cref="T:System.InvalidOperationException">Этот поток был создан с помощью делегата <see cref="T:System.Threading.ThreadStart" />, а не делегата <see cref="T:System.Threading.ParameterizedThreadStart" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Создание потоков</related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Приостанавливает работу потока; если работа потока уже приостановлена, не оказывает влияния.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если потока уже приостановлена, этот метод не действует.  
  
> [!CAUTION]
>  Не используйте <xref:System.Threading.Thread.Suspend%2A> и <xref:System.Threading.Thread.Resume%2A> методы для синхронизации действий потоков. У вас нет способа узнать, какой код потока выполняется в том случае, когда его приостановки. Если поток приостановлен во время удержания блокировки во время оценки разрешений безопасности, другие потоки в <xref:System.AppDomain> может быть заблокирован. Если поток приостановлен при выполнении конструктора класса, другие потоки в <xref:System.AppDomain> , пытаются использовать, что класс заблокированы. Очень легко могут возникнуть взаимоблокировки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Только в .NET Core: этот элемент не поддерживается.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Поток не запущен или удален.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающей стороны отсутствует надлежащий <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для дополнительных операций в потоках. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Приостановка и прерывание потоков</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="rgszNames">Переданный массив имен, которые необходимо сопоставить.</param>
        <param name="cNames">Количество сопоставляемых имен.</param>
        <param name="lcid">Контекст языкового стандарта для интерпретации имен.</param>
        <param name="rgDispId">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</param>
        <summary>Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetIDsOfNames`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Возвращаемые сведения о типе.</param>
        <param name="lcid">Идентификатор языкового стандарта для сведений о типе.</param>
        <param name="ppTInfo">Получает указатель на объект с запрошенными сведениями о типе.</param>
        <summary>Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfo`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</param>
        <summary>Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfoCount`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Идентифицирует член.</param>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="lcid">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</param>
        <param name="wFlags">Флаги, описывающие контекст вызова.</param>
        <param name="pDispParams">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</param>
        <param name="pVarResult">Указатель, по которому будет сохранен результат.</param>
        <param name="pExcepInfo">Указатель на структуру, содержащую сведения об исключении.</param>
        <param name="puArgErr">Индекс первого аргумента, вызвавшего ошибку.</param>
        <summary>Предоставляет доступ к открытым свойствам и методам объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::Invoke`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, содержащее состояния текущего потока.</summary>
        <value>Одно из значений <see cref="T:System.Threading.ThreadState" />, показывающее состояние текущего потока. Начальное значение — <see cref="F:System.Threading.ThreadState.Unstarted" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.ThreadState%2A> Свойство предоставлены более конкретные сведения, чем <xref:System.Threading.Thread.IsAlive%2A> свойство.  
  
> [!IMPORTANT]
>  Состояние потока используется только в сценариях отладки. Не используйте в коде состояния потоков для синхронизации действий потоков.  
  
   
  
## Examples  
 В следующем примере кода показано обращение к `ThreadState` потока.  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="state">Новая модель "apartment".</param>
        <summary>Задает модель "apartment" для потока до его запуска.</summary>
        <returns>Значение <see langword="true" />, если задана модель "apartment"; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Новые потоки инициализируются как <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> если их состояние подразделения не было задано, прежде чем они запускаются. Необходимо задать состояние подразделения до запуска потока.  
  
> [!NOTE]
>  Основной поток приложения инициализируется <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> по умолчанию. Единственный способ задать состояние подразделения потока основного приложения для <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> заключается в применении <xref:System.STAThreadAttribute> атрибут к методу точки входа.  
  
 <xref:System.Threading.Thread.TrySetApartmentState%2A> Метод, вместе с <xref:System.Threading.Thread.GetApartmentState%2A> метод и <xref:System.Threading.Thread.SetApartmentState%2A> заменяет метод, <xref:System.Threading.Thread.ApartmentState%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, и <xref:System.Threading.Thread.TrySetApartmentState%2A> методы. В примере кода создается поток. До запуска потока, <xref:System.Threading.Thread.GetApartmentState%2A> отображает начальный <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> состояние и <xref:System.Threading.Thread.SetApartmentState%2A> изменяет состояние на <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. <xref:System.Threading.Thread.TrySetApartmentState%2A> Метод затем возвращает `false` при попытке изменить состояние на <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> так, как состояние подразделения уже задано. Если попытке та же операция <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> возвращал исключение.  
  
 После запуска потока, <xref:System.Threading.Thread.TrySetApartmentState%2A> снова используется метод. Это время, возникает исключение <xref:System.Threading.ThreadStateException> поскольку поток уже запущен.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="state" /> не является допустимым состоянием подразделения.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Поток уже запущен.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле для чтения.</param>
        <summary>Считывает значение поля. Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</summary>
        <returns>Последнее значение, записанное в поле любым процессором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileRead%2A> Получает самое последнее значение, записанное в ячейку памяти любым процессором. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Int16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.SByte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UInt16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UIntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Поле, в которое требуется записать значение.</param>
        <param name="value">Записываемое значение.</param>
        <summary>Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации. В обычных условиях, C# `lock` инструкции, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor> класса предоставляют более простые альтернативы.  
  
 На многопроцессорных систем <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение записывается в расположение памяти является видимым для всех процессоров. Это может потребовать сброс кэша процессора.  
  
 Даже на однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> убедитесь, что значение чтение или запись в область памяти и не кэшируются (например, в регистре процессора). Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.  
  
 Вызов этого метода влияет только однократный доступ к памяти. Для обеспечения эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  В C# с помощью `volatile` модификатор по полю гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Позволяет вызвавшему потоку передать выполнение другому потоку, готовому к использованию на текущем процессоре. Операционная система выбирает, какому потоку передается выполнение.</summary>
        <returns>Значение <see langword="true" />, если операционная система переключила выполнение на другой поток, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод выполняется успешно, получением остальная часть потока текущего интервала времени. Операционная система назначает вызывающим потоком к другой временной срез, в соответствии с ее приоритет и состояние других потоков, доступных для запуска.  
  
 Выдача ограничена процессором, который выполняет вызывающий поток. Операционная система не переключит выполнение на другой процессор, даже в том случае, если процессор, бездействует или выполняется поток с более низким приоритетом. Если нет других потоков, готовых к выполнению на текущем процессоре, операционная система не дает выполнения, и этот метод возвращает `false`.  
  
 Этот метод является эквивалентом в вызове неуправляемого кода для вызова собственного Win32 `SwitchToThread` функции. Следует вызывать <xref:System.Threading.Thread.Yield%2A> вызова метода вместо использования платформы, так как неуправляемого кода обходит запросил любое пользовательское потоковое поведение узла.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>