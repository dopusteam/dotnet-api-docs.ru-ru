<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d1f1c78afc776209e87eb703d91df0fb21999318" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57922254" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type LogRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет последовательность записей, которая хранится в <see cref="T:System.IO.Log.LogStore" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.IO.Log.LogRecordSequence> предоставляет реализацию интерфейса последовательности записей на базе журнала CLFS. Помимо стандартных возможностей для записи этот класс предоставляет модель политики, которая помогает избежать переполнения журнала, и позволяет мультиплексирование клиентов в одном физическом файле. Он работает с классом <xref:System.IO.Log.LogStore>, который предоставляет интерфейс для прямого управления файлом журнала CLFS. Отношение между классом <xref:System.IO.Log.LogStore> и классом <xref:System.IO.Log.LogRecordSequence> аналогично отношению между файлом на диске и объектом <xref:System.IO.FileStream>. Файл на диске предоставляет непосредственно хранилище, он имеет атрибуты длины и времени последнего обращения, тогда как объект <xref:System.IO.FileStream> предоставляет структуру файла, которая нужна для чтения и записи в файл. Аналогично, класс <xref:System.IO.Log.LogStore> имеет атрибуты политики и коллекции областей диска, а класс <xref:System.IO.Log.LogRecordSequence> предоставляет механизм для чтения и записи данных.  
  
   
  
## Examples  
 В этом примере показано, как использовать класс <xref:System.IO.Log.LogRecordSequence>.  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence logStore" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore">Объект <see cref="T:System.IO.Log.LogStore" />, который должна использовать данная последовательность записей.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogRecordSequence" /> с указанным хранилищем журналов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Размер буфера определяет максимальный размер записи, которую можно добавить или прочитать. В этом конструкторе по умолчанию задано значение 64. Для требуемого количества буферов задано значение 10.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logStore" /> недопустим.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к базовому файлу хранилища журналов для открытия.</param>
        <param name="mode">Одно из значений <see cref="T:System.IO.FileMode" />, с помощью которого можно определить способ открытия или создания хранилища.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogRecordSequence" /> с указанным путем к хранилищу журналов и режимом доступа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует новый экземпляр <xref:System.IO.Log.LogRecordSequence> в новом объекте <xref:System.IO.Log.LogStore>, который открывается с указанным путем и режимом. Хранилищу предоставляется доступ на чтение и запись, и оно открывается с общим доступом на чтение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> является пустой строкой ("").  
  
-или- 
 Параметр <paramref name="path" /> содержит только пробелы.  
  
-или- 
 Параметр <paramref name="path" /> содержит один или несколько недопустимых символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.IOException">При открытии хранилища журналов произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.NotSupportedException">Эта операция не поддерживается.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Невозможно использовать <see cref="T:System.IO.Log.LogRecordSequence" />, так как не установлен требуемый компонент CLFS. Установите компонент CLFS, если он доступен на платформе, или используйте класс <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (logStore, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore">Объект <see cref="T:System.IO.Log.LogStore" />, который должна использовать данная последовательность записей.</param>
        <param name="bufferSize">Требуемый размер буфера в байтах. Размер буфера определяет максимальный размер записи, которую можно добавить или прочитать.</param>
        <param name="bufferCount">Требуемое количество буферов.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogRecordSequence" /> с указанным хранилищем журналов, размером буфера и количеством буферов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор, если необходимо указать значения для параметров `bufferSize` и `bufferCount`, а не использовать значение по умолчанию — 64 для `bufferSize` и 10 для `bufferCount`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="logStore" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="bufferSize" /> имеет отрицательное значение или равен нулю.  
  
-или- 
 Параметр <paramref name="bufferCount" /> имеет отрицательное значение или равен нулю.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к базовому файлу хранилища журналов для открытия.</param>
        <param name="mode">Одно из значений <see cref="T:System.IO.FileMode" />, с помощью которого можно определить способ открытия или создания хранилища.</param>
        <param name="access">Одно из значений <see cref="T:System.IO.FileAccess" />, определяющее, каким образом объект <see cref="T:System.IO.Log.LogStore" /> может получить доступ к файлу.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogRecordSequence" /> с указанным путем к хранилищу журналов и режимами доступа и общего доступа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует новый экземпляр <xref:System.IO.Log.LogRecordSequence> в новом объекте <xref:System.IO.Log.LogStore>, который открывается с указанным путем, режимом и доступом. Хранилище открывается с общим доступом для чтения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> является пустой строкой ("").  
  
-или- 
 Параметр <paramref name="path" /> содержит только пробелы.  
  
-или- 
 Параметр <paramref name="path" /> содержит один или несколько недопустимых символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.IOException">При открытии хранилища журналов произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.NotSupportedException">Эта операция не поддерживается.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Невозможно использовать <see cref="T:System.IO.Log.LogRecordSequence" />, так как не установлен требуемый компонент CLFS. Установите компонент CLFS, если он доступен на платформе, или используйте класс <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к базовому файлу хранилища журналов для открытия.</param>
        <param name="mode">Одно из значений <see cref="T:System.IO.FileMode" />, с помощью которого можно определить способ открытия или создания хранилища.</param>
        <param name="access">Одно из значений <see cref="T:System.IO.FileAccess" />, определяющее, каким образом объект <see cref="T:System.IO.Log.LogStore" /> может получить доступ к файлу.</param>
        <param name="share">Одно из значений <see cref="T:System.IO.FileShare" />, с помощью которых можно определить, как процессы будут совместно использовать хранилище журнала.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogRecordSequence" /> с указанным путем к хранилищу журналов и режимом доступа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует новый экземпляр <xref:System.IO.Log.LogRecordSequence> в новом объекте <xref:System.IO.Log.LogStore>, который открывается с указанным путем, режимом и доступом. Хранилище открывается с общим указанным доступом.  
  
   
  
## Examples  
 В этом примере показано, как использовать конструктор <xref:System.IO.Log.LogRecordSequence>:  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> является пустой строкой ("").  
  
-или- 
 Параметр <paramref name="path" /> содержит только пробелы.  
  
-или- 
 Параметр <paramref name="path" /> содержит один или несколько недопустимых символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.IOException">При открытии хранилища журналов произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.NotSupportedException">Эта операция не поддерживается.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Невозможно использовать <see cref="T:System.IO.Log.LogRecordSequence" />, так как не установлен требуемый компонент CLFS. Установите компонент CLFS, если он доступен на платформе, или используйте класс <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, bufferCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к базовому файлу хранилища журналов для открытия.</param>
        <param name="mode">Одно из значений <see cref="T:System.IO.FileMode" />, с помощью которого можно определить способ открытия или создания хранилища.</param>
        <param name="access">Одно из значений <see cref="T:System.IO.FileAccess" />, определяющее, каким образом объект <see cref="T:System.IO.Log.LogStore" /> может получить доступ к файлу.</param>
        <param name="share">Одно из значений <see cref="T:System.IO.FileShare" />, с помощью которых можно определить, как процессы будут совместно использовать хранилище журнала.</param>
        <param name="bufferSize">Требуемый размер буфера в байтах. Размер буфера определяет максимальный размер записи, которую можно добавить или прочитать.</param>
        <param name="bufferCount">Требуемое количество буферов.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogRecordSequence" /> с указанным путем к хранилищу журналов, разрешением для файлов, а также размером и количеством буферов для записей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует новый экземпляр <xref:System.IO.Log.LogRecordSequence> в новом объекте <xref:System.IO.Log.LogStore>, который открывается с указанным путем, режимом и доступом. Хранилище открывается с общим указанным доступом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> является пустой строкой ("").  
  
-или- 
 Параметр <paramref name="path" /> содержит только пробелы.  
  
-или- 
 Параметр <paramref name="path" /> содержит один или несколько недопустимых символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.IOException">При открытии хранилища журналов произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.NotSupportedException">Эта операция не поддерживается.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Невозможно использовать <see cref="T:System.IO.Log.LogRecordSequence" />, так как не установлен требуемый компонент CLFS. Установите компонент CLFS, если он доступен на платформе, или используйте класс <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к базовому файлу хранилища журналов для открытия.</param>
        <param name="mode">Допустимое значение <see cref="T:System.IO.FileMode" />, с помощью которого можно определить способ открытия или создания хранилища.</param>
        <param name="access">Допустимое значение <see cref="T:System.IO.FileAccess" />, определяющее способ доступа к хранилищу журналов.</param>
        <param name="share">Допустимое значение <see cref="T:System.IO.FileShare" />, определяющее совместное использование хранилища сертификатов процессами.</param>
        <param name="bufferSize">Требуемый размер буфера в байтах. Размер буфера определяет максимальный размер записи, которую можно добавить или прочитать.</param>
        <param name="bufferCount">Требуемое количество буферов.</param>
        <param name="fileSecurity">Допустимое значение <see cref="T:System.Security.AccessControl.FileSecurity" />, указывающее параметры безопасности, задаваемые для нового хранилища в случае его создания.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Файл, заданный параметром <paramref name="path" />, является недопустимым.  
  
-или- 
Указанное имя файла хранилища журналов недопустимо.  
  
-или- 
 Параметр <paramref name="mode" /> имеет значение <see cref="F:System.IO.FileMode.CreateNew" /> и не может использоваться без доступа на запись.  
  
-или- 
 Параметр <paramref name="mode" /> имеет значение <see cref="F:System.IO.FileMode.OpenOrCreate" /> и не может использоваться без доступа на запись.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл, заданный свойством <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Не удается получить доступ к файлу, указанному в параметре <paramref name="path" />, так как он уже используется другим процессом.  
  
-или- 
Невозможно создать файл, указанный параметром <paramref name="path" />, так как файл или каталог уже существует.  
  
-или- 
Не удается привязать дескриптор журнала к пулу потоков.  
  
-или- 
Указан недопустимый формат или версия файла журнала.</exception>
        <exception cref="T:System.NotSupportedException">Эта операция не поддерживается.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Невозможно использовать <see cref="T:System.IO.Log.LogRecordSequence" />, так как не установлен требуемый компонент CLFS. Установите компонент CLFS, если он доступен на платформе, или используйте класс <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Указывает новый базовый порядковый номер <see cref="T:System.IO.Log.SequenceNumber" /> для журнала. Значение должно находиться в диапазоне между текущим базовым порядковым номер и последним порядковым номером включительно.</param>
        <summary>Выполняет переход базового порядкового номера журнала. Наследовать этот метод нельзя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод часто используется с событием <xref:System.IO.Log.LogRecordSequence.TailPinned>, чтобы освободить пространство в записи. Событие <xref:System.IO.Log.LogRecordSequence.TailPinned>, указывающее, что завершающая часть последовательности (то есть базовый порядковый номер) должна переместиться вперед для освобождения места. Освободить место можно либо при записи областей перезапуска с помощью метода <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>, либо усечением журнала с помощью метода <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>, чтобы переместить базовый порядковый номер журнала в значение, указанное в параметре `newBaseSequenceNumber`. Образец кода в разделе "Пример" иллюстрирует второй подход.  
  
 Обратите внимание, что вызов этого метода аналогичен установке нового базового порядкового номера с помощью метода <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>, за исключением того, что в журнале не регистрируется запись перезапуска.  
  
   
  
## Examples  
 В этом примере показано, как использовать метод <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> с событием <xref:System.IO.Log.LogRecordSequence.TailPinned>, чтобы освободить место в последовательности журналов.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="newBaseSequenceNumber" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Новая или существующая архивная цепочка или база активного журнала недействительна.  
  
-или- 
 Значение <paramref name="newBaseSequenceNumber" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный журнал не содержит областей. Перед использованием последовательности записей необходимо создать одну или несколько областей.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует запись журнала в <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере показано использование элемента <xref:System.IO.Log.LogRecordSequence.Append%2A>.  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <summary>Регистрирует запись журнала в <see cref="T:System.IO.Log.LogRecordSequence" />. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
   
  
## Examples  
 В следующем примере показано, как использовать этот метод для добавления записи журнала в последовательность.  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не является допустимым для этой последовательности.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не лежит между основным и последним порядковыми номерами этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="userRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <summary>Добавляет запись журнала в <see cref="T:System.IO.Log.IRecordSequence" />. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не является допустимым для этой последовательности.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не лежит между основным и последним порядковыми номерами этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной записи.</param>
        <summary>Добавляет запись журнала в <see cref="T:System.IO.Log.IRecordSequence" />, используя пространство, которое было ранее зарезервировано в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Добавленная запись будет занимать пространство, ранее зарезервированное с помощью резервирования, заданного параметром `reservations`. Если выполнить добавление удается, оно займет минимальную область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не является допустимым для этой последовательности.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не лежит между основным и последним порядковыми номерами этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="userRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной записи.</param>
        <summary>Добавляет запись журнала в <see cref="T:System.IO.Log.IRecordSequence" />, используя пространство, которое было ранее зарезервировано в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Добавленная запись будет занимать пространство, ранее зарезервированное с помощью резервирования, заданного параметром `reservations`. Если выполнить добавление удается, оно займет минимальную область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не является допустимым для этой последовательности.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не лежит между основным и последним порядковыми номерами этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает порядковый номер первой допустимой записи в текущем объекте <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <value>Самый низкий порядковый номер, соответствующий допустимой записи в последовательности <see cref="T:System.IO.Log.LogRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Допустимые порядковые номера больше или равны <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> и меньше <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.  
  
 Значение этого свойства можно изменить вызовом метода <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> или <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>.  
  
   
  
## Examples  
 В этом примере показано, как использовать элемент <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> в цикле.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает асинхронную операцию добавления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>Начинает асинхронную операцию добавления. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронное добавление, которое может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="nextUndoRecord" /> или <paramref name="previousRecord" /> не является допустимым для этой последовательности.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="nextUndoRecord" /> или <paramref name="previousRecord" /> не лежит между основным и последним порядковыми номерами этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="userRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>Начинает асинхронную операцию добавления. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронное добавление, которое может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не является допустимым для этой последовательности.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не лежит между основным и последним порядковыми номерами этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной записи.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>Начинает асинхронную операцию добавления. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронное добавление, которое может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Добавленная запись будет занимать пространство, ранее зарезервированное с помощью резервирования, заданного параметром `reservations`. Если выполнить добавление удается, оно займет минимальную область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не является допустимым для этой последовательности.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не лежит между основным и последним порядковыми номерами этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="userRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной записи.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>Начинает асинхронную операцию добавления. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронное добавление, которое может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Добавленная запись будет занимать пространство, ранее зарезервированное с помощью резервирования, заданного параметром `reservations`. Если выполнить добавление удается, оно займет минимальную область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не является допустимым для этой последовательности.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не лежит между основным и последним порядковыми номерами этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Порядковый номер последней записи, которую требуется записать. Если этот номер <see cref="T:System.IO.Log.SequenceNumber" /> недопустим, необходимо записать все записи.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении операции записи на диск.</param>
        <param name="state">Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного запроса на запись на диск от других запросов.</param>
        <summary>Начинает асинхронную операцию записи на диск, используя пространство, которое было ранее зарезервировано в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронную операцию записи на диск, которая может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо передать объект <xref:System.IAsyncResult>, возвращаемый текущим методом, методу <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>, чтобы обеспечить завершение очистки и правильное освобождение ресурсов. Если ошибка возникает при выполнении асинхронной очистки, исключение не будет создано до тех пор, пока не будет вызван метод <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> с объектом <xref:System.IAsyncResult>, возвращаемым данным методом.  
  
 Вызов этого метода гарантирует, что внесены все записи, добавленные в последовательность <xref:System.IO.Log.LogRecordSequence>.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронной очистки, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="sequenceNumber" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="sequenceNumber" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный журнал не содержит областей. Перед использованием последовательности записей необходимо создать одну или несколько областей.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает асинхронную операцию резервирования и добавления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservationCollection">Коллекция резервирования, в которой требуется сделать резервирования.</param>
        <param name="reservations">Размер необходимого резервирования (в байтах).</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>Начинает асинхронную операцию резервирования и добавления. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий данную асинхронную операцию, которая может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Заданные резервирования добавляются в предоставленную коллекцию резервирования при помощи атомарной операции добавления записи. Если выполнить добавление не удается, место не резервируется.  
  
 Обычно этот метод может завершить работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не является допустимым для этой последовательности.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не лежит между основным и последним порядковыми номерами этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="userRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservationCollection">Коллекция резервирования, в которой требуется сделать резервирования.</param>
        <param name="reservations">Размер необходимого резервирования (в байтах).</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>Начинает асинхронную операцию резервирования и добавления. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий данную асинхронную операцию, которая может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Заданные резервирования добавляются в предоставленную коллекцию резервирования при помощи атомарной операции добавления записи. Если выполнить добавление не удается, место не резервируется.  
  
 Обычно этот метод может завершить работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи или выполнить резервирование.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает операцию записи в область перезапуска.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Фрагменты массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSeqNum">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <param name="reservation">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной области перезапуска.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении записи в области перезапуска.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронную запись в область перезапуска от других запросов.</param>
        <summary>Начинает асинхронную операцию записи в область перезапуска, используя пространство, которое было ранее зарезервировано в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" /> представляет асинхронную операцию записи в область перезапуска, которая может все еще быть отложена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции записи в область перезапуска и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>. Если ошибка возникла при выполнении операции асинхронной записи в область перезапуска, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 При успешном выполнении операции базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если задано <xref:System.IO.Log.ReservationCollection>, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования. Если метод завершается успешно, будет занята минимальная область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="newBaseSeqNum" /> недопустимо для этой последовательности.  
  
-или- 
Указанный порядковый номер начала регистрационного перечисления недопустим.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservation" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Значение одного или несколько параметров — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Новая или существующая архивная цепочка или база активного журнала недействительна.  
  
-или- 
 Значение <paramref name="newBaseSeqNum" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservationCollection, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSeqNum">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <param name="reservationCollection">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной области перезапуска.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении записи в области перезапуска.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронную запись в область перезапуска от других запросов.</param>
        <summary>Начинает асинхронную операцию записи в область перезапуска, используя пространство, которое было ранее зарезервировано в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" /> представляет асинхронную операцию записи в область перезапуска, которая может все еще быть отложена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции записи в область перезапуска и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>. Если ошибка возникла при выполнении операции асинхронной записи в область перезапуска, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 При успешном выполнении операции базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если задано <xref:System.IO.Log.ReservationCollection>, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования. Если метод завершается успешно, будет занята минимальная область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="newBaseSeqNum" /> недопустимо для этой последовательности.  
  
-или- 
Указанный порядковый номер начала регистрационного перечисления недопустим.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservationCollection" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Значение одного или несколько параметров — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Новая или существующая архивная цепочка или база активного журнала недействительна.  
  
-или- 
 Значение <paramref name="newBaseSeqNum" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="logRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый экземпляр <see cref="T:System.IO.Log.ReservationCollection" />. Наследовать этот метод нельзя.</summary>
        <returns>Вновь созданный <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Резервирование можно выполнить двумя способами, которые демонстрируют следующие примеры. Для надежной обработки можно пользоваться способами из образцов. Обратите внимание, что эта задача может быть выполнена только при использовании класса <xref:System.IO.Log.LogRecordSequence>, основанного на CLFS.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает ресурсы, используемые компонентом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере показано, как использовать <xref:System.IO.Log.LogRecordSequence.Dispose%2A> для освобождения ресурсов:  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на невыполненный асинхронный запрос ввода-вывода.</param>
        <summary>Завершает асинхронную операцию добавления. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-вывода, отображаются при вызове <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>.  
  
 Этот метод должен вызываться ровно по одному разу для каждого объекта <xref:System.IAsyncResult>, возвращенного методом <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> недопустим.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see langword="End" /> уже был вызван для данной асинхронной операции.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на невыполненный асинхронный запрос ввода-вывода.</param>
        <summary>Завершает асинхронную операцию записи на диск. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер последней записи, которая была записана.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной очистки, например ошибка диска в процессе запроса ввода-вывода, отображаются при вызове <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>.  
  
 Этот метод должен вызываться ровно по одному разу для каждого объекта <xref:System.IAsyncResult>, возвращенного методом <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> недопустим.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see langword="End" /> уже был вызван для данной асинхронной операции.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на невыполненный асинхронный запрос ввода-вывода.</param>
        <summary>Завершает асинхронную операцию резервирования и добавления. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-вывода, отображаются при вызове <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 Этот метод должен вызываться ровно по одному разу для каждого объекта <xref:System.IAsyncResult>, возвращенного методом <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> недопустим.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see langword="End" /> уже был вызван для данной асинхронной операции.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на невыполненный асинхронный запрос ввода-вывода.</param>
        <summary>Завершает операцию записи в область перезапуска. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-вывода, отображаются при вызове <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>.  
  
 Этот метод должен вызываться ровно по одному разу для каждого объекта <xref:System.IAsyncResult>, возвращенного методом <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый параметр <paramref name="result" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Новая или существующая архивная цепочка или база активного журнала недействительна.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see langword="End" /> уже был вызван для данной асинхронной операции.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет устойчивую запись всех добавленных записей</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обеспечивает запись всех добавленных записей. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер последней записи, которая была записана.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода гарантирует выполнение устойчивых записей, добавленных в последовательность <xref:System.IO.Log.LogRecordSequence>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">При очистке данных произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.NotSupportedException">Эта операция не поддерживается.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный журнал не содержит областей. Перед использованием последовательности записей необходимо создать одну или несколько областей.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Порядковый номер последней записи, которую требуется записать. Если этот номер <see cref="T:System.IO.Log.SequenceNumber" /> недопустим, необходимо записать все записи.</param>
        <summary>Обеспечивает устойчивую запись всех добавленных записей до указанного порядкового номера включительно. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер последней записи, которая была записана.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода обеспечивает устойчивую запись всех записей до указанного порядкового номера включительно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="sequenceNumber" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="sequenceNumber" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный журнал не содержит областей. Перед использованием последовательности записей необходимо создать одну или несколько областей.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает порядковый номер, превышающий последнюю добавленную запись</summary>
        <value>Порядковый номер, превышающий последнюю добавленную запись.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное свойство содержит порядковый номер, который гарантированно больше, чем порядковый номер последней добавленной записи. Допустимые порядковые номера больше или равны <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> и меньше <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>. Все другие порядковые номера недопустимы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStore As LogStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogStore ^ LogStore { System::IO::Log::LogStore ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogStore : System.IO.Log.LogStore" Usage="System.IO.Log.LogRecordSequence.LogStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.IO.Log.LogStore" />, содержащий данные для этой последовательности записей. Наследовать этот метод нельзя.</summary>
        <value>Объект <see cref="T:System.IO.Log.LogStore" />, содержащий данные для этой последовательности записей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере показано, как использовать элемент <xref:System.IO.Log.LogRecordSequence.LogStore%2A> для добавления областей.  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальный размер записи, которая может быть добавлена в данную последовательности записей.</summary>
        <value>Максимальный размер записи, которая может быть добавлена в данную последовательности записей.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Порядковый номер первой записи, с которой начинается чтение.</param>
        <param name="logRecordEnum">Допустимое значение <see cref="T:System.IO.Log.LogRecordEnumeratorType" />, указывающее способ (вперед или назад), которым записи должны считываться из <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Возвращает перечислимую коллекцию записей в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Перечисляемая коллекция записей в последовательности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает перечисляемую коллекцию записей в последовательности. Порядок перечисленных записей зависит от значения параметра `logRecordEnum`.  
  
   
  
## Examples  
 В этом примере показано, как использовать метод <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> в цикле.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="start" /> недопустимо для этой последовательности.  
  
-или- 
 <paramref name="logRecordEnum" /> недопустим.  
  
-или- 
Указанный элемент не найден в свойстве.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="start" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.  
  
-или 
Размер буфера, используемого для регистрации записи журнала, больше размера буфера, используемого для чтения этой записи.  
  
-или- 
Последовательность записей повреждена.  
  
-или- 
Указан недопустимый формат или версия файла журнала.  
  
-или- 
Запись была сделана с помощью несовместимой версии последовательности записей.</exception>
        <exception cref="T:System.InvalidOperationException">Операция недействительна, поскольку перечисление не запущено. Должен быть вызван метод <see cref="M:System.Collections.IEnumerator.MoveNext" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечисляемую коллекцию областей перезапуска в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Перечисляемая коллекция областей перезапуска в последовательности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Области перезапуска перечислены в обратном порядке их номеров, т.е. от самого высокого порядкового номера до самого низкого. Выполняется перечисление только областей перезапуска между последним и базовым порядковым номером.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="start" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.  
  
-или 
Размер буфера, используемого для регистрации записи журнала, больше размера буфера, используемого для чтения этой записи.  
  
-или- 
Последовательность записей повреждена.  
  
-или- 
Указан недопустимый формат или версия файла журнала.  
  
-или- 
Запись была сделана с помощью несовместимой версии последовательности записей.</exception>
        <exception cref="T:System.InvalidOperationException">Операция недействительна, поскольку перечисление не запущено. Должен быть вызван метод <see cref="M:System.Collections.IEnumerator.MoveNext" />.  
  
-или 
Перечисление завершено.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Автоматически делает одно резервирование и добавляет запись в последовательность.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservationCollection">Объект <see cref="T:System.IO.Log.ReservationCollection" />, содержащий коллекцию, в которой создается резервирование.</param>
        <param name="reservations">Размер необходимого резервирования (в байтах).</param>
        <summary>Автоматически делает одно резервирование и добавляет запись в последовательность. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Заданные резервирования добавляются в предоставленную коллекцию резервирования при помощи атомарной операции добавления записи. Если выполнить добавление не удается, место не резервируется.  
  
 Обычно этот метод может завершить работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
   
  
## Examples  
 В следующем примере показано, как использовать этот метод для создания резервирований. Обратите внимание, что эта задача может быть выполнена только при использовании класса <xref:System.IO.Log.LogRecordSequence>, основанного на CLFS.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="nextUndoRecord" /> или <paramref name="previousRecord" /> не является допустимым для этой последовательности.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="nextUndoRecord" /> или <paramref name="previousRecord" /> не лежит между основным и последним порядковыми номерами этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="userRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservationCollection">Коллекция резервирования, в которой требуется сделать резервирования.</param>
        <param name="reservations">Размер необходимого резервирования (в байтах).</param>
        <summary>Автоматически делает одно резервирование и добавляет запись в последовательность. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Заданные резервирования добавляются в предоставленную коллекцию резервирования при помощи атомарной операции добавления записи. Если выполнить добавление не удается, место не резервируется.  
  
 Обычно этот метод может завершить работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи или выполнить резервирование.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="userRecord" /> или <paramref name="previousRecord" /> не лежит между основным и последним порядковыми номерами этой последовательности.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает общее число зарезервированных байтов.</summary>
        <value>Общий размер резервирований, созданных в последовательности записей.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает порядковый номер области перезапуска, ближайшей к концу журнала.</summary>
        <value>Порядковый номер области перезапуска, ближайшей к концу журнала.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Файловая система CLFS поддерживает две области перезапуска, чтобы всегда была доступна хотя бы одна действительная область. Если требуется выполнить восстановление, файловая система CLFS читает область перезапуска и все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 С помощью метода <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A> можно удалить последнюю записанную область перезапуска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, выполняется ли повторная автоматическая попытка добавления в случае заполнения журнала.</summary>
        <value>Значение <see langword="true" />, если выполняется автоматическая повторная попытка добавления при заполнении журнала; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значением данного свойства является `true` и происходит сбой вызова <xref:System.IO.Log.LogRecordSequence.Append%2A> из-за недостатка места в последовательности, последовательность записей пытается освободить место и совершает повторную попытку добавления.  
  
   
  
## Examples  
 В этом примере показано, как использовать свойство <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A>.  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLastRecord(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="member this.SetLastRecord : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.SetLastRecord sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Новый последний порядковый номер в последовательности <see cref="T:System.IO.Log.LogRecordSequence" />.  
  
Он должен указывать на текущую действительную запись в журнале.</param>
        <summary>Задает последнюю запись в последовательности <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указанный порядковый номер должен быть больше, чем базовый порядковый номер.  
  
 После завершения этого метода все записи, которые ранее были добавлены с порядковым номером, превышающим указанный порядковый номер, будут недоступны.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="sequenceNumber" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Новая или существующая архивная цепочка или база активного журнала недействительна.  
  
-или- 
 Значение <paramref name="sequenceNumber" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Достигнут конец журнала.  
  
-или- 
Указан недопустимый формат или версия файла журнала.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сигнализирует о необходимости переместить завершающую часть последовательности.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие можно создать, когда в последовательности записей закончилось свободное пространство. При создании этого события завершающая часть последовательности (то есть базовый порядковый номер) перемещается вперед для освобождения места.  
  
 Событие может генерироваться в любой момент, когда последовательности записей по какой бы то ни было причине требуется освободить место. Например, обработчик политик CLFS может создать это событие, когда обнаружит, что завершающие части двух клиентов с общим файлом журнала слишком далеко разошлись. Освобождение пространства может происходить либо при записи области перезапуска, либо при усечении журнала и применении метода <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> для освобождения пространства. Образец кода в разделе "Пример" иллюстрирует второй подход.  
  
 Также можно вызвать метод <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> независимо от события <xref:System.IO.Log.LogRecordSequence.TailPinned>, чтобы освободить место. Область перезаписи аналогична контрольной точке в других системах обработки журналов. Вызов этого метода означает, что приложение рассматривает все предыдущие записи как полностью завершенные и считает, что их можно использовать для дальнейшего добавления записей. Как и всякая другая запись, запись, выполняемая этим методом, требует фактического свободного пространства в журнале.  
  
   
  
## Examples  
 В этом примере показано, как использовать событие <xref:System.IO.Log.LogRecordSequence.TailPinned>.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает область перезапуска в объект <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Файловая система CLFS поддерживает две области перезапуска, чтобы всегда была доступна хотя бы одна действительная область. Если требуется выполнить восстановление, файловая система CLFS читает область перезапуска и все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Фрагмент массива, который будет сцеплен и добавлен в качестве записи.</param>
        <summary>Записывает область перезапуска в объект <see cref="T:System.IO.Log.LogRecordSequence" />. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Файловая система CLFS поддерживает две области перезапуска, чтобы всегда была доступна хотя бы одна действительная область. Если требуется выполнить восстановление, файловая система CLFS читает область перезапуска и все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Данные в этих фрагментах массива байтов будут сцеплены в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При записи в область перезапуска произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <summary>Записывает область перезапуска в объект <see cref="T:System.IO.Log.LogRecordSequence" />. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Файловая система CLFS поддерживает две области перезапуска, чтобы всегда была доступна хотя бы одна действительная область. Если требуется выполнить восстановление, файловая система CLFS читает область перезапуска и все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Данные в этих фрагментах массива байтов будут сцеплены в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При записи в область перезапуска произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSeqNum">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <summary>Записывает область перезапуска в <see cref="T:System.IO.Log.LogRecordSequence" /> и обновляет базовый порядковый номер. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Файловая система CLFS поддерживает две области перезапуска, чтобы всегда была доступна хотя бы одна действительная область. Если требуется выполнить восстановление, файловая система CLFS читает область перезапуска и все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 При успешном выполнении этого метода базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При записи в область перезапуска произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSeqNum">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <summary>Записывает область перезапуска в <see cref="T:System.IO.Log.LogRecordSequence" /> и обновляет базовый порядковый номер. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Файловая система CLFS поддерживает две области перезапуска, чтобы всегда была доступна хотя бы одна действительная область. Если требуется выполнить восстановление, файловая система CLFS читает область перезапуска и все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 При успешном выполнении этого метода базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При записи в область перезапуска произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSeqNum">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной области перезапуска.</param>
        <summary>Записывает область перезапуска в <see cref="T:System.IO.Log.LogRecordSequence" />, используя резервирование, и обновляет базовый порядковый номер. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Файловая система CLFS поддерживает две области перезапуска, чтобы всегда была доступна хотя бы одна действительная область. Если требуется выполнить восстановление, файловая система CLFS читает область перезапуска и все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 Если задано резервирование, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования. Если метод завершается успешно, будет занята минимальная область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 При успешном выполнении этого метода базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При записи в область перезапуска произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservationCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSeqNum">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <param name="reservationCollection">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной области перезапуска.</param>
        <summary>Записывает область перезапуска в <see cref="T:System.IO.Log.LogRecordSequence" />, используя резервирование, и обновляет базовый порядковый номер. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Файловая система CLFS поддерживает две области перезапуска, чтобы всегда была доступна хотя бы одна действительная область. Если требуется выполнить восстановление, файловая система CLFS читает область перезапуска и все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 Если задано резервирование, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования. Если метод завершается успешно, будет занята минимальная область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 При успешном выполнении этого метода базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="newBaseSeqNum" /> недопустимо для этой последовательности.  
  
-или- 
Указанный порядковый номер начала регистрационного перечисления недопустим.  
  
-или- 
 Невозможно добавить параметр <paramref name="data" />, так как его размеры превышают максимальный размер записи.  
  
-или- 
 Параметр <paramref name="reservationCollection" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.ArgumentNullException">Значение одного или несколько параметров — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Новая или существующая архивная цепочка или база активного журнала недействительна.  
  
-или- 
 Значение <paramref name="newBaseSeqNum" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.  
  
-или- 
Выполнить запрос невозможно из-за ошибки устройства ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданной последовательности журнала запрещен операционной системой.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
  </Members>
</Type>