<Type Name="GC" FullName="System.GC">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dc7c9e2c685dfc7c172e841a4a185e5104bc2007" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57957029" /></Metadata><TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Управляет системным сборщиком мусора — службой, которая автоматически высвобождает неиспользуемую память.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборщик мусора является в компонент среды выполнения, который управляет выделением и освобождением управляемой памяти. Методы этого класса влияет на выполнение сбора мусора на объект и освобождать ресурсы, выделенные объекту. Свойства этого класса предоставляют информацию о общий объем памяти, доступной в системе и возрастную категорию или поколения, память, выделенная для объекта.  
  
 Сборщик мусора отслеживает и уничтожает объекты, находящиеся в управляемой памяти. Периодически сборщик мусора выполняет сборку мусора для освобождения памяти, выделенной для объектов, для которых не существует допустимых ссылок. Сборка мусора происходит автоматически, если запрос на выделение памяти не могут быть удовлетворены с помощью доступной свободной памяти. Кроме того, приложение может принудительно запустить сбор мусора с помощью <xref:System.GC.Collect%2A> метод.  
  
 Сборка мусора состоит из следующих действий:  
  
1.  Сборщик мусора выполняет поиск управляемых объектов, на которые имеются ссылки в управляемом коде.  
  
2.  Сборщик мусора пытается завершить объекты, на которые нет ссылок.  
  
3.  Сборщик мусора освобождает объекты, на которые нет ссылок и возвращает их память.  
  
 Этот раздел включает следующие подразделы:  
  
 [Сборщик мусора и неуправляемых ресурсов](#unmanaged)   
 [Время существования объекта и поколений](#generations)   
 [Отключение сбора мусора](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>Сборщик мусора и неуправляемых ресурсов  
 Во время сбора сборщик мусора не освобождает объект при обнаружении одну или несколько ссылок на объект в управляемом коде. Тем не менее сборщик мусора не распознает ссылки на объект из неуправляемого кода и может уничтожать объекты, которые используются исключительно в неуправляемом коде, если явно запрещено сделать это. <xref:System.GC.KeepAlive%2A> Метод предоставляет механизм, который не позволяет сборщику мусора сбор объектов, которые по-прежнему используются в неуправляемом коде.  
  
 Помимо распределения управляемой памяти реализации сборщика мусора не работают со сведениями о ресурсах, принадлежащих объекту, такие как дескрипторы файлов или подключения к базе данных. Если тип использует неуправляемые ресурсы, которые должны быть освобождены до освобождения экземпляров типа, тип может реализовать метод завершения.  
  
 В большинстве случаев методы завершения реализуются путем переопределения <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метода; тем не менее, типы, написанные на C# или C++ реализуют деструкторы, которые компилятор преобразует в переопределения <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. В большинстве случаев Если объект имеет метод завершения, сборщик мусора вызывает его перед освобождением объекта. Тем не менее сборщик мусора не является обязательным для вызова методов завершения во всех ситуациях; например <xref:System.GC.SuppressFinalize%2A> метод явным образом запрещает финализатор объекта вызова. Кроме того сборщик мусора не требуется использовать из определенного потока для завершения объектов или гарантирует порядок, в котором вызываются методы завершения для объектов, которые ссылаются друг на друга, но в остальном доступных для сборки мусора.  
  
 В сценариях, где в определенное время, в котором необходимо освободить ресурсы, классы могут реализовывать <xref:System.IDisposable> интерфейс, содержащий <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> метод, который выполняет задачи управления и очистки ресурсов. Классы, реализующие <xref:System.IDisposable.Dispose%2A> , необходимо указать как часть своего контракта класса, при потребителями класса вызовите метод, чтобы очистить объект. Сборщик мусора не, по умолчанию вызывает <xref:System.IDisposable.Dispose%2A> метод, однако реализации <xref:System.IDisposable.Dispose%2A> метод можно вызывать методы в <xref:System.GC> класс для настройки поведения сборщика мусора.  
  
 Дополнительные сведения о завершение объекта и шаблон dispose, см. в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>Время существования объекта и поколений  
 Сборщик мусора в среда CLR поддерживает время существования объекта, с помощью поколений. Поколение — это единица измерения относительного времени хранения объектов в памяти. Номер поколения, или возраст объекта указывает поколения, к которой принадлежит объект. Объекты, создаваемые дополнительные недавно входят новые поколения и имеют меньший номер поколения, чем цикл объекты, созданные ранее в жизни приложения. Объекты в самого последнего поколения находятся в поколении 0. Эта реализация сборщика мусора поддерживает три поколения объектов поколений 0, 1 и 2. Можно получить значение <xref:System.GC.MaxGeneration%2A> свойства, чтобы определить максимальный номер поколения поддерживается системой.  
  
 Время существования объекта позволяет приложениям целевой сборка мусора на конкретный набор поколений, а не что сборщику мусора обрабатывать все поколения. Перегруженные версии <xref:System.GC.Collect%2A> метод, который включают `generation` параметра позволяют пользователю указать старших поколений, для быть подвергнута сбору мусора.  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>Отключение сбора мусора  
 Начиная с [!INCLUDE[net_v46](~/includes/net-v46-md.md)], сборщик мусора поддерживает GC режим задержки без области, можно использовать во время выполнения критических путей, в какие сборки мусора коллекции может отрицательно сказаться на производительности приложения. Сборщик Мусора режим задержки без области, необходимо указать объем памяти, который может быть выделен, не мешая сборщиком мусора. Если среда выполнения может выделить память, среда выполнения не выполнит сбор мусора во время выполнения кода на критическом пути.  
  
 Определение начала критический путь без области сборки Мусора путем вызова одной из перегрузок <xref:System.GC.TryStartNoGCRegion%2A>. Укажите в конец его критического пути, вызвав <xref:System.GC.EndNoGCRegion%2A> метод.  
  
 Не удается вложить вызовы к <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в настоящее время находится в режиме задержки без области сборки Мусора. Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> выполнена успешно.  
  
   
  
## Examples  
 В следующем примере несколько методов сборки Мусора поколения памяти данные о блоке неиспользуемых объектов и вывода его на консоль. Неиспользуемые объекты затем собираются и отображаются результирующие итоги памяти.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md">Сборка мусора</related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Основы сборки мусора</related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Дополнительный объем выделенной неуправляемой памяти.</param>
        <summary>Информирует среду выполнения о выделении большого объема неуправляемой памяти, которую необходимо учесть при планировании сборки мусора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При определении времени запланировать сбор мусора, среда выполнения учитывает объем управляемой памяти выделяется. Если маленький управляемый объект выделяет большой объем неуправляемой памяти, среда выполнения учитывает только управляемую память и поэтому недооценивает срочность планировании сборки мусора. <xref:System.GC.AddMemoryPressure%2A> Метод информирует среду CLR о этот дополнительную нагрузку на системную память.  
  
 Самый простой шаблон использования, управляемый объект выделяет неуправляемую память в конструкторе и освобождает его в `Dispose` или `Finalize` метод. Вызовите <xref:System.GC.AddMemoryPressure%2A> метод после выделения неуправляемой памяти и вызовите <xref:System.GC.RemoveMemoryPressure%2A> метод после ее освобождения.  
  
 В более сложных сценариях, где выделения неуправляемой памяти значительно изменяется в течение времени существования управляемого объекта, можно вызвать <xref:System.GC.AddMemoryPressure%2A> и <xref:System.GC.RemoveMemoryPressure%2A> методы для взаимодействия эти добавочные изменения в среду выполнения.  
  
> [!CAUTION]
>  Необходимо гарантировать, что удаляется именно степень давления, добавляемые. Невыполнение этого может отрицательно сказаться на производительности системы в приложениях, выполняемых в течение длительных периодов времени.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytesAllocated" /> меньше или равно 0.  
  
-или- 
На 32-разрядном компьютере <paramref name="bytesAllocated" /> больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода, при обработке приоритетом сборки мусора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет регистрацию уведомления о сборке мусора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод отменяет уведомление о сборке мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод. Нет необходимости вызывать этот метод перед настройкой пороговые значения параметров в последующих вызовах <xref:System.GC.RegisterForFullGCNotification%2A> метод.  
  
   
  
## Examples  
 В следующем примере отменяется регистрация сборки мусора. Этот пример является частью большего примера для [уведомлений сборки мусора](~/docs/standard/garbage-collection/notifications.md) раздела.  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот член недоступен, если включена параллельная сборка мусора. Сведения об отключении параллельной сборки мусора см. в статье, посвященной параметру среды выполнения [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Уведомления о сборке мусора</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Принудительно начинает сборку мусора.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Принудительно запускает немедленную сборку мусора для всех поколений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет восстанавливать всю память, который недоступен. Он выполняет блокирующей сборки мусора для всех поколений.  
  
 Все объекты, независимо от того, как долго они находятся в памяти, считаются для коллекции; Тем не менее объекты, упоминаемые в управляемом коде не собираются. Этот метод позволяет принудительно предпринять попытку освободить максимальный объем доступной памяти.  
  
 Начиная с [!INCLUDE[net_v451](~/includes/net-v451-md.md)], можно сжать кучу больших объектов (LOH), задав <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> свойства <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> перед вызовом <xref:System.GC.Collect%2A> метод, как показано следующем примере.  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.GC.Collect%2A> метод, чтобы выполнить сборку мусора для всех поколений памяти. Код создает число неиспользуемых объектов, а затем вызывает <xref:System.GC.Collect%2A> метод для их удаления из памяти.  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Индуцированные коллекции</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Количество старших поколений, для которых следует выполнить сборку мусора.</param>
        <summary>Принудительно начинает немедленную сборку мусора, начиная с нулевого поколения и вплоть до указанного поколения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для освобождения памяти, который недоступен. Тем не менее с помощью этого метода не гарантирует что всю память, недоступны в указанном поколении.  
  
 Если реализуется время существования объекта, сборщик мусора не собирать объекты с номер поколения больше заданного поколения. Если время существования объекта не реализован, сборщик мусора считает, что все объекты во время сборки мусора.  
  
 Используйте <xref:System.GC.MaxGeneration%2A> свойства, чтобы определить максимальное допустимое значение параметра `generation` параметр.  
  
 Чтобы сборщик мусора учесть все объекты, независимо от их создания, используйте версию этого метода, который не принимает параметров. Чтобы сборщик мусора освобождает объекты, на основе <xref:System.GCCollectionMode> задание, используйте <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> перегрузки метода.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.GC.Collect%2A> метод, чтобы выполнить сборку мусора для отдельных уровней памяти. Код создает число неиспользуемых объектов, а затем вызывает <xref:System.GC.Collect%2A> метод для их удаления из памяти.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Недопустимый параметр <paramref name="generation" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Индуцированные коллекции</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation">Количество старших поколений, для которых следует выполнить сборку мусора.</param>
        <param name="mode">Значение перечисления, указывающее, является ли сборка мусора принудительной (<see cref="F:System.GCCollectionMode.Default" /> или <see cref="F:System.GCCollectionMode.Forced" />) или оптимизированной (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <summary>Принудительно запускает немедленную сборку мусора начиная с нулевого поколения и вплоть до указанного поколения в момент времени, заданный значением <see cref="T:System.GCCollectionMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `mode` параметр для указания сборки мусора должна ли выполняться немедленно или только если время является оптимальным для освобождения объектов. С помощью этого метода не гарантирует что всю память, недоступны в указанном поколении.  
  
 Чтобы настроить степень вмешательства сборщика мусора критические периоды, в приложении, установите <xref:System.Runtime.GCSettings.LatencyMode%2A> свойство.  
  
 Сборщик мусора не собирает объекты с номер поколения, выше, чем указано в `generation` параметра. Используйте <xref:System.GC.MaxGeneration%2A> свойства, чтобы определить максимальное допустимое значение `generation`.  
  
 Чтобы сборщик мусора учесть все объекты, независимо от их создания, используйте версию этого метода, который не принимает параметров.  
  
 Чтобы сборщик мусора освобождает объекты, вплоть до указанного поколения объектов, используйте <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> перегрузки метода. При указании максимально возможного поколения собираются все объекты.  
  
   
  
## Examples  
 Следующий пример принудительно проводит сборку мусора для объектов поколения 2 с <xref:System.GCCollectionMode.Optimized> параметр.  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Недопустимый параметр <paramref name="generation" />.  
  
-или- 
 <paramref name="mode" /> не является одним из значений <see cref="T:System.GCCollectionMode" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Индуцированные коллекции</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation">Количество старших поколений, для которых следует выполнить сборку мусора.</param>
        <param name="mode">Значение перечисления, указывающее, является ли сборка мусора принудительной (<see cref="F:System.GCCollectionMode.Default" /> или <see cref="F:System.GCCollectionMode.Forced" />) или оптимизированной (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">Значение <see langword="true" /> для выполнения блокирующей сборки мусора; значение <see langword="false" /> для выполнения фоновой сборки мусора, где это возможно.</param>
        <summary>Принудительная сборка мусора с поколения 0 до указанного поколения во время, указанное значением <see cref="T:System.GCCollectionMode" />, со значением, указывающим, должна ли сборка быть блокирующей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены взаимодействия `mode` и `blocking` параметры:  
  
|`mode`|`blocking` равно `true`|`blocking` равно `false`|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> или <xref:System.GCCollectionMode.Default>|Блокирующий сбор выполнится, как только это станет возможным. Если фоновая сборка выполняется и `generation` равен 0 или 1, <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> метод немедленно активирует блокирующую сборку и возвращает при завершении коллекции. Если фоновая сборка выполняется и `generation` равно 2, метод дожидается завершения фоновой сборки, активирует блокирующую сборку поколения 2 и возвращает.|Сборка выполнится, как только это станет возможным. Метод <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> запрашивает фоновую сборку, но не гарантирует этот режим. В зависимости от обстоятельств может выполняться блокирующая сборка. Если фоновая сборка уже выполняется, метод возвращает управление немедленно.|  
|<xref:System.GCCollectionMode.Optimized>|В зависимости от текущего состояния сборщика мусора и значения параметра `generation` может выполняться блокирующая сборка. Сборщик мусора пытается обеспечить оптимальную производительность.|Сборка может быть выполнена в зависимости от состояния сборщика мусора. Метод <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> запрашивает фоновую сборку, но не гарантирует этот режим. В зависимости от обстоятельств может выполняться блокирующая сборка. Сборщик мусора пытается обеспечить оптимальную производительность. Если фоновая сборка уже выполняется, метод возвращает управление немедленно.|  
  
 Если в вызове <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> полной блокирующей сборки мусора выполняет метод, можно также сжать кучу больших объектов, задав <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> свойства <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> перед вызовом <xref:System.GC.Collect%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Недопустимый параметр <paramref name="generation" />.  
  
-или- 
 <paramref name="mode" /> не является одним из значений <see cref="T:System.GCCollectionMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="compacting" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation">Количество старших поколений, для которых следует выполнить сборку мусора.</param>
        <param name="mode">Значение перечисления, указывающее, является ли сборка мусора принудительной (<see cref="F:System.GCCollectionMode.Default" /> или <see cref="F:System.GCCollectionMode.Forced" />) или оптимизированной (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">Значение <see langword="true" /> для выполнения блокирующей сборки мусора; значение <see langword="false" /> для выполнения фоновой сборки мусора, где это возможно.</param>
        <param name="compacting">Значение <see langword="true" />, чтобы сжимать кучу маленьких объектов; значение <see langword="false" />, чтобы только очищать.</param>
        <summary>Принудительная сборка мусора с поколения 0 до указанного поколения во время, указанное значением <see cref="T:System.GCCollectionMode" />, со значениями, указывающими, должна ли сборка быть блокирующей и сжимающей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `blocking` является `false`, сборщик Мусора решает, следует ли для выполнения фоновых или блокирующей сборки мусора. Если `compacting` является `true`, он выполняет блокирующей сборки мусора.  
  
 Если `compacting` является `true`, среда выполнения сжимает кучу небольших объектов (SOH). Куча больших объектов (LOH) не сжимается, если не <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> свойству <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>. Обратите внимание, что сюда входят все блокирующие сборки мусора, не только полностью блокирующие сборки мусора.  
  
 Вы можете вызвать <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> метод уменьшить размер управляемой кучи до минимального размера, как показано в следующем фрагменте кода.  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 Указание `true` для `compacting` аргумент гарантирует со сжатием, полной блокирующей сборки мусора. Установка <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> свойства <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> гарантирует, что SOH и LOH сжимаются.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation">Поколение объектов, для которого будет определено количество операций сборки мусора.</param>
        <summary>Возвращает количество операций сборки мусора, выполненных для заданного поколения объектов.</summary>
        <returns>Количество операций сборки мусора, выполненных для заданного поколения объектов с начала процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы реализуете собственное управление ресурсами, может потребоваться принудительно запустить сборку мусора периодически путем вызова <xref:System.GC.Collect%2A> метод. Так как это ресурсоемкая операция, можно повысить производительность, пропуская указанный вызов, когда сбор мусора выполнена недавно. Сохраните значение, возвращенное <xref:System.GC.CollectionCount%2A> сразу после вызова <xref:System.GC.Collect%2A>. В следующий раз, необходимо вызвать <xref:System.GC.Collect%2A>, сравнить текущее значение, возвращенное <xref:System.GC.CollectionCount%2A> сохраненному значению. Если два значения равны, ни одна из коллекций произошло до этого времени, и следует вызвать <xref:System.GC.Collect%2A> еще раз.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="generation" /> меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает режим задержки без области сборки мусора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.EndNoGCRegion%2A> Вызывает метод <xref:System.InvalidOperationException> если сборщик мусора не находится в режиме задержки без области сборки Мусора. Это происходит при любом из следующих условий:  
  
-   <xref:System.GC.TryStartNoGCRegion%2A> Метод не был вызван ранее.  
  
-   Вызов <xref:System.GC.TryStartNoGCRegion%2A> возвращаемое значение метода `false`.  
  
-   Вызов <xref:System.GC.TryStartNoGCRegion%2A> метод вызвал исключение.  
  
 С помощью следующего кода можно предотвратить возникновение исключений для любой из следующих причин:  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сборщик мусора не находится в режиме задержки без области сборки мусора.  
  
-или- 
Режим задержки без области сборки мусора был завершен заранее, поскольку была вызвана сборка мусора.  
  
-или- 
Выделение памяти превышает объем, указанный в вызове метода <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />.</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Режимы задержки</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает общее число байтов, выделенных для текущего потока с начала времени его существования.</summary>
        <returns>Общее число байтов, выделенных для текущего потока с начала времени его существования.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`GetAllocatedBytesForCurrentThread` Метод возвращает общее число байтов, выделенных в управляемой куче, в течение времени существования потока, а не общее число байтов, которые остались после сборки мусора. Возвращаемое значение также не поддерживает все собственные выделения.

Этот метод особенно полезен в сценарии для измерения отличаются выделения памяти интервалы времени или события мониторинга.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает текущий номер поколения объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, информация о поколении которого извлекается.</param>
        <summary>Возвращает номер текущего поколения указанного объекта.</summary>
        <returns>Текущий номер поколения <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет определить возраст объекта, а затем использовать эти сведения с <xref:System.GC.Collect%2A> объектов способ принудительного сборщику мусора этого поколения. Например используйте этот метод при наличии набора объектов, которые создаются в виде группы и стали недоступными в то же время.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.GC.GetGeneration%2A> метод, чтобы определить возраст объекта. Затем в примере выполняется сборки мусора для очистки памяти. и сравнения pre и post итоги памяти коллекции в консоли.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="wo">Объект <see cref="T:System.WeakReference" />, указывающий на целевой объект, номер поколения которого требуется определить.</param>
        <summary>Возвращает текущий номер поколения для целевого объекта указанной слабой ссылки.</summary>
        <returns>Текущий номер поколения для целевого объекта <paramref name="wo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано использование <xref:System.GC.GetGeneration%2A> метод, чтобы определить, как давно обновлялось объект слабой ссылки.  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Сборка мусора уже выполнена для <paramref name="wo" />.</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">Значение <see langword="true" />, указывающий, что перед возвратом этот метод может дождаться выполнения сборки мусора; в противном случае — <see langword="false" />.</param>
        <summary>Извлекает предполагаемое количество выделенных в данный момент байтов. Параметр указывает, может ли этот метод выдержать короткий интервал времени ожидания перед возвратом, пока система выполняет сборку мусора и завершает объекты.</summary>
        <returns>Наилучшая доступная аппроксимация числа байтов, распределенных в данный момент в управляемой памяти.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `forceFullCollection` параметр `true`, этот метод ожидает короткий интервал времени перед возвратом, пока система выполняет сборку мусора и завершает объекты. Длительность интервала находится внутри заданного зависит от числа циклов сборки мусора завершена и изменения восстановленного объема памяти между циклами. Сборщик мусора не гарантирует, что собираются все недоступной памяти.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.GC.GetTotalMemory%2A> метод для возврата и отображения число байтов, выделенных в данный момент в управляемой памяти.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для ссылки.</param>
        <summary>Ссылается на указанный объект, делая его недоступным для сборщика мусора с момента начала текущей процедуры до вызова этого метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Цель <xref:System.GC.KeepAlive%2A> метод является обеспечить наличие ссылки на объект, который находится под угрозой из преждевременно освобождается сборщиком мусора. Обычно такая ситуация может сложиться — при отсутствии ссылок на объект в управляемом коде или данных, но он по-прежнему используется в неуправляемый код, например API-интерфейсов Win32, неуправляемой библиотеки DLL, или методов с использованием модели COM.  
  
 Ссылается на этот метод `obj` параметра, что делает этот объект становится недоступным для сборки мусора в начале подпрограммы к точке, в порядке их выполнения, где вызывается этот метод. Код этого метода в конце, а не в начале диапазона инструкций, где `obj` должны быть доступны.  
  
 <xref:System.GC.KeepAlive%2A> Метод не выполняет никаких действий и создает без побочных эффектов, отличный от увеличения времени существования объекта, переданного в качестве параметра.  
  
   
  
## Examples  
 В следующем примере кода создает объект в начале его `Main` метода и не ссылается на объект до самого конца при <xref:System.GC.KeepAlive%2A> вызывается метод. Объект сохраняется в течение 30-секундной `Main` метод, несмотря на вызовы <xref:System.GC.Collect%2A> и <xref:System.GC.WaitForPendingFinalizers%2A> методы.  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает наибольшее число поколений, поддерживаемое системой в настоящее время.</summary>
        <value>Значение от нуля до максимального числа поддерживаемых поколений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Номер поколения, или возраст объекта — это определяемое реализацией относительная мера из объекта зависящая от. Недавно созданные объекты являются в поколении 0. они самые старые объекты в поколении, меньше или равно поколение возвращаемые <xref:System.GC.MaxGeneration%2A> свойство.  
  
 Сборщик мусора предполагает, что память, выделенная скорее всего будет под сбор мусора, чем старые памяти. Таким образом, сборщик мусора повышает его производительность, настраивая номера поколений каждый раз, он освобождает память, и <xref:System.GC.MaxGeneration%2A> значение свойства может увеличиваться с течением времени.  
  
 Если время существования объекта реализован, <xref:System.GC.MaxGeneration%2A> свойство возвращает максимальный номер поколения используемой системой; в противном случае это свойство возвращает ноль.  
  
   
  
## Examples  
 Следующий пример демонстрирует использование свойства MaxGeneration для отображения наибольший номер поколения в настоящее время используется.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Для этой реализации значение, возвращаемое функцией <see cref="P:System.GC.MaxGeneration" /> свойство гарантированно не изменяются в течение времени существования выполнения приложения.  
  
Используйте <see cref="P:System.GC.MaxGeneration" /> свойства, чтобы определить максимальное значение, которое можно указать при вызове <see cref="M:System.GC.Collect(System.Int32)" /> метод, принимающий параметр поколения.</para></block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">Число от 1 до 99, указывающее условия создания уведомления в зависимости от объектов, выделенных в поколение 2.</param>
        <param name="largeObjectHeapThreshold">Число от 1 до 99, указывающее условия создания уведомления в зависимости от объектов, помещенных в кучу больших объектов.</param>
        <summary>Указывает, что необходимо отправлять уведомления о сборке мусора, когда соблюдены условия для полной сборки мусора и когда завершена сборка.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для каждого поколения сборщик мусора Задает пороговое значение для выделений памяти в этом поколении. Превышение этого порогового значения, размер выделений мусора этого поколения. Для примера, если пороговое значение поколения 2 составляет 20 МБ (что означает, что 20 МБ выдерживает его поколения 1 и перешедшие в поколение 2) и более чем 20 МБ уцелел после сборки поколения 1 и предлагается в поколение 2, будет предпринята попытка следующей сборки мусора как сборки поколения 2. Аналогичным образом Если куча больших объектов (LOH) пороговое значение — 20 МБ и приложения выделил более чем 20 МБ больших объектов, следующей сборки мусора также будет выполняться как поколения 2, (поскольку LOH собирается только в сборках мусора поколения 2).  
  
 `maxGenerationThreshold` И `largeObjectHeapThreshold` пороговые значения контролировать, насколько заранее вы получите уведомление, прежде чем произойдет полная сборка мусора. Чем больше порогового значения, дополнительные распределения, которые могут возникать между уведомлений и следующей сборке мусора.  
  
 Если у вас есть ситуации, в которых полная сборка мусора средой CLR бы отрицательно на производительность приложения, вы можете запросить получать уведомления, когда среда выполнения собирается выполнить полную сборку мусора и обходить эту сборку вызывая сборку самостоятельно (с помощью <xref:System.GC.Collect%2A> метод) Если предпочтительна, по-прежнему выполняются условия. Помимо изменения расписание сбора мусора самостоятельно, полный текст уведомления сборки Мусора полезно в следующих сценариях:  
  
-   Мониторинг для подхода полная сборка мусора и, если вы получите уведомление, что один приближается, снижается размер динамических данных (например, освободив некоторые записи кэша). Таким образом когда происходит сборка мусора, имеет возможность освободить больше памяти.  
  
-   Вы отслеживать завершения полной сборки мусора, таким образом, вы можете собирать статистику.  Например может потребоваться измерить размер кучи по завершении сборки Мусора, чтобы знать размер данных в реальном времени. (После полной сборки Мусора, кучи — наименьший размер.)  
  
 Дополнительные сведения о что представляет полную сборку мусора, см. в разделе [уведомлений сборки мусора](~/docs/standard/garbage-collection/notifications.md).  
  
 При регистрации уведомлений о сборке мусора, вы можете получать при приближении полной сборки мусора и когда она готова. Этот шаблон похож на том, как операционная система отслеживает уведомления о нехватке памяти.  
  
 Следуйте приведенным ниже рекомендациям для указания `maxGenerationThreshold` и `largeObjectHeapThreshold` параметры:  
  
-   Больше верхнего порогового значения, дополнительные выделения происходит между уведомление и полной сборки мусора.  
  
     Больше верхнего порогового значения обеспечивает дополнительные возможности для среды выполнения проверить приближение сборки. Это увеличивает вероятность того, что вы получите уведомление. Тем не менее следует не задано слишком высокое пороговое значение, так как дополнительные выделения прежде, чем среда выполнения вызывает следующую сборку.  
  
     Когда вы сборку мусора самостоятельно после уведомления, используя значение верхнего порогового значения, меньше объектов были удалены, не будет утилизирован очередную сборку мусора среды выполнения.  
  
-   Чем меньше порогового значения, меньше операции выделения памяти от уведомления до полной сборки мусора.  
  
   
  
## Examples  
 В следующем примере показано, как зарегистрировать уведомление о сборке мусора и запустить поток, чтобы отслеживать состояние уведомления о сборке мусора. Данный пример кода является частью большего примера для [уведомлений сборки мусора](~/docs/standard/garbage-collection/notifications.md) раздела.  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maxGenerationThreshold" /> или <paramref name="largeObjectHeapThreshold" /> не входит в диапазон от 1 до 99.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Уведомления о сборке мусора</related>
        <exception cref="T:System.InvalidOperationException">Этот член недоступен, если включена параллельная сборка мусора. Сведения об отключении параллельной сборки мусора см. в статье, посвященной параметру среды выполнения &lt;gcConcurrent&gt;.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Объем освобожденной неуправляемой памяти.</param>
        <summary>Информирует среду выполнения о том, что неуправляемая память освобождена и ее более не требуется учитывать при планировании сборки мусора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При определении времени запланировать сбор мусора, среда выполнения учитывает объем управляемой памяти выделяется. Если маленький управляемый объект выделяет большой объем неуправляемой памяти, среда выполнения учитывает только управляемую память и поэтому недооценивает срочность планировании сборки мусора. <xref:System.GC.AddMemoryPressure%2A> Метод информирует среду CLR о этот дополнительную нагрузку на память системы и <xref:System.GC.RemoveMemoryPressure%2A> метод сообщает среде выполнения отжатии дополнительных давление.  
  
 Самый простой шаблон использования, управляемый объект выделяет неуправляемую память в конструкторе и освобождает его в `Dispose` или `Finalize` метод. Вызовите <xref:System.GC.AddMemoryPressure%2A> метод после выделения неуправляемой памяти и вызовите <xref:System.GC.RemoveMemoryPressure%2A> метод после ее освобождения.  
  
 В более сложных сценариях, где выделения неуправляемой памяти значительно изменяется в течение времени существования управляемого объекта, можно вызвать <xref:System.GC.AddMemoryPressure%2A> и <xref:System.GC.RemoveMemoryPressure%2A> методы для взаимодействия эти добавочные изменения в среду выполнения.  
  
> [!CAUTION]
>  Необходимо гарантировать, что удаляется именно степень давления, добавляемые. Невыполнение этого может отрицательно сказаться на производительности системы в приложениях, выполняемых в течение длительных периодов времени.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytesAllocated" /> меньше или равно 0.  
  
-или- 
На 32-разрядном компьютере <paramref name="bytesAllocated" /> больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода, при обработке приоритетом сборки мусора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, для которого должен быть вызван метод завершения.</param>
        <summary>Требует, чтобы система вызвала метод завершения для указанного объекта, для которого ранее был вызван метод <see cref="M:System.GC.SuppressFinalize(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.ReRegisterForFinalize%2A> Добавляет метод `obj` параметр к списку объектов, которые запрашивают завершения, прежде чем сборщик мусора освободит объект. `obj` Параметр должен быть вызывающая сторона этого метода.  
  
 Вызов <xref:System.GC.ReRegisterForFinalize%2A> не гарантирует, что сборщик мусора вызывает финализатор объекта.  
  
 По умолчанию все объекты, реализующие методы завершения добавляются в список объектов, которые требуют завершения; Тем не менее, объект может быть уже завершен или может отключен путем вызова <xref:System.GC.SuppressFinalize%2A> метод.  
  
 Метод завершения может использовать этот метод, чтобы восстановить себя или объект, который он ссылается.  
  
   
  
## Examples  
 В следующем примере показано, как с помощью метода ReRegisterForFinalize завершить объект второй после сборки мусора.  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, метод завершения для которого не должен выполняться.</param>
        <summary>Сообщает среде CLR, что она на не должна вызывать метод завершения для указанного объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод устанавливает для бита в заголовке объекта `obj`, который среда выполнения проверяет при вызове метода завершения. Метод завершения, который представляется <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метод, используемый для освобождения неуправляемых ресурсов, прежде чем объекта сборщиком мусора. Если `obj` не метод завершения, вызов <xref:System.GC.SuppressFinalize%2A> метод не оказывает влияния.  
  
 Объекты, реализующие <xref:System.IDisposable> интерфейс этот метод можно вызывать из объекта <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализацию, чтобы помешать сборщику мусора вызвать <xref:System.Object.Finalize%2A?displayProperty=nameWithType> на объекте, который она не является обязательной. Как правило, это позволяет предотвратить метода завершения освободить неуправляемые ресурсы, которые уже был освобожден, <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.GC.SuppressFinalize%2A> метод в класс ресурсов для предотвращения избыточной сборки мусора из вызова. В примере используется [dispose](~/docs/standard/garbage-collection/implementing-dispose.md) шаблон освободить как управляемые ресурсы (то есть объекты, реализующие <xref:System.IDisposable>) и неуправляемые ресурсы.  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb">Шаблон ликвидации</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается запретить сборку мусора во время выполнения критического пути.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Не удается вложить вызовы к <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в настоящее время находится в режиме задержки без области сборки Мусора. Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> выполнена успешно.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="totalSize">Объем памяти в байтах для выделения без запуска сборки мусора. Он должен быть меньше или равен размеру временного сегмента. Сведения о размере эфемерных сегментов см. в разделе "Эфемерные поколения и сегменты" статьи [Основы сборки мусора](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <summary>Пытается запретить сборку мусора во время выполнения критического пути, если доступен указанный достаточный объем памяти.</summary>
        <returns>Значение <see langword="true" />, если среде выполнения удалось зафиксировать необходимый объем памяти и сборщик мусора может перейти в режим задержки без области сборки мусора; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> Метод пытается перевести сборщик мусора в GC режим задержки без области, который не разрешает сбор мусора, пока приложение выполняет критической области кода.  Если среда выполнения не может изначально выделяемый запрошенного объема памяти, сборщик мусора выполняет полной блокирующей сборки мусора, при попытке освободить память. Сборщик мусора переходит в режим задержки без области сборки Мусора, если он может выделить необходимый объем памяти, что в данном случае является фактически 2 * `totalSize` байт (он пытается выделить `totalSize` байт для кучи маленьких объектов и `totalSize` байт для куча больших объектов).  
  
 `totalSize` должно быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь. Сюда входят выделения, приложение, а также параметры распределения, среда выполнения предоставляет от имени приложения.  
  
> [!IMPORTANT]
>  Не удается вложить вызовы к <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в настоящее время находится в режиме задержки без области сборки Мусора. Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> выполнена успешно.  
  
 Сборщик Мусора режим задержки без области можно выйти посредством вызова метода <xref:System.GC.EndNoGCRegion%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> превышает размер эфемерного сегмента.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс уже находится в режиме задержки без области сборки мусора.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Основы сборки мусора</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Режимы задержки</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="totalSize">Объем памяти в байтах для выделения без запуска сборки мусора. Он должен быть меньше или равен размеру временного сегмента. Сведения о размере эфемерных сегментов см. в разделе "Эфемерные поколения и сегменты" статьи [Основы сборки мусора](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="disallowFullBlockingGC">Значение <see langword="true" />, чтобы пропустить полную блокирующую сборку мусора, если сборщику мусора изначально не удалось выделить <paramref name="totalSize" /> байтов; в противном случае — значение <see langword="false" />.</param>
        <summary>Пытается запретить сборку мусора во время выполнения критического пути, если доступен указанный объем памяти, и устанавливает, будет ли выполняться полная блокирующая сборка мусора, если изначально не хватает памяти.</summary>
        <returns>Значение <see langword="true" />, если среде выполнения удалось зафиксировать необходимый объем памяти и сборщик мусора может перейти в режим задержки без области сборки мусора; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> Метод пытается перевести сборщик мусора в GC режим задержки без области, который не разрешает сбор мусора, пока приложение выполняет критической области кода.  Если среда выполнения не может изначально выделяемый запрошенного объема памяти и `disallowFullBlockingGC` аргумент `false`, сборщик мусора выполняет полной блокирующей сборки мусора, при попытке освободить память; в противном случае выделение происходит сбой и метод возвращает `false`. Сборщик мусора переходит в режим задержки без области сборки Мусора, если он может выделить необходимый объем памяти, что в данном случае является фактически 2 * `totalSize` (он пытается выделить `totalSize` для кучи маленьких объектов и `totalSize` для больших объектов куча).  
  
 `totalSize` должно быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь. Сюда входят выделения, приложение, а также параметры распределения, среда выполнения предоставляет от имени приложения.  
  
 Установка `disallowFullBlockingGC` для `true` для предотвращения полной блокирующей сборки мусора коллекция, если изначально не хватает памяти наиболее полезен в сценарии балансировки нагрузки: одной системы можно вызвать этот метод и сообщает о себе как Готово к приему запросов, если он возвращает `true`, и Подсистема балансировки нагрузки перенаправлять запросы в другие системы, если он возвращает `false`. Его можно затем выполните полной блокирующей сборки мусора, когда он не обрабатывает запросы путем вызова <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> метод.  
  
> [!IMPORTANT]
>  Не удается вложить вызовы к <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в настоящее время находится в режиме задержки без области сборки Мусора. Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> выполнена успешно.  
  
 Сборщик Мусора режим задержки без области можно выйти посредством вызова метода <xref:System.GC.EndNoGCRegion%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> превышает размер эфемерного сегмента.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс уже находится в режиме задержки без области сборки мусора.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Основы сборки мусора</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Режимы задержки</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="totalSize">Объем памяти в байтах для выделения без запуска сборки мусора. Значение <paramref name="totalSize" /> -<paramref name="lohSize" /> должно быть меньше или равно размеру эфемерного сегмента. Сведения о размере эфемерных сегментов см. в разделе "Эфемерные поколения и сегменты" статьи [Основы сборки мусора](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">Число байтов в <paramref name="totalSize" /> для назначения кучи больших объектов.</param>
        <summary>Пытается запретить сборку мусора во время выполнения критического пути, если указанный объем памяти доступен для кучи больших объектов и для кучи маленьких объектов.</summary>
        <returns>Значение <see langword="true" />, если среде выполнения удалось зафиксировать необходимый объем памяти и сборщик мусора может перейти в режим задержки без области сборки мусора; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> Метод пытается перевести сборщик мусора в GC режим задержки без области, который не разрешает сбор мусора, пока приложение выполняет критической области кода.  Если среда выполнения не может изначально выделяемый запрошенного объема памяти, сборщик мусора выполняет полной блокирующей сборки мусора, при попытке освободить память. Сборщик мусора переходит в режим задержки без области сборки Мусора, если он может выделить `lohSize` для кучи массивных Объектов и `totalSize`  -  `lohSize` для кучи маленьких объектов (SOH).  
  
 `lohSize` должен быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь для кучи массивных Объектов, и `totalSize`  -  `lohSize` должен быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь для SOH. Сюда входят выделения, приложение, а также параметры распределения, среда выполнения предоставляет от имени приложения.  
  
> [!IMPORTANT]
>  Не удается вложить вызовы к <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в настоящее время находится в режиме задержки без области сборки Мусора. Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> выполнена успешно.  
  
 Сборщик Мусора режим задержки без области можно выйти посредством вызова метода <xref:System.GC.EndNoGCRegion%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> - <paramref name="lohSize" /> превышает размер эфемерного сегмента.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс уже находится в режиме задержки без области сборки мусора.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Основы сборки мусора</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Режимы задержки</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="totalSize">Объем памяти в байтах для выделения без запуска сборки мусора. Значение <paramref name="totalSize" /> -<paramref name="lohSize" /> должно быть меньше или равно размеру эфемерного сегмента. Сведения о размере эфемерных сегментов см. в разделе "Эфемерные поколения и сегменты" статьи [Основы сборки мусора](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">Число байтов в <paramref name="totalSize" /> для назначения кучи больших объектов.</param>
        <param name="disallowFullBlockingGC">Значение <see langword="true" />, чтобы пропустить полную блокирующую сборку мусора, если сборщику мусора изначально не удалось выделить указанную память в куче малых и в куче больших объектов; в противном случае — значение <see langword="false" />.</param>
        <summary>Пытается запретить сборку мусора во время выполнения критического пути, если доступен указанный объем памяти для кучи больших объектов и для кучи маленьких объектов, и устанавливает, будет ли выполняться полная блокирующая сборка мусора, если изначально не хватает памяти.</summary>
        <returns>Значение <see langword="true" />, если среде выполнения удалось зафиксировать необходимый объем памяти и сборщик мусора может перейти в режим задержки без области сборки мусора; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> Метод пытается перевести сборщик мусора в GC режим задержки без области, который не разрешает сбор мусора, пока приложение выполняет критической области кода.  Если среда выполнения не может изначально выделяемый запрошенного объема памяти и `disallowFullBlockingGC` аргумент `false`, сборщик мусора выполняет полной блокирующей сборки мусора, при попытке освободить память; в противном случае выделение происходит сбой и метод возвращает `false`. Сборщик мусора переходит в режим задержки без области сборки Мусора, если он может выделить `lohSize` для кучи массивных Объектов и `totalSize`  -  `lohSize` для кучи маленьких объектов (SOH).  
  
 `lohSize` должен быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь для кучи массивных Объектов, и `totalSize`  -  `lohSize` должен быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь для SOH. Сюда входят выделения, приложение, а также параметры распределения, среда выполнения предоставляет от имени приложения.  
  
 Установка `disallowFullBlockingGC` для `true` для предотвращения полной блокирующей сборки мусора коллекция, если изначально не хватает памяти наиболее полезен в сценарии балансировки нагрузки: одной системы можно вызвать этот метод и сообщает о себе как Готово к приему запросов, если он возвращает `true`, и Подсистема балансировки нагрузки перенаправлять запросы в другие системы, если он возвращает `false`. Его можно затем выполните полной блокирующей сборки мусора, когда он не обрабатывает запросы путем вызова <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> метод.  
  
> [!IMPORTANT]
>  Не удается вложить вызовы к <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в настоящее время находится в режиме задержки без области сборки Мусора. Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> выполнена успешно.  
  
 Сборщик Мусора режим задержки без области можно выйти посредством вызова метода <xref:System.GC.EndNoGCRegion%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> - <paramref name="lohSize" /> превышает размер эфемерного сегмента.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс уже находится в режиме задержки без области сборки мусора.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Основы сборки мусора</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Режимы задержки</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает состояние зарегистрированного уведомления, чтобы определить, является ли неизбежной полная, блокирующая сборка мусора средой CLR.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает состояние зарегистрированного уведомления, чтобы определить, является ли неизбежной полная, блокирующая сборка мусора средой CLR.</summary>
        <returns>Состояние зарегистрированного уведомления о сборке мусора.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.GCNotificationStatus> перечисление, возвращенное этим методом, чтобы определить состояние текущего уведомления сбора мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод. Можно также использовать <xref:System.GC.WaitForFullGCComplete%2A> метод, чтобы определить, завершена ли полная сборка мусора.  
  
 При возвращении перечисления <xref:System.GCNotificationStatus.Succeeded>, вы можете выполнять задачи, такие как дополнительные объекты, предотвращая выделяется и вызывая сборку самостоятельно с помощью <xref:System.GC.Collect%2A> метод. Обратите внимание, что уведомление не гарантирует, что полная сборка мусора будет выполнена, только то, что условия Достигнуто пороговое значение, подходящую для полной сборки мусора возникает.  
  
 Этот метод бесконечно ожидает уведомление о сборке мусора получить невозможно. Если вы хотите указать время ожидания для метода для возврата, если не удается получить уведомление, используйте <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> перегрузки метода. Если этот метод вызывается без указания времени ожидания, можно вызвать <xref:System.GC.CancelFullGCNotification%2A> метод, если ожидается больше, чем предпочтительные.  
  
 Этот метод с вызовом необходимо следовать <xref:System.GC.WaitForFullGCComplete%2A> метод, чтобы убедиться в том, что имеется полная сборка мусора. Вызов этого метода только дает неопределенные результаты.  
  
   
  
## Examples  
 В следующем примере показано, как этот метод позволяет определить, приближается ли полная блокировка сборки мусора. Каждый раз, когда находится в состоянии уведомление <xref:System.GCNotificationStatus.Succeeded>, пользовательский метод `OnFullGCApproachNotify` вызывается для выполнения действий в соответствии с размером около коллекции. Данный пример кода является частью большего примера для [уведомлений сборки мусора](~/docs/standard/garbage-collection/notifications.md) раздела.  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Уведомления о сборке мусора</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Продолжительность времени ожидания, прежде чем можно извлечь состояние уведомления. Укажите значение -1, если период ожидания неограниченный.</param>
        <summary>Возвращает состояние зарегистрированного уведомления в пределах указанного времени ожидания, чтобы определить, является ли неизбежной полная блокировка сборки мусора средой CLR.</summary>
        <returns>Состояние зарегистрированного уведомления о сборке мусора.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.GCNotificationStatus> перечисление, возвращенное этим методом, чтобы определить состояние текущего уведомления сбора мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод. Можно также использовать <xref:System.GC.WaitForFullGCComplete%2A> метод, чтобы определить, завершена ли полная сборка мусора.  
  
 Обратите внимание, что этот метод возвращается сразу же каждый раз, когда получается состояние уведомления сбора мусора, независимо от значения, указанного в `millisecondsTimeout`. Если состояние уведомления сбора мусора не будет получена перед `millisecondsTimeout` раз, этот метод возвращает <xref:System.GCNotificationStatus.NotApplicable>.  
  
 При возвращении перечисления <xref:System.GCNotificationStatus.Succeeded>, вы можете выполнять задачи, такие как дополнительные объекты, предотвращая выделяется и вызывая сборку самостоятельно с помощью <xref:System.GC.Collect%2A> метод. Обратите внимание, что уведомление не гарантирует, что полная сборка мусора будет выполнена, только то, что условия Достигнуто пороговое значение, подходящую для полной сборки мусора возникает.  
  
 Вы можете вызвать <xref:System.GC.CancelFullGCNotification%2A> метод, если вы не можете ждать период ожидания, которое должно пройти.  
  
 Этот метод с вызовом необходимо следовать <xref:System.GC.WaitForFullGCComplete%2A> метод, чтобы убедиться в том, что имеется полная сборка мусора. Вызов этого метода только дает неопределенные результаты.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="millisecondsTimeout" /> должно быть либо неотрицательным, либо меньше или равно <see cref="F:System.Int32.MaxValue" /> или –1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Уведомления о сборке мусора</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает состояние зарегистрированного уведомления, чтобы определить, завершена ли полная блокировка сборки мусора средой CLR.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает состояние зарегистрированного уведомления, чтобы определить, завершена ли полная блокировка сборки мусора средой CLR.</summary>
        <returns>Состояние зарегистрированного уведомления о сборке мусора.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.GCNotificationStatus> перечисление, возвращенное этим методом, чтобы определить состояние текущего уведомления сбора мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод. Можно также использовать <xref:System.GC.WaitForFullGCApproach%2A> метод, чтобы определить, является ли неизбежной полная сборка мусора.  
  
 При возвращении перечисления <xref:System.GCNotificationStatus.Succeeded>, вы можете выполнять задачи, такие как возобновление работы и получения число коллекций с <xref:System.GC.CollectionCount%2A> свойство.  
  
 Этот метод бесконечно ожидает уведомление о сборке мусора получить невозможно. Если вы хотите указать время ожидания для метода для возврата, если не удается получить уведомление, используйте <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> перегрузки метода. Если этот метод вызывается без указания времени ожидания, можно вызвать <xref:System.GC.CancelFullGCNotification%2A> метод, если ожидается больше, чем предпочтительные.  
  
 Вызов этого метода необходимо указывать с помощью вызова <xref:System.GC.WaitForFullGCApproach%2A> метод, чтобы убедиться в том, что имеется полная сборка мусора. Сам по себе вызов этого метода может привести к непредсказуемым результатам.  
  
   
  
## Examples  
 В следующем примере показано, как этот метод позволяет определить, завершена ли полная сборка мусора. Каждый раз, когда находится в состоянии уведомление <xref:System.GCNotificationStatus.Succeeded>, пользовательский метод `OnFullGCCompletedNotify` вызывается для выполнения действий в ответ на выполненной сборки. Данный пример кода является частью большего примера для [уведомлений сборки мусора](~/docs/standard/garbage-collection/notifications.md) раздела.  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Уведомления о сборке мусора</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Продолжительность времени ожидания, прежде чем можно извлечь состояние уведомления. Укажите значение -1, если период ожидания неограниченный.</param>
        <summary>Возвращает состояние зарегистрированного уведомления в пределах указанного времени ожидания, чтобы определить, завершена ли полная блокировка сборки мусора средой CLR.</summary>
        <returns>Состояние зарегистрированного уведомления о сборке мусора.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.GCNotificationStatus> перечисление, возвращенное этим методом, чтобы определить состояние текущего уведомления сбора мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод. Можно также использовать <xref:System.GC.WaitForFullGCApproach%2A> метод, чтобы определить, является ли неизбежной полная сборка мусора.  
  
 Обратите внимание, что этот метод возвращается сразу же каждый раз, когда получается состояние уведомления сбора мусора, независимо от значения, указанного в `millisecondsTimeout`. Если состояние уведомления сбора мусора не будет получена перед `millisecondsTimeout` раз, этот метод возвращает <xref:System.GCNotificationStatus.NotApplicable>.  
  
 При возвращении перечисления <xref:System.GCNotificationStatus.Succeeded>, вы можете выполнять задачи, такие как возобновление работы и получения число коллекций с <xref:System.GC.CollectionCount%2A> свойство.  
  
 Вы можете вызвать <xref:System.GC.CancelFullGCNotification%2A> метод, если вы не можете ждать период ожидания, которое должно пройти.  
  
 Вызов этого метода необходимо указывать с помощью вызова <xref:System.GC.WaitForFullGCApproach%2A> метод, чтобы убедиться в том, что имеется полная сборка мусора. Сам по себе вызов этого метода может привести к непредсказуемым результатам.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение <paramref name="millisecondsTimeout" /> должно быть либо неотрицательным, либо меньше или равно <see cref="F:System.Int32.MaxValue" /> или –1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Уведомления о сборке мусора</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Приостанавливает текущий поток до тех пор, пока поток, обрабатывающий очередь методов завершения, не обработает всю очередь.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда сборщик мусора находит объекты, которые могут быть освобождены, он проверяет каждый объект, для определения требований к финализации объекта. Если объект реализует метод завершения и завершения не отключен, вызвав <xref:System.GC.SuppressFinalize%2A>, то объект помещается в список объектов, которые помечены как готовые к завершению. Сборщик мусора вызывает <xref:System.Object.Finalize%2A> методы для объектов в этом списке и удаляет элементы из списка. Этот метод блокируется до завершения всех выполненных до завершения.  
  
 Поток, на котором выполняются методы завершения не определен, поэтому нет никакой гарантии, что этот метод будет завершена. Тем не менее, этот поток может быть прерван другим потоком <xref:System.GC.WaitForPendingFinalizers%2A> метод выполняется. Например можно запустить другой поток, который ожидает в течение определенного периода времени и затем прерывает работу потока, если он по-прежнему находится в приостановленном состоянии.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.GC.WaitForPendingFinalizers%2A> методе для приостановки текущего потока до завершения всех объектов.  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>