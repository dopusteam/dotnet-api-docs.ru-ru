<Type Name="Environment" FullName="System.Environment">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5dc9ac9466ea4ea16f08203acac2a967cedd6c42" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57928728" /></Metadata><TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет сведения о текущей среде и платформе, а также необходимые для управления ими средства. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Environment> класса для извлечения сведения, такие как аргументы командной строки, код выхода, параметров переменных среды, содержимое стека вызовов, времени с момента последней загрузки системы и версии среды CLR.  
  
   
  
## Examples  
 В следующем примере показано отображение списка сведений о текущей среде.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает командную строку для данного процесса.</summary>
        <value>Строка, содержащая аргументы командной строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет доступ к имени программы и все аргументы, указанные в командной строке, когда текущий процесс был запущен.  
  
 Имя программы может включать сведения о пути, но не требуется, чтобы сделать это. Используйте <xref:System.Environment.GetCommandLineArgs%2A> метод для извлечения сведений командной строки, синтаксический анализ и хранятся в массив строк.  
  
 Максимальный размер буфера командной строки не присваивается определенное количество символов; Это зависит от операционной системы Windows, на котором выполняется на компьютере.  
  
   
  
## Examples  
 В следующем примере отображается в отдельной командной строке.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ на чтение к переменной среды PATH. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает полный путь к текущей рабочей папке.</summary>
        <value>Строка, содержащая путь к каталогу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По определению, если этот процесс начинается в корневом каталоге локального или сетевого диска, значение этого свойства является имя диска, следуют косой чертой (например, «C:\\«). Если этот процесс запускается в подкаталоге, значение этого свойства является диска и путь без косой чертой (например, «C:\mySubDirectory»).  
  
   
  
## Examples  
 В следующем примере показано задание <xref:System.Environment.CurrentDirectory%2A> свойство.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Попытка задать пустую строку ("").</exception>
        <exception cref="T:System.ArgumentNullException">Попытка установить значение <see langword="null." />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Попытка установить локальный путь, который не удается найти.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует соответствующее разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для записи к файлам или каталогам в наборе операций. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям, включенным в путь в операции get. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает уникальный идентификатор текущего управляемого потока.</summary>
        <value>Целочисленное значение, представляющее уникальный идентификатор для этого управляемого потока.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="exitCode">Код выхода, возвращаемый операционной системе. Чтобы указать, что процесс прошел успешно, следует использовать 0 (ноль).</param>
        <summary>Завершает этот процесс и возвращает код выхода операционной системе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для `exitCode` параметр, используйте ненулевое число для указания ошибки. В приложении можно определить собственные коды ошибок в перечислении и возвращают соответствующий код ошибки на основе сценария. Например возвращают значение 1, чтобы указать, что требуемый файл отсутствует и значение 2, чтобы указать, что файл находится в неверном формате. Список кодов выхода, используемый операционной системой Windows, см. в разделе [коды системных ошибок](https://msdn.microsoft.com/library/ms681381.aspx) в документации по Windows.  
  
 Вызов <xref:System.Environment.Exit%2A> метод отличается от на языке программирования `return` инструкции следующим образом:  
  
-   <xref:System.Environment.Exit%2A> всегда завершает работу приложения. С помощью `return` инструкция может завершить приложение только в том случае, если используется в точке входа приложения, такие как в `Main` метод.  
  
-   <xref:System.Environment.Exit%2A> завершает приложение немедленно, даже если работают другие потоки. Если `return` в точку входа приложения вызывается инструкция, это вызывает приложение завершить работу, только в том случае, когда завершены все основные потоки.  
  
-   <xref:System.Environment.Exit%2A> вызывающая программа должна иметь разрешение на вызов неуправляемого кода. `return` Инструкция не поддерживает.  
  
-   Если <xref:System.Environment.Exit%2A> вызывается из `try` или `catch` блока кода в любом `finally` блок не выполняется. Если `return` используется инструкция, код в `finally` блок выполнения.  
  
-   Если <xref:System.Environment.Exit%2A> вызывается, когда код в [область ограниченного выполнения](~/docs/framework/performance/constrained-execution-regions.md) запущена (CER), CER не завершится выполнение. Если `return` используется инструкция, CER завершает выполнение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект не имеет достаточных разрешений на выполнение этой функции.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает код выхода из процесса.</summary>
        <value>32-битовое целое число со знаком, содержащее код выхода. Значение по умолчанию 0 (нуль), что соответствует успешно выполненному процессу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `Main` возвращает метод `void`, это свойство позволяет задать код выхода, который возвращается вызывающей среде. Если `Main` не возвращает `void`, это свойство учитывается. Начальное значение этого свойства равно нулю.  
  
> [!WARNING]
>  <xref:System.Environment.ExitCode%2A> Свойство является 32-битового знакового целого числа. Чтобы запретить свойство возвращать код выхода отрицательное, не следует использовать значения больше или равно 0x80000000.  
  
 Используйте ненулевое число для указания ошибки. В приложении можно определить собственные коды ошибок в перечислении и возвращают соответствующий код ошибки на основе сценария. Например возвращают значение 1, чтобы указать, что требуемый файл отсутствует и значение 2, чтобы указать, что файл находится в неверном формате. Список кодов выхода, используемый операционной системой Windows, см. в разделе [коды системных ошибок](https://msdn.microsoft.com/library/ms681381\(v=vs.85\)) в документации по Windows.  
  
   
  
## Examples  
 Вот простое приложение с именем Double.exe, удваивает значение типа integer, переданного в качестве аргумента командной строки. Коды ошибок для назначает значение <xref:System.Environment.ExitCode%2A> свойства для описания ошибок. Обратите внимание на то, что необходимо добавить ссылку на сборку System.Numerics.dll, чтобы успешно скомпилировать этот пример.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 Пример может быть вызвана из пакетного файла, как указано ниже, в результате чего становится доступным его коды ошибок с помощью `ERRORLEVEL` команды.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 Ниже показано несколько примеров выходных данных, полученных при вызове пакетный файл.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Обратите внимание, что код Double.exe идентична в функции в следующем примере, за исключением того, что первое из них определяет точку входа с именем `Main` , не имеет возвращаемого значения, тогда как в этом примере определяет точку входа с именем `Main` , возвращает целое число.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая либо не содержащая имена переменных среды. Каждая переменная среды с двух сторон окружена знаками процента (%).</param>
        <summary>Замещает имя каждой переменной среды, внедренной в указанную строку, строчным эквивалентом значения переменной, а затем возвращает результирующую строку.</summary>
        <returns>Строка, в которой каждая переменная среды замещена ее значением.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 COM-взаимодействия используется для извлечения переменных среды из операционной системы. Если переменные среды не извлекаются из-за ошибки COM, HRESULT, выясните причину сбоя используется для создания одного из нескольких возможных исключений; то есть исключение зависит от значения HRESULT. Дополнительные сведения о том, как обрабатывается значение HRESULT, см. в разделе "Примечания" <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> метод.  
  
 Замена происходит только для переменных среды, которые заданы. Например, предположим, что `name` является «MyENV = % MyENV %». Если переменной среды MyENV имеет значение 42, этот метод возвращает «MyENV = 42». Если MyENV не задано, изменений не происходит; Этот метод возвращает «MyENV = % MyENV %».  
  
 Размер возвращаемого значения ограничен 32 КБ.  
  
   
  
## Examples  
 Приведенный ниже показано, как получить системный диск и системные переменные корневой.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для возможности доступа к переменным среды в <paramref name="name" />. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Завершает процесс сразу после записи сообщения в журнал событий приложений Windows, после чего включает сообщение и дополнительные сведения об исключении в отчет об ошибках, отправляемый в корпорацию Майкрософт.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение, в котором объясняется причина завершения процесса или содержится значение <see langword="null" />, если объяснение отсутствует.</param>
        <summary>Завершает процесс сразу после записи сообщения в журнал событий приложений Windows, после чего включает сообщение в отчет об ошибках, отправляемый в корпорацию Майкрософт.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод завершает процесс без запуска все активные `try` / `finally` блоки и методы завершения.  
  
 <xref:System.Environment.FailFast%2A> Метод записи `message` строки в журнале событий приложений Windows создает дамп приложения и затем прекращает работу текущего процесса. `message` Строка также включается в ошибках в корпорацию Майкрософт.  
  
 Используйте <xref:System.Environment.FailFast%2A> вместо метода <xref:System.Environment.Exit%2A> метод для завершения работы вашего приложения, поврежденного состояния приложения после восстановления и выполнение приложения `try` / `finally` блоки и методы завершения приведет к повреждению ресурсов программы.  
  
 Сведения передаются в корпорацию Майкрософт с помощью отчетов об ошибках Windows. Дополнительные сведения см. в разделе [отчеты об ошибках Windows: Приступая к работе](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 В следующем примере осуществляется запись в журнал событий приложений Windows и прекращает выполнение текущего процесса.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exception" Type="System.Exception" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение, в котором объясняется причина завершения процесса или содержится значение <see langword="null" />, если объяснение отсутствует.</param>
        <param name="exception">Исключение, представляющее ошибку, вызвавшую завершение процесса. Обычно это исключение в блоке <see langword="catch" />.</param>
        <summary>Завершает процесс сразу после записи сообщения в журнал событий приложений Windows, после чего включает сообщение и сведения об исключении в отчет об ошибках, отправляемый в корпорацию Майкрософт.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод завершает процесс без запуска все активные `try` / `finally` блоки и методы завершения.  
  
 <xref:System.Environment.FailFast%2A> Метод записи `message` строки в журнале событий приложений Windows создает дамп приложения и затем прекращает работу текущего процесса.  
  
 Сведения передаются в корпорацию Майкрософт с помощью отчетов об ошибках Windows. Дополнительные сведения см. в разделе [отчеты об ошибках Windows: Приступая к работе](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Ошибка в корпорацию Майкрософт содержит `message` и `exception` сведения, возвращающие подробные сведения, используемые для классификации ошибки. Несмотря на то что `exception` является не обработано, так как процесс завершается, контекстные сведения, который вызвал исключение по-прежнему получается.  
  
 Если `exception` — `null`, или если `exception` — не исключение, этот метод работает так же, как <xref:System.Environment.FailFast%28System.String%29> перегрузки метода.  
  
 Используйте <xref:System.Environment.FailFast%2A> вместо метода <xref:System.Environment.Exit%2A> метод для завершения работы вашего приложения, поврежденного состояния приложения после восстановления и выполнение приложения `try` / `finally` блоки и методы завершения приведет к повреждению ресурсов программы.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строковый массив, содержащий аргументы командной строки для текущего процесса.</summary>
        <returns>Массив строк, каждый элемент которого содержит аргумент командной строки. Первым элементом является имя исполняемого файла. Последующие элементы, если они существуют, содержат аргументы командной строки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Первый элемент в массиве содержит имя файла выполняемой программе. Если имя файла не доступен, первый элемент равен <xref:System.String.Empty?displayProperty=nameWithType>. Остальные элементы содержат все дополнительные лексемы, введенные в командной строке.  
  
 Имя файла программы можно, но не требуется, включают сведения о пути.  
  
 Аргументы командной строки разделяются пробелами. Чтобы добавить пробелы в аргумент можно использовать двойные кавычки (""). Тем не менее, одинарной кавычки ('), не предоставляет такой возможности.  
  
 Если двойная кавычка за два или четного числа символов обратной косой черты, каждая последующая пара заменяется одной обратной косой чертой, а двойная кавычка удаляется. Если двойная кавычка за нечетного числа символов обратной косой черты, включая одну, каждая предыдущая пара заменяется одну обратную косую черту и оставшихся косых удаляется; Однако в этом случае двойная кавычка не удаляется.  
  
 В следующей таблице показано, как аргументы командной строки могут быть с разделителями и предполагается, что `MyApp` как текущего выполняемого приложения.  
  
|Введите в командной строке|Результирующие аргументы командной строки|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Для получения командной строки в виде одной строки, используйте <xref:System.Environment.CommandLine%2A> свойство.  
  
   
  
## Examples  
 Следующий пример отображает аргументы командной строки приложения.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Система не поддерживает аргументы командной строки.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ на чтение к переменной среды PATH. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получение значения переменной среды.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Имя переменной среды.</param>
        <summary>Возвращает из текущего процесса значение переменной среды.</summary>
        <returns>Значение переменной среды, заданное параметром <paramref name="variable" /> или значение <see langword="null" />, если переменная среды не найдена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Environment.GetEnvironmentVariable%28System.String%29> Метод позволяет получить переменную среды из текущего процесса только блок среды. Он эквивалентен вызову <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. 

Чтобы получить все переменные среды, а также их значения, вызовите <xref:System.Environment.GetEnvironmentVariables%2A> метод.  
  
Имена переменных среды учитывают регистр в macOS и Linux, но не с учетом регистра на Windows.  
 
### <a name="on-windows-systems"></a>В системах Windows

 В системах Windows блок среды текущего процесса включает в себя:
 
- Все переменные среды, предоставленные для его родительского процесса, который его создал. Например это приложение .NET, которое запускается из окна консоли наследует все переменные среды в окне консоли. 

  Если не существует родительского процесса, вместо них используются переменные среды на уровне компьютера и пользователя. Например новое окно консоли имеет все на уровне компьютера и пользователя переменные среды, определенные в момент оно было запущено.

- Любой переменным, добавленным в блок process, пока процесс выполняется с помощью вызова <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> метод или <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Эти переменные среды сохраняются до завершения приложения .NET.  
  
Если переменные среды создаются после запуска процесса, этот метод можно использовать для получения только те переменные, которые были созданы путем вызова <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> метод или <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>В macOS и Linux систем

В macOS и Linux блок среды текущего процесса включает следующие переменные среды:

- Все переменные среды, предоставленные для его родительского процесса, который его создал. Для приложений .NET, запускаемых из оболочки Сюда входят все переменные среды, определенные в оболочке.

- Любой переменным, добавленным в блок process, пока процесс выполняется с помощью вызова <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> метод или <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Эти переменные среды сохраняются до завершения приложения .NET.  

.NET core в macOS и Linux не поддерживает переменные среды на уровне компьютера или пользователя.   
  
## Examples  
 В следующем примере используется <xref:System.Environment.GetEnvironmentVariable%2A> метод для извлечения `windir` переменной среды, которая содержит путь к каталогу Windows.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 В следующем примере предпринимается для получения значения переменной среды с именем `Test1` из процесса блок среды. Если переменная не существует, в примере создается его и извлекает его значение. Выводится значение переменной. Если пример создания переменной, он вызывает <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> метод с каждым членом <xref:System.EnvironmentVariableTarget> перечисления для установления того, что переменной можно получить только из текущей среды блок process. Наконец Если в примере была создана переменная, удаляет ее.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для выполнения этой операции.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">возможность считывать значение <paramref name="variable" />. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Имя переменной среды.</param>
        <param name="target">Одно из значений <see cref="T:System.EnvironmentVariableTarget" />.</param>
        <summary>Возвращает из текущего процесса или раздела реестра операционной системы Windows значение переменной среды для текущего пользователя или локального компьютера.</summary>
        <returns>Значение переменной среды, заданное параметрами <paramref name="variable" /> и <paramref name="target" /> или значение <see langword="null" />, если переменная среды не найдена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 

Чтобы получить все переменные среды, а также их значения, вызовите <xref:System.Environment.GetEnvironmentVariables%2A> метод.  
  
Имена переменных среды учитывают регистр в macOS и Linux, но не с учетом регистра на Windows. 

### <a name="on-windows-systems"></a>В системах Windows

В Windows `target` параметр указывает ли переменная среды извлекаются из текущего процесса или раздела реестра операционной системы Windows для текущего пользователя или локального компьютера. Все переменные среды на уровне пользователя и компьютера автоматически копируется в блок среды текущего процесса, как и другие переменные среды, доступные родительскому процессу созданной процессом .NET. Тем не менее, добавлять переменные среды только в блок среды текущего процесса с помощью вызова <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> метод или <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> сохраняются только на протяжении всего процесса.  
  
### <a name="on-macos-and-linux-systems"></a>В macOS и Linux систем

В macOS и Linux `GetEnvironmentVariable(String, EnvironmentVariableTarget)` поддерживает метод `target` значение <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithtype> только. Вызовы с `target` значение <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithtype> или <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithtype> не поддерживаются и возвращать `null`. 

Ниже перечислены переменные среды на уровне процесса:

- Те, наследуется из родительского процесса, обычно оболочки, используемый для вызова `dotnet.exe` или для запуска приложения .NET.

- Определенные с помощью вызова <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> метод или <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Эти переменные среды сохраняется только до `dotnet` завершает процесс или приложение .NET.   
  
## Examples  
 Следующий пример создает переменные среды для целевых объектов процесса, пользователя и компьютера, проверяет ли реестра операционной системы содержит переменные среды пользователя и компьютера, а затем удаляет переменные среды.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> не является допустимым значением <see cref="T:System.EnvironmentVariableTarget" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для выполнения этой операции.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">возможность считывать значение <paramref name="variable" /> Если <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.Process" /> (связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
или 
для полного доступа к переменным среды Если <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.User" /> или <see cref="F:System.EnvironmentVariableTarget.Machine" /> (связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает имена всех переменных среды и их значения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает из текущего процесса имена всех переменных среды и их значения.</summary>
        <returns>Словарь, в котором содержатся имена всех переменных среды и их значения; в противном случае, если переменные среды не найдены, — пустой словарь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имена и значения для переменных среды хранятся в виде пар ключ значение в возвращаемом <xref:System.Collections.IDictionary>.  
  
### <a name="on-windows-systems"></a>В системах Windows

В системах Windows `GetEnvironmentVariables` метод возвращает следующие переменным среды:
  
- Все на уровне компьютера переменные среды, которые определены во время создания процесса вместе со значениями.  
  
- Все переменные среды пользователя, которые определены во время процесса создания вместе со значениями.  

- Все переменные, унаследованные от родительского процесса, из которого был запущен или добавляемый блок process, пока выполняется процесс приложения .NET. Добавляются переменные среды, пока процесс выполняется с помощью вызова <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> метод или <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>В macOS и Linux систем

В MacOS и Linux `GetEnvironmentVariables` метод позволяет получить имя и значение всех переменных среды, которые наследуются от родительского процесса, запустившего `dotnet` процесса или, определяются в пределах `dotnet` сам процесс. Один раз `dotnet` процесс завершается, эти переменные среды в последнем исчезают. 

.NET core не поддерживает переменные среды на уровне компьютера или пользователя.   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Environment.GetEnvironmentVariables%2A> метод.  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для выполнения этой операции.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти буфера.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для возможности чтения имена и значения переменных среды. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target">Одно из значений <see cref="T:System.EnvironmentVariableTarget" />.</param>
        <summary>Возвращает из текущего процесса или раздела реестра операционной системы Windows имена и значения всех переменных среды для текущего пользователя или локального компьютера.</summary>
        <returns>Словарь, в котором содержатся имена всех переменных среды и их значения, извлеченные из источника, заданного параметром <paramref name="target" />; в противном случае, если переменные среды не найдены, — пустой словарь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Имена и значения переменных среды хранятся в виде пар ключ/значение в возвращаемом <xref:System.Collections.IDictionary> объекта.  

### <a name="on-windows-systems"></a>В системах Windows

В системах Windows `target` параметр указывает, является ли источник текущего процесса, раздел реестра для текущего пользователя или раздел реестра для локального компьютера.  

### <a name="on-macos-and-linux-systems"></a>В macOS и Linux систем

В macOS и Linux, только `target` значение <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> поддерживается. Переменные среды на уровне процесса, унаследованные от родительского процесса, используемого для запуска (обычно оболочка) `dotnet` обработки или определяются в пределах `dotnet` сам процесс. Один раз dotnet процесс завершается, эти переменные среды в последнем исчезают.  

Переменные среды на уровне компьютера и пользователя, не поддерживаются. Объект `target` значение <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> или <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> возвращает пустой массив.
  
## Examples  
 Следующий пример создает переменные среды для целевых объектов процесса, пользователя и компьютера, проверяет ли реестра операционной системы содержит переменные среды пользователя и компьютера, а затем удаляет переменные среды.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для выполнения этой операции для указанного значения <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> содержит недопустимое значение.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для возможности чтения имена и значения переменных среды, если <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.Process" /> (связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
или 
для полного доступа к переменным среды Если <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.User" /> или <see cref="F:System.EnvironmentVariableTarget.Machine" /> (связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает путь к особой системной папке, указанной в заданном перечислении.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="folder">Одно из значений перечисления, указывающее особую системную папку.</param>
        <summary>Возвращает путь к особой системной папке, указанной в заданном перечислении.</summary>
        <returns>Путь к указанной особой системной папке, если эта папка физически существует на компьютере; в противном случае — пустая строка ("").  
  
Папка физически не существует, если она не была создана операционной системой, была удалена или является виртуальным каталогом, таким как "Мой компьютер", которому не сопоставлен физический путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает путь к особой системной папке, например Program Files, программы, системой или запуска, который может использоваться для доступа к общей информации. Специальные папки задаются по умолчанию системой, или явно пользователем, при установке версии платформы Windows.  
  
 `folder` Параметр указывает специальную папку, для получения и должен иметь одно из значений в <xref:System.Environment.SpecialFolder> перечисления; именем любого другого значения создает исключение.  
  
 Дополнительные сведения о специальных папках см. в разделе [CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) значения раздела.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.Environment.GetFolderPath%2A> метод для определения и отображения путь, связанный с `folder` параметра.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> не является членом <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая платформа не поддерживается.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям, включенным в путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="folder">Одно из значений перечисления, указывающее особую системную папку.</param>
        <param name="option">Одно из значений перечисления, указывающее параметры доступа к особой папке.</param>
        <summary>Получает путь к особой системной папке, указанной в заданном перечислении, и использует заданный параметр для доступа к особым папкам.</summary>
        <returns>Путь к указанной особой системной папке, если эта папка физически существует на компьютере; в противном случае — пустая строка ("").  
  
Папка физически не существует, если она не была создана операционной системой, была удалена или является виртуальным каталогом, таким как "Мой компьютер", которому не сопоставлен физический путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает путь к особой системной папке, например Program Files, программы, системой или запуска, который может использоваться для доступа к общей информации. Специальные папки задаются по умолчанию системой, или явно пользователем, при установке версии платформы Windows.  
  
 `folder` Параметр указывает специальную папку, для получения и должен иметь одно из значений в <xref:System.Environment.SpecialFolder> перечисления; именем любого другого значения создает исключение.  
  
 Дополнительные сведения о специальных папках см. в разделе [CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) значения раздела.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> не является членом <see cref="T:System.Environment.SpecialFolder" />.
-или-

<paramref name="options" /> не является членом <see cref="T:System.Environment.SpecialFolderOption" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая платформа не поддерживается.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям, включенным в путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив строк, содержащий имена логических дисков текущего компьютера.</summary>
        <returns>Массив строк, в каждом элементе которого содержится имя логического диска. Например, если первым логическим диском является жесткий диск компьютера, первым возвращаемым элементом будет "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано, как для отображения логических дисков текущего компьютера с помощью <xref:System.Environment.GetLogicalDrives%2A> метод.  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода-вывода.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствуют необходимые разрешения.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к ресурсу, защищенному этим разрешением. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, выгружается ли текущий домен приложения или среда CLR завершает работу.</summary>
        <value><see langword="true" /> Если текущий домен приложения выгружается или среда CLR завершает работу; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда среда CLR выгружает домен приложения, она запускает методы завершения на все объекты, имеющие в методе завершения в этом домене приложения. Если среда CLR завершает работу, он начнет поток метода завершения для всех объектов, имеющих в методе завершения. <xref:System.Environment.HasShutdownStarted%2A> Возвращает `true` только в том случае, после запуска потока финализатора. Если это свойство возвращает `true`, можно определить ли домен приложения выгружается или самой CLR завершает работу, вызвав <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> метод. Этот метод возвращает `true` Если финализаторов, так как домен приложения выгружается или `false` Если среда CLR завершает работу.  
  
 <xref:System.Environment.HasShutdownStarted%2A> Возвращает `false` Если поток метода завершения не был запущен.  
  
 С помощью этого свойства, можно определить, следует ли для доступа к статическим переменным в коде завершения. Если домен приложения или среда CLR завершает работу, может оказаться недоступным любой объект, имеющий метод финализации, и, на который ссылается статическое поле. Это потому, что эти объекты могут быть уже завершен.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет, является ли текущая операционная система 64-разрядной.</summary>
        <value>Значение <see langword="true" />, если операционная система является 64-разрядной; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет, является ли текущий процесс 64-разрядным.</summary>
        <value>Значение <see langword="true" />, если процесс является 64-разрядным; в противном случае —значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя NetBIOS данного локального компьютера.</summary>
        <value>Строка, содержащая имя данного компьютера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имя этого компьютера устанавливается при запуске системы, при считывании из реестра. Если этот компьютер является узлом кластера, возвращается имя узла.  
  
   
  
## Examples  
 Следующий пример отображает имя компьютера, на котором выполняется в примере кода. (Имя компьютера указана в выходных данных примера по соображениям безопасности).  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Не удается получить имя этого компьютера.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ на чтение к переменной среды COMPUTERNAME. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает строку, обозначающую в данной среде начало новой строки.</summary>
        <value>Строка, содержащая "\r\n" для платформ, отличных от Unix, или строка, содержащая "\n" для платформ Unix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства <xref:System.Environment.NewLine%2A> является константа, настроенная специально для текущей платформы и реализации платформы .NET Framework. Дополнительные сведения об escape-символов в значении свойства см. в разделе [escape-](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 Функциональные возможности, предоставляемые <xref:System.Environment.NewLine%2A> часто является определение условий перехода на новую строку, перевод строки, разрыв строки, возврат каретки, CRLF и конец строки.  
  
 <xref:System.Environment.NewLine%2A> можно использовать в сочетании с поддержкой новой строки для конкретного языка, такие как символы escape «\r» и «\n» в Microsoft C# и C/C++, или `vbCrLf` в Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> автоматически добавляется к тексту, обрабатываемых <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> и <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> методы.  
  
   
  
## Examples  
 В следующем примере отображаются три строки, разделенных новыми строками.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.OperatingSystem" />, который содержит идентификатор текущей платформы и номер версии.</summary>
        <value>Объект, который содержит идентификатор платформы и номер версии.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`Environment.OSVersion` Свойства не предоставляет надежный способ определить точный операционной системы и ее версии. Таким образом не рекомендуется использовать этот метод. Вместо этого: 

- Чтобы определить платформу операционной системы, используйте <xref:System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform%2A?displayProperty=nameWithType> метод. 

- Следует Избегайте создания кода, который зависит от версии операционной системы. Вместо этого проверьте доступность функций, которые необходимы приложению.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Это свойство не смогло получить версию системы.  
  
-или- 
Полученный идентификатор платформы не является членом <see cref="T:System.PlatformID" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает число процессоров на текущем компьютере.</summary>
        <value>32-битовое целое число со знаком, которое задает количество процессоров на текущем компьютере. Значение по умолчанию отсутствует. Если текущий компьютер содержит несколько групп процессоров, данное свойство возвращает число логических процессоров, доступных для использования средой CLR.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о группах процессоров и логических процессоров см. в разделе [групп процессоров](https://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Environment.ProcessorCount%2A> свойство.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает, изменяет или удаляет переменную среды.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Имя переменной среды.</param>
        <param name="value">Значение, которое необходимо присвоить параметру <paramref name="variable" />.</param>
        <summary>Создает, изменяет или удаляет переменную среды, хранящуюся в текущем процессе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода эквивалентен вызову <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> перегрузки со значением <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> для `target` аргумент.  
  
 Если `value` аргумент не является пустой (см. в обсуждении удаление переменной среды, далее в этом разделе для определения пустое значение) и переменную среды с именем, `variable` параметр не существует, среды создается и назначается содержимое переменной `value`. Если она существует, его значение изменяется. Так как переменная среды определена в блок среды только текущего процесса, он не сохраняется после завершения процесса.  
  
 Если `variable` знаков не начальный шестнадцатеричный символ нуля, прежде чем символ нуля, считаются имя переменной среды, и все последующие символы игнорируются.  
  
 Если `value` знаков не начальный шестнадцатеричный символ нуля, прежде чем символ нуля назначаются в переменную среды, и все последующие символы игнорируются.  
  
 Если `value` пуста, а также переменную среды с именем, `variable` существует, удалить переменную среды. Если `variable` не существует, ошибка не возникает несмотря на то, что невозможно выполнить операцию. `value` считается пустым выполняется любое из следующих условий:  
  
-   Это `null`.  
  
-   Это <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Он состоит из одного символа, значение которого равно U + 0000.  
  
   
  
## Examples  
 Следующий пример проверяет, является ли переменную среды с именем `APPDOMAIN` существует в текущем процессе. Если этого не произошло, он создает его и задает его значение на «True». Если значение `APPDOMAIN` переменная среды — «True», он вызывает метод `Message.Display` метод в новом домене приложения. В противном случае он выполняет `Message.Display` метод в текущем домене приложения.  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 При выполнении примера в первый раз, сообщение «Выполняется в домене домен2» выводит на консоль. Если вы задали переменную среды из командной строки, с помощью команды:  
  
 `Set AppDomain=False`  
  
 в примере отображается сообщение «выполнение в домене *exeName*.exe», где *exeName* — это имя исполняемого файла.  
  
 В следующем примере предпринимается для получения значения переменной среды с именем `Test1` из процесса блок среды. Если переменная не существует, в примере создается переменная и извлекает его значение. Выводится значение переменной. Если пример создания переменной, он вызывает <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> метод с каждым членом <xref:System.EnvironmentVariableTarget> перечисления для установления того, что переменной можно получить только из текущей среды блок process. Наконец Если в примере была создана переменная, удаляет ее.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> содержит строку нулевой длины, начальный шестнадцатеричный символ нуля (0x00) или знак равенства ("=").  
  
-или- 
Длина параметра <paramref name="variable" /> или <paramref name="value" /> больше или равна 32 767 символам.  
  
-или- 
Во время выполнения этой операции произошла ошибка.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для выполнения этой операции.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Имя переменной среды.</param>
        <param name="value">Значение, которое необходимо присвоить параметру <paramref name="variable" />.</param>
        <param name="target">Одно из значений перечисления, указывающее местоположение переменной среды.</param>
        <summary>Создает, изменяет или удаляет переменную среды, хранящуюся в текущем процессе или разделе реестра операционной системы Windows, зарезервированном для текущего пользователя или локального компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Метод позволяет определить переменную среды, которая доступна для текущего процесса ( <xref:System.EnvironmentVariableTarget.Process> значение). Переменные среды, которые являются уникальными для текущей среды блок process сохраняются только до завершения данного процесса.

Кроме того, Windows только в системах <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> метод позволяет определить переменную среды, которая доступна для всех процессов, выполняющихся на компьютере ( <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> значение) и ко всем процессам, запускаемый пользователем ( <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> значение). Переменные среды на уровне компьютера и пользователя копируется в блок среды текущего процесса.  
 
В .NET Core в macOS и систем Linux, вызовы <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> метод со значением <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> или <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> игнорируются. 
  
 Если `value` аргумент не является пустой (см. в обсуждении удаление переменной среды, далее в этом разделе для определения пустое значение) и переменную среды с именем, `variable` аргумент отсутствует, среды создается и назначается содержимое переменной `value`.  Если она существует, его значение изменяется.  
  
 Если `variable` знаков не начальный шестнадцатеричный символ нуля, прежде чем символ нуля, считаются имя переменной среды, и все последующие символы игнорируются.  
  
 Если `value` знаков не начальный шестнадцатеричный символ нуля, прежде чем символ нуля назначаются в переменную среды, и все последующие символы игнорируются.  
  
 Если `value` пуста, а также переменную среды с именем, `variable` существует, удалить переменную среды. `value` считается пустым выполняется любое из следующих условий:  
  
-   Это `null`.  
  
-   Это <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Он состоит из одного символа, значение которого равно U + 0000.  
  
 Если `variable` не существует, ошибка не возникает несмотря на то, что невозможно выполнить операцию. Будьте внимательны при `target` является <xref:System.EnvironmentVariableTarget.Machine>, так как может случайно удалить переменную среды, которая влияет на весь локальный компьютер, а не только текущий процесс или пользователь.  

### <a name="environmentvariabletargetmachine-and-environmentvariabletargetuser-on-windows-systems"></a>EnvironmentVariableTarget.Machine и EnvironmentVariableTarget.User в системах Windows

Если `target` является <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, переменная среды хранится в разделе hkey_current_user\environment реестра локального компьютера. Кроме того, он копируется в экземпляры проводника, работающих под управлением имени текущего пользователя. Переменная среды затем наследуется любым новым процессам, пользователь запускает в проводнике.  
  
 Аналогично Если `target` является <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, переменная среды хранится в HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment ключ реестра локального компьютера. Он также копируются все экземпляры проводника. Переменная среды затем наследуется любым новым процессам, которые запускаются в проводнике.  
  
 Если `target` — <xref:System.EnvironmentVariableTarget.User> или <xref:System.EnvironmentVariableTarget.Machine>, другие приложения получают операции задания по Windows `WM_SETTINGCHANGE` сообщения.  
  
 Если `target` — <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> или <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, рекомендуется, чтобы длина `value` меньше 2048 символов.  
  
## Examples  
 В следующем примере создается переменная среды для <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, и <xref:System.EnvironmentVariableTarget.Machine> предназначен, проверяет ли реестра операционной системы содержит переменные среды компьютера и пользователя, а затем удаляет среду переменные.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> содержит строку нулевой длины, начальный шестнадцатеричный символ нуля (0x00) или знак равенства ("=").  
  
-или- 
Длина параметра <paramref name="variable" /> составляет больше или ровно 32 767 символов.  
  
-или- 
 Элемент <paramref name="target" /> не является элементом перечисления <see cref="T:System.EnvironmentVariableTarget" />.  
  
-или- 
 <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.Machine" /> или <see cref="F:System.EnvironmentVariableTarget.User" />, а длина параметра <paramref name="variable" /> больше или равна 255.  
  
-или- 
 <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.Process" />, а длина параметра <paramref name="value" /> больше или равна 32 767 символам.  
  
-или- 
Во время выполнения этой операции произошла ошибка.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для выполнения этой операции.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущие сведения о трассировке стека.</summary>
        <value>Строка, содержащая сведения о трассировке стека. Это значение может быть равно <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.StackTrace%2A> Свойство перечисляет вызовы метода в обратном хронологическом порядке, то есть сначала описан самый последний вызов метода одну строку сведений о трассировке стека в списке, а для каждого вызова метода в стеке. Тем не менее <xref:System.Environment.StackTrace%2A> свойство может сообщить столько предполагаемых вызовах методов из-за преобразований кода в процессе оптимизации.  
  
> [!NOTE]
>  Иерархическое представление данные трассировки стека в классе, используйте <xref:System.Diagnostics.StackTrace> класса.  
  
 <xref:System.Environment.StackTrace%2A> Свойство форматирует сведения о трассировке стека для каждого вызова метода, следующим образом:  
  
 «в `FullClassName`.`MethodName` (`MethodParams`) в `FileName` : строки `LineNumber` "  
  
 Литерал «на» предшествует три пробела, а вся подстрока, начиная с «in» пропускается в том случае, если символы отладки недоступны. Заполнители, `FullClassName`, `MethodName`, `MethodParams`, `FileName`, и `LineNumber`, заменяются фактическими значениями и определяются следующим образом:  
  
 FullClassName  
 Полное имя класса, включая пространство имен.  
  
 `MethodName`  
 Имя метода.  
  
 `MethodParams`  
 Список пар имен и типов параметров. Каждая пара отделяется запятой («",»"). Эта информация указывается, если `MethodName` не принимает никаких параметров.  
  
 `FileName`  
 Имя источника файла where `MethodName` метод объявляется. Эта информация указывается, если символы отладки недоступны.  
  
 `LineNumber`  
 Номер строки в `FileName` , содержащий исходный код из `MethodName` для инструкции в стеке вызовов. Эта информация указывается, если символы отладки недоступны.  
  
 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Строка завершает каждой строки трассировки стека.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Environment.StackTrace%2A> свойство.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к ресурсу, защищенному с помощью разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает полный путь к системному каталогу.</summary>
        <value>Строка, содержащая путь к каталогу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пример возвращаемого значения — строка «C:\WinNT\System32».  
  
   
  
## Examples  
 Следующий пример отображает каталог системы компьютера, на котором выполняется в примере кода. (Системного каталога указана в выходных данных примера по соображениям безопасности).  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям, включенным в путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает количество байтов на странице памяти операционной системы.</summary>
        <value>Количество в байтах в странице памяти системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта информация может пригодиться при определении, следует ли использовать <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> параметр при работе с файлами, размещенный в памяти.  
  
 В Windows, это значение равно `dwPageSize` члена в `SYSTEM_INFO` структуры.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для доступа к системным и пользовательским переменным среды. Связанное исключение: 
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает время, истекшее с момента загрузки системы (в миллисекундах).</summary>
        <value>32-битовое целое число со знаком, содержащее время, истекшее с момента с последней загрузки системы (в миллисекундах).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого свойства является производным от системного таймера и хранится в виде 32-разрядное целое число со знаком. Обратите внимание, что, поскольку он является производным от системного таймера, разрешение <xref:System.Environment.TickCount%2A> свойство ограничена разрешение системного таймера, который обычно находится в диапазоне от 10 до 16 миллисекунд.  
  
> [!IMPORTANT]
>  Так как значение <xref:System.Environment.TickCount%2A> значение свойства равно 32-разрядное знаковое целое число, если система работает непрерывно, <xref:System.Environment.TickCount%2A> будет увеличиваться от нуля до <xref:System.Int32.MaxValue?displayProperty=nameWithType> приблизительно 24,9 дней, затем перейти к <xref:System.Int32.MinValue?displayProperty=nameWithType>, который является отрицательным числом, затем увеличивается до нуля в течение следующих 24,9 дней. Эту проблему можно обойти, вызвав Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) функцию, которая обнуляется приблизительно дней или вызвав [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) функции.  
  
 <xref:System.Environment.TickCount%2A> отличается от <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> свойство, которое является количество 100-наносекундных интервалов, прошедших с 1/1/0001 12:00 am.  
  
 Используйте <xref:System.DateTime.Now%2A?displayProperty=nameWithType> свойство, чтобы получить текущую локальную дату и время данного компьютера.  
  
   
  
## Examples  
 Приведенный ниже показано, как получить диапазон положительных значений, возвращенных <xref:System.Environment.TickCount%2A> свойство. <xref:System.Environment.TickCount%2A> Свойство циклически переключается между <xref:System.Int32.MinValue?displayProperty=nameWithType>, который является отрицательным числом, и <xref:System.Int32.MaxValue?displayProperty=nameWithType> раз 49.8 дней. Этот пример кода удаляет бит знака для получения неотрицательное число, в котором с нуля и <xref:System.Int32.MaxValue> раз 24,9 дней.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя сетевого домена, связанное с текущим пользователем.</summary>
        <value>Имя сетевого домена, связанное с текущим пользователем.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Учетные данные учетной записи домена для пользователя в формате имени домена пользователя, "\\" символ, а также имя пользователя. Используйте <xref:System.Environment.UserDomainName%2A> свойство для получения имени пользователя домена без указания имени пользователя и <xref:System.Environment.UserName%2A> свойство для получения имени пользователя без имени домена.  Например, если доменное имя пользователя и имя пользователя, CORPORATENETWORK\john <xref:System.Environment.UserDomainName%2A> свойство возвращает «CORPORATENETWORK».  
  
 <xref:System.Environment.UserDomainName%2A> Свойство сначала пытается получить компонент имени домена, имя учетной записи Windows для текущего пользователя. Если попытка не удалась, это свойство пытается получить имя домена, связанный с именем пользователя, предоставляемых <xref:System.Environment.UserName%2A> свойство. Если попытка не удалась, поскольку компьютер не присоединен к домену, то возвращается имя главного компьютера.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Операционная система не поддерживает получение имени сетевого домена.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось получить имя сетевого домена.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ на чтение к переменной среды USERDOMAIN. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, выполняется ли текущий процесс в режиме взаимодействия с пользователем.</summary>
        <value>Значение <see langword="true" />, если текущий процесс выполняется в режиме взаимодействия с пользователем; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.UserInteractive%2A> Отчеты свойство `false` для процесса Windows или службы, такие как IIS, который выполняется без пользовательского интерфейса. Если это свойство имеет `false`, не отображать модальные диалоговые окна или сообщения диалоговые окна, так как нет графического пользовательского интерфейса для взаимодействия с пользователем.  
  
   
  
## Examples  
 В следующем примере отображается ли текущий процесс выполняется в режиме взаимодействия с пользователем.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя пользователя, который на данный момент выполнил вход в операционную систему.</summary>
        <value>Имя пользователя, пользователя, который вошел в систему для операционной системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Environment.UserName%2A> свойство для идентификации пользователя в текущем потоке, чтобы системы и приложений в целях безопасности или доступа. Он может также использоваться для настройки данного приложения для каждого пользователя.  
 
 В Windows <xref:System.Environment.UserName%2A> свойство создает оболочку для вызова Windows [GetUserName](https://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) функции. Учетные данные учетной записи домена для пользователя в формате имени домена пользователя, "\\" символ, а также имя пользователя. Используйте <xref:System.Environment.UserDomainName%2A> свойство для получения имени пользователя домена и <xref:System.Environment.UserName%2A> свойство для получения имени пользователя.  
 
 На платформах Unix <xref:System.Environment.UserName%2A> свойство создает оболочку для вызова `getpwuid_r` функции.
 
 Если приложение ASP.NET выполняется в среде разработки, <xref:System.Environment.UserName%2A> свойство возвращает имя текущего пользователя. В опубликованном в приложении ASP.NET это свойство возвращает имя учетной записи пула приложений (например, пул приложений по умолчанию).  
  
   
  
## Examples  
 Следующий пример отображает имя пользователя, запустившего текущего потока.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ на чтение к переменной среды USERNAME. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Version" />, который описывает основной и дополнительный номера, а также номер построения и редакции среды CLR.</summary>
        <value>Объект, содержащий версию среды CLR.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для платформы .NET Framework версий 4, 4.5, 4.5.1 и 4.5.2 свойство <xref:System.Environment.Version%2A?displayProperty=nameWithType> возвращает объект <xref:System.Version>, строковое представление которого имеет форму `4.0.30319.xxxxx`. .NET Framework 4.6 и более поздних версиях, он имеет вид `4.0.30319.42000`.  
  
> [!WARNING]
>  Для [!INCLUDE[net_v45](~/includes/net-v45-md.md)] и более поздней версии, мы не рекомендуем использовать <xref:System.Environment.Version%2A> свойство для определения версии среды выполнения; вместо этого можно определить версию среда CLR путем запроса реестра. Дополнительные сведения см. в разделе [Как Определение установленных версий платформы .NET Framework](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Дополнительные сведения о версии среды CLR, которая устанавливается вместе с каждой версии платформы .NET Framework, см. в разделе [версии и зависимости](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Следующий пример отображает версию среды CLR. (Версия указана в выходных данных примера по соображениям безопасности).  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем физической памяти, сопоставленной контексту процесса.</summary>
        <value>Целое 64-битовое число со знаком, содержащее число байтов физической памяти, сопоставленное контексту процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример отображает размер рабочего набора компьютера, на котором выполняется в примере кода.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к ресурсу, защищенному этим разрешением. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>