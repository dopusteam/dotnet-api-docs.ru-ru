<Type Name="Array" FullName="System.Array">
  <Metadata><Meta Name="ms.openlocfilehash" Value="03495bd103167c8d6457c796f8983cb6cd93d1b9" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58723845" /></Metadata><TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет методы для создания, изменения, поиска и сортировки массивов, то есть выступает в роли базового класса для всех массивов в среде CLR.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Класс не является частью <xref:System.Collections> пространства имен. Тем не менее, он по-прежнему считается коллекции так, как он основан на <xref:System.Collections.IList> интерфейс.  
  
 <xref:System.Array> Класс является базовым классом для реализаций языков, поддерживающих массивы. Однако только система и компиляторы могут явно наследовать <xref:System.Array> класса. Пользователи должны применять массива конструкции языка.  
  
 Элемент — это значение в <xref:System.Array>. Длина <xref:System.Array> — общее количество элементов, он может содержать. Нижняя граница <xref:System.Array> — это индекс ее первого элемента. <xref:System.Array> Может иметь любую нижнюю границу, но он имеет нижнюю границу, равную нулю, по умолчанию. Другая нижняя граница могут быть определены при создании экземпляра <xref:System.Array> используя <xref:System.Array.CreateInstance%2A>. Многомерный массив <xref:System.Array> может иметь разные границы всех измерений. Массив может иметь более 32 измерений.  
  
 В отличие от классов в <xref:System.Collections> пространства имен, <xref:System.Array> имеют фиксированную емкость. Чтобы увеличить емкость, необходимо создать новый <xref:System.Array> объекта, используя требуемую емкость, копируются элементы из старого <xref:System.Array> объекта в новую, а затем удалить старый <xref:System.Array>.  
  
 По умолчанию, максимальный размер <xref:System.Array> составляет 2 гигабайта (ГБ). В 64-разрядной среде, можно избежать ограничения на размер, задав `enabled` атрибут [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) элемент конфигурации, `true` в среде выполнения. Тем не менее массив по-прежнему будет иметь только 4 миллиардов элемента, а в максимальный индекс 0X7FEFFFFF в любого заданного измерения (0X7FFFFFC7 для массивов байтов и массивы структур однобайтовые).  
  
 Одномерные массивы реализуют <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> и <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> универсальных интерфейсов. Реализации предоставляются массивам во время выполнения, и таким образом, универсальные интерфейсы не отображаются в синтаксисе объявления <xref:System.Array> класса. Кроме того существует не справочные разделы для членов интерфейса, которые доступны только путем приведения массива типа универсального интерфейса (явные реализации интерфейса). Ключевой момент необходимо учитывать при приведении массиве к одному из этих интерфейсов заключается в том, что члены, которые добавляют, вставки или удаления элементов throw <xref:System.NotSupportedException>.  
  
 <xref:System.Type> объекты предоставляют сведения об объявлениях типов массивов. <xref:System.Array> объекты с тем же типом массива одного и того же <xref:System.Type> объекта.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> и <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> могут не возвращать ожидаемые результаты с <xref:System.Array> потому что если массив приводится к типу <xref:System.Array>, результат — это объект, не является массивом. То есть `typeof(System.Array).IsArray` возвращает `false`, и `typeof(System.Array).GetElementType` возвращает `null`.  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType> Метод копирует элементы не только между массивами того же типа, но и между стандартными массивами различных типов; он автоматически осуществляет приведение типов.  
  
 Некоторые методы, такие как <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, и <xref:System.Array.SetValue%2A>, предоставляют перегрузки, принимающие 64-разрядных целых чисел в качестве параметров в соответствии с массивами большой емкости. <xref:System.Array.LongLength%2A> и <xref:System.Array.GetLongLength%2A> возвращают 64-разрядных целых чисел, указывающее длину массива.  
  
 <xref:System.Array> Необязательно должны быть отсортированы.  Сначала нужно отсортировать <xref:System.Array> перед выполнением операций (таких как <xref:System.Array.BinarySearch%2A>), для которых требуется <xref:System.Array> для сортировки.  
  
 С помощью <xref:System.Array> объект указателей в машинном коде не поддерживается и вызывает исключение <xref:System.NotSupportedException> для нескольких методов.  
  
   
  
## Examples  
 В следующем примере кода как <xref:System.Array.Copy%2A?displayProperty=nameWithType> копирует элементы между массив целочисленного типа и массив объектов типа <xref:System.Object>.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 В следующем примере кода создает и инициализирует <xref:System.Array> и отображает его свойства и элементы.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Открытые статические (<see langword="Shared" /> в Visual Basic) члены этого типа являются потокобезопасными. Потокобезопасность членов экземпляров не гарантируется.  
  
Эта реализация не поддерживает синхронизированную (потокобезопасную) оболочку для <see cref="T:System.Array" />, однако на основе классов .NET Framework <see cref="T:System.Array" /> предоставить собственную синхронизированную версию коллекции с помощью <see cref="P:System.Array.SyncRoot" /> свойство.  
  
Перечисление коллекции не является потокобезопасной процедурой. Даже если коллекция синхронизирована, другие потоки могут ее изменить, что приведет к тому, что перечислитель создаст исключение. Для обеспечения потокобезопасности при перечислении можно либо заблокировать коллекцию на все время перечисления, либо перехватывать исключения, возникающие в результате изменений, внесенных другими потоками.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">Массивы (Руководство по программированию на C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Массивы в Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный индексируемый от нуля массив, для которого создается доступная только для чтения программа-оболочка <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</param>
        <summary>Возвращает для заданного массива доступную только для чтения программу-оболочку.</summary>
        <returns>Доступная только для чтения оболочка <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> для указанного массива.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы предотвратить любые изменения в массив, предоставлять массиве только через эту оболочку.  
  
 Коллекция, которая доступна только для чтения — это просто коллекция с оболочкой, предотвращает изменение коллекции; Таким образом при внесении изменений в базовую коллекцию, эти изменения отражаются в коллекции только для чтения.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере показан массив только для чтения <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск значения в отсортированном одномерном массиве <see cref="T:System.Array" />, используя для этого алгоритм двоичного поиска.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, в котором выполняется поиск.</param>
        <param name="value">Объект, который нужно найти.</param>
        <summary>Выполняет поиск заданного элемента во всем отсортированном одномерном массиве, используя интерфейс <see cref="T:System.IComparable" />, реализуемый каждым элементом массива и заданным объектом.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивы, содержащие отрицательные индексы. `array` Перед вызовом этого метода должны быть отсортированы.  
  
 Если <xref:System.Array> не содержит указанное значение, метод возвращает отрицательное целое число. Можно применить оператор поразрядного дополнения (~ в C# `Not` в Visual Basic) для отрицательного результата для создания индекса. Если этот индекс больше, чем значение верхней границы массива, нет элементов, размер которых превышает `value` в массиве. В противном случае это индекс первого элемента, большего, чем `value`.  
  
 Либо `value` или каждый элемент `array` должен реализовывать <xref:System.IComparable> интерфейс, который используется для сравнения. Элементы `array` уже должны быть отсортированы по возрастанию в соответствии с порядком сортировки, определяется <xref:System.IComparable> реализации; в противном случае результаты могут быть неправильными.  
  
> [!NOTE]
>  Если`value` не реализует <xref:System.IComparable> интерфейс, элементы `array` не проверяются на наличие <xref:System.IComparable> до начала поиска. Исключение возникает в том случае, если поиск обнаруживает элемент, который не реализует <xref:System.IComparable>.  
  
 Допускаются повторяющиеся элементы. Если <xref:System.Array> содержит более одного элемента, равным `value`, метод возвращает индекс только одного из них, а не только первый из них.  
  
 `null` всегда можно сравнить с любым другим ссылочным типом; поэтому сравнение с `null` не создает исключение.  
  
> [!NOTE]
>  Для каждого элемента протестированы `value` передается в соответствующий <xref:System.IComparable> реализацию, даже если `value` является `null`. То есть <xref:System.IComparable> реализация определяет сравнение данного элемента на `null`.  
  
 Этот метод является операцией O (log `n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Array.BinarySearch%2A> для поиска определенного объекта в <xref:System.Array>.  
  
> [!NOTE]
>  Массив создается с его элементы в порядке сортировки по возрастанию. <xref:System.Array.BinarySearch%2A> Методу требуется массивов должны быть отсортированы в порядке возрастания.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> относится к типу, который несовместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> не реализует интерфейс <see cref="T:System.IComparable" />, и поиск обнаруживает элемент, который не реализует интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, в котором выполняется поиск.</param>
        <param name="value">Объект, который нужно найти.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Выполняет поиск значения во всем отсортированном одномерном массиве, используя указанный универсальный интерфейс <see cref="T:System.Collections.IComparer" />.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивы, содержащие отрицательные индексы. `array` Перед вызовом этого метода должны быть отсортированы.  
  
 Если <xref:System.Array> не содержит указанное значение, метод возвращает отрицательное целое число. Можно применить оператор поразрядного дополнения (~ в C# `Not` в Visual Basic) для отрицательного результата для создания индекса. Если этот индекс больше, чем значение верхней границы массива, нет элементов, размер которых превышает `value` в массиве. В противном случае это индекс первого элемента, большего, чем `value`.  
  
 Функция сравнения определяет способ сравнения элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> как компаратор, используемый для поиска строк без учета регистра.  
  
 Если `comparer` не `null`, элементы `array` сравниваются с указанного значения, используя указанный <xref:System.Collections.IComparer> реализации. Элементы `array` уже должны быть отсортированы по возрастанию в соответствии с порядком сортировки, определяется `comparer`; в противном случае результаты могут быть неправильными.  
  
 Если`comparer` — `null`, сравнение выполняется с помощью <xref:System.IComparable> реализацию, предоставляемую самим элементом и заданным значением. Элементы `array` уже должны быть отсортированы по возрастанию в соответствии с порядком сортировки, определяется <xref:System.IComparable> реализации; в противном случае результаты могут быть неправильными.  
  
> [!NOTE]
>  Если `comparer` — `null` и `value` не реализует <xref:System.IComparable> интерфейс, элементы `array` не проверяются на наличие <xref:System.IComparable> до начала поиска. Исключение возникает в том случае, если поиск обнаруживает элемент, который не реализует <xref:System.IComparable>.  
  
 Допускаются повторяющиеся элементы. Если <xref:System.Array> содержит более одного элемента, равным `value`, метод возвращает индекс только одного из них, а не только первый из них.  
  
 `null` всегда можно сравнить с любым другим ссылочным типом; поэтому сравнение с `null` не создает исключение.  
  
> [!NOTE]
>  Для каждого элемента протестированы `value` передается в соответствующий <xref:System.IComparable> реализацию, даже если `value` является `null`. То есть <xref:System.IComparable> реализация определяет сравнение данного элемента на `null`.  
  
 Этот метод является операцией O (log `n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> имеет значение <see langword="null" />, и <paramref name="value" /> относится к типу, который несовместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, <paramref name="value" /> не реализует интерфейс <see cref="T:System.IComparable" />, а при поиске обнаруживается элемент, который не реализует интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, в котором выполняется поиск.</param>
        <param name="index">Начальный индекс диапазона поиска.</param>
        <param name="length">Длина диапазона поиска.</param>
        <param name="value">Объект, который нужно найти.</param>
        <summary>Выполняет поиск значения в диапазоне элементов отсортированного одномерного массива, используя интерфейс <see cref="T:System.IComparable" />, реализуемый каждым элементом массива и заданным значением.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивы, содержащие отрицательные индексы. `array` Перед вызовом этого метода должны быть отсортированы.  
  
 Если <xref:System.Array> не содержит указанное значение, метод возвращает отрицательное целое число. Можно применить оператор поразрядного дополнения (~ в C# `Not` в Visual Basic) для отрицательного результата для создания индекса. Если этот индекс больше, чем значение верхней границы массива, нет элементов, размер которых превышает `value` в массиве. В противном случае это индекс первого элемента, большего, чем `value`.  
  
 Либо `value` или каждый элемент `array` должен реализовывать <xref:System.IComparable> интерфейс, который используется для сравнения. Элементы `array` уже должны быть отсортированы по возрастанию в соответствии с порядком сортировки, определяется <xref:System.IComparable> реализации; в противном случае результаты могут быть неправильными.  
  
> [!NOTE]
>  Если `value` не реализует <xref:System.IComparable> интерфейс, элементы `array` не проверяются на наличие <xref:System.IComparable> до начала поиска. Исключение возникает в том случае, если поиск обнаруживает элемент, который не реализует <xref:System.IComparable>.  
  
 Допускаются повторяющиеся элементы. Если <xref:System.Array> содержит более одного элемента, равным `value`, метод возвращает индекс только одного из них, а не только первый из них.  
  
 `null` всегда можно сравнить с любым другим ссылочным типом; поэтому сравнение с `null` не создает исключение.  
  
> [!NOTE]
>  Для каждого элемента протестированы `value` передается в соответствующий <xref:System.IComparable> реализацию, даже если `value` является `null`. То есть <xref:System.IComparable> реализация определяет сравнение данного элемента на `null`.  
  
 Этот метод является операцией O (log `n`) операции, где `n` является `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.  
  
-или- 
 <paramref name="value" /> относится к типу, который не совместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> не реализует интерфейс <see cref="T:System.IComparable" />, и поиск обнаруживает элемент, который не реализует интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, в котором выполняется поиск.</param>
        <param name="index">Начальный индекс диапазона поиска.</param>
        <param name="length">Длина диапазона поиска.</param>
        <param name="value">Объект, который нужно найти.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Выполняет поиск значения в диапазоне элементов отсортированного одномерного массива, используя указанный интерфейс <see cref="T:System.Collections.IComparer" />.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивы, содержащие отрицательные индексы. `array` Перед вызовом этого метода должны быть отсортированы.  
  
 Если <xref:System.Array> не содержит указанное значение, метод возвращает отрицательное целое число. Можно применить оператор поразрядного дополнения (~ в C# `Not` в Visual Basic) для отрицательного результата для создания индекса. Если этот индекс больше, чем значение верхней границы массива, нет элементов, размер которых превышает `value` в массиве. В противном случае это индекс первого элемента, большего, чем `value`.  
  
 Функция сравнения определяет способ сравнения элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> как компаратор, используемый для поиска строк без учета регистра.  
  
 Если `comparer` не `null`, элементы `array` сравниваются с указанного значения, используя указанный <xref:System.Collections.IComparer> реализации. Элементы `array` уже должны быть отсортированы по возрастанию в соответствии с порядком сортировки, определяется `comparer`; в противном случае результаты могут быть неправильными.  
  
 Если `comparer` — `null`, сравнение выполняется с помощью <xref:System.IComparable> реализацию, предоставляемую самим элементом и заданным значением. Элементы `array` уже должны быть отсортированы по возрастанию в соответствии с порядком сортировки, определяется <xref:System.IComparable> реализации; в противном случае результаты могут быть неправильными.  
  
> [!NOTE]
>  Если `comparer` — `null` и `value` не реализует <xref:System.IComparable> интерфейс, элементы `array` не проверяются на наличие <xref:System.IComparable> до начала поиска. Исключение возникает в том случае, если поиск обнаруживает элемент, который не реализует <xref:System.IComparable>.  
  
 Допускаются повторяющиеся элементы. Если <xref:System.Array> содержит более одного элемента, равным `value`, метод возвращает индекс только одного из них, а не только первый из них.  
  
 `null` всегда можно сравнить с любым другим ссылочным типом; поэтому сравнение с `null` не создает исключение при использовании <xref:System.IComparable>.  
  
> [!NOTE]
>  Для каждого элемента протестированы `value` передается в соответствующий <xref:System.IComparable> реализацию, даже если `value` является `null`. То есть <xref:System.IComparable> реализация определяет сравнение данного элемента на `null`.  
  
 Этот метод является операцией O (log `n`) операции, где `n` является `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.  
  
-или- 
 <paramref name="comparer" /> имеет значение <see langword="null" />, и <paramref name="value" /> относится к типу, который несовместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, <paramref name="value" /> не реализует интерфейс <see cref="T:System.IComparable" />, а при поиске обнаруживается элемент, который не реализует интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором выполняется поиск.</param>
        <param name="value">Объект, который нужно найти.</param>
        <summary>Выполняет поиск заданного элемента во всем отсортированном одномерном массиве, используя для этого универсальный интерфейс <see cref="T:System.IComparable`1" />, реализуемый каждым элементом массива <see cref="T:System.Array" /> и заданным объектом.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивы, содержащие отрицательные индексы. `array` Перед вызовом этого метода должны быть отсортированы.  
  
 Если `array` не содержит указанное значение, метод возвращает отрицательное целое число. Можно применить оператор поразрядного дополнения (~ в C# `Not` в Visual Basic) для отрицательного результата для создания индекса. Если индекс равен размеру массива, нет больше элементов, `value` в массиве. В противном случае это индекс первого элемента, большего, чем `value`.  
  
 `T` необходимо реализовать <xref:System.IComparable%601> универсальный интерфейс, который используется для сравнения. Элементы `array` уже должны быть отсортированы по возрастанию в соответствии с порядком сортировки, определяется <xref:System.IComparable%601> реализации; в противном случае результаты могут быть неправильными.  
  
 Допускаются повторяющиеся элементы. Если <xref:System.Array> содержит более одного элемента, равным `value`, метод возвращает индекс только одного из них, а не только первый из них.  
  
 `null` всегда можно сравнить с любым другим ссылочным типом; поэтому сравнение с `null` не создает исключение.  
  
> [!NOTE]
>  Для каждого элемента протестированы `value` передается в соответствующий <xref:System.IComparable%601> реализацию, даже если `value` является `null`. То есть <xref:System.IComparable%601> реализация определяет сравнение данного элемента на `null`.  
  
 Этот метод является операцией O (log `n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> перегрузки универсального метода и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> перегрузки универсального метода. Создается массив строк в произвольном порядке.  
  
 Массив отображается, сортировки и отображаться в дальнейшем. Массивы должны быть отсортированы, чтобы использовать <xref:System.Array.BinarySearch%2A> метод.  
  
> [!NOTE]
>  Вызовы <xref:System.Array.Sort%2A> и <xref:System.Array.BinarySearch%2A> универсальные методы не поменяется, из вызовов их неуниверсальные аналоги, так как Visual Basic, C# и C++ вывести тип параметра универсального типа из типа первого аргумента. Если вы используете [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) изучаемый промежуточного языка Майкрософт (MSIL), вы увидите, что универсальные методы вызываются.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> Перегрузки универсального метода затем используется для поиска двух строк, одна из которых является массивом, а также один, —. Массив и значение, возвращаемое <xref:System.Array.BinarySearch%2A> метод передаются `ShowWhere` универсальный метод, который отображает значение индекса, если строка найдена, а в противном случае элементы строка поиска, которая бы делятся между если бы он был в массиве. Индекс является отрицательным, если строка не в массиве, поэтому `ShowWhere` метод принимает поразрядным дополнением значения (~ оператор в C# и Visual C++, `Xor`-1 в Visual Basic) для получения индекса первого элемента в списке, который больше, чем поиск str ing.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> не реализует универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором выполняется поиск.</param>
        <param name="value">Объект, который нужно найти.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable`1" /> каждого элемента.</param>
        <summary>Выполняет поиск значения во всем отсортированном одномерном массиве, используя указанный универсальный интерфейс <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивы, содержащие отрицательные индексы. `array` Перед вызовом этого метода должны быть отсортированы.  
  
 Если <xref:System.Array> не содержит указанное значение, метод возвращает отрицательное целое число. Можно применить оператор поразрядного дополнения (~ в C# `Not` в Visual Basic) для отрицательного результата для создания индекса. Если индекс равен размеру массива, нет больше элементов, `value` в массиве. В противном случае это индекс первого элемента, большего, чем `value`.  
  
 Функция сравнения определяет способ сравнения элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> как компаратор, используемый для поиска строк без учета регистра.  
  
 Если `comparer` не `null`, элементы `array` сравниваются с указанного значения, используя указанный <xref:System.Collections.Generic.IComparer%601> реализацию универсального интерфейса. Элементы `array` уже должны быть отсортированы по возрастанию в соответствии с порядком сортировки, определяется `comparer`; в противном случае результаты могут быть неправильными.  
  
 Если `comparer` — `null`, сравнение выполняется с помощью <xref:System.IComparable%601> реализацию универсального интерфейса, предоставляемые `T`. Элементы `array` уже должны быть отсортированы по возрастанию в соответствии с порядком сортировки, определяется <xref:System.IComparable%601> реализации; в противном случае результаты могут быть неправильными.  
  
> [!NOTE]
>  Если `comparer` — `null` и `value` не реализует <xref:System.IComparable%601> универсальный интерфейс, элементы `array` не проверяются на наличие <xref:System.IComparable%601> до начала поиска. Исключение возникает в том случае, если поиск обнаруживает элемент, который не реализует <xref:System.IComparable%601>.  
  
 Допускаются повторяющиеся элементы. Если <xref:System.Array> содержит более одного элемента, равным `value`, метод возвращает индекс только одного из них, а не только первый из них.  
  
 `null` всегда можно сравнить с любым другим ссылочным типом; поэтому сравнение с `null` не создает исключение.  
  
> [!NOTE]
>  Для каждого элемента протестированы `value` передается в соответствующий <xref:System.IComparable%601> реализацию, даже если `value` является `null`. То есть <xref:System.IComparable%601> реализация определяет сравнение данного элемента на `null`.  
  
 Этот метод является операцией O (log `n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> перегрузки универсального метода и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> перегрузки универсального метода.  
  
 В примере кода определяется компаратором альтернативные для строк, с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальный интерфейс. Вызовы функции сравнения <xref:System.String.CompareTo%28System.String%29> метод, изменяя порядок сравниваемых объектов, так, что строки сортируются высокого или низкого вместо низкого к высокому.  
  
 Массив отображается, сортировки и отображаться в дальнейшем. Массивы должны быть отсортированы, чтобы использовать <xref:System.Array.BinarySearch%2A> метод.  
  
> [!NOTE]
>  Вызовы <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> универсальные методы не поменяется, из вызовов их неуниверсальные аналоги, так как Visual Basic, C# и C++ вывести тип параметра универсального типа из типа первого аргумента. Если вы используете [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) изучаемый промежуточного языка Майкрософт (MSIL), вы увидите, что универсальные методы вызываются.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Перегрузки универсального метода затем используется для поиска двух строк, одна из которых является массивом, а также один, —. Массив и значение, возвращаемое <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> метод передаются `ShowWhere` универсальный метод, который отображает значение индекса, если строка найдена, а в противном случае элементы строка поиска, которая бы делятся между если бы он был в массиве. Индекс является отрицательным, если строка не n массива, поэтому `ShowWhere` метод принимает поразрядным дополнением значения (~ оператор в C# и Visual C++, `Xor` -1 в Visual Basic) для получения индекса первого элемента в списке, который больше, чем строго поиска: ng.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> имеет значение <see langword="null" />, а <paramref name="value" /> относится к типу, который несовместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, а <paramref name="T" /> не реализует универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором выполняется поиск.</param>
        <param name="index">Начальный индекс диапазона поиска.</param>
        <param name="length">Длина диапазона поиска.</param>
        <param name="value">Объект, который нужно найти.</param>
        <summary>Выполняет поиск значения в диапазоне элементов отсортированного одномерного массива, используя для этого универсальный интерфейс <see cref="T:System.IComparable`1" />, реализуемый каждым элементом массива <see cref="T:System.Array" /> и заданным значением.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивы, содержащие отрицательные индексы. `array` Перед вызовом этого метода должны быть отсортированы.  
  
 Если массив не содержит указанное значение, метод возвращает отрицательное целое число. Можно применить оператор поразрядного дополнения (~ в C# `Not` в Visual Basic) для отрицательного результата для создания индекса. Если индекс равен размеру массива, нет больше элементов, `value` в массиве. В противном случае это индекс первого элемента, большего, чем `value`.  
  
 `T` необходимо реализовать <xref:System.IComparable%601> универсальный интерфейс, который используется для сравнения. Элементы `array` уже должны быть отсортированы по возрастанию в соответствии с порядком сортировки, определяется <xref:System.IComparable%601> реализации; в противном случае результаты могут быть неправильными.  
  
 Допускаются повторяющиеся элементы. Если <xref:System.Array> содержит более одного элемента, равным `value`, метод возвращает индекс только одного из них, а не только первый из них.  
  
 `null` всегда можно сравнить с любым другим ссылочным типом; поэтому сравнение с `null` не создает исключение.  
  
> [!NOTE]
>  Для каждого элемента протестированы `value` передается в соответствующий <xref:System.IComparable%601> реализацию, даже если `value` является `null`. То есть <xref:System.IComparable%601> реализация определяет сравнение данного элемента на `null`.  
  
 Этот метод является операцией O (log `n`) операции, где `n` является `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.  
  
-или- 
 <paramref name="value" /> относится к типу, который не совместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> не реализует универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Отсортированный одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором выполняется поиск.</param>
        <param name="index">Начальный индекс диапазона поиска.</param>
        <param name="length">Длина диапазона поиска.</param>
        <param name="value">Объект, который нужно найти.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable`1" /> каждого элемента.</param>
        <summary>Выполняет поиск значения в диапазоне элементов отсортированного одномерного массива, используя указанный универсальный интерфейс <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <returns>Индекс заданного параметра <paramref name="value" /> в указанном массиве <paramref name="array" />, если параметр <paramref name="value" /> найден; в противном случае — отрицательное число. Если параметр <paramref name="value" /> не найден и значение параметра <paramref name="value" /> меньше одного или нескольких элементов массива <paramref name="array" />, возвращенное отрицательное число —это побитовое дополнение индекса первого элемента, превышающего по значению параметр <paramref name="value" />. Если параметр <paramref name="value" /> не найден и значение <paramref name="value" /> больше всех элементов массива <paramref name="array" />, возвращенное отрицательное число является побитовым дополнением увеличенного на 1 индекса последнего элемента. Если этот метод вызывается с неотсортированным <paramref name="array" />, возвращаемое значение может быть неправильным, и может быть возвращено отрицательное число, даже если <paramref name="value" /> присутствует в <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не поддерживает поиск массивы, содержащие отрицательные индексы. `array` Перед вызовом этого метода должны быть отсортированы.  
  
 Если массив не содержит указанное значение, метод возвращает отрицательное целое число. Можно применить оператор поразрядного дополнения (~ в C# `Not` в Visual Basic) для отрицательного результата для создания индекса. Если индекс равен размеру массива, нет больше элементов, `value` в массиве. В противном случае это индекс первого элемента, большего, чем `value`.  
  
 Функция сравнения определяет способ сравнения элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> как компаратор, используемый для поиска строк без учета регистра.  
  
 Если `comparer` не `null`, элементы `array` сравниваются с указанного значения, используя указанный <xref:System.Collections.Generic.IComparer%601> реализацию универсального интерфейса. Элементы `array` уже должны быть отсортированы по возрастанию в соответствии с порядком сортировки, определяется `comparer`; в противном случае результаты могут быть неправильными.  
  
 Если `comparer` — `null`, сравнение выполняется с помощью <xref:System.IComparable%601> реализацию универсального интерфейса, предоставленное для типа `T`. Элементы `array` уже должны быть отсортированы по возрастанию в соответствии с порядком сортировки, определяется <xref:System.IComparable%601> реализации; в противном случае результаты могут быть неправильными.  
  
 Допускаются повторяющиеся элементы. Если <xref:System.Array> содержит более одного элемента, равным `value`, метод возвращает индекс только одного из них, а не только первый из них.  
  
 `null` всегда можно сравнить с любым другим ссылочным типом; поэтому сравнение с `null` не создает исключение при использовании <xref:System.IComparable%601>.  
  
> [!NOTE]
>  Для каждого элемента протестированы `value` передается в соответствующий <xref:System.IComparable%601> реализацию, даже если `value` является `null`. То есть <xref:System.IComparable%601> реализация определяет сравнение данного элемента на `null`.  
  
 Этот метод является операцией O (log `n`) операции, где `n` является `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.  
  
-или- 
 <paramref name="comparer" /> имеет значение <see langword="null" />, и <paramref name="value" /> относится к типу, который несовместим с элементами <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, и <paramref name="T" /> не реализует универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Массив, элементы которого необходимо очистить.</param>
        <param name="index">Начальный индекс диапазона элементов, которые необходимо очистить.</param>
        <param name="length">Число элементов, подлежащих очистке.</param>
        <summary>Задает для диапазона элементов в массиве значение, предусмотренное по умолчанию для каждого типа элементов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод сбрасывает каждый элемент массива в значение по умолчанию тип элемента. Он устанавливает элементы ссылочных типов (включая <xref:System.String> элементов) чтобы `null`и задает значения по умолчанию, показанные в следующей таблице элементы типов значений.  
  
|Тип|Значение|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Все числовые типы целочисленные и с плавающей точкой|0 (ноль)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Другие типы значений|Значение по умолчанию поля типа|  
  
 Диапазон очистке wrap элементы от строки к строке в многомерный массив.  
  
 Этот метод удаляет только значения элементов; элементы, не удаляются. Массив имеет фиксированный размер; Таким образом нельзя добавлять или удалять элементы.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Array.Clear%2A> метод, чтобы сбросить целочисленные значения в одномерный, двухмерный и трехмерный массив.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 В следующем примере определяется `TimeZoneTime` структуру, которая включает в себя <xref:System.TimeZoneInfo> поля и <xref:System.DateTimeOffset> поля. Затем он вызывает <xref:System.Array.Clear%2A> метод, чтобы удалить один элемент из двух элементов массива `TimeZoneTime` значения. Метод задает значение очищенного элемента к значению по умолчанию <xref:System.TimeZoneInfo> объект, являющийся `null`и значение по умолчанию <xref:System.DateTimeOffset> объект, являющийся <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.  
  
-или- 
Сумма <paramref name="index" /> и <paramref name="length" /> больше, чем размер <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает неполную копию <see cref="T:System.Array" />.</summary>
        <returns>Неполная копия <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неполная копия объекта <xref:System.Array> копирует только те элементы <xref:System.Array>, они являются ссылочными типами или типами значений, но он не копирует объекты, которые ссылаются на. Ссылки в новом <xref:System.Array> точки на тот же объекты, ссылки в исходном <xref:System.Array> пункты.  
  
 Напротив, глубокая копия объекта <xref:System.Array> копирует элементы и все, что прямо или косвенно ссылаются элементы.  
  
 Клон имеет тот же <xref:System.Type> на исходном <xref:System.Array>.  
  
 Этот метод является операцией O (`n`) операции, где `n` является <xref:System.Array.Length%2A>.  
  
   
  
## Examples  
 В следующем примере кода примера клонов <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> массива и демонстрирует поведение поверхностной копии.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Массив <see cref="T:System.Array" />, содержащий данные, которые требуется скопировать.</param>
        <param name="sourceIndex">32-разрядное целое число, представляющее индекс в массиве <paramref name="sourceArray" />, с которого начинается копирование.</param>
        <param name="destinationArray">Массив <see cref="T:System.Array" />, принимающий данные.</param>
        <param name="destinationIndex">32-разрядное целое число, представляющее индекс в массиве <paramref name="destinationArray" />, с которого начинается сохранение.</param>
        <param name="length">32-битовое целое число, представляющее число копируемых элементов.</param>
        <summary>Копирует диапазон элементов из массива <see cref="T:System.Array" />, начиная с заданного индекса источника, и вставляет его в другой массив <see cref="T:System.Array" />, начиная с заданного индекса назначения.  Гарантирует, что в случае невозможности успешно скопировать весь диапазон, все изменения будут отменены.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` И `destinationArray` параметры должны иметь одинаковое количество измерений.  `sourceArray` Тип должен быть таким же, как, или производным от `destinationArray` введите; в противном случае <xref:System.ArrayTypeMismatchException> возникает исключение.  В отличие от <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> проверяет совместимость типов массива перед выполнением любой операции.  
  
 При копировании между многомерные массивы, массив ведет себя как длинный одномерный массив, где строки (или столбцы) расположены последовательно end-to-end. Например если массив имеет три строки (или столбцы) с четырьмя элементами, при копировании шесть элементов с начала массива будут скопированы все четыре элемента первой строки (или столбца) и два элемента второй строки (или столбца). Чтобы начать копирование со второй элемент третьей строки (или столбца), `sourceIndex` должно быть верхнюю границу первой строки (или столбца) плюс длина второй строки (или столбца) плюс два.  
  
 Если `sourceArray` и `destinationArray` перекрываются, этот метод работает так, как если исходные значения `sourceArray` были сохранены во временном расположении перед `destinationArray` перезаписывается.  
  
 [C++]  
  
 Этот метод эквивалентен стандартной функции C/C++ `memmove`, а не `memcpy`.  
  
 Массивы могут иметь ссылочный тип или тип значения.  Если `sourceArray` и `destinationArray` оба массива ссылочного типа или оба массива типа <xref:System.Object>, выполняется Неполная копия. Неполная копия объекта <xref:System.Array> — это новая <xref:System.Array> содержащий ссылки на те же элементы, что и исходный <xref:System.Array>. Элементы сами или что-нибудь ссылаются элементы не копируются. Напротив, глубокая копия объекта <xref:System.Array> копирует элементы и все, что прямо или косвенно ссылаются элементы.  
  
 Если этот метод вызывает исключение при копировании, `destinationArray` остается без изменений; таким образом, <xref:System.Array.ConstrainedCopy%2A> может использоваться в области ограниченного выполнения (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 Этот метод является операцией O (`n`) операции, где `n` является `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> — <see langword="null" />.  
  
-или- 
 <paramref name="destinationArray" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют различные ранги.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Тип <paramref name="sourceArray" /> не совпадает с типом <paramref name="destinationArray" /> и не является производным от него.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в <paramref name="sourceArray" /> не может быть приведен к типу <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> меньше, чем нижняя граница первого измерения массива <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="destinationIndex" /> меньше, чем нижняя граница первого измерения массива <paramref name="destinationArray" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> больше числа элементов с <paramref name="sourceIndex" /> до конца <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="length" /> больше числа элементов с <paramref name="destinationIndex" /> до конца <paramref name="destinationArray" />.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Тип элементов исходного массива.</typeparam>
        <typeparam name="TOutput">Тип элементов массива назначения.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля, и который приводится к типу целевого объекта.</param>
        <param name="converter">Объект <see cref="T:System.Converter`2" />, преобразующий каждый элемент из одного типа в другой тип.</param>
        <summary>Преобразует массив одного типа в массив другого типа.</summary>
        <returns>Массив целевого типа, содержащий преобразованные элементы исходного массива.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> Делегат для метода, который преобразует объект в целевой тип.  Элементы `array` передаются по отдельности <xref:System.Converter%602>, и сохраняются в новый массив преобразованных элементов.  
  
 Источник `array` остается неизменным.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода определяется метод с именем `PointFToPoint` , преобразующий <xref:System.Drawing.PointF> структуру <xref:System.Drawing.Point> структуры. Затем в примере создается массив <xref:System.Drawing.PointF> структуры, создает `Converter<PointF, Point>` делегировать (`Converter(Of PointF, Point)` в Visual Basic) для представления `PointFToPoint` метод и передает делегат, который <xref:System.Array.ConvertAll%2A> метод. <xref:System.Array.ConvertAll%2A> Метод передает каждому элементу входного списка для `PointFToPoint` метод и помещает в новый список преобразованных элементов <xref:System.Drawing.Point> структуры. Отображаются оба списка.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="converter" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует диапазон элементов из одного массива <see cref="T:System.Array" /> в другой массив <see cref="T:System.Array" /> и, при необходимости, выполняет приведение типов и упаковку-преобразование.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Массив <see cref="T:System.Array" />, содержащий данные, которые требуется скопировать.</param>
        <param name="destinationArray">Массив <see cref="T:System.Array" />, принимающий данные.</param>
        <param name="length">32-битовое целое число, представляющее число копируемых элементов.</param>
        <summary>Копирует диапазон элементов из массива <see cref="T:System.Array" />, начиная с первого элемента, и вставляет его в другой массив <see cref="T:System.Array" />, также начиная с первого элемента. Длина задается как 32-разрядное целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` И `destinationArray` параметры должны иметь одинаковое количество измерений. Кроме того `destinationArray` должен уже был определен и должен иметь достаточное количество элементов для размещения всех скопированных данных.  
  
 При копировании между многомерные массивы, массив ведет себя как длинный одномерный массив, где строки (или столбцы) расположены последовательно сквозного. Например если массив имеет три строки (или столбцы) с четырьмя элементами, при копировании шесть элементов с начала массива будут скопированы все четыре элемента первой строки (или столбца) и два элемента второй строки (или столбца).  
  
 Если `sourceArray` и `destinationArray` перекрываются, этот метод работает так, как если исходные значения `sourceArray` были сохранены во временном расположении перед `destinationArray` перезаписывается.  
  
 [C++]  
  
 Этот метод эквивалентен стандартной функции C/C++ `memmove`, а не `memcpy`.  
  
 Массивы могут иметь ссылочный тип или тип значения. Выполняется приведение типов, при необходимости.  
  
-   При копировании из массива ссылочного типа в массив типа значения, каждый элемент преобразуется и затем копируются. При копировании из массива типа значения ссылочного типа, каждый элемент упаковывается и затем копируются.  
  
-   При копировании из массива ссылочного типа или типа значения в <xref:System.Object> массива, <xref:System.Object> создается для хранения каждого значения или ссылки, а затем копируются. При копировании из <xref:System.Object> массива в массив ссылочного типа или типа значения, и присваивание не поддерживается, <xref:System.InvalidCastException> возникает исключение.  
  
-   Если `sourceArray` и `destinationArray` оба массива ссылочного типа или оба массива типа <xref:System.Object>, выполняется Неполная копия. Неполная копия объекта <xref:System.Array> — это новая <xref:System.Array> содержащий ссылки на те же элементы, что и исходный <xref:System.Array>. Элементы сами или что-нибудь ссылаются элементы не копируются. Напротив, глубокая копия объекта <xref:System.Array> копирует элементы и все, что прямо или косвенно ссылаются элементы.  
  
 <xref:System.ArrayTypeMismatchException> Возникает, если массивы имеют несовместимые типы. Совместимость типов определяется следующим образом:  
  
-   Тип совместим с самим собой.  
  
-   Тип значения совместим с <xref:System.Object> и с типом интерфейса, реализуемый этим типом значения. Тип значения считается подключен к интерфейсу, только в том случае, если он непосредственно реализует этот интерфейс. Отключенные типы несовместимы.  
  
-   Два встроенных (предопределенных) типа значений являются совместимыми, если копирование из исходного типа в конечный тип — расширяющего преобразования. Расширяющее преобразование никогда не данные теряются, тогда как сужающее преобразование может привести к потере информации. Например будет расширяющее преобразование, преобразование 32-разрядное целое число со знаком в 64-разрядное целое число со знаком, а преобразование 64-разрядное целое число со знаком в 32-разрядное знаковое целое число является сужающим преобразованием. Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
-   Тип значения встроенным (пользовательская) совместим только с самим собой.  
  
-   Перечисления поддерживают неявное преобразование к <xref:System.Enum> и к своему базовому типу.  
  
 Если каждый элемент массива `sourceArray` требует приведения (например, от базового класса в производный класс или из интерфейса на объект) и один или несколько элементов не может быть преобразован в соответствующий тип в `destinationArray`, <xref:System.InvalidCastException> возникает исключение.  
  
 Если этот метод вызывает исключение при копировании, состояние `destinationArray` не определено.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> — <see langword="null" />.  
  
-или- 
 <paramref name="destinationArray" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют различные ранги.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют несовместимые типы.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в <paramref name="sourceArray" /> не может быть приведен к типу <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> больше числа элементов в <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="length" /> больше числа элементов в <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Массив <see cref="T:System.Array" />, содержащий данные, которые требуется скопировать.</param>
        <param name="destinationArray">Массив <see cref="T:System.Array" />, принимающий данные.</param>
        <param name="length">64-битовое целое число, представляющее число копируемых элементов. Целое число должно лежать в диапазоне от 0 до <see cref="F:System.Int32.MaxValue" /> включительно.</param>
        <summary>Копирует диапазон элементов из массива <see cref="T:System.Array" />, начиная с первого элемента, и вставляет его в другой массив <see cref="T:System.Array" />, также начиная с первого элемента. Длина задается как 64-битовое целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` И `destinationArray` параметры должны иметь одинаковое количество измерений. Кроме того `destinationArray` должен уже был определен и должен иметь достаточное количество элементов для размещения всех скопированных данных.  
  
 При копировании между многомерные массивы, массив ведет себя как длинный одномерный массив, где строки (или столбцы) расположены последовательно сквозного. Например если массив имеет три строки (или столбцы) с четырьмя элементами, при копировании шесть элементов с начала массива будут скопированы все четыре элемента первой строки (или столбца) и два элемента второй строки (или столбца).  
  
 Если `sourceArray` и `destinationArray` перекрываются, этот метод работает так, как если исходные значения `sourceArray` были сохранены во временном расположении перед `destinationArray` перезаписывается.  
  
 [C++]  
  
 Этот метод эквивалентен стандартной функции C/C++ `memmove`, а не `memcpy`.  
  
 Массивы могут иметь ссылочный тип или тип значения. Выполняется приведение типов, при необходимости.  
  
-   При копировании из массива ссылочного типа в массив типа значения, каждый элемент преобразуется и затем копируются. При копировании из массива типа значения ссылочного типа, каждый элемент упаковывается и затем копируются.  
  
-   При копировании из массива ссылочного типа или типа значения в <xref:System.Object> массива, <xref:System.Object> создается для хранения каждого значения или ссылки, а затем копируются. При копировании из <xref:System.Object> массива в массив ссылочного типа или типа значения, и присваивание не поддерживается, <xref:System.InvalidCastException> возникает исключение.  
  
-   Если `sourceArray` и `destinationArray` оба массива ссылочного типа или оба массива типа <xref:System.Object>, выполняется Неполная копия. Неполная копия объекта <xref:System.Array> — это новая <xref:System.Array> содержащий ссылки на те же элементы, что и исходный <xref:System.Array>. Элементы сами или что-нибудь ссылаются элементы не копируются. Напротив, глубокая копия объекта <xref:System.Array> копирует элементы и все, что прямо или косвенно ссылаются элементы.  
  
 <xref:System.ArrayTypeMismatchException> Возникает, если массивы имеют несовместимые типы. Совместимость типов определяется следующим образом:  
  
-   Тип совместим с самим собой.  
  
-   Тип значения совместим с <xref:System.Object> и с типом интерфейса, реализуемый этим типом значения. Тип значения считается подключен к интерфейсу, только в том случае, если он непосредственно реализует этот интерфейс. Отключенные типы несовместимы.  
  
-   Два встроенных (предопределенных) типа значений являются совместимыми, если копирование из исходного типа в конечный тип — расширяющего преобразования. Расширяющее преобразование никогда не данные теряются, тогда как сужающее преобразование может привести к потере информации. Например будет расширяющее преобразование, преобразование 32-разрядное целое число со знаком в 64-разрядное целое число со знаком, а преобразование 64-разрядное целое число со знаком в 32-разрядное знаковое целое число является сужающим преобразованием. Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
-   Тип значения встроенным (пользовательская) совместим только с самим собой.  
  
-   Перечисления поддерживают неявное преобразование к <xref:System.Enum> и к своему базовому типу.  
  
 Если каждый элемент массива `sourceArray` требует приведения (например, от базового класса в производный класс или из интерфейса на объект) и один или несколько элементов не может быть преобразован в соответствующий тип в `destinationArray`, <xref:System.InvalidCastException> возникает исключение.  
  
 Если этот метод вызывает исключение при копировании, состояние `destinationArray` не определено.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> — <see langword="null" />.  
  
-или- 
 <paramref name="destinationArray" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют различные ранги.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют несовместимые типы.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в <paramref name="sourceArray" /> не может быть приведен к типу <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="length" /> имеет значение меньше 0 или больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> больше числа элементов в <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="length" /> больше числа элементов в <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Массив <see cref="T:System.Array" />, содержащий данные, которые требуется скопировать.</param>
        <param name="sourceIndex">32-разрядное целое число, представляющее индекс в массиве <paramref name="sourceArray" />, с которого начинается копирование.</param>
        <param name="destinationArray">Массив <see cref="T:System.Array" />, принимающий данные.</param>
        <param name="destinationIndex">32-разрядное целое число, представляющее индекс в массиве <paramref name="destinationArray" />, с которого начинается сохранение.</param>
        <param name="length">32-битовое целое число, представляющее число копируемых элементов.</param>
        <summary>Копирует диапазон элементов из массива <see cref="T:System.Array" />, начиная с заданного индекса источника, и вставляет его в другой массив <see cref="T:System.Array" />, начиная с заданного индекса назначения. Длина и индексы задаются как 32-разрядные целые числа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` И `destinationArray` параметры должны иметь одинаковое количество измерений. Кроме того `destinationArray` должен уже был определен и должен иметь достаточное количество элементов, начиная с `destinationIndex` позицию для размещения всех скопированных данных.  
  
 При копировании между многомерные массивы, массив ведет себя как длинный одномерный массив, где строки (или столбцы) расположены последовательно end-to-end. Например если массив имеет три строки (или столбцы) с четырьмя элементами, при копировании шесть элементов с начала массива будут скопированы все четыре элемента первой строки (или столбца) и два элемента второй строки (или столбца). Чтобы начать копирование со второй элемент третьей строки (или столбца), `sourceIndex` должно быть верхнюю границу первой строки (или столбца) плюс длина второй строки (или столбца) плюс два.  
  
 Если `sourceArray` и `destinationArray` перекрываются, этот метод работает так, как если исходные значения `sourceArray` были сохранены во временном расположении перед `destinationArray` перезаписывается.  
  
 [C++]  
  
 Этот метод эквивалентен стандартной функции C/C++ `memmove`, а не `memcpy`.  
  
 Массивы могут иметь ссылочный тип или тип значения. Выполняется приведение типов, при необходимости.  
  
-   При копировании из массива ссылочного типа в массив типа значения, каждый элемент преобразуется и затем копируются. При копировании из массива типа значения ссылочного типа, каждый элемент упаковывается и затем копируются.  
  
-   При копировании из массива ссылочного типа или типа значения в <xref:System.Object> массива, <xref:System.Object> создается для хранения каждого значения или ссылки, а затем копируются. При копировании из <xref:System.Object> массива в массив ссылочного типа или типа значения, и присваивание не поддерживается, <xref:System.InvalidCastException> возникает исключение.  
  
-   Если `sourceArray` и `destinationArray` оба массива ссылочного типа или оба массива типа <xref:System.Object>, выполняется Неполная копия. Неполная копия объекта <xref:System.Array> — это новая <xref:System.Array> содержащий ссылки на те же элементы, что и исходный <xref:System.Array>. Элементы сами или что-нибудь ссылаются элементы не копируются. Напротив, глубокая копия объекта <xref:System.Array> копирует элементы и все, что прямо или косвенно ссылаются элементы.  
  
 <xref:System.ArrayTypeMismatchException> Возникает, если массивы имеют несовместимые типы. Совместимость типов определяется следующим образом:  
  
-   Тип совместим с самим собой.  
  
-   Тип значения совместим с <xref:System.Object> и с типом интерфейса, реализуемый этим типом значения. Тип значения считается подключен к интерфейсу, только в том случае, если он непосредственно реализует этот интерфейс. Отключенные типы несовместимы.  
  
-   Два встроенных (предопределенных) типа значений являются совместимыми, если копирование из исходного типа в конечный тип — расширяющего преобразования. Расширяющее преобразование никогда не данные теряются, тогда как сужающее преобразование может привести к потере информации. Например будет расширяющее преобразование, преобразование 32-разрядное целое число со знаком в 64-разрядное целое число со знаком, а преобразование 64-разрядное целое число со знаком в 32-разрядное знаковое целое число является сужающим преобразованием. Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
-   Тип значения встроенным (пользовательская) совместим только с самим собой.  
  
-   Перечисления поддерживают неявное преобразование к <xref:System.Enum> и к своему базовому типу.  
  
 Если каждый элемент массива `sourceArray` требует приведения (например, от базового класса в производный класс или из интерфейса на объект) и один или несколько элементов не может быть преобразован в соответствующий тип в `destinationArray`, <xref:System.InvalidCastException> возникает исключение.  
  
 Если этот метод вызывает исключение при копировании, состояние `destinationArray` не определено.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как скопировать текст в одном <xref:System.Array> типа <xref:System.Object> в другой <xref:System.Array> целочисленного типа.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> — <see langword="null" />.  
  
-или- 
 <paramref name="destinationArray" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют различные ранги.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют несовместимые типы.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в <paramref name="sourceArray" /> не может быть приведен к типу <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> меньше, чем нижняя граница первого измерения массива <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="destinationIndex" /> меньше, чем нижняя граница первого измерения массива <paramref name="destinationArray" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> больше числа элементов с <paramref name="sourceIndex" /> до конца <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="length" /> больше числа элементов с <paramref name="destinationIndex" /> до конца <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="sourceIndex" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationIndex" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Массив <see cref="T:System.Array" />, содержащий данные, которые требуется скопировать.</param>
        <param name="sourceIndex">64-разрядное целое число, представляющее индекс в массиве <paramref name="sourceArray" />, с которого начинается копирование.</param>
        <param name="destinationArray">Массив <see cref="T:System.Array" />, принимающий данные.</param>
        <param name="destinationIndex">64-разрядное целое число, представляющее индекс в массиве <paramref name="destinationArray" />, с которого начинается сохранение.</param>
        <param name="length">64-битовое целое число, представляющее число копируемых элементов. Целое число должно лежать в диапазоне от 0 до <see cref="F:System.Int32.MaxValue" /> включительно.</param>
        <summary>Копирует диапазон элементов из массива <see cref="T:System.Array" />, начиная с заданного индекса источника, и вставляет его в другой массив <see cref="T:System.Array" />, начиная с заданного индекса назначения. Длина и индексы задаются как 64-разрядные целые числа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` И `destinationArray` параметры должны иметь одинаковое количество измерений. Кроме того `destinationArray` должен уже был определен и должен иметь достаточное количество элементов, начиная с `destinationIndex` позицию для размещения всех скопированных данных.  
  
 При копировании между многомерные массивы, массив ведет себя как длинный одномерный массив, где строки (или столбцы) расположены последовательно end-to-end. Например если массив имеет три строки (или столбцы) с четырьмя элементами, при копировании шесть элементов с начала массива будут скопированы все четыре элемента первой строки (или столбца) и два элемента второй строки (или столбца). Чтобы начать копирование со второй элемент третьей строки (или столбца), `sourceIndex` должно быть верхнюю границу первой строки (или столбца) плюс длина второй строки (или столбца) плюс два.  
  
 Если `sourceArray` и `destinationArray` перекрываются, этот метод работает так, как если исходные значения `sourceArray` были сохранены во временном расположении перед `destinationArray` перезаписывается.  
  
 [C++]  
  
 Этот метод эквивалентен стандартной функции C/C++ `memmove`, а не `memcpy`.  
  
 Массивы могут иметь ссылочный тип или тип значения. Выполняется приведение типов, при необходимости.  
  
-   При копировании из массива ссылочного типа в массив типа значения, каждый элемент преобразуется и затем копируются. При копировании из массива типа значения ссылочного типа, каждый элемент упаковывается и затем копируются.  
  
-   При копировании из массива ссылочного типа или типа значения в <xref:System.Object> массива, <xref:System.Object> создается для хранения каждого значения или ссылки, а затем копируются. При копировании из <xref:System.Object> массива в массив ссылочного типа или типа значения, и присваивание не поддерживается, <xref:System.InvalidCastException> возникает исключение.  
  
-   Если `sourceArray` и `destinationArray` оба массива ссылочного типа или оба массива типа <xref:System.Object>, выполняется Неполная копия. Неполная копия объекта <xref:System.Array> — это новая <xref:System.Array> содержащий ссылки на те же элементы, что и исходный <xref:System.Array>. Элементы сами или что-нибудь ссылаются элементы не копируются. Напротив, глубокая копия объекта <xref:System.Array> копирует элементы и все, что прямо или косвенно ссылаются элементы.  
  
 <xref:System.ArrayTypeMismatchException> Возникает, если массивы имеют несовместимые типы. Совместимость типов определяется следующим образом:  
  
-   Тип совместим с самим собой.  
  
-   Тип значения совместим с <xref:System.Object> и с типом интерфейса, реализуемый этим типом значения. Тип значения считается подключен к интерфейсу, только в том случае, если он непосредственно реализует этот интерфейс. Отключенные типы несовместимы.  
  
-   Два встроенных (предопределенных) типа значений являются совместимыми, если копирование из исходного типа в конечный тип — расширяющего преобразования. Расширяющее преобразование никогда не данные теряются, тогда как сужающее преобразование может привести к потере информации. Например будет расширяющее преобразование, преобразование 32-разрядное целое число со знаком в 64-разрядное целое число со знаком, а преобразование 64-разрядное целое число со знаком в 32-разрядное знаковое целое число является сужающим преобразованием. Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
-   Тип значения встроенным (пользовательская) совместим только с самим собой.  
  
-   Перечисления поддерживают неявное преобразование к <xref:System.Enum> и к своему базовому типу.  
  
 Если каждый элемент массива `sourceArray` требует приведения (например, от базового класса в производный класс или из интерфейса на объект) и один или несколько элементов не может быть преобразован в соответствующий тип в `destinationArray`, <xref:System.InvalidCastException> возникает исключение.  
  
 Если этот метод вызывает исключение при копировании, состояние `destinationArray` не определено.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как скопировать текст в одном <xref:System.Array> типа <xref:System.Object> в другой <xref:System.Array> целочисленного типа.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> — <see langword="null" />.  
  
-или- 
 <paramref name="destinationArray" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют различные ранги.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> и <paramref name="destinationArray" /> имеют несовместимые типы.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в <paramref name="sourceArray" /> не может быть приведен к типу <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> находится вне диапазона допустимых индексов для <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="destinationIndex" /> находится вне диапазона допустимых индексов для <paramref name="destinationArray" />.  
  
-или- 
 Параметр <paramref name="length" /> имеет значение меньше 0 или больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> больше числа элементов с <paramref name="sourceIndex" /> до конца <paramref name="sourceArray" />.  
  
-или- 
 <paramref name="length" /> больше числа элементов с <paramref name="destinationIndex" /> до конца <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует все элементы текущего одномерного массива в заданный одномерный массив.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив, который является массивом назначения для элементов, скопированных из текущего массива.</param>
        <param name="index">32-разрядное целое число, представляющее индекс в массиве <paramref name="array" />, с которого начинается копирование.</param>
        <summary>Копирует все элементы текущего одномерного массива в заданный одномерный массив начиная с указанного индекса в массиве назначения. Индекс задается как 32-разрядное целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует все элементы текущего экземпляра массива `array` массив назначения, начиная с индекса `index`. `array` Массив назначения должен уже был определен и должен иметь достаточное количество элементов в соответствии с скопированных элементов. В противном случае метод создает исключение.  
  
 Этот метод поддерживает <xref:System.Collections.ICollection?displayProperty=nameWithType> интерфейс. Если реализация <xref:System.Collections.ICollection?displayProperty=nameWithType> является явно не требуется, используйте <xref:System.Array.Copy%2A> во избежание дополнительных косвенных обращений.  
  
 Если этот метод вызывает исключение при копировании, состояние `array` не определено.  
  
 Этот метод является операцией O (`n`) операции, где `n` является <xref:System.Array.Length%2A>. Он выполняет неполную копию.  
  
   
  
## Examples  
 В следующем примере кода показано, как скопировать <xref:System.Array> в другой <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 В следующем примере кода показано, как скопировать <xref:System.Array> в другой <xref:System.Array> с ненулевой нижней границей. Обратите внимание, что всего источника <xref:System.Array> копируется, включая пустые элементы, которые перезаписывают существующие элементы в целевом объекте <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="array" /> является многомерным.  
  
-или- 
Число элементов в исходном массиве больше доступного числа элементов от индекса <paramref name="index" /> до конца массива назначения <paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Тип исходного массива <see cref="T:System.Array" /> не может быть автоматически приведен к типу массива назначения <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Исходный массив является многомерным.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в исходном массиве <see cref="T:System.Array" /> нельзя привести к типу массива назначения <paramref name="array" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив, который является массивом назначения для элементов, скопированных из текущего массива.</param>
        <param name="index">64-разрядное целое число, представляющее индекс в массиве <paramref name="array" />, с которого начинается копирование.</param>
        <summary>Копирует все элементы текущего одномерного массива в заданный одномерный массив начиная с указанного индекса в массиве назначения. Индекс задается как 64-битовое целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует все элементы текущего экземпляра массива `array` массив назначения, начиная с индекса `index`. `array` Массив назначения должен уже был определен и должен иметь достаточное количество элементов в соответствии с скопированных элементов. В противном случае метод создает исключение.  
  
 Этот метод поддерживает <xref:System.Collections.ICollection?displayProperty=nameWithType> интерфейс. Если реализация <xref:System.Collections.ICollection?displayProperty=nameWithType> является явно не требуется, используйте <xref:System.Array.Copy%2A> во избежание дополнительных косвенных обращений.  
  
 Если этот метод вызывает исключение при копировании, состояние `array` не определено.  
  
 Этот метод является операцией O (`n`) операции, где `n` является <xref:System.Array.Length%2A>. Он выполняет неполную копию.  
  
   
  
## Examples  
 В следующем примере кода показано, как скопировать <xref:System.Array> в другой <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 В следующем примере кода показано, как скопировать <xref:System.Array> в другой <xref:System.Array> с ненулевой нижней границей. Обратите внимание, что всего источника <xref:System.Array> копируется, включая пустые элементы, которые перезаписывают существующие элементы в целевом объекте <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="array" /> является многомерным.  
  
-или- 
Число элементов в исходном массиве больше доступного числа элементов от индекса <paramref name="index" /> до конца массива назначения <paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Тип исходного массива <see cref="T:System.Array" /> не может быть автоматически приведен к типу массива назначения <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Исходный массив <see cref="T:System.Array" /> — многомерный.</exception>
        <exception cref="T:System.InvalidCastException">По меньшей мере один элемент в исходном массиве <see cref="T:System.Array" /> нельзя привести к типу массива назначения <paramref name="array" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Type" /> массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="length">Размер массива <see cref="T:System.Array" />, который необходимо создать.</param>
        <summary>Создает одномерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> и длины, индексация которого начинается с нуля.</summary>
        <returns>Новый одномерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> и длины, индексация которого начинается с нуля.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от большинства классов <xref:System.Array> предоставляет <xref:System.Array.CreateInstance%2A> метод, а не открытые конструкторы, чтобы разрешить доступа с поздней привязкой.  
  
 Элементы ссылочного типа инициализируются `null`. Элементы типа значения инициализируются нулевым значением.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать одномерный <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> не является допустимым <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="elementType" /> не поддерживается. Например, <see cref="T:System.Void" /> не поддерживается.  
  
-или- 
 <paramref name="elementType" /> представляет собой открытый универсальный тип.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="length" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Type" /> массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="lengths">Массив 32-разрядных целых чисел, представляющих размер каждого измерения массива <see cref="T:System.Array" />, который нужно создать.</param>
        <summary>Создает многомерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> с заданными длинами по измерениям и индексацией, начинающейся с нуля. Длины по измерениям задаются в массиве 32-разрядных целых чисел.</summary>
        <returns>Новый многомерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> с заданной для каждого измерения длиной и индексацией, начинающейся с нуля.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от большинства классов <xref:System.Array> предоставляет <xref:System.Array.CreateInstance%2A> метод, а не открытые конструкторы, чтобы разрешить доступа с поздней привязкой.  
  
 Число элементов в `lengths` массива должно быть равно числу измерений в новом <xref:System.Array>. Каждый элемент `lengths` массива необходимо указать длину соответствующего измерения в новом <xref:System.Array>.  
  
 Элементы ссылочного типа инициализируются `null`. Элементы типа значения инициализируются нулевым значением.  
  
 Этот метод является операцией O (`n`) операции, где `n` — это совокупность всех значений в `lengths`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать многомерный массив <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> — <see langword="null" />.  
  
-или- 
 <paramref name="lengths" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> не является допустимым <see cref="T:System.Type" />.  
  
-или- 
Массив <paramref name="lengths" /> содержит менее одного элемента.</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="elementType" /> не поддерживается. Например, <see cref="T:System.Void" /> не поддерживается.  
  
-или- 
 <paramref name="elementType" /> представляет собой открытый универсальный тип.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Любое значение в <paramref name="lengths" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lengths" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Type" /> массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="lengths">Массив 64-разрядных целых чисел, представляющих размер каждого измерения массива <see cref="T:System.Array" />, который нужно создать. Каждое целое число в массиве должно лежать в диапазоне от нуля до <see cref="F:System.Int32.MaxValue" /> включительно.</param>
        <summary>Создает многомерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> с заданными длинами по измерениям и индексацией, начинающейся с нуля. Длины по измерениям задаются в массиве 64-разрядных целых чисел.</summary>
        <returns>Новый многомерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> с заданной для каждого измерения длиной и индексацией, начинающейся с нуля.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от большинства классов <xref:System.Array> предоставляет <xref:System.Array.CreateInstance%2A> метод, а не открытые конструкторы, чтобы разрешить доступа с поздней привязкой.  
  
 Число элементов в `lengths` массива должно быть равно числу измерений в новом <xref:System.Array>. Каждый элемент `lengths` массива необходимо указать длину соответствующего измерения в новом <xref:System.Array>.  
  
 Элементы ссылочного типа инициализируются `null`. Элементы типа значения инициализируются нулевым значением.  
  
 Этот метод является операцией O (`n`) операции, где `n` — это совокупность всех значений в `lengths`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать многомерный массив <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> — <see langword="null" />.  
  
-или- 
 <paramref name="lengths" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> не является допустимым <see cref="T:System.Type" />.  
  
-или- 
Массив <paramref name="lengths" /> содержит менее одного элемента.</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="elementType" /> не поддерживается. Например, <see cref="T:System.Void" /> не поддерживается.  
  
-или- 
 <paramref name="elementType" /> представляет собой открытый универсальный тип.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Какое-либо значение массива <paramref name="lengths" /> меньше нуля или больше <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Type" /> массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="length1">Размер первого измерения массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="length2">Размер второго измерения массива <see cref="T:System.Array" />, который требуется создать.</param>
        <summary>Создает двумерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> с заданными длинами по измерениям и индексацией, начинающейся с нуля.</summary>
        <returns>Новый двумерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> с заданной для каждого измерения длиной и индексацией, начинающейся с нуля.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от большинства классов <xref:System.Array> предоставляет <xref:System.Array.CreateInstance%2A> метод, а не открытые конструкторы, чтобы разрешить доступа с поздней привязкой.  
  
 Элементы ссылочного типа инициализируются `null`. Элементы типа значения инициализируются нулевым значением.  
  
 Этот метод является операцией O (`n`) операции, где `n` — это совокупность `length1` и `length2`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать двухмерный <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> не является допустимым <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="elementType" /> не поддерживается. Например, <see cref="T:System.Void" /> не поддерживается.  
  
-или- 
 <paramref name="elementType" /> представляет собой открытый универсальный тип.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="length1" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="length2" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Type" /> массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="lengths">Одномерный массив, содержащий размер всех измерений массива <see cref="T:System.Array" />, который необходимо создать.</param>
        <param name="lowerBounds">Одномерный массив, содержащий нижние границы (начальные индексы) всех измерений массива <see cref="T:System.Array" />, который необходимо создать.</param>
        <summary>Создает многомерный массив <see cref="T:System.Array" /> с указанным типом <see cref="T:System.Type" /> и длиной по измерениям и с заданными нижними границами.</summary>
        <returns>Новый многомерный массив <see cref="T:System.Array" /> указанного типа <see cref="T:System.Type" /> с заданной длиной и нижней границей каждого измерения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от большинства классов <xref:System.Array> предоставляет <xref:System.Array.CreateInstance%2A> метод, а не открытые конструкторы, чтобы разрешить доступа с поздней привязкой.  
  
 `lengths` И `lowerBounds` массивы должны иметь одинаковое количество элементов. Число элементов в `lengths` массива должно быть равно числу измерений в новом <xref:System.Array>.  
  
 Каждый элемент `lengths` массива необходимо указать длину соответствующего измерения в новом <xref:System.Array>.  
  
 Каждый элемент `lowerBounds` массива необходимо указать значение нижней границы соответствующего измерения в новом <xref:System.Array>. Как правило библиотеки классов .NET Framework и многие языки программирования не обрабатывают ненулевых значений нижних границ.  
  
 Элементы ссылочного типа инициализируются `null`. Элементы типа значения инициализируются нулевым значением.  
  
 Этот метод является операцией O (`n`) операции, где `n` — это совокупность всех значений в `lengths`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать многомерный массив <xref:System.Array> с заданными нижними границами.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> — <see langword="null" />.  
  
-или- 
 <paramref name="lengths" /> — <see langword="null" />.  
  
-или- 
 <paramref name="lowerBounds" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> не является допустимым <see cref="T:System.Type" />.  
  
-или- 
Массив <paramref name="lengths" /> содержит менее одного элемента.  
  
-или- 
Массивы <paramref name="lengths" /> и <paramref name="lowerBounds" /> содержат разное число элементов.</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="elementType" /> не поддерживается. Например, <see cref="T:System.Void" /> не поддерживается.  
  
-или- 
 <paramref name="elementType" /> представляет собой открытый универсальный тип.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Любое значение в <paramref name="lengths" /> меньше нуля.  
  
-или- 
Какое-либо значение в <paramref name="lowerBounds" /> очень велико, вследствие чего сумма нижней границы измерения и длины превышает значение <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Type" /> массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="length1">Размер первого измерения массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="length2">Размер второго измерения массива <see cref="T:System.Array" />, который требуется создать.</param>
        <param name="length3">Размер третьего измерения массива <see cref="T:System.Array" />, который требуется создать.</param>
        <summary>Создает трехмерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> с заданными длинами по измерениям и индексацией, начинающейся с нуля.</summary>
        <returns>Новый трехмерный массив <see cref="T:System.Array" /> заданного типа <see cref="T:System.Type" /> с заданной для каждого измерения длиной и индексацией, начинающейся с нуля.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от большинства классов <xref:System.Array> предоставляет <xref:System.Array.CreateInstance%2A> метод, а не открытые конструкторы, чтобы разрешить доступа с поздней привязкой.  
  
 Элементы ссылочного типа инициализируются `null`. Элементы типа значения инициализируются нулевым значением.  
  
 Этот метод является операцией O (`n`) операции, где `n` — это совокупность `length1`, `length2`, и `length3`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать трехмерный массив <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> не является допустимым <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">Тип <paramref name="elementType" /> не поддерживается. Например, <see cref="T:System.Void" /> не поддерживается.  
  
-или- 
 <paramref name="elementType" /> представляет собой открытый универсальный тип.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="length1" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="length2" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="length3" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <summary>Возвращает пустой массив.</summary>
        <returns>Пустой массив.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элементов.</param>
        <summary>Определяет, содержит ли заданный массив элементы, удовлетворяющие условиям указанного предиката.</summary>
        <returns>Значение <see langword="true" />, если массив <paramref name="array" /> содержит один или несколько элементов, удовлетворяющих условиям указанного предиката; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Делегат для метода, который возвращает `true` если переданный объект соответствует условиям, определенным в делегате.  Элементы `array` передаются по отдельности <xref:System.Predicate%601>, и обработка прекращается при обнаружении совпадения.  
  
> [!NOTE]
>  В C# и Visual Basic, нет необходимости создавать <xref:System.Predicate%601> делегировать явным образом. Эти языки нужный делегат из контекста определяется и создается автоматически.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере задается условия совпадения для <xref:System.Array.Exists%2A> метода с помощью лямбда-выражения проверить, начинается ли планеты с указанную букву или ли планете находится в заданном массиве.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 В следующем примере используется <xref:System.Array.Exists%2A> метод для указания ли все имена в массиве строк начинаются с указанного символа. В примере создается экземпляр `StringSearcher` объекта, передав строку для поиска, чтобы его конструктор. `StringSearcher.StartsWith` Метод имеет такую же сигнатуру, как <xref:System.Predicate%601> делегировать. Когда <xref:System.Array.Exists%2A> вызывается метод, каждый элемент массива передается делегату, пока не будет возвращено `true` или выполняет итерацию всех элементов в массиве.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 Можно также использовать лямбда-выражения вместо явно определить метод, сигнатура которого соответствует к списку делегата. В следующем примере заменяется `StringSearcher` класса и его `StartsWith` метод с лямбда-выражения.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="match" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Лямбда-выражения (Руководство по программированию в C#)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">Лямбда-выражения (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Индексируемый от нуля одномерный массив, в котором выполняется поиск.</param>
        <param name="match">Предикат, определяющий условия элемента, который требуется найти.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает первое найденное вхождение в пределах всего списка <see cref="T:System.Array" />.</summary>
        <returns>Первый элемент, удовлетворяющий условиям указанного предиката, если такой элемент найден; в противном случае — значение по умолчанию для типа <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Делегат для метода или лямбда-выражение, возвращающее `true` если переданный объект соответствует условиям, определенным в делегат или лямбда-выражении.  Элементы `array` передаются по отдельности <xref:System.Predicate%601>, начиная с первого элемента и заканчивая последним элементом.  Обработка прекращается при обнаружении совпадения.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Predicate%601> делегат со <xref:System.Array.Find%2A> универсальный метод для поиска массив <xref:System.Drawing.Point> структуры. Представляет делегат, метод `ProductGT10`, возвращает `true` Если произведение поля X и Y больше 100 000. <xref:System.Array.Find%2A> Вызывает делегат для каждого элемента массива, возвращая первую точку, удовлетворяет условию теста.  
  
> [!NOTE]
>  Visual Basic и C# пользователей нет необходимости явно создайте делегат или укажите аргумент типа универсального метода. Компиляторы определяют необходимые типы на основе аргументов метода, который вы указали.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Вместо явного определения метода с необходимой сигнатурой, создание экземпляров <xref:System.Predicate%601> делегат и передает делегат, который <xref:System.Array.Find%2A> метод, обычно лямбда-выражение. Следующий пример идентичен предыдущему, за исключением того, что она использует лямбда-выражение как `match` аргумент.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="match" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элементов.</param>
        <summary>Извлекает все элементы, удовлетворяющие условиям указанного предиката.</summary>
        <returns>Массив <see cref="T:System.Array" />, содержащий все элементы, удовлетворяющие условиям указанного предиката, если такие элементы найдены; в противном случае — пустой массив <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Делегат для метода, который возвращает `true` если переданный объект соответствует условиям, определенным в делегате.  Элементы `array` передаются по отдельности <xref:System.Predicate%601>, и элементы, удовлетворяющие условиям, сохраняются в возвращенном массиве.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере создается массив из 50 случайных чисел со значениями, которые могут варьироваться от 0 до 1000. Затем он вызывает <xref:System.Array.FindAll%2A> метод с лямбда-выражения и возвращает значения этого диапазона от 300 до 600. Обратите внимание, что лямбда-выражение передается параметр с именем `x`;  Представляет отдельные массива, передаваемое <xref:System.Predicate%601>. Также Обратите внимание, что локальный `lBound` и `uBound` переменные доступны внутри лямбда-выражения.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 В следующем примере кода показано <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, и <xref:System.Array.FindAll%2A> универсальных методов. Создается массив строк, содержащий 8 имена динозавров, два из которых (в позициях, 1 и 5) и заканчиваться на «saurus». В примере также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, является ли входная строка заканчивается на «saurus».  
  
 <xref:System.Array.Find%2A> Универсального метода проходит через массив с самого начала, передавая каждый элемент по очереди к `EndsWithSaurus` метод. Поиск останавливается, когда `EndsWithSaurus` возвращает метод `true` для элемента «Amargasaurus».  
  
> [!NOTE]
>  В C# и Visual Basic, нет необходимости создавать `Predicate<string>` делегировать (`Predicate(Of String)` в Visual Basic) явным образом. Эти языки нужный делегат из контекста определяется и создается автоматически.  
  
 <xref:System.Array.FindLast%2A> Универсальный метод используется для поиска назад от конца массива. Он находит элемент «Dilophosaurus» в позиции 5. <xref:System.Array.FindAll%2A> Универсальный метод позволяет вернуть массив, содержащий все элементы, которые заканчиваются на «saurus». Элементы отображаются.  
  
 В примере также показано <xref:System.Array.Exists%2A> и <xref:System.Array.TrueForAll%2A> универсальных методов.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="match" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого найденного вхождения в пределах массива <see cref="T:System.Array" /> или его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого найденного вхождения в пределах всего списка <see cref="T:System.Array" />.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента, отвечающего условиям предиката <paramref name="match" />, если такой элемент найден. В противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Выполняется поиск вперед, начиная с первого элемента и заканчивая последним элементом.  
  
 <xref:System.Predicate%601> Делегат для метода, который возвращает `true` если переданный объект соответствует условиям, определенным в делегате.  Элементы `array` передаются по отдельности <xref:System.Predicate%601>.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируются все три перегрузки <xref:System.Array.FindIndex%2A> универсального метода. Создается массив строк, содержащий 8 имена динозавров, два из которых (в позициях, 1 и 5) и заканчиваться на «saurus». В примере также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, является ли входная строка заканчивается на «saurus».  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Перегрузку метода проходит через массив с самого начала, передавая каждый элемент по очереди к `EndsWithSaurus` метод. Поиск останавливается, когда `EndsWithSaurus` возвращает метод `true` для элемента в позиции 1.  
  
> [!NOTE]
>  В C# и Visual Basic, нет необходимости создавать `Predicate<string>` делегировать (`Predicate(Of String)` в Visual Basic) явным образом. Эти языки нужный делегат из контекста определяется и создается автоматически.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Перегруженный метод используется для поиска массив, начиная с позиции 2 и до конца массива. Он находит элемент в позиции 5. Наконец <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> перегруженный метод используется для поиска диапазон из трех элементов, начиная с позиции 2. Возвращается значение -1, так как имена динозавров в этом диапазоне, которые заканчиваются на «saurus».  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="match" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Array" />, начиная с заданного индекса и заканчивая последним элементом.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента, отвечающего условиям предиката <paramref name="match" />, если такой элемент найден. В противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Выполняется от в `startIndex` и заканчивая последним элементом.  
  
 <xref:System.Predicate%601> Делегат для метода, который возвращает `true` если переданный объект соответствует условиям, определенным в делегате.  Элементы `array` передаются по отдельности <xref:System.Predicate%601>.  
  
 Этот метод является операцией O (`n`) операции, где `n` — количество элементов из `startIndex` в конец `array`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируются все три перегрузки <xref:System.Array.FindIndex%2A> универсального метода. Создается массив строк, содержащий 8 имена динозавров, два из которых (в позициях, 1 и 5) и заканчиваться на «saurus». В примере также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, является ли входная строка заканчивается на «saurus».  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Перегрузку метода проходит через массив с самого начала, передавая каждый элемент по очереди к `EndsWithSaurus` метод. Поиск останавливается, когда `EndsWithSaurus` возвращает метод `true` для элемента в позиции 1.  
  
> [!NOTE]
>  В C# и Visual Basic, нет необходимости создавать `Predicate<string>` делегировать (`Predicate(Of String)` в Visual Basic) явным образом. Эти языки нужный делегат из контекста определяется и создается автоматически.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Перегруженный метод используется для поиска массив, начиная с позиции 2 и до конца массива. Он находит элемент в позиции 5. Наконец <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> перегруженный метод используется для поиска диапазон из трех элементов, начиная с позиции 2. Возвращается значение -1, так как имена динозавров в этом диапазоне, которые заканчиваются на «saurus».  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="match" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Array" />, начинающемся с заданного индекса и содержащем указанное число элементов.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента, отвечающего условиям предиката <paramref name="match" />, если такой элемент найден. В противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Выполняется от в `startIndex` и заканчивая `startIndex` , а также `count` минус 1, если `count` больше 0.  
  
 <xref:System.Predicate%601> Делегат для метода, который возвращает `true` если переданный объект соответствует условиям, определенным в делегате.  Элементы `array` передаются по отдельности <xref:System.Predicate%601>.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `count`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируются все три перегрузки <xref:System.Array.FindIndex%2A> универсального метода. Создается массив строк, содержащий 8 имена динозавров, два из которых (в позициях, 1 и 5) и заканчиваться на «saurus». В примере также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, является ли входная строка заканчивается на «saurus».  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Перегрузку метода проходит через массив с самого начала, передавая каждый элемент по очереди к `EndsWithSaurus` метод. Поиск останавливается, когда `EndsWithSaurus` возвращает метод `true` для элемента в позиции 1.  
  
> [!NOTE]
>  В C# и Visual Basic, нет необходимости создавать `Predicate<string>` делегировать (`Predicate(Of String)` в Visual Basic) явным образом. Эти языки нужный делегат из контекста определяется и создается автоматически.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Перегруженный метод используется для поиска массив, начиная с позиции 2 и до конца массива. Он находит элемент в позиции 5. Наконец <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> перегруженный метод используется для поиска диапазон из трех элементов, начиная с позиции 2. Возвращается значение -1, так как имена динозавров в этом диапазоне, которые заканчиваются на «saurus».  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="match" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает последнее найденное вхождение в пределах всего списка <see cref="T:System.Array" />.</summary>
        <returns>Последний элемент, удовлетворяющий условиям указанного предиката, если такой элемент найден; в противном случае — значение по умолчанию для типа <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Делегат для метода, который возвращает `true` если переданный объект соответствует условиям, определенным в делегате.  Элементы `array` передаются по отдельности <xref:System.Predicate%601>, перемещение назад в <xref:System.Array>, начиная с последнего элемента и заканчивая первого элемента.  Обработка прекращается при обнаружении совпадения.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, и <xref:System.Array.FindAll%2A> универсальных методов. Создается массив строк, содержащий 8 имена динозавров, два из которых (в позициях, 1 и 5) и заканчиваться на «saurus». В примере также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, является ли входная строка заканчивается на «saurus».  
  
 <xref:System.Array.Find%2A> Универсального метода проходит через массив с самого начала, передавая каждый элемент по очереди к `EndsWithSaurus` метод. Поиск останавливается, когда `EndsWithSaurus` возвращает метод `true` для элемента «Amargasaurus».  
  
> [!NOTE]
>  В C# и Visual Basic, нет необходимости создавать`Predicate<string>` делегировать (`Predicate(Of String)` в Visual Basic) явным образом. Эти языки нужный делегат из контекста определяется и создается автоматически.  
  
 <xref:System.Array.FindLast%2A> Универсальный метод используется для поиска назад от конца массива. Он находит элемент «Dilophosaurus» в позиции 5. <xref:System.Array.FindAll%2A> Универсальный метод позволяет вернуть массив, содержащий все элементы, которые заканчиваются на «saurus». Элементы отображаются.  
  
 В примере также показано <xref:System.Array.Exists%2A> и <xref:System.Array.TrueForAll%2A> универсальных методов.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="match" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего найденного вхождения в пределах всего массива <see cref="T:System.Array" /> или его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего найденного вхождения в пределах всего списка <see cref="T:System.Array" />.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Осуществляется в обратном направлении, начиная с последнего элемента и заканчивается на первый элемент.  
  
 <xref:System.Predicate%601> Делегат для метода, который возвращает `true` если переданный объект соответствует условиям, определенным в делегате.  Элементы `array` передаются по отдельности <xref:System.Predicate%601>.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируются все три перегрузки <xref:System.Array.FindLastIndex%2A> универсального метода. Создается массив строк, содержащий 8 имена динозавров, два из которых (в позициях, 1 и 5) и заканчиваться на «saurus». В примере также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, является ли входная строка заканчивается на «saurus».  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Перегрузку метода проходит через обратной массива с конца, передавая каждый элемент по очереди к `EndsWithSaurus` метод. Поиск останавливается, когда `EndsWithSaurus` возвращает метод `true` для элемента в позиции 5.  
  
> [!NOTE]
>  В C# и Visual Basic, нет необходимости создавать `Predicate<string>` делегировать (`Predicate(Of String)` в Visual Basic) явным образом. Эти языки нужный делегат из контекста определяется и создается автоматически.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Перегруженный метод используется для поиска массив, начиная с позиции 4 и обратном направлении до первого элемента массива. Он находит элемент в позиции 1. Наконец <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> перегруженный метод используется для поиска в диапазоне трех элементов, начиная с позиции 4 и далее в обратном направлении (то есть элементы 2, 3 и 4). Возвращается значение -1, так как имена динозавров в этом диапазоне, которые заканчиваются на «saurus».  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="match" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Array" />, начиная с первого элемента и заканчивая элементом с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Поиска в обратном направлении от `startIndex` и заканчивается на первый элемент.  
  
 <xref:System.Predicate%601> Делегат для метода, который возвращает `true` если переданный объект соответствует условиям, определенным в делегате.  Элементы `array` передаются по отдельности <xref:System.Predicate%601>.  
  
 Этот метод является операцией O (`n`) операции, где `n` — количество элементов в начале `array` для `startIndex`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируются все три перегрузки <xref:System.Array.FindLastIndex%2A> универсального метода. Создается массив строк, содержащий 8 имена динозавров, два из которых (в позициях, 1 и 5) и заканчиваться на «saurus». В примере также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, является ли входная строка заканчивается на «saurus».  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Перегрузку метода проходит через обратной массива с конца, передавая каждый элемент по очереди к `EndsWithSaurus` метод. Поиск останавливается, когда `EndsWithSaurus` возвращает метод `true` для элемента в позиции 5.  
  
> [!NOTE]
>  В C# и Visual Basic, нет необходимости создавать `Predicate<string>` делегировать (`Predicate(Of String)` в Visual Basic) явным образом. Эти языки нужный делегат из контекста определяется и создается автоматически.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Перегруженный метод используется для поиска массив, начиная с позиции 4 и обратном направлении до первого элемента массива. Он находит элемент в позиции 1. Наконец <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> перегруженный метод используется для поиска в диапазоне трех элементов, начиная с позиции 4 и далее в обратном направлении (то есть элементы 2, 3 и 4). Возвращается значение -1, так как имена динозавров в этом диапазоне, которые заканчиваются на «saurus».  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="match" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <param name="match">Объект <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Array" />, содержащем указанное число элементов и заканчивающемся элементом с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Поиска в обратном направлении от `startIndex` и заканчивая `startIndex` минус `count` плюс 1, если `count` больше 0.  
  
 <xref:System.Predicate%601> Делегат для метода, который возвращает `true` если переданный объект соответствует условиям, определенным в делегате.  Элементы `array` передаются по отдельности <xref:System.Predicate%601>.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `count`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируются все три перегрузки <xref:System.Array.FindLastIndex%2A> универсального метода. Создается массив строк, содержащий 8 имена динозавров, два из которых (в позициях, 1 и 5) и заканчиваться на «saurus». В примере также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение, указывающее, является ли входная строка заканчивается на «saurus».  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Перегрузку метода проходит через обратной массива с конца, передавая каждый элемент по очереди к `EndsWithSaurus` метод. Поиск останавливается, когда `EndsWithSaurus` возвращает метод `true` для элемента в позиции 5.  
  
> [!NOTE]
>  В C# и Visual Basic, нет необходимости создавать `Predicate<string>` делегировать (`Predicate(Of String)` в Visual Basic) явным образом. Эти языки нужный делегат из контекста определяется и создается автоматически.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Перегруженный метод используется для поиска массив, начиная с позиции 4 и обратном направлении до первого элемента массива. Он находит элемент в позиции 1. Наконец <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> перегруженный метод используется для поиска в диапазоне трех элементов, начиная с позиции 4 и далее в обратном направлении (то есть элементы 2, 3 и 4). Возвращается значение -1, так как имена динозавров в этом диапазоне, которые заканчиваются на «saurus».  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="match" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля, и для элементов которого нужно выполнить данное действие.</param>
        <param name="action">Делегат <see cref="T:System.Action`1" />, выполняемый для каждого элемента массива <paramref name="array" />.</param>
        <summary>Выполняет указанное действие с каждым элементом указанного массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> Делегат для метода, который выполняет действие объекта передается в него.  Элементы `array` передаются по отдельности <xref:System.Action%601>.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Array.ForEach%2A> для отображения квадратов каждый элемент массива целых чисел.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="action" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель <see cref="T:System.Collections.IEnumerator" /> для словаря <see cref="T:System.Array" />.</summary>
        <returns>Интерфейс <see cref="T:System.Collections.IEnumerator" /> для <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 `foreach` Инструкции языка C# (`for each` в C++, `For Each` в Visual Basic) скрывает сложность перечислителей. Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. Метод <xref:System.Collections.IEnumerator.Reset%2A> также переводит перечислитель в эту позицию.  В этой позиции значение свойства <xref:System.Collections.IEnumerator.Current%2A> не определено. Поэтому необходимо вызвать метод <xref:System.Collections.IEnumerator.MoveNext%2A>, чтобы переместить перечислитель к первому элементу коллекции до считывания значения свойства <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> возвращает тот же объект, пока не будет вызван метод <xref:System.Collections.IEnumerator.MoveNext%2A> или <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> задает <xref:System.Collections.IEnumerator.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.IEnumerator.MoveNext%2A> передает в конец коллекции, перечислитель помещается за последним элементом в коллекции и <xref:System.Collections.IEnumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.IEnumerator.MoveNext%2A> также возвращать `false`. Если последний вызов <xref:System.Collections.IEnumerator.MoveNext%2A> возвращается `false`, <xref:System.Collections.IEnumerator.Current%2A> не определено. Чтобы снова задать в качестве значения свойства <xref:System.Collections.IEnumerator.Current%2A> первый элемент коллекции, можно последовательно вызвать методы <xref:System.Collections.IEnumerator.Reset%2A> и<xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если в коллекцию вносятся изменения, например добавляются, изменяются или удаляются элементы, перечислитель становится недействительным без возможности восстановление, а его поведение не определено.  
  
 Перечислитель не имеет монопольного доступа к коллекции, поэтому перечисление элементов коллекции само по себе не является потокобезопасной процедурой.  Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Array.GetEnumerator%2A> указывать элементы массива.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Измерение массива <see cref="T:System.Array" />, индексация которого начинается с нуля, и для которого необходимо определить длину.</param>
        <summary>Получает 32-разрядное целое число, представляющее количество элементов в заданном измерении массива <see cref="T:System.Array" />.</summary>
        <returns>32-разрядное целое число, представляющее количество элементов в заданном измерении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пример <xref:System.Array.GetLength%2A> — `GetLength(0)`, который возвращает количество элементов в первом измерении <xref:System.Array>.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Array.GetLength%2A> для отображения размеры двух массивов с использованием разных рангов.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="dimension" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="dimension" /> больше или равно значению свойства <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="dimension">Измерение массива <see cref="T:System.Array" />, индексация которого начинается с нуля, и для которого необходимо определить длину.</param>
        <summary>Возвращает 64-разрядное целое число, представляющее количество элементов в заданном измерении массива <see cref="T:System.Array" />.</summary>
        <returns>64-разрядное целое число, представляющее количество элементов в заданном измерении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пример <xref:System.Array.GetLongLength%2A> — `GetLongLength(0)`, который возвращает количество элементов в первом измерении <xref:System.Array>.  
  
 Этот метод является операцией o(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="dimension" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="dimension" /> больше или равно значению свойства <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Измерение массива основанное на нуле, для которого необходимо определить индекс начала.</param>
        <summary>Получает Индекс первого элемента заданного измерения в массиве.</summary>
        <returns>Индекс первого элемента заданного измерения в массиве.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` Возвращает начальный индекс в первом измерении массива, и `GetLowerBound(Rank - 1)` Возвращает начальный индекс последнего измерения массива.  
  
 <xref:System.Array.GetLowerBound%2A> Метод всегда возвращает значение, указывающее индекс нижней границы массива, даже если массив пуст.  
  
 Обратите внимание, что, несмотря на то, что большинство массивы в .NET Framework отсчитываются от нуля (то есть <xref:System.Array.GetLowerBound%2A> метод возвращает нулевое значение для каждого измерения массива), .NET Framework поддерживает массивы с индексацией не от нуля. Такие массивы могут создаваться с помощью <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> метод и также может быть получен из неуправляемого кода.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> методы для отображения границы одномерного массива и двухмерный массив и отобразить значения элементов массива.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="dimension" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="dimension" /> больше или равно значению свойства <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Измерение массива, индексация которого начинается с нуля, и для которого необходимо определить верхнюю границу.</param>
        <summary>Получает Индекс последнего элемента заданного измерения в массиве.</summary>
        <returns>Индекс последнего элемента указанного измерения в массиве, или -1, если определенное измерение пусто.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` Возвращает последний индекс в первом измерении массива, и `GetUpperBound(Rank - 1)` возвращает последний индекс последнего измерения массива.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Array.GetLowerBound%2A> и <xref:System.Array.GetUpperBound%2A> методы для отображения границы одномерного массива и двухмерный массив и отобразить значения элементов массива.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="dimension" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="dimension" /> больше или равно значению свойства <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает значение заданного элемента в текущем массиве <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="index">32-разрядное целое, представляющее позицию получаемого элемента в массиве <see cref="T:System.Array" />.</param>
        <summary>Получает значение, хранящееся в указанной позиции одномерного массива <see cref="T:System.Array" />. Индекс задается как 32-разрядное целое число.</summary>
        <returns>Значение, хранящееся в указанной позиции одномерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли значение `index` выходит за границы.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Размерность текущего массива <see cref="T:System.Array" /> не равна единице.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="index" /> находится вне диапазона допустимых индексов текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Одномерный массив 32-разрядных целых чисел, представляющий индексы, которые задают позицию получаемого элемента в массиве <see cref="T:System.Array" />.</param>
        <summary>Получает значение, хранящееся в указанной позиции многомерного массива <see cref="T:System.Array" />. Индексы задаются как массив 32-разрядных целых чисел.</summary>
        <returns>Значение, хранящееся в указанной позиции многомерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Число элементов в `indices` должно быть равно числу измерений в <xref:System.Array>. Все элементы в `indices` массива задают положение необходимого элемента в многомерном <xref:System.Array>.  
  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли любой из индексов выходит за границы.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Размерность текущего массива <see cref="T:System.Array" /> не равна числу элементов в параметре <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Какой-либо элемент в параметре <paramref name="indices" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">64-разрядное целое число, представляющее позицию возвращаемого элемента <see cref="T:System.Array" />.</param>
        <summary>Получает значение, хранящееся в указанной позиции одномерного массива <see cref="T:System.Array" />. Индекс задается как 64-битовое целое число.</summary>
        <returns>Значение, хранящееся в указанной позиции одномерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли значение `index` выходит за границы.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Размерность текущего массива <see cref="T:System.Array" /> не равна единице.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> находится вне диапазона допустимых индексов текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Одномерный массив 64-разрядных целых чисел, представляющих индексы, которые определяют позицию возвращаемого элемента <see cref="T:System.Array" />.</param>
        <summary>Получает значение, хранящееся в указанной позиции многомерного массива <see cref="T:System.Array" />. Индексы задаются как массив 64-разрядных целых чисел.</summary>
        <returns>Значение, хранящееся в указанной позиции многомерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Число элементов в `indices` должно быть равно числу измерений в <xref:System.Array>. Все элементы в `indices` массива задают положение необходимого элемента в многомерном <xref:System.Array>.  
  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли любой из индексов выходит за границы.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Размерность текущего массива <see cref="T:System.Array" /> не равна числу элементов в параметре <paramref name="indices" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Какой-либо элемент в параметре <paramref name="indices" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">32-разрядное целое число, представляющее индекс получаемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">32-разрядное целое число, представляющее индекс получаемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <summary>Получает значение в заданной позиции двухмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 32-разрядных целых чисел.</summary>
        <returns>Значение, хранящееся в указанной позиции двумерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли любой из индексов выходит за границы.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Число измерений текущего массива <see cref="T:System.Array" /> не равно двум.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="index1" /> или <paramref name="index2" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">64-разрядное целое число, представляющее индекс возвращаемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">64-разрядное целое число, представляющее индекс возвращаемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <summary>Получает значение в заданной позиции двухмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 64-разрядных целых чисел.</summary>
        <returns>Значение, хранящееся в указанной позиции двумерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли любой из индексов выходит за границы.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Число измерений текущего массива <see cref="T:System.Array" /> не равно двум.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index1" /> или <paramref name="index2" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">32-разрядное целое число, представляющее индекс получаемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">32-разрядное целое число, представляющее индекс получаемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <param name="index3">32-разрядное целое число, представляющее индекс получаемого элемента в третьем измерении массива <see cref="T:System.Array" />.</param>
        <summary>Получает значение, хранящееся в указанной позиции трехмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 32-разрядных целых чисел.</summary>
        <returns>Значение, хранящееся в указанной позиции трехмерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли любой из индексов выходит за границы.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Число измерений текущего массива <see cref="T:System.Array" /> не равно трем.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="index1" />, <paramref name="index2" /> или <paramref name="index3" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">64-разрядное целое число, представляющее индекс возвращаемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">64-разрядное целое число, представляющее индекс возвращаемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <param name="index3">64-разрядное целое число, представляющее индекс возвращаемого элемента в третьем измерении массива <see cref="T:System.Array" />.</param>
        <summary>Получает значение, хранящееся в указанной позиции трехмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 64-разрядных целых чисел.</summary>
        <returns>Значение, хранящееся в указанной позиции трехмерного массива <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли любой из индексов выходит за границы.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Число измерений текущего массива <see cref="T:System.Array" /> не равно трем.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index1" />, <paramref name="index2" /> или <paramref name="index3" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск указанного объекта и возвращает индекс первого найденного совпадения в одномерном массиве или диапазоне элементов массива.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив для поиска.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <summary>Выполняет поиск указанного объекта внутри всего одномерного массива и возвращает индекс его первого вхождения.</summary>
        <returns>Индекс первого вхождения <paramref name="value" /> в массиве <paramref name="array" />, если найден. В противном случае — нижняя граница массива минус 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск всех элементов одномерного массива для `value`. Чтобы определить ли `value` существует в `array`, метод выполняет сравнения на равенство, вызвав каждый элемент `Equals` метод, пока не найдет совпадение. Это означает, что если элемент переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> вызывается метод, что переопределение.  
  
 Так как большинство массивы имеют нижнюю границу, равную нулю, этот метод обычно возвращает -1, если`value` не найден. В тех редких случаях, нижняя граница массива равен <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) и `value` не найден, этот метод возвращает <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В примере вызывается следующие три перегрузки <xref:System.Array.IndexOf%2A> способ поиска индекс строки в массиве строк:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, чтобы определить, первого вхождения строки «» в массиве строк.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, чтобы определить, первого вхождения строки «» в четвертый — на последние элементы массива строк.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, чтобы определить, первого вхождения строки «» в строке массива из элемента после последнего успешного сопоставления в конец массива.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив для поиска.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Начальный индекс поиска. Значение 0 (ноль) действительно в пустом массиве.</param>
        <summary>Выполняет поиск указанного объекта в диапазоне элементов одномерного массива и возвращает индекс первого найденного совпадения. Диапазон начинается с указанного индекса и заканчивается концом массива.</summary>
        <returns>Индекс первого вхождения значения <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, начинающемся с элемента с индексом <paramref name="startIndex" /> и заканчивающемся последним элементом, если значение найдено; в противном случае нижняя граница массива минус 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод осуществляет одномерный массив из элемента по индексу `startIndex` на последний элемент. Чтобы определить ли `value` существует в `array`, метод выполняет сравнения на равенство, вызвав `Equals` метод каждого элемента, пока не найдет совпадение. Это означает, что если элемент переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> вызывается метод, что переопределение.  
  
 Так как большинство массивы имеют нижнюю границу, равную нулю, этот метод обычно возвращает -1, если `value` не найден. В тех редких случаях, нижняя граница массива равен <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) и `value` не найден, этот метод возвращает <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Если `startIndex` равно <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод возвращает значение -1. Если `startIndex` больше, чем <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод вызывает <xref:System.ArgumentOutOfRangeException>.  
  
 Этот метод является операцией O (`n`) операции, где `n` — количество элементов из `startIndex` в конец `array`.  
  
   
  
## Examples  
 В примере вызывается следующие три перегрузки <xref:System.Array.IndexOf%2A> способ поиска индекс строки в массиве строк:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, чтобы определить, первого вхождения строки «» в массиве строк.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, чтобы определить, первого вхождения строки «» в четвертый — на последние элементы массива строк.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, чтобы определить, первого вхождения строки «» в строке массива из элемента после последнего успешного сопоставления в конец массива.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив для поиска.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Начальный индекс поиска. Значение 0 (ноль) действительно в пустом массиве.</param>
        <param name="count">Число искомых элементов.</param>
        <summary>Выполняет поиск указанного объекта в диапазоне элементов одномерного массива и возвращает индекс первого найденного совпадения. Диапазон расширяется от указанного индекса заданного числа элементов.</summary>
        <returns>Индекс первого вхождения значения <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, начинающемся с индекса <paramref name="startIndex" /> и заканчивающемся элементом с индексом <paramref name="startIndex" /> + <paramref name="count" /> — 1, если значение найдено. В противном случае нижняя граница массива минус 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск элементов одномерного массива из `startIndex` для `startIndex` , а также `count` минус 1, если `count` больше 0. Чтобы определить ли `value` существует в `array`, метод выполняет сравнения на равенство, вызвав `Equals` метод каждого элемента, пока не найдет совпадение. Это означает, что если элемент переопределяет <xref:System.Object.Equals%2A?displayProperty=nameWithType> вызывается метод, что переопределение.  
  
 Поскольку большинство массивы имеют нижнюю границу, равную нулю, этот метод обычно возвращает – 1, если `value` не найден. В тех редких случаях, нижняя граница массива равен <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) и `value` не найден, этот метод возвращает <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Если `startindex` равно <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод возвращает значение -1. Если `startIndex` больше, чем <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод вызывает <xref:System.ArgumentOutOfRangeException>.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `count`.  
  
   
  
## Examples  
 В примере вызывается следующие три перегрузки <xref:System.Array.IndexOf%2A> способ поиска индекс строки в массиве строк:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, чтобы определить, первого вхождения строки «» в массиве строк.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, чтобы определить, первого вхождения строки «» в четвертый — на последние элементы массива строк.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, чтобы определить, первого вхождения строки «» в строке массива из элемента после последнего успешного сопоставления в конец массива. Чтобы определить значение `count` аргумент, он вычитает верхнюю границу массива из начального индекса и добавляет единицу.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Индексируемый от нуля одномерный массив, в котором выполняется поиск.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <summary>Выполняет поиск указанного объекта внутри всего одномерного массива и возвращает индекс его первого вхождения.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения объекта <paramref name="value" /> во всем массиве <paramref name="array" />; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск всех элементов одномерного массива для `value`. Чтобы определить ли `value` существует в `array`, метод выполняет сравнения на равенство, вызвав `T.Equals` метод для каждого элемента. Это означает, что если `T` переопределяет <xref:System.Object.Equals%2A> вызывается метод, что переопределение.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере показано все три универсальные перегрузки <xref:System.Array.IndexOf%2A> метод. Массив строк, создается с одной записью, повторяющейся дважды — по индексу 0 и 5. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Перегрузка метода выполняет поиск от начала массива и находит первое вхождение строки. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Перегруженный метод используется для поиска в массив, начиная с индексом 3 и до конца массива и находит второе вхождение строки. Наконец <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> перегруженный метод используется для поиска диапазон две записи, начиная с индекса расположение двух; возвращается значение -1, так как отсутствуют экземпляры строки поиска в этом диапазоне.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Индексируемый от нуля одномерный массив, в котором выполняется поиск.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска. Значение 0 (ноль) действительно в пустом массиве.</param>
        <summary>Выполняет поиск указанного объекта в диапазоне элементов одномерного массива и возвращает индекс первого найденного совпадения. Диапазон начинается с указанного индекса и заканчивается концом массива.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента <paramref name="value" /> в диапазоне элементов списка <paramref name="array" />, начиная с позиции <paramref name="startIndex" /> и до конца списка, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод осуществляет одномерный массив из элемента в `startIndex` в конец массива. Чтобы определить ли `value` существует в `array`, метод выполняет сравнения на равенство, вызвав `T.Equals` метод для каждого элемента. Это означает, что если `T` переопределяет <xref:System.Object.Equals%2A> вызывается метод, что переопределение.  
  
 Если `startIndex` равно <xref:System.Array.Length%2A>, метод возвращает - 1.If `startIndex` больше, чем <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод вызывает <xref:System.ArgumentOutOfRangeException>.  
  
 Этот метод является операцией O (`n`) операции, где `n` — количество элементов из `startIndex` в конец `array`.  
  
   
  
## Examples  
 В следующем примере показано все три универсальные перегрузки <xref:System.Array.IndexOf%2A> метод. Массив строк, создается с одной записью, повторяющейся дважды — по индексу 0 и 5. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Перегрузка метода выполняет поиск от начала массива и находит первое вхождение строки. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Перегруженный метод используется для поиска в массив, начиная с индексом 3 и до конца массива и находит второе вхождение строки. Наконец <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> перегруженный метод используется для поиска диапазон две записи, начиная с индекса расположение двух; возвращается значение -1, так как отсутствуют экземпляры строки поиска в этом диапазоне.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Индексируемый от нуля одномерный массив, в котором выполняется поиск.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска. Значение 0 (ноль) действительно в пустом массиве.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <summary>Выполняет поиск указанного объекта в диапазоне элементов одномерного массива и возвращает индекс первого найденного совпадения. Диапазон расширяется от указанного индекса заданного числа элементов.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, который начинается с позиции <paramref name="startIndex" /> и содержит количество элементов, указанное в <paramref name="count" />, если искомый объект найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск элементов одномерного массива из `startIndex` для `startIndex` , а также `count` минус 1, если `count` больше 0. Чтобы определить ли `value` существует в `array`, метод выполняет сравнения на равенство, вызвав `T.Equals` метод для каждого элемента. Это означает, что если `T` переопределяет <xref:System.Object.Equals%2A> вызывается метод, что переопределение.  
  
 Если `startIndex` равно <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод возвращает значение -1.  Если `startIndex` больше, чем <xref:System.Array.Length%2A?displayProperty=nameWithType>, метод вызывает <xref:System.ArgumentOutOfRangeException>.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `count`.  
  
   
  
## Examples  
 В следующем примере показано все три универсальные перегрузки <xref:System.Array.IndexOf%2A> метод. Массив строк, создается с одной записью, повторяющейся дважды — по индексу 0 и 5. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Перегрузка метода выполняет поиск от начала массива и находит первое вхождение строки. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Перегруженный метод используется для поиска в массив, начиная с индексом 3 и до конца массива и находит второе вхождение строки. Наконец <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> перегруженный метод используется для поиска диапазон две записи, начиная с индекса расположение двух; возвращается значение -1, так как отсутствуют экземпляры строки поиска в этом диапазоне.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует каждый элемент массива <see cref="T:System.Array" /> типа значения путем вызова конструктора по умолчанию для типа значений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для компиляторов, которые поддерживает массивы типа значения; Большинство пользователей не обязательно этот метод. Он не должен использоваться на ссылочный тип.  
  
 Если <xref:System.Array> не является типом значения <xref:System.Array> или если тип значения не имеет конструктор по умолчанию, <xref:System.Array> не изменяется.  
  
 Тип значения <xref:System.Array> может иметь любую нижнюю границу и любое количество измерений.  
  
 Этот метод является операцией O (`n`) операции, где `n` является <xref:System.Array.Length%2A>.  
  
> [!CAUTION]
>  Этот метод можно использовать только для типов значений, которые имеют конструкторы; Тем не менее типы значений, которые являются собственными для C# нет конструкторов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, имеет ли список <see cref="T:System.Array" /> фиксированный размер.</summary>
        <value>Данное свойство для всех массивов всегда имеет значение <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> реализует <xref:System.Array.IsFixedSize%2A> свойство так, как он необходим для <xref:System.Collections.IList?displayProperty=nameWithType> интерфейс.  
  
 Массив фиксированного размера не поддерживает добавление или удаление элементов после создания массива, но разрешается изменять существующие элементы.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли объект <see cref="T:System.Array" /> доступным только для чтения.</summary>
        <value>Данное свойство для всех массивов всегда имеет значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> реализует <xref:System.Array.IsReadOnly%2A> свойство так, как он необходим для <xref:System.Collections.IList?displayProperty=nameWithType> интерфейс. Массив, который доступен только для чтения не поддерживает добавление, изменение или удаление элементов после создания массива.  
  
 Если требуется только для чтения коллекция, используйте <xref:System.Collections> класс, реализующий <xref:System.Collections.IList?displayProperty=nameWithType> интерфейс.  
  
 Если приведение или преобразование массива <xref:System.Collections.IList> объект интерфейса <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> возвращает `false`. Тем не менее если приведение или преобразование массива <xref:System.Collections.Generic.IList%601> интерфейс, `IsReadOnly` возвращает `true`.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, является ли доступ к коллекции <see cref="T:System.Array" /> синхронизированным (потокобезопасным).</summary>
        <value>Данное свойство для всех массивов всегда имеет значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> реализует <xref:System.Array.IsSynchronized%2A> свойство так, как он необходим для <xref:System.Collections.ICollection?displayProperty=nameWithType> интерфейс.  
  
 На основе классов .NET framework <xref:System.Array> предоставить собственную синхронизированную версию коллекции с помощью <xref:System.Array.SyncRoot%2A> свойство.  
  
 Классы, использующие массивы также можно реализовать собственные синхронизации с помощью <xref:System.Array.SyncRoot%2A> свойство. Синхронизированный код должен выполнять операции над `SyncRoot` коллекции, не над самой коллекцией. Это обеспечивает правильную работу коллекций, являющихся производными других объектов. В частности это обеспечивает правильную синхронизацию с другими потоками, которые могут одновременно вносить изменения коллекции. Обратите внимание, что в некоторых реализациях <xref:System.Array.SyncRoot%2A> могут возвращать <xref:System.Array> сам.  
  
 Перечисление коллекции само по себе не является потокобезопасной процедурой. Даже если коллекция синхронизирована, другие потоки могут ее изменить, что приведет к тому, что перечислитель создаст исключение. Для обеспечения потокобезопасности при перечислении можно либо заблокировать коллекцию на все время перечисления, либо перехватывать исключения, возникающие в результате изменений, внесенных другими потоками.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как заблокировать массив на все время перечисления с помощью <xref:System.Array.SyncRoot%2A> свойство.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает индекс последнего вхождения значения в одномерном массиве <see cref="T:System.Array" /> или в части массива <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> для поиска.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <summary>Выполняет поиск заданного объекта и возвращает индекс его последнего вхождения внутри всего одномерного массива <see cref="T:System.Array" />.</summary>
        <returns>Индекс последнего вхождения значения <paramref name="value" /> во всем массиве <paramref name="array" />, если значение найдено; в противном случае — нижняя граница массива минус 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Одномерный массив <xref:System.Array> осуществляется в обратном направлении, начиная с последнего элемента и заканчивается на первый элемент.  
  
 Сравнение элементов с указанным значением с помощью <xref:System.Object.Equals%2A?displayProperty=nameWithType> метод. Если тип элемента не является встроенным (пользовательская), `Equals` используется реализация этого типа.  
  
 Поскольку большинство массивов нижней границей, равной нулю, этот метод обычно возвращает – 1, если `value` не найден. В тех редких случаях, нижняя граница массива равен <xref:System.Int32.MinValue?displayProperty=nameWithType> и `value` не найден, этот метод возвращает <xref:System.Int32.MaxValue?displayProperty=nameWithType>, который является `System.Int32.MinValue - 1`.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
 В платформе .NET Framework версии 2.0 этот метод использует <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы <xref:System.Array> для определения ли <xref:System.Object> определяется `value` параметр существует. В более ранних версиях платформы .NET Framework, такое определение осуществлялось с помощью <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы `value` <xref:System.Object> сам.  
  
 <xref:System.IComparable.CompareTo%2A> методы `item` параметр для объектов в коллекции.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить индекс последнего вхождения указанного элемента в массиве.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> для поиска.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Начальный индекс обратного поиска.</param>
        <summary>Выполняет поиск указанного объекта и возвращает индекс его последнего вхождения в диапазоне элементов одномерного массива <see cref="T:System.Array" />, начинающемся с первого элемента и заканчивающемся элементом с заданным индексом.</summary>
        <returns>Индекс последнего вхождения значения <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, начинающемся с первого элемента и заканчивающемся элементом с индексом <paramref name="startIndex" />, если объект найден; в противном случае — нижняя граница массива минус 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Одномерный массив <xref:System.Array> поиска в обратном направлении от `startIndex` и заканчивается на первый элемент.  
  
 Сравнение элементов с указанным значением с помощью <xref:System.Object.Equals%2A?displayProperty=nameWithType> метод. Если тип элемента не является встроенным (пользовательская), `Equals` используется реализация этого типа.  
  
 Поскольку большинство массивов нижней границей, равной нулю, этот метод обычно возвращает – 1, если `value` не найден. В тех редких случаях, нижняя граница массива равен <xref:System.Int32.MinValue?displayProperty=nameWithType> и `value` не найден, этот метод возвращает <xref:System.Int32.MaxValue?displayProperty=nameWithType>, который является `System.Int32.MinValue - 1`.  
  
 Этот метод является операцией O (`n`) операции, где `n` — количество элементов в начале `array` для `startIndex`.  
  
 В платформе .NET Framework версии 2.0 этот метод использует <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы <xref:System.Array> для определения ли <xref:System.Object> определяется `value` параметр существует. В более ранних версиях платформы .NET Framework, такое определение осуществлялось с помощью <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы `value` <xref:System.Object> сам.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить индекс последнего вхождения указанного элемента в массиве.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> для поиска.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Начальный индекс обратного поиска.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <summary>Выполняет поиск указанного объекта и возвращает индекс последнего вхождения в диапазоне элементов одномерного массива <see cref="T:System.Array" />, содержащем указанное число элементов и заканчивающемся элементом с заданным индексом.</summary>
        <returns>Индекс последнего вхождения значения <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, содержащем число элементов, заданных в параметре <paramref name="count" />, и заканчивающемся элементом с индексом <paramref name="startIndex" />, если объект найден; в противном случае — нижняя граница массива минус 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Одномерный массив <xref:System.Array> поиска в обратном направлении от `startIndex` и заканчивая `startIndex` минус `count` плюс 1, если `count` больше 0.  
  
 Сравнение элементов с указанным значением с помощью <xref:System.Object.Equals%2A?displayProperty=nameWithType> метод. Если тип элемента не является встроенным (пользовательская),`Equals` используется реализация этого типа.  
  
 Поскольку большинство массивов нижней границей, равной нулю, этот метод обычно возвращает – 1, если `value` не найден. В тех редких случаях, нижняя граница массива равен <xref:System.Int32.MinValue?displayProperty=nameWithType> и `value` не найден, этот метод возвращает <xref:System.Int32.MaxValue?displayProperty=nameWithType>, который является `System.Int32.MinValue - 1`.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `count`.  
  
 В платформе .NET Framework версии 2.0 этот метод использует <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы <xref:System.Array> для определения ли <xref:System.Object> определяется `value` параметр существует. В более ранних версиях платформы .NET Framework, такое определение осуществлялось с помощью <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы `value` <xref:System.Object> сам.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить индекс последнего вхождения указанного элемента в массиве. Обратите внимание, что <xref:System.Array.LastIndexOf%2A> метод является поиска в обратном направлении; поэтому `count` должно быть меньше или равно (`startIndex` минус нижняя граница массива плюс 1).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <summary>Выполняет поиск указанного объекта и возвращает индекс последнего вхождения во всем массиве <see cref="T:System.Array" />.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения <paramref name="value" /> в пределах всего массива <paramref name="array" />, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Осуществляется в обратном направлении, начиная с последнего элемента и заканчивается на первый элемент.  
  
 Сравнение элементов с указанным значением с помощью <xref:System.Object.Equals%2A?displayProperty=nameWithType> метод. Если тип элемента не является встроенным (пользовательская), `Equals` используется реализация этого типа.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируются все три универсальные перегрузки <xref:System.Array.LastIndexOf%2A> метод. Массив строк, создается с одной записью, повторяющейся дважды — по индексу 0 и 5. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Перегрузку метода, выполняет весь массив с конца и обнаруживается второе вхождение строки. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Перегруженный метод используется для поиска назад массив, начиная с индексом 3 и до первого элемента массива и находит первое вхождение строки. Наконец <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> перегруженный метод используется для поиска диапазон четыре записи, начиная с расположением индекса 4 и расширение назад (то есть выполняется поиск элементов в расположениях, 4, 3, 2 и 1); поиск возвращает -1, так как отсутствуют экземпляры поиска Строка в этом диапазоне.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <summary>Выполняет поиск указанного объекта и возвращает индекс последнего вхождения в диапазоне элементов массива <see cref="T:System.Array" />, начиная с первого элемента и заканчивая элементом с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, начиная с первого элемента и до позиции <paramref name="startIndex" />, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Поиска в обратном направлении от `startIndex` и заканчивается на первый элемент.  
  
 Сравнение элементов с указанным значением с помощью <xref:System.Object.Equals%2A?displayProperty=nameWithType> метод. Если тип элемента не является встроенным (пользовательская), `Equals` используется реализация этого типа.  
  
 Этот метод является операцией O (`n`) операции, где `n` — количество элементов в начале `array` для `startIndex`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируются все три универсальные перегрузки <xref:System.Array.LastIndexOf%2A> метод. Массив строк, создается с одной записью, повторяющейся дважды — по индексу 0 и 5. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Перегрузку метода, выполняет весь массив с конца и обнаруживается второе вхождение строки. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Перегруженный метод используется для поиска назад массив, начиная с индексом 3 и до первого элемента массива и находит первое вхождение строки. Наконец <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> перегруженный метод используется для поиска диапазон четыре записи, начиная с расположением индекса 4 и расширение назад (то есть выполняется поиск элементов в расположениях, 4, 3, 2 и 1); поиск возвращает -1, так как отсутствуют экземпляры поиска Строка в этом диапазоне.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля и в котором нужно выполнить поиск.</param>
        <param name="value">Объект, который требуется найти в <paramref name="array" />.</param>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <summary>Выполняет поиск указанного объекта и возвращает индекс последнего вхождения в диапазоне элементов массива <see cref="T:System.Array" />, содержащем указанное число элементов и заканчивающемся в позиции с указанным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения <paramref name="value" /> в диапазоне элементов массива <paramref name="array" />, состоящем из элементов, заданных в <paramref name="count" />, и заканчивающемся в позиции <paramref name="startIndex" />, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Поиска в обратном направлении от `startIndex` и заканчивая `startIndex` минус `count` плюс 1, если `count` больше 0.  
  
 Сравнение элементов с указанным значением с помощью <xref:System.Object.Equals%2A?displayProperty=nameWithType> метод. Если тип элемента не является встроенным (пользовательская), `Equals` используется реализация этого типа.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `count`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируются все три универсальные перегрузки <xref:System.Array.LastIndexOf%2A> метод. Массив строк, создается с одной записью, повторяющейся дважды — по индексу 0 и 5. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Перегрузку метода, выполняет весь массив с конца и обнаруживается второе вхождение строки. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Перегруженный метод используется для поиска назад массив, начиная с индексом 3 и до первого элемента массива и находит первое вхождение строки. Наконец <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> перегруженный метод используется для поиска диапазон четыре записи, начиная с расположением индекса 4 и расширение назад (то есть выполняется поиск элементов в расположениях, 4, 3, 2 и 1); поиск возвращает -1, так как отсутствуют экземпляры поиска Строка в этом диапазоне.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает общее число элементов во всех измерениях массива <see cref="T:System.Array" />.</summary>
        <value>Общее число элементов во всех измерениях массива <see cref="T:System.Array" />; ноль, если в массиве нет элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Array.Length%2A> свойство, чтобы получить общее число элементов в массиве. Он также использует <xref:System.Array.GetUpperBound%2A> метод, чтобы определить количество элементов в каждом измерении многомерного массива.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Массив является многомерным и содержит более <see cref="F:System.Int32.MaxValue" /> элементов.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает 64-разрядное целое число, представляющее общее число элементов во всех измерениях массива <see cref="T:System.Array" />.</summary>
        <value>64-разрядное целое число, представляющее общее число элементов во всех измерениях массива <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает ранг (размерность) объекта <see cref="T:System.Array" />. Например, одномерный массив возвращает 1, двухмерный массив возвращает 2 и т д</summary>
        <value>Ранг (размерность) объекта <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например код Visual Basic  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 и код на C#  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 Создайте массив из трех измерений с <xref:System.Array.Rank%2A> свойство, значение которого равно 3.  
  
 Массив массивов (массив массивов) является одномерным массивом. значение его <xref:System.Array.Rank%2A> свойства является 1.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 Следующий пример инициализирует одномерный массив, двумерный массив и массив массивов, а также извлекает <xref:System.Array.Rank%2A> каждого элемента.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="newSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Подлежащий изменению размера одномерный массив, индексация которого начинается с нуля, или значение <see langword="null" /> для создания нового массива заданного размера.</param>
        <param name="newSize">Размер нового массива.</param>
        <summary>Изменяет количество элементов в одномерном массиве до указанной величины.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выделяет новый массив с указанным размером, копирует элементы из старого массива в новый и затем заменяет старый массив новым. `array` должен быть одномерным массивом.  
  
 Если `array` является `null`, этот метод создает новый массив с указанным размером.  
  
 Если `newSize` больше, чем <xref:System.Array.Length%2A> старого массива, выделяется новый массив и все элементы копируются из старого массива в новый.  Если `newSize` — меньше, чем <xref:System.Array.Length%2A> старого массива, выделяется новый массив и элементы копируются из старого массива в новую, пока не будет заполнено новым; остальные элементы старого массива учитываются.  Если `newSize` равен <xref:System.Array.Length%2A> старого массива, этот метод не выполняет никаких действий.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `newSize`.  
  
 <xref:System.Array.Resize%2A> Метод изменяет размер только одномерного массива. <xref:System.Array> Класс не поддерживает метод для изменения размеров многомерных массивов. Чтобы сделать это, необходимо предоставить собственный код или вызвать метод специального назначения в стороннюю библиотеку. Следующий код иллюстрирует один из возможных вариантов реализации для метода, который изменяет размер массива *n* измерений.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 Следующий пример показывает, как изменение размера влияет на массив.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="newSize" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Изменяет порядок элементов в одномерном массиве <see cref="T:System.Array" /> или в части массива <see cref="T:System.Array" /> на обратный.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, порядок элементов которого нужно изменить на обратный.</param>
        <summary>Изменяет порядок элементов во всем одномерном массиве <see cref="T:System.Array" /> на обратный.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После вызова этого метода, элемент в `myArray[i]`, где `i` — любой индекс в массиве, перемещает `myArray[j]`, где `j` равно `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
 Как показано в следующем примере, <xref:System.Array.Reverse%2A> метод может использоваться для отмены массив массивов. Он инициализирует массив массивов с одним элементом для каждого месяца года в календаре текущего языка и региональных параметров. Каждый элемент содержит массив с столько элементов, сколько дней имеет этот месяц. В примере отображается содержимое массива, вызовы <xref:System.Array.Reverse%2A> метод, а затем отображает содержимое Обращенный массив.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 В следующем примере кода показано, как порядок сортировки значений в <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, порядок элементов которого нужно изменить на обратный.</param>
        <param name="index">Начальный индекс той части массива, порядок элементов которой необходимо изменить на обратный.</param>
        <param name="length">Число элементов в части массива, порядок которых нужно изменить на обратный.</param>
        <summary>Изменяет последовательность элементов в диапазоне элементов одномерного массива <see cref="T:System.Array" /> на обратную.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После вызова этого метода, элемент в `myArray[i]`, где `i` — любой индекс в массиве, перемещает `myArray[j]`, где `j` равно `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 <xref:System.Array.Reverse%2A> Метод может использоваться для отмены массив массивов.  
  
 Этот метод является операцией O (`n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как порядок сортировки значений в диапазоне элементов списка <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Присваивает заданному элементу текущего массива <see cref="T:System.Array" /> заданное значение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="index">32-разрядное целое число, представляющее позицию элемента в массиве <see cref="T:System.Array" />, для которого требуется установить значение.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции одномерного массива <see cref="T:System.Array" />. Индекс задается как 32-разрядное целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли значение `index` выходит за границы.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией o(1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` к элементу массива типов значений, все поля элемента инициализируются нулевым значением. Значение элемента не является указателем null и не удается найти, выполнив поиск ссылкой на null.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Размерность текущего массива <see cref="T:System.Array" /> не равна единице.</exception>
        <exception cref="T:System.InvalidCastException">Значение <paramref name="value" /> не удается привести к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="index" /> находится вне диапазона допустимых индексов текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="indices">Одномерный массив 32-разрядных целых чисел, представляющий индексы, которые задают позицию задаваемого элемента в массиве.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции многомерного массива <see cref="T:System.Array" />. Индексы задаются как массив 32-разрядных целых чисел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Число элементов в `indices` должно быть равно числу измерений в <xref:System.Array>. Все элементы в `indices` массива задают положение необходимого элемента в многомерном <xref:System.Array>.  
  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методы можно выяснить, какие значения в `indices` массива выходит за границы.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией o(1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` к элементу массива типов значений, все поля элемента инициализируются нулевым значением. Значение элемента не является указателем null и не удается найти, выполнив поиск ссылкой на null.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Размерность текущего массива <see cref="T:System.Array" /> не равна числу элементов в параметре <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">Значение <paramref name="value" /> не удается привести к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Какой-либо элемент в параметре <paramref name="indices" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="index">64-разрядное целое число, представляющее позицию элемента в массиве <see cref="T:System.Array" />, для которого требуется установить значение.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции одномерного массива <see cref="T:System.Array" />. Индекс задается как 64-битовое целое число.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли значение `index` выходит за границы.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией o(1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` к элементу массива типов значений, все поля элемента инициализируются нулевым значением. Значение элемента не является указателем null и не удается найти, выполнив поиск ссылкой на null.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Размерность текущего массива <see cref="T:System.Array" /> не равна единице.</exception>
        <exception cref="T:System.InvalidCastException">Значение <paramref name="value" /> не удается привести к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> находится вне диапазона допустимых индексов текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indices" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="indices">Одномерный массив 64-разрядных целых чисел, представляющий индексы, которые указывают позицию задаваемого элемента в массиве.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции многомерного массива <see cref="T:System.Array" />. Индексы задаются как массив 64-разрядных целых чисел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Число элементов в `indices` должно быть равно числу измерений в <xref:System.Array>. Все элементы в `indices` массива задают положение необходимого элемента в многомерном <xref:System.Array>.  
  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методы можно выяснить, какие значения в `indices` массива выходит за границы.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией o(1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` к элементу массива типов значений, все поля элемента инициализируются нулевым значением. Значение элемента не является указателем null и не удается найти, выполнив поиск ссылкой на null.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Размерность текущего массива <see cref="T:System.Array" /> не равна числу элементов в параметре <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">Значение <paramref name="value" /> не удается привести к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Какой-либо элемент в параметре <paramref name="indices" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="index1">32-разрядное целое число, представляющее индекс задаваемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">32-разрядное целое число, представляющее индекс задаваемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции двухмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 32-разрядных целых чисел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли любой из индексов выходит за границы.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией o(1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` к элементу массива типов значений, все поля элемента инициализируются нулевым значением. Значение элемента не является указателем null и не удается найти, выполнив поиск ссылкой на null.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Число измерений текущего массива <see cref="T:System.Array" /> не равно двум.</exception>
        <exception cref="T:System.InvalidCastException">Значение <paramref name="value" /> не удается привести к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="index1" /> или <paramref name="index2" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="index1">64-разрядное целое число, представляющее индекс задаваемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">64-разрядное целое число, представляющее индекс задаваемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции двухмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 64-разрядных целых чисел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли любой из индексов выходит за границы.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией o(1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` к элементу массива типов значений, все поля элемента инициализируются нулевым значением. Значение элемента не является указателем null и не удается найти, выполнив поиск ссылкой на null.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Число измерений текущего массива <see cref="T:System.Array" /> не равно двум.</exception>
        <exception cref="T:System.InvalidCastException">Значение <paramref name="value" /> не удается привести к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index1" /> или <paramref name="index2" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="index1">32-разрядное целое число, представляющее индекс задаваемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">32-разрядное целое число, представляющее индекс задаваемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <param name="index3">32-разрядное целое число, представляющее индекс задаваемого элемента в третьем измерении массива <see cref="T:System.Array" />.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции трехмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 32-разрядных целых чисел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли любой из индексов выходит за границы.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией o(1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` к элементу массива типов значений, все поля элемента инициализируются нулевым значением. Значение элемента не является указателем null и не удается найти, выполнив поиск ссылкой на null.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Число измерений текущего массива <see cref="T:System.Array" /> не равно трем.</exception>
        <exception cref="T:System.InvalidCastException">Значение <paramref name="value" /> не удается привести к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Значение параметра <paramref name="index1" />, <paramref name="index2" /> или <paramref name="index3" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Новое значение указанного элемента.</param>
        <param name="index1">64-разрядное целое число, представляющее индекс задаваемого элемента в первом измерении массива <see cref="T:System.Array" />.</param>
        <param name="index2">64-разрядное целое число, представляющее индекс задаваемого элемента во втором измерении массива <see cref="T:System.Array" />.</param>
        <param name="index3">64-разрядное целое число, представляющее индекс задаваемого элемента в третьем измерении массива <see cref="T:System.Array" />.</param>
        <summary>Присваивает значение элементу, находящемуся в указанной позиции трехмерного массива <see cref="T:System.Array" />. Индексы задаются в виде 64-разрядных целых чисел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> И <xref:System.Array.GetUpperBound%2A> методов можно определить, является ли любой из индексов выходит за границы.  
  
 Дополнительные сведения о преобразованиях см. в разделе <xref:System.Convert>.  
  
 Этот метод является операцией o(1).  
  
> [!NOTE]
>  Если <xref:System.Array.SetValue%2A> используется для назначения `null` к элементу массива типов значений, все поля элемента инициализируются нулевым значением. Значение элемента не является указателем null и не удается найти, выполнив поиск ссылкой на null.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить конкретное значение в одномерный или многомерный массив.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Число измерений текущего массива <see cref="T:System.Array" /> не равно трем.</exception>
        <exception cref="T:System.InvalidCastException">Значение <paramref name="value" /> не удается привести к типу элемента текущего массива <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index1" />, <paramref name="index2" /> или <paramref name="index3" /> находится вне диапазона допустимых индексов для соответствующего измерения текущего массива <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сортирует элементы в одномерном массиве.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> для сортировки.</param>
        <summary>Сортирует элементы во всем одномерном массиве <see cref="T:System.Array" />, используя реализацию интерфейса <see cref="T:System.IComparable" /> каждого элемента массива <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый элемент `array` должен реализовывать <xref:System.IComparable> интерфейс, чтобы можно было сравнивать с любым другим элементом в `array`.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода показано, как сортировать значения в <xref:System.Array> с помощью функции сравнения по умолчанию и пользовательского модуля сравнения, который изменяет порядок сортировки. Обратите внимание, что результат может изменяться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в массиве <paramref name="array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Одномерный массив <see cref="T:System.Array" />, который содержит элементы, соответствующие ключам в массиве <see cref="T:System.Array" /><paramref name="keys" />.  
  
-или- 
 Значение <see langword="null" /> для сортировки только массива <see cref="T:System.Array" /><paramref name="keys" />.</param>
        <summary>Сортирует пару одномерных объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя реализацию интерфейса <see cref="T:System.IComparable" /> каждого ключа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys` <xref:System.Array> имеет соответствующий элемент `items` <xref:System.Array>. При изменении положения ключ во время сортировки, соответствующий элемент в `items` <xref:System.Array> аналогичным образом перемещен. Таким образом `items` <xref:System.Array> сортируется в соответствии с расположение соответствующих ключей в `keys` <xref:System.Array>.  
  
 Каждый ключ в `keys` <xref:System.Array> должен реализовывать <xref:System.IComparable> интерфейс, чтобы можно было сравнивать с любым другим ключом.  
  
 Сортировка в случае, если существует больше элементов, чем ключи, но не будут удалены элементы, которых нет соответствующих ключей. Нельзя выполнить сортировку при наличии нескольких ключей, чем элементы; в этом случае создается это <xref:System.ArgumentException>.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` — <xref:System.Array.Length%2A> из `keys`.  
  
   
  
## Examples  
 Приведенный ниже показано, как отсортировать два связанных между, где первый массив содержит ключи, а второй массив содержит значения. Сортировка выполняется с помощью функции сравнения по умолчанию и пользовательского модуля сравнения, который изменяет порядок сортировки. Обратите внимание, что результат может изменяться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="keys" /><see cref="T:System.Array" /> является многомерным.  
  
-или- 
Массив <paramref name="items" /><see cref="T:System.Array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="items" /> не равно <see langword="null" />, и длина параметра <paramref name="keys" /> больше длины параметра <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в массиве <paramref name="keys" /><see cref="T:System.Array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив для сортировки.</param>
        <param name="comparer">Реализация интерфейса, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Сортирует элементы в одномерном массиве <see cref="T:System.Array" />, используя заданный интерфейс <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` — `null`, каждый элемент `array` должен реализовывать <xref:System.IComparable> интерфейс, чтобы можно было сравнивать с любым другим элементом в `array`.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
 .NET Framework включает предопределенные <xref:System.Collections.IComparer> реализаций, перечисленные в следующей таблице.  
  
|Реализация|Описание|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Сравнивает любые два объекта, но выполняет сравнение без учета регистра строк.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Сравнивает любые два объекта с помощью соглашений сортировки текущего языка и региональных параметров.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Сравнивает любые два объекта с помощью правил сортировки инвариантного языка и региональных параметров.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Сравнивает два объекта типа `T` , используя порядок сортировки по умолчанию для этого типа.|  
  
 Можно также поддерживать пользовательских вариантов сравнения путем предоставления собственного экземпляра <xref:System.Collections.IComparer> реализацию `comparer` параметра. В примере это выполняется путем определения `ReverseComparer` класс, который изменяет порядок сортировки по умолчанию для экземпляров типа и выполняет сравнение строк без учета регистра.  
  
   
  
## Examples  
 Следующий пример сортирует значения в массиве строк, используя компаратор по умолчанию. Он также определяет пользовательский <xref:System.Collections.IComparer> реализацию, именуемую `ReverseComparer` , обращает порядок сортировки по умолчанию объекта при выполнении сравнения строк без учета регистра. Обратите внимание, что выходные данные могут отличаться в зависимости от текущего языка и региональных параметров.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.InvalidOperationException">Значение параметра <paramref name="comparer" /> — <see langword="null" />, а один или несколько элементов в параметре <paramref name="array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.ArgumentException">Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 и более ранних версий используется только алгоритм Quicksort. QuickSort идентифицирует недопустимое функции сравнения, в некоторых ситуациях, в которых вызывает операции сортировки <see cref="T:System.IndexOutOfRangeException" /> исключения и генерирует <see cref="T:System.ArgumentException" /> исключение вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, что операции сортировки, ранее вызвал <see cref="T:System.ArgumentException" /> не вызовет исключение, так как алгоритмы сортировки и heapsort вставки не обнаруживают компаратор недопустимый. В основном это относится к массивы с менее чем 16 элементов.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Одномерный массив <see cref="T:System.Array" />, который содержит элементы, соответствующие ключам в массиве <see cref="T:System.Array" /><paramref name="keys" />.  
  
-или- 
 Значение <see langword="null" /> для сортировки только массива <see cref="T:System.Array" /><paramref name="keys" />.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Сортирует пару одномерных объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя заданный интерфейс <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys` <xref:System.Array> имеет соответствующий элемент `items` <xref:System.Array>. При изменении положения ключ во время сортировки, соответствующий элемент в `items` <xref:System.Array> аналогичным образом перемещен. Таким образом `items` <xref:System.Array> сортируется в соответствии с расположение соответствующих ключей в `keys` <xref:System.Array>.  
  
 Если `comparer` — `null`, каждый ключ в `keys` <xref:System.Array> должен реализовывать <xref:System.IComparable> интерфейс, чтобы можно было сравнивать с любым другим ключом.  
  
 Сортировка в случае, если существует больше элементов, чем ключи, но не будут удалены элементы, которых нет соответствующих ключей. Нельзя выполнить сортировку при наличии нескольких ключей, чем элементы; в этом случае создается это <xref:System.ArgumentException>.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 .NET Framework включает предопределенные <xref:System.Collections.IComparer> реализаций, перечисленные в следующей таблице.  
  
|Реализация|Описание|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Сравнивает любые два объекта, но выполняет сравнение без учета регистра строк.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Сравнивает любые два объекта с помощью соглашений сортировки текущего языка и региональных параметров.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Сравнивает любые два объекта с помощью правил сортировки инвариантного языка и региональных параметров.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Сравнивает два объекта типа `T` , используя порядок сортировки по умолчанию для этого типа.|  
  
 Можно также поддерживать пользовательских вариантов сравнения путем предоставления собственного экземпляра <xref:System.Collections.IComparer> реализацию `comparer` параметра. В примере это выполняется путем определения <xref:System.Collections.IComparer> реализация, которая изменяет порядок сортировки по умолчанию и выполняет сравнение строк без учета регистра.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` — <xref:System.Array.Length%2A> из `keys`.  
  
   
  
## Examples  
 Приведенный ниже показано, как отсортировать два связанных между, где первый массив содержит ключи, а второй массив содержит значения. Сортировка выполняется с помощью функции сравнения по умолчанию и пользовательского модуля сравнения, который изменяет порядок сортировки. Обратите внимание, что результат может изменяться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="keys" /><see cref="T:System.Array" /> является многомерным.  
  
-или- 
Массив <paramref name="items" /><see cref="T:System.Array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="items" /> не равно <see langword="null" />, и длина параметра <paramref name="keys" /> больше длины параметра <paramref name="items" />.  
  
-или- 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException">Значение параметра <paramref name="comparer" /> — <see langword="null" />, а один или несколько элементов в параметре <paramref name="keys" /><see cref="T:System.Array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 и более ранних версий используется только алгоритм Quicksort. QuickSort идентифицирует недопустимое функции сравнения, в некоторых ситуациях, в которых вызывает операции сортировки <see cref="T:System.IndexOutOfRangeException" /> исключения и генерирует <see cref="T:System.ArgumentException" /> исключение вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, что операции сортировки, ранее вызвал <see cref="T:System.ArgumentException" /> не вызовет исключение, так как алгоритмы сортировки и heapsort вставки не обнаруживают компаратор недопустимый. В основном это относится к массивы с менее чем 16 элементов.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> для сортировки.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <summary>Сортирует элементы в диапазоне элементов одномерного массива <see cref="T:System.Array" /> с помощью реализации интерфейса <see cref="T:System.IComparable" /> каждого элемента массива <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый элемент в указанном диапазоне элементов списка `array` должен реализовывать <xref:System.IComparable> интерфейс, чтобы можно было сравнивать с любым другим элементом в `array`.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как сортировать значения в <xref:System.Array> с помощью функции сравнения по умолчанию и пользовательского модуля сравнения, который изменяет порядок сортировки. Обратите внимание, что результат может изменяться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в массиве <paramref name="array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Одномерный массив <see cref="T:System.Array" />, который содержит элементы, соответствующие ключам в массиве <see cref="T:System.Array" /><paramref name="keys" />.  
  
-или- 
 Значение <see langword="null" /> для сортировки только массива <see cref="T:System.Array" /><paramref name="keys" />.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <summary>Сортирует диапазон элементов в паре одномерных объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя реализацию интерфейса <see cref="T:System.IComparable" /> каждого ключа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys` <xref:System.Array> имеет соответствующий элемент `items` <xref:System.Array>. При изменении положения ключ во время сортировки, соответствующий элемент в `items` <xref:System.Array> аналогичным образом перемещен. Таким образом `items` <xref:System.Array> сортируется в соответствии с расположение соответствующих ключей в `keys` <xref:System.Array>.  
  
 Каждый ключ в указанном диапазоне элементов списка `keys` <xref:System.Array> должен реализовывать <xref:System.IComparable> интерфейс, чтобы можно было сравнивать с любым другим ключом.  
  
 Сортировка в случае, если существует больше элементов, чем ключи, но не будут удалены элементы, которых нет соответствующих ключей. Нельзя выполнить сортировку при наличии нескольких ключей, чем элементы; в этом случае создается это <xref:System.ArgumentException>.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как отсортировать два связанных между, где первый массив содержит ключи, а второй массив содержит значения. Сортировка выполняется с помощью функции сравнения по умолчанию и пользовательского модуля сравнения, который изменяет порядок сортировки. Обратите внимание, что результат может изменяться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="keys" /><see cref="T:System.Array" /> является многомерным.  
  
-или- 
Массив <paramref name="items" /><see cref="T:System.Array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="keys" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="items" /> не равно <see langword="null" />, и длина параметра <paramref name="keys" /> больше длины параметра <paramref name="items" />.  
  
-или- 
 <paramref name="index" /> и <paramref name="length" /> не определяют допустимый диапазон в <paramref name="keys" /><see cref="T:System.Array" />.  
  
-или- 
 Значение параметра <paramref name="items" /> не равно <see langword="null" />, а параметры <paramref name="index" /> и <paramref name="length" /> не определяют допустимый диапазон в массиве <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в массиве <paramref name="keys" /><see cref="T:System.Array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> для сортировки.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Сортирует элементы в диапазоне элементов одномерного массива <see cref="T:System.Array" />, используя заданный интерфейс <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` — `null`, каждый элемент в указанном диапазоне элементов списка `array` должен реализовывать <xref:System.IComparable> интерфейс, чтобы можно было сравнивать с любым другим элементом в `array`.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 .NET Framework включает предопределенные <xref:System.Collections.IComparer> реализаций, перечисленные в следующей таблице.  
  
|Реализация|Описание|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Сравнивает любые два объекта, но выполняет сравнение без учета регистра строк.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Сравнивает любые два объекта с помощью соглашений сортировки текущего языка и региональных параметров.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Сравнивает любые два объекта с помощью правил сортировки инвариантного языка и региональных параметров.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Сравнивает два объекта типа `T` , используя порядок сортировки по умолчанию для этого типа.|  
  
 Можно также поддерживать пользовательских вариантов сравнения путем предоставления собственного экземпляра <xref:System.Collections.IComparer> реализацию `comparer` параметра. В примере это выполняется путем определения `ReverseComparer` класс, который изменяет порядок сортировки по умолчанию для экземпляров типа и выполняет сравнение строк без учета регистра.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как сортировать значения в <xref:System.Array> с помощью функции сравнения по умолчанию и пользовательского модуля сравнения, который изменяет порядок сортировки. Обратите внимание, что результат может изменяться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.  
  
-или- 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException">Значение параметра <paramref name="comparer" /> — <see langword="null" />, а один или несколько элементов в параметре <paramref name="array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 и более ранних версий используется только алгоритм Quicksort. QuickSort идентифицирует недопустимое функции сравнения, в некоторых ситуациях, в которых вызывает операции сортировки <see cref="T:System.IndexOutOfRangeException" /> исключения и генерирует <see cref="T:System.ArgumentException" /> исключение вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, что операции сортировки, ранее вызвал <see cref="T:System.ArgumentException" /> не вызовет исключение, так как алгоритмы сортировки и heapsort вставки не обнаруживают компаратор недопустимый. В основном это относится к массивы с менее чем 16 элементов.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Одномерный массив <see cref="T:System.Array" />, который содержит элементы, соответствующие ключам в массиве <see cref="T:System.Array" /><paramref name="keys" />.  
  
-или- 
 Значение <see langword="null" /> для сортировки только массива <see cref="T:System.Array" /><paramref name="keys" />.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
-или- 
 Значение <see langword="null" /> для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Сортирует диапазон элементов в паре одномерных объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя заданный интерфейс <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys` <xref:System.Array> имеет соответствующий элемент `items` <xref:System.Array>. При изменении положения ключ во время сортировки, соответствующий элемент в `items` <xref:System.Array> аналогичным образом перемещен. Таким образом `items` <xref:System.Array> сортируется в соответствии с расположение соответствующих ключей в `keys` <xref:System.Array>.  
  
 Если `comparer` — `null`, каждый ключ в указанном диапазоне элементов списка `keys` <xref:System.Array> должен реализовывать <xref:System.IComparable> интерфейс, чтобы можно было сравнивать с любым другим ключом.  
  
 Сортировка в случае, если существует больше элементов, чем ключи, но не будут удалены элементы, которых нет соответствующих ключей. Нельзя выполнить сортировку при наличии нескольких ключей, чем элементы; в этом случае создается это <xref:System.ArgumentException>.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 .NET Framework включает предопределенные <xref:System.Collections.IComparer> реализаций, перечисленные в следующей таблице.  
  
|Реализация|Описание|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Сравнивает любые два объекта, но выполняет сравнение без учета регистра строк.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Сравнивает любые два объекта с помощью соглашений сортировки текущего языка и региональных параметров.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Сравнивает любые два объекта с помощью правил сортировки инвариантного языка и региональных параметров.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Сравнивает два объекта типа `T` , используя порядок сортировки по умолчанию для этого типа.|  
  
 Можно также поддерживать пользовательских вариантов сравнения путем предоставления собственного экземпляра <xref:System.Collections.IComparer> реализацию `comparer` параметра. В примере это выполняется путем определения пользовательского <xref:System.Collections.IComparer> реализация, которая изменяет порядок сортировки по умолчанию и выполняет сравнение строк без учета регистра.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере кода показано, как отсортировать два связанных между, где первый массив содержит ключи, а второй массив содержит значения. Сортировка выполняется с помощью функции сравнения по умолчанию и пользовательского модуля сравнения, который изменяет порядок сортировки. Обратите внимание, что результат может изменяться в зависимости от текущего <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> — <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Массив <paramref name="keys" /><see cref="T:System.Array" /> является многомерным.  
  
-или- 
Массив <paramref name="items" /><see cref="T:System.Array" /> является многомерным.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="keys" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="items" /> не равно <see langword="null" />, а нижняя граница массива <paramref name="keys" /> не совпадает с нижней границей массива <paramref name="items" />.  
  
-или- 
 Значение параметра <paramref name="items" /> не равно <see langword="null" />, и длина параметра <paramref name="keys" /> больше длины параметра <paramref name="items" />.  
  
-или- 
 <paramref name="index" /> и <paramref name="length" /> не определяют допустимый диапазон в <paramref name="keys" /><see cref="T:System.Array" />.  
  
-или- 
 Значение параметра <paramref name="items" /> не равно <see langword="null" />, а параметры <paramref name="index" /> и <paramref name="length" /> не определяют допустимый диапазон в массиве <paramref name="items" /><see cref="T:System.Array" />.  
  
-или- 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException">Значение параметра <paramref name="comparer" /> — <see langword="null" />, а один или несколько элементов в параметре <paramref name="keys" /><see cref="T:System.Array" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 и более ранних версий используется только алгоритм Quicksort. QuickSort идентифицирует недопустимое функции сравнения, в некоторых ситуациях, в которых вызывает операции сортировки <see cref="T:System.IndexOutOfRangeException" /> исключения и генерирует <see cref="T:System.ArgumentException" /> исключение вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, что операции сортировки, ранее вызвал <see cref="T:System.ArgumentException" /> не вызовет исключение, так как алгоритмы сортировки и heapsort вставки не обнаруживают компаратор недопустимый. В основном это относится к массивы с менее чем 16 элементов.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Сортируемый одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля.</param>
        <summary>Сортирует элементы во всем массиве <see cref="T:System.Array" />, используя реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> каждого элемента массива <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый элемент `array` должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы можно было сравнивать с любым другим элементом в `array`.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> перегрузки универсального метода и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> перегрузки универсального метода. Создается массив строк в произвольном порядке.  
  
 Массив отображается, сортировки и отображаться в дальнейшем.  
  
> [!NOTE]
>  Вызовы <xref:System.Array.Sort%2A> и <xref:System.Array.BinarySearch%2A> универсальные методы не поменяется, из вызовов их неуниверсальные аналоги, так как Visual Basic, C# и C++ вывести тип параметра универсального типа из типа первого аргумента. Если вы используете [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) изучаемый промежуточного языка Майкрософт (MSIL), вы увидите, что универсальные методы вызываются.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> Перегрузки универсального метода затем используется для поиска двух строк, одна из которых является массивом, а также один, —. Массив и значение, возвращаемое <xref:System.Array.BinarySearch%2A> метод передаются `ShowWhere` универсальный метод, который отображает значение индекса, если строка найдена, а в противном случае элементы строка поиска, которая бы делятся между если бы он был в массиве. Индекс является отрицательным, если строка не n массива, поэтому `ShowWhere` метод принимает поразрядным дополнением значения (~ оператор в C# и Visual C++, `Xor` -1 в Visual Basic) для получения индекса первого элемента в списке, который больше, чем строго поиска: ng.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в массиве <paramref name="array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Сортируемый одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля.</param>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, используемая при сравнении элементов, или значение <see langword="null" /> для использования реализации универсального интерфейса <see cref="T:System.IComparable`1" /> каждого элемента.</param>
        <summary>Сортирует элементы в одномерном массиве <see cref="T:System.Array" />, используя заданный универсальный интерфейс <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` — `null`, каждый элемент `array` должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы можно было сравнивать с любым другим элементом в `array`.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> перегрузки универсального метода и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> перегрузки универсального метода.  
  
 В примере кода определяется компаратором альтернативные для строк, с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальный интерфейс. Вызовы функции сравнения <xref:System.String.CompareTo%28System.String%29> метод, изменяя порядок сравниваемых объектов, так, что строки сортируются высокого или низкого вместо низкого к высокому.  
  
 Массив отображается, сортировки и отображаться в дальнейшем. Массивы должны быть отсортированы, чтобы использовать <xref:System.Array.BinarySearch%2A> метод.  
  
> [!NOTE]
>  Вызовы <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> универсальные методы не поменяется, из вызовов их неуниверсальные аналоги, так как Visual Basic, C# и C++ вывести тип параметра универсального типа из типа первого аргумента. Если вы используете [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) изучаемый промежуточного языка Майкрософт (MSIL), вы увидите, что универсальные методы вызываются.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Перегрузки универсального метода затем используется для поиска двух строк, одна из которых является массивом, а также один, —. Массив и значение, возвращаемое <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> метод передаются `ShowWhere` универсальный метод, который отображает значение индекса, если строка найдена, а в противном случае элементы строка поиска, которая бы делятся между если бы он был в массиве. Индекс является отрицательным, если строка не n массива, поэтому `ShowWhere` метод принимает поразрядным дополнением значения (~ оператор в C# и Visual C++, `Xor` -1 в Visual Basic) для получения индекса первого элемента в списке, который больше, чем строго поиска: ng.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Значение параметра <paramref name="comparer" /> — <see langword="null" />, а один или несколько элементов в параметре <paramref name="array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <exception cref="T:System.ArgumentException">Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 и более ранних версий используется только алгоритм Quicksort. QuickSort идентифицирует недопустимое функции сравнения, в некоторых ситуациях, в которых вызывает операции сортировки <see cref="T:System.IndexOutOfRangeException" /> исключения и генерирует <see cref="T:System.ArgumentException" /> исключение вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, что операции сортировки, ранее вызвал <see cref="T:System.ArgumentException" /> не вызовет исключение, так как алгоритмы сортировки и heapsort вставки не обнаруживают компаратор недопустимый. В основном это относится к массивы с менее чем 16 элементов.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Сортируемый одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля.</param>
        <param name="comparison"><see cref="T:System.Comparison`1" />, используемый при сравнении элементов.</param>
        <summary>Сортирует элементы массива <see cref="T:System.Array" /> с использованием указанного объекта <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> перегрузки метода.  
  
 В примере кода определяется метод альтернативное сравнение строк с именем `CompareDinosByLength`. Этот метод работает следующим образом: Во-первых, сравниваемых`null`, и ссылкой на null, считается меньше, чем отличный от null. Во-вторых длины строк сравниваются, и значение, считается более длинной строки. В-третьих Если значения длины равны, используется обычное сравнение строк.  
  
 Массив строк создается и заполняется с четырьмя строками в произвольном порядке. Список также содержит пустую строку, а также ссылку на null. Список, при сортировке <xref:System.Comparison%601> универсальный делегат, представляющий `CompareDinosByLength` метод и отображаться в дальнейшем.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="comparison" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Реализация <paramref name="comparison" /> вызвала ошибку во время сортировки. Например, <paramref name="comparison" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 и более ранних версий используется только алгоритм Quicksort. QuickSort идентифицирует недопустимое функции сравнения, в некоторых ситуациях, в которых вызывает операции сортировки <see cref="T:System.IndexOutOfRangeException" /> исключения и генерирует <see cref="T:System.ArgumentException" /> исключение вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, что операции сортировки, ранее вызвал <see cref="T:System.ArgumentException" /> не вызовет исключение, так как алгоритмы сортировки и heapsort вставки не обнаруживают компаратор недопустимый. В основном это относится к массивы с менее чем 16 элементов.</para></block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Сортируемый одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <summary>Сортирует элементы в диапазоне элементов массива <see cref="T:System.Array" />, используя реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> каждого элемента массива <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый элемент в указанном диапазоне элементов списка `array` должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы можно было сравнивать с любым другим элементом в `array`.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> перегрузки универсального метода и <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> перегрузки универсального метода для сортировки диапазон в массиве.  
  
 В примере кода определяется компаратором альтернативные для строк, с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальный интерфейс. Вызовы функции сравнения <xref:System.String.CompareTo%28System.String%29> метод, изменяя порядок сравниваемых объектов, так, что строки сортируются высокого или низкого вместо низкого к высокому.  
  
 В примере кода создает и отображает массив имен динозавр, состоящий из трех травоядных трех плотоядных видов (а точнее, тираннозавридов точнее). <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Перегрузки универсального метода используется для сортировки последние три элементы массива, который затем отображается. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Перегрузки универсального метода используется с `ReverseCompare` элементы требуется сортировать последние три в обратном порядке. Сомнительные имена динозавров отображаются снова.  
  
> [!NOTE]
>  Вызовы <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> универсальные методы не поменяется, из вызовов их неуниверсальные аналоги, так как Visual Basic, C# и C++ вывести тип параметра универсального типа из типа первого аргумента. Если вы используете [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) изучаемый промежуточного языка Майкрософт (MSIL), вы увидите, что универсальные методы вызываются.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в массиве <paramref name="array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Сортируемый одномерный массив <see cref="T:System.Array" />, индексация которого начинается с нуля.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, используемая при сравнении элементов, или значение <see langword="null" /> для использования реализации универсального интерфейса <see cref="T:System.IComparable`1" /> каждого элемента.</param>
        <summary>Сортирует элементы в диапазоне элементов массива <see cref="T:System.Array" />, используя заданный универсальный интерфейс <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` — `null`, каждый элемент в указанном диапазоне элементов списка `array` должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы можно было сравнивать с любым другим элементом в `array`.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> перегрузки универсального метода и <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> перегрузки универсального метода для сортировки диапазон в массиве.  
  
 В примере кода определяется компаратором альтернативные для строк, с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальный интерфейс. Вызовы функции сравнения <xref:System.String.CompareTo%28System.String%29> метод, изменяя порядок сравниваемых объектов, так, что строки сортируются высокого или низкого вместо низкого к высокому.  
  
 В примере кода создает и отображает массив имен динозавр, состоящий из трех травоядных трех плотоядных видов (а точнее, тираннозавридов точнее). <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Перегрузки универсального метода используется для сортировки последние три элементы массива, который затем отображается. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Перегрузки универсального метода используется с `ReverseCompare` элементы требуется сортировать последние три в обратном порядке. Сомнительные имена динозавров отображаются снова.  
  
> [!NOTE]
>  Вызовы <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> и <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> универсальные методы не поменяется, из вызовов их неуниверсальные аналоги, так как Visual Basic, C# и C++ вывести тип параметра универсального типа из типа первого аргумента. Если вы используете [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) изучаемый промежуточного языка Майкрософт (MSIL), вы увидите, что универсальные методы вызываются.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="array" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="length" /> не указывают допустимый диапазон в <paramref name="array" />.  
  
-или- 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException">Значение параметра <paramref name="comparer" /> — <see langword="null" />, а один или несколько элементов в параметре <paramref name="array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 и более ранних версий используется только алгоритм Quicksort. QuickSort идентифицирует недопустимое функции сравнения, в некоторых ситуациях, в которых вызывает операции сортировки <see cref="T:System.IndexOutOfRangeException" /> исключения и генерирует <see cref="T:System.ArgumentException" /> исключение вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, что операции сортировки, ранее вызвал <see cref="T:System.ArgumentException" /> не вызовет исключение, так как алгоритмы сортировки и heapsort вставки не обнаруживают компаратор недопустимый. В основном это относится к массивы с менее чем 16 элементов.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип элементов массива ключей.</typeparam>
        <typeparam name="TValue">Тип элементов массива элементов.</typeparam>
        <param name="keys">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий элементы, соответствующие ключам в массиве <paramref name="keys" />, или значение <see langword="null" /> для сортировки только массива <paramref name="keys" />.</param>
        <summary>Сортирует пару одномерных объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> каждого ключа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys` <xref:System.Array> имеет соответствующий элемент `items` <xref:System.Array>. При изменении положения ключ во время сортировки, соответствующий элемент в `items` <xref:System.Array> аналогичным образом перемещен. Таким образом `items` <xref:System.Array> сортируется в соответствии с расположение соответствующих ключей в `keys` <xref:System.Array>.  
  
 Каждый ключ в `keys` <xref:System.Array> должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы можно было сравнивать с любым другим ключом.  
  
 Сортировка в случае, если существует больше элементов, чем ключи, но не будут удалены элементы, которых нет соответствующих ключей. Нельзя выполнить сортировку при наличии нескольких ключей, чем элементы; в этом случае создается это <xref:System.ArgumentException>.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, и <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> перегрузки универсального метода, для сортировки пары массивов, представляющих ключи и значения.  
  
 В примере кода определяется компаратором альтернативные для строк, с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальный интерфейс. Вызовы функции сравнения <xref:System.String.CompareTo%28System.String%29> метод, изменяя порядок сравниваемых объектов, так, что строки сортируются высокого или низкого вместо низкого к высокому.  
  
 В примере кода создает и отображает массив имен динозавров (ключи) и массив целых чисел, представляющий максимальную длину каждого динозавров в метрах (значения). Затем массивы отсортированы и отображаются несколько раз:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Перегрузка используется для сортировки обоих массивов в порядке названий динозавров в первом массиве.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Перегрузки и экземпляром `ReverseCompare` позволяют изменить порядок сортировки в связанном массивов.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Перегрузка используется для сортировки последних трех элементов обоих массивов.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Перегрузка используется для сортировки последних трех элементов обоих массивов в обратном порядке.  
  
> [!NOTE]
>  Вызовы универсальных методов выглядят отличается от вызова их неуниверсальные аналоги, так как Visual Basic, C# и C++ вывести тип параметра универсального типа из первых двух аргументов типа. Если вы используете [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) изучаемый промежуточного языка Майкрософт (MSIL), вы увидите, что универсальные методы вызываются.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="items" /> не равно <see langword="null" />, а нижняя граница массива <paramref name="keys" /> не совпадает с нижней границей массива <paramref name="items" />.  
  
-или- 
 Значение параметра <paramref name="items" /> не равно <see langword="null" />, и длина параметра <paramref name="keys" /> больше длины параметра <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в массиве <paramref name="keys" /><see cref="T:System.Array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип элементов массива ключей.</typeparam>
        <typeparam name="TValue">Тип элементов массива элементов.</typeparam>
        <param name="keys">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий элементы, соответствующие ключам в массиве <paramref name="keys" />, или значение <see langword="null" /> для сортировки только массива <paramref name="keys" />.</param>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, используемая при сравнении элементов, или значение <see langword="null" /> для использования реализации универсального интерфейса <see cref="T:System.IComparable`1" /> каждого элемента.</param>
        <summary>Сортирует пару одномерных объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя заданный универсальный интерфейс <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys` <xref:System.Array> имеет соответствующий элемент `items` <xref:System.Array>. При изменении положения ключ во время сортировки, соответствующий элемент в `items` <xref:System.Array> аналогичным образом перемещен. Таким образом `items` <xref:System.Array> сортируется в соответствии с расположение соответствующих ключей в `keys` <xref:System.Array>.  
  
 Если `comparer` — `null`, каждый ключ в `keys` <xref:System.Array> должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы можно было сравнивать с любым другим ключом.  
  
 Сортировка в случае, если существует больше элементов, чем ключи, но не будут удалены элементы, которых нет соответствующих ключей. Нельзя выполнить сортировку при наличии нескольких ключей, чем элементы; в этом случае создается это <xref:System.ArgumentException>.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, и <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> перегрузки универсального метода, для сортировки пары массивов, представляющих ключи и значения.  
  
 В примере кода определяется компаратором альтернативные для строк, с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальный интерфейс. Вызовы функции сравнения <xref:System.String.CompareTo%28System.String%29> метод, изменяя порядок сравниваемых объектов, так, что строки сортируются высокого или низкого вместо низкого к высокому.  
  
 В примере кода создает и отображает массив имен динозавров (ключи) и массив целых чисел, представляющий максимальную длину каждого динозавров в метрах (значения). Затем массивы отсортированы и отображаются несколько раз:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Перегрузка используется для сортировки обоих массивов в порядке названий динозавров в первом массиве.  
  
-   [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > перегрузки и экземпляром `ReverseCompare` позволяют изменить порядок сортировки Парный массивов.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Перегрузка используется для сортировки последних трех элементов обоих массивов.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Перегрузка используется для сортировки последних трех элементов обоих массивов в обратном порядке.  
  
> [!NOTE]
>  Вызовы универсальных методов выглядят отличается от вызова их неуниверсальные аналоги, так как Visual Basic, C# и C++ вывести тип параметра универсального типа из первых двух аргументов типа. Если вы используете [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) изучаемый промежуточного языка Майкрософт (MSIL), вы увидите, что универсальные методы вызываются.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="items" /> не равно <see langword="null" />, а нижняя граница массива <paramref name="keys" /> не совпадает с нижней границей массива <paramref name="items" />.  
  
-или- 
 Значение параметра <paramref name="items" /> не равно <see langword="null" />, и длина параметра <paramref name="keys" /> больше длины параметра <paramref name="items" />.  
  
-или- 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException">Значение параметра <paramref name="comparer" /> — <see langword="null" />, а один или несколько элементов в параметре <paramref name="keys" /><see cref="T:System.Array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 и более ранних версий используется только алгоритм Quicksort. QuickSort идентифицирует недопустимое функции сравнения, в некоторых ситуациях, в которых вызывает операции сортировки <see cref="T:System.IndexOutOfRangeException" /> исключения и генерирует <see cref="T:System.ArgumentException" /> исключение вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, что операции сортировки, ранее вызвал <see cref="T:System.ArgumentException" /> не вызовет исключение, так как алгоритмы сортировки и heapsort вставки не обнаруживают компаратор недопустимый. В основном это относится к массивы с менее чем 16 элементов.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип элементов массива ключей.</typeparam>
        <typeparam name="TValue">Тип элементов массива элементов.</typeparam>
        <param name="keys">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий элементы, соответствующие ключам в массиве <paramref name="keys" />, или значение <see langword="null" /> для сортировки только массива <paramref name="keys" />.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <summary>Сортирует диапазон элементов в паре объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> каждого ключа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys` <xref:System.Array> имеет соответствующий элемент `items` <xref:System.Array>. При изменении положения ключ во время сортировки, соответствующий элемент в `items` <xref:System.Array> аналогичным образом перемещен. Таким образом `items` <xref:System.Array> сортируется в соответствии с расположение соответствующих ключей в `keys` <xref:System.Array>.  
  
 Каждый ключ в указанном диапазоне элементов списка `keys` <xref:System.Array> должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы можно было сравнивать с любым другим ключом.  
  
 Сортировка в случае, если существует больше элементов, чем ключи, но не будут удалены элементы, которых нет соответствующих ключей. Нельзя выполнить сортировку при наличии нескольких ключей, чем элементы; в этом случае создается это <xref:System.ArgumentException>.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, и <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> перегрузки универсального метода, для сортировки пары массивов, представляющих ключи и значения.  
  
 В примере кода определяется компаратором альтернативные для строк, с именем `ReverseCompare`, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальный интерфейс. Вызовы функции сравнения <xref:System.String.CompareTo%28System.String%29> метод, изменяя порядок сравниваемых объектов, так, что строки сортируются высокого или низкого вместо низкого к высокому.  
  
 В примере кода создает и отображает массив имен динозавров (ключи) и массив целых чисел, представляющий максимальную длину каждого динозавров в метрах (значения). Затем массивы отсортированы и отображаются несколько раз:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Перегрузка используется для сортировки обоих массивов в порядке названий динозавров в первом массиве.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Перегрузки и экземпляром `ReverseCompare` позволяют изменить порядок сортировки в связанном массивов.  
  
-   [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > перегрузка используется для сортировки последних трех элементов обоих массивов.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Перегрузка используется для сортировки последних трех элементов обоих массивов в обратном порядке.  
  
> [!NOTE]
>  Вызовы универсальных методов выглядят отличается от вызова их неуниверсальные аналоги, так как Visual Basic, C# и C++ вывести тип параметра универсального типа из первых двух аргументов типа. Если вы используете [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) изучаемый промежуточного языка Майкрософт (MSIL), вы увидите, что универсальные методы вызываются.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="keys" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="items" /> не равно <see langword="null" />, а нижняя граница массива <paramref name="keys" /> не совпадает с нижней границей массива <paramref name="items" />.  
  
-или- 
 Значение параметра <paramref name="items" /> не равно <see langword="null" />, и длина параметра <paramref name="keys" /> больше длины параметра <paramref name="items" />.  
  
-или- 
 <paramref name="index" /> и <paramref name="length" /> не определяют допустимый диапазон в <paramref name="keys" /><see cref="T:System.Array" />.  
  
-или- 
 Значение параметра <paramref name="items" /> не равно <see langword="null" />, а параметры <paramref name="index" /> и <paramref name="length" /> не определяют допустимый диапазон в массиве <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Один или несколько элементов в массиве <paramref name="keys" /><see cref="T:System.Array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Тип элементов массива ключей.</typeparam>
        <typeparam name="TValue">Тип элементов массива элементов.</typeparam>
        <param name="keys">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий ключи для сортировки.</param>
        <param name="items">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, содержащий элементы, соответствующие ключам в массиве <paramref name="keys" />, или значение <see langword="null" /> для сортировки только массива <paramref name="keys" />.</param>
        <param name="index">Начальный индекс диапазона сортировки.</param>
        <param name="length">Число элементов в диапазоне сортировки.</param>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, используемая при сравнении элементов, или значение <see langword="null" /> для использования реализации универсального интерфейса <see cref="T:System.IComparable`1" /> каждого элемента.</param>
        <summary>Сортирует диапазон элементов в паре объектов <see cref="T:System.Array" /> (один содержит ключи, а другой — соответствующие элементы) по ключам в первом массиве <see cref="T:System.Array" />, используя заданный универсальный интерфейс <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый ключ в `keys` <xref:System.Array> имеет соответствующий элемент `items` <xref:System.Array>. При изменении положения ключ во время сортировки, соответствующий элемент в `items` <xref:System.Array> аналогичным образом перемещен. Таким образом `items` <xref:System.Array> сортируется в соответствии с расположение соответствующих ключей в `keys` <xref:System.Array>.  
  
 Если `comparer` — `null`, каждый ключ в указанном диапазоне элементов списка `keys` <xref:System.Array> должен реализовывать <xref:System.IComparable%601> универсальный интерфейс, чтобы можно было сравнивать с любым другим ключом.  
  
 Сортировка в случае, если существует больше элементов, чем ключи, но не будут удалены элементы, которых нет соответствующих ключей. Нельзя выполнить сортировку при наличии нескольких ключей, чем элементы; в этом случае создается это <xref:System.ArgumentException>.  
  
 Если сортировка не будет успешно завершена, результаты будут неопределенными.  
  
 Этот метод использует алгоритм реализует интроспективную сортировку (introsort) следующим образом:  
  
-   Если нужный размер раздела меньше 16 элементов, он использует [сортировку вставками](https://en.wikipedia.org/wiki/Insertion_sort) алгоритм.  
  
-   Если число секций превышает 2 * журнала<sup>N</sup>, где *N* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритм.  
  
-   В противном случае он использует [Quicksort](https://en.wikipedia.org/wiki/Quicksort) алгоритм.  
  
 Эта реализация осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок может не сохраняться. Напротив стабильная сортировка сохраняет порядок равных элементов.  
  
 Для массивов, которые сортируются с помощью алгоритмов Heapsort и быстрой сортировки, в худшем случае этот метод является операцией O (`n` журнала `n`) операции, где `n` является `length`.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, и [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7b%60%600%7D%29 > перегрузки универсального метода, для сортировки пары массивов, представляющих ключи и значения.  
  
 В примере кода определяется компаратором альтернативные для строк, с именем `ReverseCompare`, который реализует `IComparer<string>`(`IComparer(Of String)` в Visual Basic, `IComparer<String^>` в Visual C++) универсальный интерфейс. Вызовы функции сравнения <xref:System.String.CompareTo%28System.String%29> метод, изменяя порядок сравниваемых объектов, так, что строки сортируются высокого или низкого вместо низкого к высокому.  
  
 В примере кода создает и отображает массив имен динозавров (ключи) и массив целых чисел, представляющий максимальную длину каждого динозавров в метрах (значения). Затем массивы отсортированы и отображаются несколько раз:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Перегрузка используется для сортировки обоих массивов в порядке названий динозавров в первом массиве.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Перегрузки и экземпляром `ReverseCompare` позволяют изменить порядок сортировки в связанном массивов.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Перегрузка используется для сортировки последних трех элементов обоих массивов.  
  
-   [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > перегрузка используется для сортировки последние три элементы обоих массивов в обратном порядке.  
  
> [!NOTE]
>  Вызовы универсальных методов выглядят отличается от вызова их неуниверсальные аналоги, так как Visual Basic, C# и C++ вывести тип параметра универсального типа из первых двух аргументов типа. Если вы используете [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) изучаемый промежуточного языка Майкрософт (MSIL), вы увидите, что универсальные методы вызываются.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> меньше нижней границы массива <paramref name="keys" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="items" /> не равно <see langword="null" />, а нижняя граница массива <paramref name="keys" /> не совпадает с нижней границей массива <paramref name="items" />.  
  
-или- 
 Значение параметра <paramref name="items" /> не равно <see langword="null" />, и длина параметра <paramref name="keys" /> больше длины параметра <paramref name="items" />.  
  
-или- 
 <paramref name="index" /> и <paramref name="length" /> не определяют допустимый диапазон в <paramref name="keys" /><see cref="T:System.Array" />.  
  
-или- 
 Значение параметра <paramref name="items" /> не равно <see langword="null" />, а параметры <paramref name="index" /> и <paramref name="length" /> не определяют допустимый диапазон в массиве <paramref name="items" /><see cref="T:System.Array" />.  
  
-или- 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException">Значение параметра <paramref name="comparer" /> — <see langword="null" />, а один или несколько элементов в параметре <paramref name="keys" /><see cref="T:System.Array" /> не реализуют универсальный интерфейс <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 и более ранних версий используется только алгоритм Quicksort. QuickSort идентифицирует недопустимое функции сравнения, в некоторых ситуациях, в которых вызывает операции сортировки <see cref="T:System.IndexOutOfRangeException" /> исключения и генерирует <see cref="T:System.ArgumentException" /> исключение вызывающему объекту. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], возможно, что операции сортировки, ранее вызвал <see cref="T:System.ArgumentException" /> не вызовет исключение, так как алгоритмы сортировки и heapsort вставки не обнаруживают компаратор недопустимый. В основном это относится к массивы с менее чем 16 элементов.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Выполнение в массивах строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект, с помощью которого можно синхронизировать доступ к коллекции <see cref="T:System.Array" />.</summary>
        <value>Объект, который может использоваться для синхронизации доступа к <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство реализует <xref:System.Collections.ICollection?displayProperty=nameWithType> интерфейс.  
  
 На основе классов .NET framework <xref:System.Array> предоставить собственную синхронизированную версию коллекции с помощью <xref:System.Array.SyncRoot%2A> свойство.  
  
 Классы, использующие массивы также можно реализовать собственные синхронизации с помощью <xref:System.Array.SyncRoot%2A> свойство. Синхронизированный код должен выполнять операции над `SyncRoot` коллекции, не над самой коллекцией. Это обеспечивает правильную работу коллекций, являющихся производными других объектов. В частности это обеспечивает правильную синхронизацию с другими потоками, которые могут одновременно вносить изменения коллекции. Обратите внимание, что в некоторых реализациях <xref:System.Array.SyncRoot%2A> могут возвращать <xref:System.Array> сам.  
  
 Перечисление коллекции само по себе не является потокобезопасной процедурой. Даже если коллекция синхронизирована, другие потоки могут ее изменить, что приведет к тому, что перечислитель создаст исключение. Для обеспечения потокобезопасности при перечислении можно либо заблокировать коллекцию на все время перечисления, либо перехватывать исключения, возникающие в результате изменений, внесенных другими потоками.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как заблокировать массив на все время перечисления с помощью <xref:System.Array.SyncRoot%2A> свойство.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Array" />.</summary>
        <value>Количество элементов в коллекции.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее, является ли доступ к коллекции <see cref="T:System.Array" /> синхронизированным (потокобезопасным).</summary>
        <value>Значение true, если доступ к коллекции <see cref="T:System.Array" /> является синхронизированным (потокобезопасным); в противном случае — значение false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект, с помощью которого можно синхронизировать доступ к коллекции <see cref="T:System.Array" />.</summary>
        <value>Объект, который может использоваться для синхронизации доступа к <see cref="T:System.Array" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который должен быть добавлен в коллекцию <see cref="T:System.Collections.IList" />.</param>
        <summary>При вызове этого метода всегда возникает исключение <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Добавление значений в массив не поддерживается. Возвращаемое значение отсутствует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> реализации добавляет элемент в коллекцию. Тем не менее так как массивы имеют фиксированный размер ( <xref:System.Array.IsFixedSize%2A> свойство всегда возвращает `true`), этот метод всегда создает <xref:System.NotSupportedException> исключение.  
  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> имеет фиксированный размер.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все элементы из коллекции <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.IList" /> доступен только для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который требуется найти в текущем списке. Элемент, который требуется найти, для ссылочных типов может быть равен <see langword="null" />.</param>
        <summary>Определяет, входит ли элемент в коллекцию <see cref="T:System.Collections.IList" />.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> найден в коллекции <see cref="T:System.Collections.IList" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который требуется найти в текущем списке.</param>
        <summary>Определяет индекс заданного элемента в списке <see cref="T:System.Collections.IList" />.</summary>
        <returns>Индекс значения, если оно найдено в списке; в противном случае — значение, равное -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Индекс, по которому требуется вставить элемент <paramref name="value" />.</param>
        <param name="value">Вставляемый объект.</param>
        <summary>Вставляет элемент в список <see cref="T:System.Collections.IList" /> по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> не является допустимым индексом в <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.IList" /> доступен только для чтения.  
  
-или- 
<see cref="T:System.Collections.IList" /> имеет фиксированный размер.</exception>
        <exception cref="T:System.NullReferenceException">Параметр <paramref name="value" /> является ссылкой со значением null в списке <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, имеет ли объект <see cref="T:System.Array" /> фиксированный размер.</summary>
        <value>Значение true, если коллекция <see cref="T:System.Array" /> имеет фиксированный размер; в противном случае — значение false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое определяет, является ли коллекция <see cref="T:System.Array" /> доступной только для чтения.</summary>
        <value>Значение true, если коллекция <see cref="T:System.Array" /> доступна только для чтения; в противном случае — значение false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Индекс элемента, который необходимо получить или задать.</param>
        <summary>Возвращает или задает элемент по указанному индексу.</summary>
        <value>Элемент, расположенный по указанному индексу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="index" /> больше или равно значению свойства <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">Размерность текущего массива <see cref="T:System.Array" /> не равна единице.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который необходимо удалить из коллекции <see cref="T:System.Collections.IList" />.</param>
        <summary>Удаляет первое вхождение указанного объекта из коллекции <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.IList" /> доступен только для чтения.  
  
-или- 
<see cref="T:System.Collections.IList" /> имеет фиксированный размер.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Индекс элемента, который должен быть удален.</param>
        <summary>Удаляет элемент <see cref="T:System.Collections.IList" />, расположенный по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">индекс не является допустимым в <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.IList" /> доступен только для чтения.  
  
-или- 
<see cref="T:System.Collections.IList" /> имеет фиксированный размер.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Объект для сравнения с текущим экземпляром.</param>
        <param name="comparer">Объект, сравнивающий текущий объект и объект <paramref name="other" />.</param>
        <summary>Определяет позицию текущего объекта коллекции относительно другого объекта в порядке сортировки (находится перед другим объектов, на одной позиции с ним или после другого объекта).</summary>
        <returns>Целое число, определяющее, как соотносятся между собой текущий объект коллекции и другой объект. Возможные соотношения показаны в следующей таблице.  
  
 <list type="table"><listheader><term> Возвращаемое значение 
 </term><description> Описание 
 </description></listheader><item><term> -1 
 </term><description> Текущий экземпляр стоит перед объектом <paramref name="other" />.  
  
 </description></item><item><term> 0 
 </term><description> Текущий экземпляр и объект <paramref name="other" /> равны.  
  
 </description></item><item><term> 1 
 </term><description> Текущий экземпляр стоит после объекта <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IStructuralComparable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Объект для сравнения с текущим экземпляром.</param>
        <param name="comparer">Объект, определяющий, равны ли текущий экземпляр и объект <paramref name="other" />.</param>
        <summary>Определяет, равен ли объект текущему экземпляру.</summary>
        <returns>Значение <see langword="true" />, если эти два объекта равны; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="comparer">Объект, вычисляющий хэш-код текущего объекта.</param>
        <summary>Возвращает хэш-код текущего экземпляра.</summary>
        <returns>Хэш-код для текущего экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Array> приведен к типу интерфейса <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов массива.</typeparam>
        <param name="array">Индексируемый от нуля одномерный массив <see cref="T:System.Array" />, который необходимо проверить на соответствие условиям.</param>
        <param name="match">Предикат, определяющий условия, на соответствие которым проверяются элементы.</param>
        <summary>Определяет, все ли элементы массива удовлетворяют условиям указанного предиката.</summary>
        <returns>Значение <see langword="true" />, если каждый элемент массива <paramref name="array" /> удовлетворяет условиям заданного предиката; в противном случае — значение <see langword="false" />. Если элементы в массиве отсутствуют, возвращается значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Делегат для метода, который возвращает`true` если переданный объект соответствует условиям, определенным в делегате.  Элементы `array` передаются по отдельности <xref:System.Predicate%601>, и обработка прекращается, когда делегат возвращается `false` для любого элемента.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Array.Length%2A> из `array`.  
  
   
  
## Examples  
 Следующий пример определяет, является ли последний символ каждого элемента в массиве строк число. Он создает два массива строк. Первый массив содержит строки, которые заканчиваются буквенные символы и строки, которые заканчиваются цифровых символов. Второй массив состоит только из строк, которые заканчиваются цифровых символов. В примере также определяется `EndWithANumber` метод, сигнатура которого соответствует <xref:System.Predicate%601> делегировать. В примере передается каждого массива для <xref:System.Array.TrueForAll%2A> метод и делегат, представляющий `EndsWithANumber` метод.  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 Следующий пример аналогичен первой, за исключением того, что он передает массив строк, нужно <xref:System.Array.TrueForAll%2A> метод вместе с лямбда-выражение, которое определяет, заканчивается ли конкретному элементу массива строковое представление числа.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 В обоих случаях <xref:System.Array.TrueForAll%2A> возвращает метод `false` как только он встречает первый элемент массива, который не оканчивается на число. В противном случае возвращается `true` после итерации всех элементов в массиве.  
  
> [!NOTE]
>  Как показано в обоих примерах, в C# и Visual Basic, нет необходимости создавать `Predicate<string>` делегировать (`Predicate(Of String)` в Visual Basic) явным образом. Эти языки нужный делегат из контекста определяется и создается автоматически.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.  
  
-или- 
 <paramref name="match" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>