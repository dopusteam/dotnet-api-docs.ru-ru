<Type Name="Uri" FullName="System.Uri">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8d34d711c31dd37f90c0ccf0ac9bb2b9b89518a6" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57937230" /></Metadata><TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Uri = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Обеспечивает объектное представление универсального кода ресурсов (URI), а также простой доступ к его частям.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI — это компактное представление ресурсов, доступных для приложения в интрасети или Интернете. <xref:System.Uri> Класс определяет свойства и методы для обработки URI, включая анализ, сравнение и объединение. <xref:System.Uri> Свойства класса доступны только для чтения; для создания объекта изменяемой, используйте <xref:System.UriBuilder> класса.  
  
 Относительные URI (например, «/ new/index.htm») должны быть дополнены базовый URI, чтобы они были абсолютный. <xref:System.Uri.MakeRelative%2A> Метод предназначен для преобразования абсолютных URI в относительные URI при необходимости.  
  
 <xref:System.Uri> Конструкторы не экранирует строки URI, если строка имеет правильный формат URI, включая идентификатор схемы.  
  
 <xref:System.Uri> Свойства возвращают каноническое представление данных в escape-кодировке, в которой все символы с больше 127, заменены на эквиваленты шестнадцатеричных значений в Юникоде. Чтобы преобразовать URI в канонической форме <xref:System.Uri> конструктор выполняет следующие действия:  
  
-   Преобразует схему URI в нижний регистр.  
  
-   Преобразует имя узла в нижний регистр.  
  
-   Если имя узла представляет собой адрес IPv6, используется канонический адрес IPv6. ScopeId и другие необязательные данные IPv6 удаляются.  
  
-   Удаляет значение по умолчанию, а также номера портов пустой.
  
-   Преобразует явные путями file:// схема неявное путей без file:// схема (например, «C:\my\file»).
  
-   Escape-символы (также известный как закодированные октетов), у которых нет зарезервированных цели декодирование (также известный как неэкранированную форму). Эти незарезервированные символы: прописные и строчные буквы (% 41-% 5а и % 61-% 7A), десятичные цифры (% 30-% 39), дефис (% 2D), период (% 2E), символ подчеркивания (% 5F), а тильда (% 7E).

-   Канонизирует путь для иерархических URI на сжатие последовательности таких как /. /, /... /, и / / (ли экранируется последовательности). Обратите внимание, что некоторые схемы, для которых эти последовательности не сжимаются.
  
-   Для иерархических URI Если узел не заканчивается косой черты (/), то он добавляется.  
  
-   По умолчанию все зарезервированные знаки в URI escape-последовательность, в соответствии с RFC 2396. Этого изменения в поведении Если анализ международных идентификаторов ресурсов или международное доменное имя в какие вариантов зарезервированные символы в URI преобразуются в соответствии с RFC 3986 и RFC 3987.

 В рамках канонизации в конструкторе для некоторых схем, точка сегментов и пустых сегментов (/. /, /.. /, и / /), сжимаются (другими словами, они удаляются). Схемы, для которых URI будет сжимать эти последовательности включают, http, https, tcp, net.pipe и net.tcp. Для некоторых других схемах этих последовательностей, не сжимаются. Вот как выглядит этот сжатие на практике.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 При выполнении этого кода, он возвращает следующие выходные данные, с помощью escape-последовательности escape-последовательности, при необходимости и затем сжимается.

```  
http://myUrl/  
/  
```  
  
 Вы можете преобразовать содержимое <xref:System.Uri> от escape-кодировку URI-ссылка на ссылку для чтения URI с помощью класса <xref:System.Uri.ToString%2A> метод. Обратите внимание, что некоторые зарезервированные символы может по-прежнему экранироваться в выходных данных <xref:System.Uri.ToString%2A> метод. Это необходимо для поддержки однозначной реконструкции URI из значения, возвращенного <xref:System.Uri.ToString%2A>.  
  
 Некоторые URI включают идентификатор фрагмента или запрос или оба. Идентификатор фрагмента представляет собой любой текст, следующий за знаком решетки (#), не включая знак числа; фрагмент текст хранится в <xref:System.Uri.Fragment%2A> свойство. Сведения о запросе является любой текст, следующий знак вопроса (?) в URI; текст запроса сохраняется в <xref:System.Uri.Query%2A> свойство.  
  
 В .NET Framework версии 1.1, если строка, указанная для конструктора содержит неизвестная схема и «c:\\«, операции вставки класс Uri «/ /» после двоеточия. Например, URI `xyz:c:\abc` преобразуется в `xyz://c:/abc`. В платформе .NET Framework версии 2.0 это поведение было удалено, и в примере строка преобразуется в `xyz:c:/abc`.  
  
> [!NOTE]
>  Класс URI поддерживает использование IP-адресов в обоих виде четырех чисел для протокола IPv4 и двоеточие шестнадцатиричное для протокола IPv6. Не забудьте заключить в квадратные скобки, как в http://[::1 IPv6-адрес].  
  
## <a name="international-resource-identifier-support"></a>Поддержка международного кода ресурса  
 Веб-адреса обычно выражаются с помощью универсальных кодов ресурсов, которые состоят из очень ограниченного набора символов:  
  
-   буквы верхнего и нижнего регистра английского алфавита в кодировке ASCII;  
  
-   цифры от 0 до 9;  
  
-   небольшое количество других символов ASCII.  
  
 Спецификации для URI документально зафиксированы в стандартах RFC 2396, RFC 2732, RFC 3986 и RFC 3987, опубликованном по Internet Engineering Task Force (IETF).  
  
 По мере расширения Интернета потребность в идентификации ресурсов на языках, отличных от английского, становится все более насущной. Идентификаторы, которые способствуют удовлетворению этой потребности и позволяют использовать символы, не принадлежащие к кодировке ASCII (символы из кодировок Unicode/ISO 10646), называются международными кодами ресурсов (IRI). Спецификации IRI документально зафиксированы в стандарте RFC 3987, опубликованном IETF. Использование IRI позволяет применять в URL символы Юникода.  
  
 Существующий <xref:System.Uri> класс был расширен в .NET Framework 3.5, 3.0 с пакетом обновления 1 и 2.0 с пакетом обновления 1 для обеспечения поддержки IRI на основе RFC 3987. Пользователи версий .NET Framework до версии 4.5 не увидят изменения в .NET Framework 2.0, пока не включат поддержку IRI. Это обеспечивает совместимость приложений с предыдущими версиями платформы .NET Framework.  
  
 Чтобы включить поддержку IRI, требуется следующее изменение:  
  
-   Укажите, нужно ли синтаксический анализ международных доменных имен (IDN), применяемый к имени домена и должны ли применяться правила синтаксического анализа IRI. Это можно сделать *machine.config* или в *app.config* файл. Например добавьте следующие строки:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Пользователи платформы .NET Framework 4.5 и более поздних всегда имеют IRI включена. Синтаксический анализ IRI нельзя изменить с помощью *.config* файл.  
  
 При включенном IDN метки в Юникоде в доменном имени будут преобразованы в аналоги в кодировке Punicode. Имена Punicode содержат только символы ASCII и всегда начинаются с префикса "xn--". Это сделано для того, чтобы поддерживать существующие DNS-серверы в интрасети, так как большинство DNS-серверов поддерживает только символы ASCII (см. RFC 3940).  
  
 Включение IRI и IDN влияет на значение свойства <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType>. Включение IRI и IDN может также привести к изменению принципа действия методов <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A> и <xref:System.Uri.IsWellFormedOriginalString%2A>.  
  
 Существует три возможных значения для IDN в зависимости от DNS-серверы, которые используются:  
  
-   IDN включена = All  
  
     При этом значении имена доменов из Юникода будут преобразовываться в их эквиваленты в Punycode (IDN-имена).  
  
-   idn enabled = AllExceptIntranet  
  
     Это значение будет преобразовать все имена доменов из Юникода не в локальной интрасети эквиваленты в Punycode (IDN-имена). В этом случае чтобы обрабатывать международные имена в локальной интрасети, DNS-серверы, которые используются для интрасети должны поддерживать разрешение имен в Юникоде.  
  
-   IDN включена = нет  
  
     При этом значении имена доменов в Юникоде не будут преобразовываться в их эквиваленты в Punycode. Это значение по умолчанию, которое совместимо с поведением .NET Framework 2.0.  
  
 При включении синтаксического анализа IRI (iriParsing включена = `true`) нормализация и проверка символов выполняются в соответствии с последними правилами IRI стандарта RFC 3986 и RFC 3987. При синтаксическом анализе IRI отключена, нормализация и проверка символов выполняются в соответствии с RFC 2396 и RFC 2732 (для литералов IPv6).  В версиях .NET Framework до версии 4.5, значение по умолчанию — `false`. В .NET Framework версии 4.5 и более поздних, значение по умолчанию — `true`, и его нельзя изменить состояние выполнения синтаксического анализа IRI параметрами *.config* файл.  
  
 Обработку IRI и IDN в <xref:System.Uri> класс также можно управлять с помощью <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>, <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, и <xref:System.Configuration.UriSection?displayProperty=nameWithType> классов параметров конфигурации. Параметр <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> включает или отключает обработку IRI в классе <xref:System.Uri>. Параметр <xref:System.Configuration.IdnElement?displayProperty=nameWithType> включает или отключает обработку IDN в классе <xref:System.Uri>. Параметр <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> также косвенно управляет IDN. Обработка IRI должна быть включена для обработки IDN. Если IRI-система не включена, то обработка IDN данных будет происходить по умолчанию, когда режим платформы .NET Framework 2.0 является совместимым и имена IDN не используются.  
  
 Параметр конфигурации для <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> и <xref:System.Configuration.IdnElement?displayProperty=nameWithType> будет считан, когда первый <xref:System.Uri?displayProperty=nameWithType> создании класса. Изменения, внесенные в параметры конфигурации после этого, игнорируются.  
  
 Расширен был также и класс <xref:System.GenericUriParser?displayProperty=nameWithType>, который теперь позволяет создавать настраиваемые средства синтаксического анализа, поддерживающие IRI и IDN. Поведение объекта <xref:System.GenericUriParser?displayProperty=nameWithType> задается путем передачи побитового сочетания значений, доступных в перечислении <xref:System.GenericUriParserOptions?displayProperty=nameWithType>, конструктору <xref:System.GenericUriParser?displayProperty=nameWithType>. Тип <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType> указывает на то, что средство синтаксического анализа поддерживает правила анализа, определенные стандартом RFC 3987 для международных кодов ресурсов (IRI). Используется ли IRI, зависит от рассмотренных ранее значений конфигурации.  
  
 Тип <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType> указывает на то, что средство синтаксического анализа поддерживает анализ международных доменных имен (IDN) узлов. Используется ли IDN, зависит от рассмотренных ранее значений конфигурации.  
  
## <a name="implicit-file-path-support"></a>Поддержка путь неявных файлов
 <xref:System.Uri> может также использоваться для представления локального пути. Эти пути могут быть представлены *явно* в URI, которые начинаются с file:// схема, и *неявно* в URI, которые не имеют file:// схема. В примерах двух следующих URI допустимы и представляют один и тот же путь файла:
```csharp
Uri uri1 = new Uri("C:/test/path/file.txt") // Implicit file path.
Uri uri2 = new Uri("file:///C:/test/path/file.txt") // Explicit file path.
```
 Эти неявные пути не соответствуют спецификации URI и поэтому следует избегать, если это возможно. При использовании .NET Core в системах на основе Unix, пути к файлам неявное может быть особенно проблематично, так как неявные абсолютный путь на диске *неотличимы* из относительный путь. При наличии такой неоднозначности, <xref:System.Uri> по умолчанию для интерпретации путь в абсолютный URI.
  
## <a name="performance-considerations"></a>Особенности производительности  
 Если вы используете *Web.config * файл, содержащий URI для инициализации приложений, дополнительные времени должна обрабатывать коды URI, в случае нестандартных идентификаторов схем. В таком случае инициализируйте части приложения, затронутых при необходимости коды URI, не указанное время начала.  
  
   
  
## Examples  
 В следующем примере создается экземпляр <xref:System.Uri> класса и использует его для создания <xref:System.Net.WebRequest> экземпляра.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>Из-за проблемы безопасности, приложение будет соблюдать осторожность при приеме <see cref="T:System.Uri" /> экземпляров из ненадежных источников и с <paramref name="dontEscape" /> присвоено <see langword="true" />. Можно проверить строку универсального кода Ресурса на допустимость, вызвав <see cref="M:System.Uri.IsWellFormedOriginalString" /> метод.</para></block>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
    <related type="Article" href="https://msdn.microsoft.com/library/35883fe9-2d09-4d8b-80ca-cf23a941e459">Изменения пространства имен System.Uri в версии 2.0</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b5e994c3-3535-4aff-8e1b-b69be22e9a22">Поддержка международного кода ресурса в System.UriSystem.Uri</related>
    <related type="Article" href="~/docs/framework/network-programming/index.md">Сетевое программирование в .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberSignature Language="F#" Value="new Uri : string -&gt; Uri" Usage="new System.Uri uriString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">Строка, позволяющая идентифицировать ресурсы, которые должны быть представлены с помощью экземпляра <see cref="T:System.Uri" />. Обратите внимание на то, что IPv6-адрес в строковой форме должен заключаться в скобки. Пример: "http://[2607:f8b0:400d:c06::69]".</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> с заданным универсальным кодом ресурса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает <xref:System.Uri> экземпляр из строки URI. Она выполняет синтаксический анализ URI, помещает его в каноническом формате и предоставляет необходимые escape-кодировки.  
  
 Этот конструктор не гарантирует, что <xref:System.Uri> ссылается на доступный ресурс.  
  
 Этот конструктор предполагается, что `string` параметр ссылается на абсолютный URI и эквивалентно вызову <xref:System.Uri.%23ctor%2A> конструктор с <xref:System.UriKind> присвоено <xref:System.UriKind.Absolute>. Если `string` параметр, передаваемый в конструктор является относительным URI, этот конструктор вызывает <xref:System.UriFormatException>.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра с URI "http://www.contoso.com/«.  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> — <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.</para>
          </block>Параметр 
          <paramref name="uriString" /> пуст.  
  
-или- 
Схема, указанная в <paramref name="uriString" />, неправильно сформирована. См. раздел <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
-или- 
 <paramref name="uriString" /> содержит слишком много знаков косой черты.  
  
-или- 
Пароль, указанный в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя узла, указанное в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя файла, указанное в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя пользователя, указанное в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя узла или центра, указанное в <paramref name="uriString" />, не может заканчиваться обратной косой чертой.  
  
-или- 
Номер порта, указанный в <paramref name="uriString" />, является недопустимым или не поддается анализу.  
  
-или- 
Длина <paramref name="uriString" /> превышает 65 519 символов.  
  
-или- 
Длина схемы, заданной в <paramref name="uriString" />, превышает 1023 символа.  
  
-или- 
Имеется недопустимая последовательность символов в <paramref name="uriString" />.  
  
-или- 
Путь MS-DOS, заданный в <paramref name="uriString" />, должен начинаться с c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new Uri : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Uri" Usage="new System.Uri (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Экземпляр класса <see cref="T:System.Runtime.Serialization.SerializationInfo" /> содержит сведения, необходимые для сериализации нового экземпляра <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Экземпляр класса <see cref="T:System.Runtime.Serialization.StreamingContext" /> содержит источник сериализованного потока, связанного с новым экземпляром <see cref="T:System.Uri" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> на основе указанных экземпляров классов <see cref="T:System.Runtime.Serialization.SerializationInfo" /> и <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор реализует <xref:System.Runtime.Serialization.ISerializable> интерфейс для <xref:System.Uri> класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="serializationInfo" /> содержит универсальный код ресурса (URI) <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">Параметр <paramref name="serializationInfo" /> содержит пустой универсальный код ресурса (URI).  
  
-или- 
Указанная схема неправильно сформирована. См. раздел <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
-или- 
Универсальный код ресурса (URI) содержит слишком много знаков косой черты.  
  
-или- 
Пароль, указанный в универсальном коде ресурса (URI), является недопустимым.  
  
-или- 
Имя узла, указанное в универсальном коде ресурса (URI), является недопустимым.  
  
-или- 
Имя файла, указанное в универсальном коде ресурса (URI), является недопустимым.  
  
-или- 
Имя пользователя, указанное в универсальном коде ресурса (URI), является недопустимым.  
  
-или- 
Имя узла или центра, указанное в универсальном коде ресурса (URI), не может заканчиваться обратной косой чертой.  
  
-или- 
Номер порта, указанный в универсальном коде ресурса (URI), является недопустимым или не поддается анализу.  
  
-или- 
Длина универсального кода ресурса (URI) превышает 65 519 символов.  
  
-или- 
Длина схемы, заданной в универсальном коде ресурса (URI), превышает 1023 символа.  
  
-или- 
Имеется недопустимая последовательность символов в универсальном коде ресурса (URI).  
  
-или- 
Путь MS-DOS, заданный в универсальном коде ресурса (URI), должен начинаться с c:\\\\.</exception>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Сериализация XML и SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : string * bool -&gt; Uri" Usage="new System.Uri (uriString, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="dontEscape" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uriString">Строка, позволяющая идентифицировать ресурсы, которые должны быть представлены с помощью экземпляра <see cref="T:System.Uri" />. Обратите внимание на то, что IPv6-адрес в строковой форме должен заключаться в скобки. Пример: "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="dontEscape">Значение <see langword="true" />, если параметр <paramref name="uriString" /> полностью преобразовывается в escape-последовательность; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> с указанным универсальным кодом ресурса и явным управлением преобразованием в escape-последовательность.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает <xref:System.Uri> экземпляр из строки URI. Он выполняет синтаксический анализ URI и помещает его в каноническом формате.  
  
 `dontEscape` Отдает ли зарезервированные символы преобразуются в escape-последовательности. Этому параметру следует присвоить `true` только если уверены, что отмечен как специальный все зарезервированные символы в URI. При установке значения `true` для URI, который не был полностью экранировать может привести к непредвиденному поведению. Настоятельно рекомендуется установить этот параметр `false`.  
  
 Если `dontEscape` присваивается `false`, конструктор экранирует все зарезервированные знаки, проверив, процента (%) следует допустимую escape-последовательность. Если последовательность символов после процента не допускается, процент заменяется на % 25.  
  
 Этот конструктор не гарантирует, что <xref:System.Uri> ссылается на доступный ресурс.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра для URI http://www.contoso.com/Hello%20World.htm. Поскольку содержащийся в нем URI полностью экранируются и составлена в канонической форме `dontEscape` параметру можно присвоить `true`.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> — <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">Параметр <paramref name="uriString" /> является пустым или содержит только пробелы.  
  
-или- 
Схема, указанная в параметре <paramref name="uriString" />, является недопустимой.  
  
-или- 
 <paramref name="uriString" /> содержит слишком много знаков косой черты.  
  
-или- 
Пароль, указанный в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя узла, указанное в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя файла, указанное в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя пользователя, указанное в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя узла или центра, указанное в <paramref name="uriString" />, не может заканчиваться обратной косой чертой.  
  
-или- 
Номер порта, указанный в <paramref name="uriString" />, является недопустимым или не поддается анализу.  
  
-или- 
Длина <paramref name="uriString" /> превышает 65 519 символов.  
  
-или- 
Длина схемы, заданной в <paramref name="uriString" />, превышает 1023 символа.  
  
-или- 
Имеется недопустимая последовательность символов в <paramref name="uriString" />.  
  
-или- 
Путь MS-DOS, заданный в <paramref name="uriString" />, должен начинаться с c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="new Uri : string * UriKind -&gt; Uri" Usage="new System.Uri (uriString, uriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uriKind" Type="System.UriKind" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uriString">Строка, позволяющая идентифицировать ресурсы, которые должны быть представлены с помощью экземпляра <see cref="T:System.Uri" />. Обратите внимание на то, что IPv6-адрес в строковой форме должен заключаться в скобки. Пример: "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="uriKind">Указывает, содержится ли в строке универсального кода ресурса относительный универсальный код ресурса, абсолютный универсальный код ресурса или неопределенный вариант.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> с заданным универсальным кодом ресурса. Этот конструктор позволяет указать, содержится ли в строке универсального кода ресурса относительный универсальный код ресурса, абсолютный универсальный код ресурса или неопределенный вариант.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Относительных и абсолютных URI имеют различные ограничения на их формат. Например относительный URI не требуется схема или центр. Значение, указываемое в `uriKind` должен соответствовать типу URI, переданный в `uriString`. Тем не менее если <xref:System.UriKind.RelativeOrAbsolute> указан, строка URI может быть относительным или абсолютным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="uriKind" /> недопустим.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> — <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.</para>
          </block>
          <paramref name="uriString" /> содержит относительный URI, и <paramref name="uriKind" /> — <see cref="F:System.UriKind.Absolute" />.  
  
или 
 <paramref name="uriString" /> содержит абсолютный URI, и <paramref name="uriKind" /> — <see cref="F:System.UriKind.Relative" />.  
  
или 
 Параметр <paramref name="uriString" /> пуст.  
  
-или- 
Схема, указанная в <paramref name="uriString" />, неправильно сформирована. См. раздел <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
-или- 
 <paramref name="uriString" /> содержит слишком много знаков косой черты.  
  
-или- 
Пароль, указанный в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя узла, указанное в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя файла, указанное в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя пользователя, указанное в <paramref name="uriString" />, является недопустимым.  
  
-или- 
Имя узла или центра, указанное в <paramref name="uriString" />, не может заканчиваться обратной косой чертой.  
  
-или- 
Номер порта, указанный в <paramref name="uriString" />, является недопустимым или не поддается анализу.  
  
-или- 
Длина <paramref name="uriString" /> превышает 65 519 символов.  
  
-или- 
Длина схемы, заданной в <paramref name="uriString" />, превышает 1023 символа.  
  
-или- 
Имеется недопустимая последовательность символов в <paramref name="uriString" />.  
  
-или- 
Путь MS-DOS, заданный в <paramref name="uriString" />, должен начинаться с c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">Базовый универсальный код ресурса.</param>
        <param name="relativeUri">Относительный универсальный код ресурса, добавляемый к базовому.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> на основе заданного базового универсального кода ресурса и строки относительного универсального кода ресурса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает <xref:System.Uri> экземпляра путем объединения `baseUri` и `relativeUri`. Если `relativeUri` является абсолютным URI (содержащий схему, имя узла и при необходимости номер порта), <xref:System.Uri> экземпляр создается только с помощью `relativeUri`.  
 
 Если `baseUri` состоит из частей относительный (как `/api`), относительный части должен заканчиваться косой чертой, а затем (как `/api/`), если относительный часть `baseUri` должен быть сохранен в сконструированный <xref:System.Uri>. 

 Кроме того Если `relativeUri` начинается с косой черты, а затем она заменяет любой относительный части `baseUri`

 Этот конструктор не гарантирует, что <xref:System.Uri> ссылается на доступный ресурс.  
  
   
  
## Examples  
 В следующем примере создается новый экземпляр класса <xref:System.Uri> класса путем объединения относительные идентификаторы URI http://www.contoso.com и catalog/shownew.htm для формирования абсолютного URI http://www.contoso.com/catalog/shownew.htm.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> не является абсолютным экземпляром <see cref="T:System.Uri" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.</para>
          </block>
URI, сформированный путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, пуст или содержит только пробелы.  
  
-или- 
Схема, заданная в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимой.  
  
-или- 
URI, сформированный путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, содержит слишком много косых черт.  
  
-или- 
Пароль, заданный в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимой.  
  
-или- 
Имя узла, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
-или- 
Имя файла, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
-или- 
Имя пользователя, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
-или- 
Имя узла или центра, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, не может заканчиваться обратной косой чертой.  
  
-или- 
Номер порта, заданный в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым или не поддается анализу.  
  
-или- 
Длина URI, сформированного путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, превышает 65 519 знаков.  
  
-или- 
Длина схемы, заданной в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, превышает 1023 знака.  
  
-или- 
Имеется недопустимая последовательность символов в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />.  
  
-или- 
Путь MS-DOS, заданный в <paramref name="uriString" />, должен начинаться с c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * Uri -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="relativeUri" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="baseUri">Абсолютный <see cref="T:System.Uri" />, являющийся основой для нового экземпляра <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Экземпляр относительного <see cref="T:System.Uri" />, объединяемый с объектом <paramref name="baseUri" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> на основе сочетания заданного базового экземпляра <see cref="T:System.Uri" /> и относительного экземпляра <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает новый <xref:System.Uri> экземпляра путем объединения является абсолютным <xref:System.Uri> экземпляра, `baseUri`, с помощью относительного <xref:System.Uri> экземпляра, `relativeUri`. Если `relativeUri` является абсолютным <xref:System.Uri> экземпляра (содержащий схему, имя узла и при необходимости номер порта), <xref:System.Uri> экземпляр создается только с помощью `relativeUri`.  
 
 Если `baseUri` состоит из частей относительный (как `/api`), относительный части должен заканчиваться косой чертой, а затем (как `/api/`), если относительный часть `baseUri` должен быть сохранен в сконструированный <xref:System.Uri>. 

 Кроме того Если `relativeUri` начинается с косой черты, а затем она заменяет любой относительный части `baseUri`
 
 Этот конструктор не гарантирует, что <xref:System.Uri> ссылается на доступный ресурс.  
  
   
  
## Examples  
 В этом примере создается абсолютный <xref:System.Uri> экземпляра, `absoluteUri`и относительного <xref:System.Uri> экземпляра, `relativeUri`. Новый <xref:System.Uri> экземпляра, `combinedUri`, затем создается из этих двух экземпляров.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="baseUri" /> не является абсолютным экземпляром <see cref="T:System.Uri" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> не является абсолютным экземпляром <see cref="T:System.Uri" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.</para>
          </block>
URI, сформированный путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, пуст или содержит только пробелы.  
  
-или- 
Схема, заданная в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимой.  
  
-или- 
URI, сформированный путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, содержит слишком много косых черт.  
  
-или- 
Пароль, заданный в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимой.  
  
-или- 
Имя узла, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
-или- 
Имя файла, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
-или- 
Имя пользователя, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
-или- 
Имя узла или центра, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, не может заканчиваться обратной косой чертой.  
  
-или- 
Номер порта, заданный в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым или не поддается анализу.  
  
-или- 
Длина URI, сформированного путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, превышает 65 519 знаков.  
  
-или- 
Длина схемы, заданной в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, превышает 1023 знака.  
  
-или- 
Имеется недопустимая последовательность символов в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />.  
  
-или- 
Путь MS-DOS, заданный в <paramref name="uriString" />, должен начинаться с c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string * bool -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="relativeUri" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="dontEscape" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="baseUri">Базовый универсальный код ресурса.</param>
        <param name="relativeUri">Относительный универсальный код ресурса, добавляемый к базовому.</param>
        <param name="dontEscape">Значение <see langword="true" />, если параметр <paramref name="uriString" /> полностью преобразовывается в escape-последовательность; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Uri" /> на основе заданных базового и относительного универсального кода ресурса с явным управлением преобразованием в escape-последовательность.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает <xref:System.Uri> экземпляра путем объединения `baseUri` и `relativeUri`. Если URI, переданный в `relativeUri` является абсолютным URI (содержащий схему, имя узла и при необходимости номер порта), <xref:System.Uri> экземпляр создается только с помощью `relativeUri`.  
  
 `dontEscape` Отдает ли зарезервированные символы преобразуются в escape-последовательности. Этому параметру следует присвоить `true` только если уверены, что отмечен как специальный все зарезервированные символы в URI. При установке значения `true` для URI, который не был полностью экранировать может привести к непредвиденному поведению. Настоятельно рекомендуется установить этот параметр `false`. Если `dontEscape` присваивается `false`, конструктор экранирует все зарезервированные знаки, проверив, процента (%) следует допустимую escape-последовательность. Если последовательность символов после процента не допускается, процент заменяется на % 25.  
  
 Этот конструктор не гарантирует, что <xref:System.Uri> ссылается на доступный ресурс.  
  
   
  
## Examples  
 В следующем примере создается новый экземпляр класса <xref:System.Uri> класса путем объединения относительные идентификаторы URI http://www.contoso.com и Hello%20World.htm для формирования абсолютного URI.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> не является абсолютным экземпляром <see cref="T:System.Uri" />.</exception>
        <exception cref="T:System.UriFormatException">URI, сформированный путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, пуст или содержит только пробелы.  
  
-или- 
Схема, заданная в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимой.  
  
-или- 
URI, сформированный путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, содержит слишком много косых черт.  
  
-или- 
Пароль, заданный в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимой.  
  
-или- 
Имя узла, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
-или- 
Имя файла, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
-или- 
Имя пользователя, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым.  
  
-или- 
Имя узла или центра, заданное в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, не может заканчиваться обратной косой чертой.  
  
-или- 
Номер порта, заданный в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, является недопустимым или не поддается анализу.  
  
-или- 
Длина URI, сформированного путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, превышает 65 519 знаков.  
  
-или- 
Длина схемы, заданной в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />, превышает 1023 знака.  
  
-или- 
Имеется недопустимая последовательность символов в URI, сформированном путем объединения <paramref name="baseUri" /> и <paramref name="relativeUri" />.  
  
-или- 
Путь MS-DOS, заданный в <paramref name="uriString" />, должен начинаться с c:\\\\.</exception>
        <block subset="none" type="usage"><para>Из-за проблемы безопасности, приложение не следует вызывать этот конструктор со строками URI из ненадежных источников и с <paramref name="dontEscape" /> присвоено <see langword="true" />. Кроме того, можно проверить строку универсального кода Ресурса на допустимость, вызвав <see cref="M:System.Uri.IsWellFormedOriginalString" /> метод до вызова этого конструктора.</para></block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsolutePath : string" Usage="System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает абсолютный путь универсального кода ресурса.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий абсолютный путь к ресурсу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.AbsolutePath%2A> Свойство содержит сведения о пути, используемый сервером для разрешения запросов сведения. Обычно это путь к требуемой информации в файловой системе сервера, несмотря на то, что он также может указывать на приложение или сценарий, которые должен выполнить сервер для предоставления сведений.  
  
 Сведения о пути не включает схему, имя узла или часть URI запроса.  
  
   
  
## Examples  
 Следующий пример записывает /catalog/shownew.htm путь на консоль.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsoluteUri : string" Usage="System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает абсолютный универсальный код ресурса.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий весь универсальный код ресурса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.AbsoluteUri%2A> Свойство включает весь универсальный код Ресурса, хранящиеся в <xref:System.Uri> экземпляра, включая все фрагменты и строки запросов.  
  
   
  
## Examples  
 Следующий пример записывает полное содержимое <xref:System.Uri> экземпляра на консоль. В примере, показанном http://www.contoso.com/catalog/shownew.htm?date=today записывается в консоль.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает для сервера службу доменных имен (DNS) или IP-адрес и номер порта.</summary>
        <value>Строка <see cref="T:System.String" />, содержащая компонент центра универсального кода ресурса, представленного этим экземпляром.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Authority%2A> Оно обычно сервера DNS-имя узла или IP-адрес. Это свойство может содержать номер порта службы, если он отличается от порта по умолчанию для URI. Если <xref:System.Uri.Authority%2A> компонента содержит зарезервированные символы, эти escape-последовательность в строковое значение, возвращаемое этим свойством.  
  
   
  
## Examples  
 Следующий пример записывает имя узла (www.contoso.com) и номер порта (8080) сервера на консоль.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberSignature Language="F#" Value="abstract member Canonicalize : unit -&gt; unit&#xA;override this.Canonicalize : unit -&gt; unit" Usage="uri.Canonicalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразует сохраненный во внутреннем хранилище универсальный код ресурса в каноническую форму.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сохраняет каноническую версию URI.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а этот метод допустимо использовать только для абсолютных URI.</exception>
        <exception cref="T:System.UriFormatException">Формат URI неправильный.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member CheckHostName : string -&gt; UriHostNameType" Usage="System.Uri.CheckHostName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя узла, подлежащее проверке. Это может быть IPv4- или IPv6-адрес или имя узла в Интернете.</param>
        <summary>Определяет, является ли указанное имя узла допустимым DNS-именем.</summary>
        <returns>Объект <see cref="T:System.UriHostNameType" />, указывающий тип имени узла. Если не удается определить тип имени узла или если имя узла имеет значение <see langword="null" /> или строку нулевой длины, этот метод возвращает <see cref="F:System.UriHostNameType.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.CheckHostName%2A> Метод проверяет, что указанное имя узла соответствует требованиям к именам узлов Интернета. Тем не менее, он не выполняет поиск имени узла для проверки существования узла.  
  
   
  
## Examples  
 В следующем примере проверяется, является ли допустимым имя узла.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberSignature Language="F#" Value="static member CheckSchemeName : string -&gt; bool" Usage="System.Uri.CheckSchemeName schemeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">Имя схемы, подлежащее проверке.</param>
        <summary>Определяет, является ли допустимым указанное имя схемы.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если имя схемы допустимо; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод проверяет имя схемы на допустимость в соответствии с RFC 2396 по умолчанию. Если включен международных идентификаторов ресурсов (IRI) или синтаксический анализ международных доменных имен (IDN), этот метод проверяет имя схемы на допустимость в соответствии с RFC 3986. Имя схемы должно начинаться с буквы и содержать только буквы, цифры и символы «.», «+» или «-».  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" <xref:System.Uri> класса.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и проверяет, является ли допустимым имя схемы.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberSignature Language="F#" Value="abstract member CheckSecurity : unit -&gt; unit&#xA;override this.CheckSecurity : unit -&gt; unit" Usage="uri.CheckSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызов этого метода ни на что не влияет.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : Uri * Uri * UriComponents * UriFormat * StringComparison -&gt; int" Usage="System.Uri.Compare (uri1, uri2, partsToCompare, compareFormat, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uri2" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="compareFormat" Type="System.UriFormat" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri1">Первая коллекция <see cref="T:System.Uri" />.</param>
        <param name="uri2">Второй объект <see cref="T:System.Uri" />.</param>
        <param name="partsToCompare">Побитовое сочетание значений <see cref="T:System.UriComponents" />, которые задают сравниваемые части <paramref name="uri1" /> и <paramref name="uri2" />.</param>
        <param name="compareFormat">Одно из значений <see cref="T:System.UriFormat" />, которое задает преобразование символов в escape-последовательность, используемую при сравнении компонентов универсального кода ресурса.</param>
        <param name="comparisonType">Одно из значений <see cref="T:System.StringComparison" />.</param>
        <summary>Сравнивает указанные части двух универсальных кодов ресурса, используя заданные правила сравнения.</summary>
        <returns>Значение типа <see cref="T:System.Int32" />, указывающее на лексическую связь между сравниваемыми компонентами <see cref="T:System.Uri" />.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Значение 
 </description></listheader><item><term> Меньше нуля 
 </term><description>Значение <paramref name="uri1" /> меньше <paramref name="uri2" />.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="uri1" /> равняется <paramref name="uri2" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description>Значение <paramref name="uri1" /> больше значения <paramref name="uri2" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если оба `uri1` и `uri2` являются `null`, этот метод возвращает значение 0. При сравнении значений URI относительный URI всегда является меньше абсолютный URI, а также ненулевой URI всегда больше, чем URI со значением null. Для случаев, где оба `uri1` и `uri2` не `null` и относительные URI или обоих абсолютные URI <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> метод выполняет сравнение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DnsSafeHost : string" Usage="System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя узла, которое после преобразования в неэкранированную форму, если это необходимо, можно безопасно использовать для разрешения DNS.</summary>
        <value>Объект <see cref="T:System.String" /> , содержащий части узла URI в формате, удобном для разрешения DNS, или исходная строка узла, если он уже можно использовать для разрешения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для IPv6-адресов, удаляются квадратные скобки ([]) и <xref:System.Net.IPAddress.ScopeId%2A> свойство имеет значение, если таковой был указан при создании этого экземпляра.

Если вы использовали escape-строку для создания данного экземпляра (например, «http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), затем DnsSafeHost возвращает escape-строку. Отменяет все escape-строку, возвращаемую `DnsSafeHost` прежде чем использовать эту строку для разрешения DNS (см. пример). Если вы использовали недопустимую строку без escape-последовательности для создания данного экземпляра (например, «http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), затем DnsSafeHost возвращает строку без escape-последовательности.
  
 <xref:System.Uri.DnsSafeHost%2A> Свойство зависит от параметров конфигурации, как описано далее в этом разделе. Не удается изменить параметры конфигурации в приложениях Windows Store, что может привести к непредсказуемым результатам при использовании <xref:System.Uri.DnsSafeHost%2A>. <xref:System.Uri.IdnHost%2A> Свойство предоставляется как предпочтительная альтернатива типу с помощью <xref:System.Uri.DnsSafeHost%2A>, так как <xref:System.Uri.IdnHost%2A> гарантированно всегда будет безопасным, независимо от того, какие текущего DNS *app.config* параметры могут быть.  
  
 <xref:System.Uri.DnsSafeHost%2A> Свойство была расширена в .NET Framework 3.5, 3.0 с пакетом обновления 1, а 2.0 с пакетом обновления 1 для предоставления международного кода ресурса (IRI) поддерживают на основе RFC 3987. Пользователи не увидят никаких функциональных изменений, внесенных после платформы .NET Framework 2.0, пока специально не включат поддержку IRI. Это обеспечивает совместимость приложений с предыдущими версиями платформы .NET Framework.  
  
 Чтобы включить поддержку IRI, необходимы следующие два изменения:  
  
1.  Добавьте следующую строку к *machine.config* файл в каталоге .NET Framework 2.0  
  
     \<Имя раздела = «uri» type="System.Configuration.UriSection, системы, версия = 2.0.0.0, язык и региональные параметры = neutral, PublicKeyToken = b77a5c561934e089» / >  
  
2.  Укажите, нужно ли синтаксический анализ международных доменных имен (IDN), применяемый к имени домена и должны ли применяться правила синтаксического анализа IRI. Это можно сделать *machine.config* или в *app.config* файл. Например добавьте следующие строки:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 При включенном IDN метки в Юникоде в доменном имени будут преобразованы в аналоги в кодировке Punicode. Имена Punicode содержат только символы ASCII и всегда начинаются с префикса "xn--". Это сделано для того, чтобы поддерживать существующие DNS-серверы в интрасети, так как большинство DNS-серверов поддерживает только символы ASCII (см. RFC 3940).  
  
 Включение IDN влияет только на значение <xref:System.Uri.DnsSafeHost%2A> свойства.  
  
 Существует три возможных значения для IDN в зависимости от DNS-серверы, которые используются:  
  
-   IDN включена = All  
  
     При этом значении имена доменов из Юникода будут преобразовываться в их эквиваленты в Punycode (IDN-имена).  
  
-   idn enabled = AllExceptIntranet  
  
     При этом значении имена всех внешних доменов из Юникода будут преобразовываться в их эквиваленты в Punycode (IDN-имена). В этом случае, чтобы обрабатывать международные имена в локальной интрасети, DNS-серверы, которые используются для интрасети, должны поддерживать имена в Юникоде.  
  
-   IDN включена = нет  
  
     При этом значении имена доменов в Юникоде не будут преобразовываться в их эквиваленты в Punycode. Это значение по умолчанию, которое совместимо с поведением .NET Framework 2.0.  
  
 Включение синтаксического анализа IRI (iriParsing включена = `true`) нормализация и проверка символов в соответствии с последней IRI правилами в RFC 3987. Значение по умолчанию — `false` и нормализации и символов проверка в соответствии с RFC 2396 и RFC 2732 (для литералов IPv6).  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" <xref:System.Uri> класса.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр из строки. Этот пример иллюстрирует разницу между значение, возвращаемое из <xref:System.Uri.Host%2A>, который возвращает имя узла или адрес, указанный в URI, и значение, возвращаемое из <xref:System.Uri.DnsSafeHost%2A>, который возвращает адрес, который можно безопасно использовать в разрешении DNS.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 Как описано в примечаниях unescape имя узла перед его устранения. Можно использовать <xref:System.Uri.UnescapeDataString%2A> метод unescape имя узла и устранить ее, вызвав <xref:System.Net.Dns.GetHostEntry%2A> метод.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uri.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">Экземпляр <see cref="T:System.Uri" /> или универсальный код ресурса, который требуется сравнить с текущим экземпляром.</param>
        <summary>Сравнивает два экземпляра <see cref="T:System.Uri" /> на предмет их равенства.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если два экземпляра представляют один универсальный код ресурса; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Equals%2A> Метод сравнивает два экземпляра независимо от сведений о пользователе (<xref:System.Uri.UserInfo%2A>) и фрагмент (<xref:System.Uri.Fragment%2A>) части, которые они могут содержать. Например, если коды URI http://www.contoso.com/index.htm#search и http://user:password@www.contoso.com/index.htm, <xref:System.Uri.Equals%2A> метод вернет `true`.  
  
 Если один <xref:System.Uri> экземпляр формируется с использованием Юникода имени узла и `comparand` параметр содержит <xref:System.Uri> экземпляра или идентификатор, который формируется с именем узла, имеющий эквивалентное имя узла в формате Punycode, затем <xref:System.Uri.Equals%2A> возвращает `true` включены только в том случае, если поддержка международного кода ресурса (IRI) и международных доменных имен (IDN). Имена Punicode содержат только символы ASCII и всегда начинаются с префикса "xn--".  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" <xref:System.Uri> класса.  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1 <xref:System.Uri.Query%2A> также учитывается.  
  
> [!NOTE]
>  <xref:System.Uri.Equals%2A> Метод может быть переопределен в производном классе; соблюдайте осторожность, так как вредоносный объект может изменить метод. Этот метод не следует использовать для выполнения проверок безопасности, если только не известно, что данный экземпляр поступил из надежного источника.  
  
   
  
## Examples  
 В этом примере создается два <xref:System.Uri> экземпляров из строк и сравнивает их, чтобы определить, представляют ли они то же значение. `address1` и `address2` являются одинаковыми, поскольку <xref:System.Uri.Fragment%2A> часть, представляющая игнорируется для сравнения. Результат записывается в консоль.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы запретить наследование от частично доверенного кода <see cref="T:System.Uri" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberSignature Language="F#" Value="abstract member Escape : unit -&gt; unit&#xA;override this.Escape : unit -&gt; unit" Usage="uri.Escape " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразует все небезопасные или зарезервированные символы в компонент пути, используя шестнадцатеричное представление.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">Переданный из конструктора URI недопустим. Это исключение может произойти, если в URI содержится слишком много символов или URI является относительным.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeDataString : string -&gt; string" Usage="System.Uri.EscapeDataString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Строка, которую нужно преобразовать в escape-представление.</param>
        <summary>Преобразует строку в ее escape-представление.</summary>
        <returns>Структура <see cref="T:System.String" />, содержащая escape-представление структуры <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Uri.EscapeDataString%2A> метод преобразует все символы, за исключением RFC 2396 незарезервированных символов в их шестнадцатеричное представление. Если включен международных идентификаторов ресурсов (IRI) или синтаксический анализ международных доменных имен (IDN), <xref:System.Uri.EscapeDataString%2A> метод преобразует все символы, за исключением RFC 3986 незарезервированных символов, в их шестнадцатеричное представление. Все символы Юникода перед экранирование преобразуются в формат UTF-8.  
  
 Этот метод предполагает, что `stringToEscape` имеет escape-последовательности не в нем.  
  
 По умолчанию строка преобразуется в соответствии с RFC 2396. Если включен международных идентификаторов ресурсов (IRI) или синтаксический анализ международных доменных имен (IDN), строка преобразуется в соответствии с RFC 3986 и RFC 3987. Определение зарезервированных и незарезервированных символов см.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" <xref:System.Uri> класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToEscape" /> — <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.</para>
          </block>  
  
 Длина <paramref name="stringToEscape" /> превышает 32 766 символов.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member EscapeString : string -&gt; string" Usage="System.Uri.EscapeString str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="str">Строка, подлежащая преобразованию в escape-представление.</param>
        <summary>Преобразует строку в ее escape-представление.</summary>
        <returns>Escape-представление строки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.EscapeString%2A> Метод преобразует RFC 2396 зарезервированных символов и все символы с больше 127 символьное значение в шестнадцатеричное представление. Все символы Юникода перед экранирование преобразуются в формат UTF-8.  
  
 По умолчанию строка преобразуется в соответствии с RFC 2396. Если включен международных идентификаторов ресурсов (IRI) или синтаксический анализ международных доменных имен (IDN), строка преобразуется в соответствии с RFC 3986 и RFC 3987.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" <xref:System.Uri> класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeUriString : string -&gt; string" Usage="System.Uri.EscapeUriString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Строка, которую нужно преобразовать в escape-представление.</param>
        <summary>Преобразует строку универсального кода ресурса в ее escape-представление.</summary>
        <returns>Структура <see cref="T:System.String" />, содержащая escape-представление структуры <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Uri.EscapeUriString%2A> метод, чтобы подготовить строку без escape-последовательности URI, чтобы быть параметр <xref:System.Uri.%23ctor%2A> конструктор.  
  
 По умолчанию <xref:System.Uri.EscapeUriString%2A> метод преобразует все символы, за исключением RFC 2396 незарезервированных символов, в их шестнадцатеричное представление. Если включен международных идентификаторов ресурсов (IRI) или синтаксический анализ международных доменных имен (IDN), <xref:System.Uri.EscapeUriString%2A> метод преобразует все символы, за исключением RFC 3986 незарезервированных символов, в их шестнадцатеричное представление. Все символы Юникода перед экранирование преобразуются в формат UTF-8.  
  
 Этот метод предполагает, что `stringToEscape` имеет escape-последовательности не в нем.  
  
 По умолчанию строка преобразуется в соответствии с RFC 2396. Если включен международных идентификаторов ресурсов (IRI) или синтаксический анализ международных доменных имен (IDN), строка преобразуется в соответствии с RFC 3986 и RFC 3987. Определение зарезервированных и незарезервированных символов см.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" <xref:System.Uri> класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToEscape" /> — <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.</para>
          </block>  
  
 Длина <paramref name="stringToEscape" /> превышает 32 766 символов.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Fragment : string" Usage="System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает escape-последовательность фрагмента универсального кода ресурса.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий любые сведения о фрагменте универсального кода ресурса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Fragment%2A> Свойство возвращает любой текст, следующий за маркером фрагмента (#) в URI, включая саму метку фрагмента. Заданный URI http://www.contoso.com/index.htm#main, <xref:System.Uri.Fragment%2A> возвратит #main.  
  
 <xref:System.Uri.Fragment%2A> Свойство не является в любом <xref:System.Uri.Equals%2A> сравнения.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и выводит сведения о фрагменте на консоль.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberSignature Language="F#" Value="static member FromHex : char -&gt; int" Usage="System.Uri.FromHex digit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="digit">Шестнадцатеричная цифра (0-9, a-f, A-F), подлежащая преобразованию.</param>
        <summary>Получает десятичное значение шестнадцатеричной цифры.</summary>
        <returns>Значение типа <see cref="T:System.Int32" />, содержащее число от 0 до 15, соответствующее указанной шестнадцатеричной цифре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.FromHex%2A> Метод преобразует символ, представляющий шестнадцатеричная цифра (0-9, a – f, A-F) в десятичный (от 0 до 15). Если `digit` не является допустимой шестнадцатеричной цифрой, <xref:System.ArgumentException> возникает исключение.  
  
   
  
## Examples  
 В следующем примере определяется ли символ шестнадцатеричным и, если это так, выводит на консоль соответствующее десятичное значение.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение <paramref name="digit" /> не представляет допустимую шестнадцатеричную цифру (0-9, a-f, A-F).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberSignature Language="F#" Value="member this.GetComponents : UriComponents * UriFormat -&gt; string" Usage="uri.GetComponents (components, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.UriFormat" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="components">Побитовое сочетание значений <see cref="T:System.UriComponents" />, позволяющее определить, какие части текущего экземпляра будут возвращены вызывающему оператору.</param>
        <param name="format">Одно из значений <see cref="T:System.UriFormat" />, позволяющее управлять преобразованием специальных знаков в escape-последовательности.</param>
        <summary>Получает заданные компоненты текущего экземпляра, используя указанное для специальных знаков escape-преобразование.</summary>
        <returns>Объект <see cref="T:System.String" />, содержащий компоненты.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UriComponents.Query>, <xref:System.UriComponents.Fragment>, <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.UserInfo>, <xref:System.UriComponents.Host>, <xref:System.UriComponents.Port>, И <xref:System.UriComponents.Path> разделитель не включался в компоненты. Вы можете объединить <xref:System.UriComponents.KeepDelimiter> флаг (с помощью битового оператора или) с любым из этих значений, чтобы получить это значение с разделителем. Для всех остальных <xref:System.UriComponents> значения и сочетаний значений разделители включаются в возвращаемое значение.  
  
 Компоненты возвращаются в порядке их появления в URI. Например если <xref:System.UriComponents.Scheme> указан, он отображается первым.  
  
 Если включена поддержка международного кода ресурса (IRI) и международных доменных имен (IDN), число символов, возвращаемых в <xref:System.String> увеличивается. Используется для поддержки IRI имена Punicode содержат только символы ASCII и всегда начинаются с префикса xn--. При включении IRI и IDN суррогатные символы Юникода обрабатываются правильно, <xref:System.Uri.GetComponents%2A> метод.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" <xref:System.Uri> класса.  
  
> [!NOTE]
>  Если <xref:System.Uri.GetComponents%2A> метод вызывается с `format` присвоено <xref:System.UriFormat.Unescaped> , возвращаемое значение не может использовать в качестве аргумента для <xref:System.Uri.%23ctor%2A> конструктор, чтобы создать эквивалент <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="components" /> не является сочетанием допустимых значений <see cref="T:System.UriComponents" />.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий <see cref="T:System.Uri" /> не является абсолютным URI. Относительные URI в этом методе использовать нельзя.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uri.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает хэш-код для универсального кода ресурса.</summary>
        <returns>Значение типа <see cref="T:System.Int32" />, содержащее хэш-значение, созданное для этого универсального кода ресурса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и хэш-код выводит на консоль.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberSignature Language="F#" Value="member this.GetLeftPart : UriPartial -&gt; string" Usage="uri.GetLeftPart part" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="part">Одно из значений <see cref="T:System.UriPartial" />, которое указывает окончание возвращаемой части универсального кода ресурса.</param>
        <summary>Возвращает заданную часть экземпляра <see cref="T:System.Uri" />.</summary>
        <returns>Объект <see cref="T:System.String" />, содержащий указанную часть экземпляра <see cref="T:System.Uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.GetLeftPart%2A> Метод возвращает строку, содержащую слева в строке URI, с частью, заданной параметром `part`.  
  
 <xref:System.Uri.GetLeftPart%2A> включает разделители в следующих случаях:  
  
-   <xref:System.UriPartial.Scheme> содержит разделитель схемы.  
  
-   <xref:System.UriPartial.Authority> отсутствует разделитель пути.  
  
-   <xref:System.UriPartial.Path> включает разделители в исходный URI вплоть до разделителей запроса или фрагмента.  
  
-   <xref:System.UriPartial.Query> включает в себя <xref:System.UriPartial.Path>, а также запрос и разделитель.  
  
 Ниже приведены примеры URI и результат вызова метода <xref:System.Uri.GetLeftPart%2A> с <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>, <xref:System.UriPartial.Path>, или <xref:System.UriPartial.Query>.  
  
|URI|Схема|Центр|Путь|Запрос|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/index.htm?date=today|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm?date=today|  
|http://www.contoso.com/index.htm#main|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm|  
|mailto:user@contoso.com?subject=uri|mailto:|mailto:user@contoso.com|mailto:user@contoso.com?subject=uri|\<none>|  
|nntp://news.contoso.com/123456@contoso.com|nntp://|nntp://news.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|Новости.|news:123456@contoso.com|news:123456@contoso.com|\<none>|  
|file://server/filename.ext|file://|file://server|file://server/filename.ext|file://server/filename.ext|  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и записывает путь на консоль.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий экземпляр <see cref="T:System.Uri" /> не является абсолютным.</exception>
        <exception cref="T:System.ArgumentException">Указанное значение <paramref name="part" /> недопустимо.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="member this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="uri.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, который содержит сведения, требуемые для сериализации коллекции <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий исходный объект и объект назначения для сериализованного потока, связанного с коллекцией <see cref="T:System.Uri" />.</param>
        <summary>Возвращает данные, необходимые для сериализации текущего экземпляра.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы использовать методы сериализации. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberSignature Language="F#" Value="static member HexEscape : char -&gt; string" Usage="System.Uri.HexEscape character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="character">Символ, подлежащий преобразованию в шестнадцатеричное представление.</param>
        <summary>Преобразует заданный символ в эквивалентное ему шестнадцатеричное число.</summary>
        <returns>Шестнадцатеричное представление заданного символа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример преобразует символ в эквивалентное ему шестнадцатеричное число и записывает его на консоль.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="character" /> больше 255.</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberSignature Language="F#" Value="static member HexUnescape : string *  -&gt; char" Usage="System.Uri.HexUnescape (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pattern">Шестнадцатеричное представление символа.</param>
        <param name="index">Место в параметре <paramref name="pattern" />, с которого начинается шестнадцатеричное представление символа.</param>
        <summary>Преобразует шестнадцатеричное представление символа в сам символ.</summary>
        <returns>Символ, представленный в шестнадцатеричной кодировке, в позиции, заданной параметром <paramref name="index" />. Если кодировка символа в позиции <paramref name="index" /> не является шестнадцатеричной, возвращается символ в позиции <paramref name="index" />. Значение параметра <paramref name="index" /> увеличивается, указывая на следующий символ после возвращенного.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующем примере кода определяет, является ли символ шестнадцатеричной и, если да, выводит на консоль эквивалентный символ.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="index" /> меньше 0 либо больше или равно числу символов в последовательности <paramref name="pattern" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : string" Usage="System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает компонент узла этого экземпляра.</summary>
        <value>Строка <see cref="T:System.String" />, которая содержит имя узла. Обычно это DNS-имя узла или IP-адрес сервера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Uri.Authority%2A> свойство, значение этого свойства не включает номер порта.  
  
   
  
## Examples  
 Следующий пример записывает имя узла (www.contoso.com) сервера на консоль.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberSignature Language="F#" Value="member this.HostNameType : UriHostNameType" Usage="System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип имени узла, заданного в универсальном коде ресурса.</summary>
        <value>Элемент перечисления <see cref="T:System.UriHostNameType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и записи <xref:System.Uri.HostNameType%2A> на консоль.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IdnHost : string" Usage="System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Международное доменное имя узла, соответствующее RFC 3490, в котором используется Punycode. Строка, которую после преобразования в неэкранированную форму, если это необходимо, можно безопасно использовать для разрешения DNS.</summary>
        <value>Имя узла, отформатированное с помощью Punycode в соответствии со стандартной IDN.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляется для использования низкоуровневых сетевых протоколов, которые требуют доменное имя в формате Punycode. Если ваш код не требуется, определенном формате, используйте <xref:System.Uri.Host%2A> для имени узла.  
  
 Устаревший <xref:System.Uri.DnsSafeHost%2A> свойство зависит от *app.config* параметры, которые нельзя изменить в приложениях Windows Store. IdnHost предоставляется как предпочтительная альтернатива типу с помощью <xref:System.Uri.DnsSafeHost%2A>, так как <xref:System.Uri.IdnHost%2A> гарантированно всегда будет безопасным, независимо от того, какие текущего DNS *app.config* параметры могут быть.  

 Если вы использовали escape-строку для создания данного экземпляра (например, «http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), затем IdnHost возвращает escape-строку. Следует unescape все escape-строку, возвращаемую IdnHost, прежде чем использовать эту строку для разрешения DNS. Имейте в виду, что если вы использовали недопустимую строку без escape-последовательности для создания данного экземпляра (например, «http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), а затем IdnHost возвращает строку без escape-последовательности.


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbsoluteUri : bool" Usage="System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли экземпляр <see cref="T:System.Uri" /> абсолютным.</summary>
        <value>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если экземпляр <see cref="T:System.Uri" /> является абсолютным; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство является `true` Если строка или <xref:System.Uri> экземпляр, который был передан в конструктор может быть проанализировано как абсолютный <xref:System.Uri> экземпляр, который содержит схему, центр и путь. В противном случае <xref:System.Uri> экземпляр считается относительным и может быть пропущена схема или другие компоненты URI.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsBadFileSystemCharacter : char -&gt; bool&#xA;override this.IsBadFileSystemCharacter : char -&gt; bool" Usage="uri.IsBadFileSystemCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="character">Объект <see cref="T:System.Char" /> для проверки.</param>
        <summary>Получает значение, позволяющее определить, содержит ли имя файловой системы недопустимый символ.</summary>
        <returns>Значение <see langword="true" />, если указанный символ недопустим; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Символ анализируется в соответствии с правилами для файловой системы NTFS.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.IsBaseOf : Uri -&gt; bool" Usage="uri.IsBaseOf uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri">Указанный экземпляр <see cref="T:System.Uri" />, который необходимо проверить.</param>
        <summary>Определяет, является ли текущий экземпляр <see cref="T:System.Uri" /> основой указанного экземпляра <see cref="T:System.Uri" />.</summary>
        <returns>Значение <see langword="true" />, если текущий экземпляр <see cref="T:System.Uri" /> является основой для <paramref name="uri" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A> используется для сравнения текущего <xref:System.Uri> экземпляр с заданным <xref:System.Uri> для определения, является ли этот URI основания для указанного <xref:System.Uri>. При сравнении двух <xref:System.Uri> объектов для определения базового отношения, сведения о пользователе (<xref:System.Uri.UserInfo%2A>) не вычисляется. При сравнении двух URI (uri1 и uri2), uri1 является основанием uri2, если при пропуске все в uri2 после последней косой черты (/), два URI идентичны. С помощью http://host/path/path/file?query как базовый URI, в следующей таблице показаны ли она является основой для других URI.  
  
|URI|http://host/path/path/file?query базовым для|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|да|  
|http://host/path/path/#fragment|да|  
|http://host/path/path/MoreDir/"|да|  
|http://host/path/path/OtherFile?Query|да|  
|http://host/path/path/|да|  
|http://host/path/path/file|да|  
|http://host/path/path|Нет|  
|http://host/path/path?query|Нет|  
|http://host/path/path#Fragment|Нет|  
|http://host/path/path2/|Нет|  
://host/path/path2/MoreDir|Нет|  
|http://host/path/File|Нет|  
  
   
  
## Examples  
 В этом примере создается <xref:System.Uri> экземпляр, представляющий базовый <xref:System.Uri> экземпляра. Затем он создает второй <xref:System.Uri> экземпляр из строки. Он вызывает <xref:System.Uri.IsBaseOf%2A> для определения, является ли базовый экземпляр базового второго экземпляра. Результат записывается в консоль.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uri" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefaultPort : bool" Usage="System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, позволяющее определить, является ли номер порта, указанный в универсальном коде ресурса, портом данной схемы по умолчанию.</summary>
        <value>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если значение свойства <see cref="P:System.Uri.Port" /> является портом данной схемы по умолчанию; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и проверяет, использует ли порт по умолчанию.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberSignature Language="F#" Value="static member IsExcludedCharacter : char -&gt; bool" Usage="System.Uri.IsExcludedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="character">Объект <see cref="T:System.Char" /> для проверки.</param>
        <summary>Возвращает значение, позволяющее определить, нужно ли преобразовывать указанный символ в escape-последовательность.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если указанный символ подлежит преобразованию в escape-последовательность; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFile : bool" Usage="System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, представляет ли заданный параметр <see cref="T:System.Uri" /> универсальный код ресурса файла.</summary>
        <value>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если <see cref="T:System.Uri" /> является универсальным кодом ресурса файла; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsFile%2A> Свойство `true` при <xref:System.Uri.Scheme%2A> равняется значению свойства <xref:System.Uri.UriSchemeFile>.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и определяет, является ли URI файла.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberSignature Language="F#" Value="static member IsHexDigit : char -&gt; bool" Usage="System.Uri.IsHexDigit character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="character">Знак, подлежащий проверке.</param>
        <summary>Определяет, является ли указанный символ допустимой шестнадцатеричной цифрой.</summary>
        <returns>Значение <see langword="true" />, если символ является допустимой шестнадцатеричной цифрой; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шестнадцатеричные цифры являются цифры от 0 до 9 и буквы A – F или a-f.  
  
   
  
## Examples  
 В следующем примере определяется ли символ шестнадцатеричным и, если это так, выводит на консоль соответствующее десятичное значение.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberSignature Language="F#" Value="static member IsHexEncoding : string * int -&gt; bool" Usage="System.Uri.IsHexEncoding (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pattern">Проверяемая строка.</param>
        <param name="index">Расположение в параметре <paramref name="pattern" /> для проверки на принадлежность к шестнадцатеричной кодировке.</param>
        <summary>Определяет, является ли кодировка символа шестнадцатеричной.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если кодировка <paramref name="pattern" /> в указанном положении является шестнадцатеричной; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsHexEncoding%2A> Метод проверяет на принадлежность к шестнадцатеричной кодировке, соответствующим шаблону «% hexhex» в строке, где «hex» — цифра от 0 до 9 и буквы от A до F (без учета регистра).  
  
   
  
## Examples  
 В следующем примере кода определяет, является ли символ шестнадцатеричной и, если да, выводит на консоль эквивалентный символ.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoopback : bool" Usage="System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, ссылается ли заданный <see cref="T:System.Uri" /> на локальный узел.</summary>
        <value>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если этот <see cref="T:System.Uri" /> ссылается на локальный узел; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A> Возвращает `true` URI, указанный при создании этого экземпляра в случае 127.0.0.1, замыкания на себя, или localhost, или если URI не указывает данные (например, file:///c:Dir/file.txt) узла. Все прочие возвращают идентификаторы URI `false`.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и определяет, ссылается ли он на локальном узле.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsReservedCharacter : char -&gt; bool&#xA;override this.IsReservedCharacter : char -&gt; bool" Usage="uri.IsReservedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="character">Объект <see cref="T:System.Char" /> для проверки.</param>
        <summary>Возвращает значение, позволяющее определить, является ли заданный символ зарезервированным знаком.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если указанный символ является зарезервированным знаком; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnc : bool" Usage="System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли заданный <see cref="T:System.Uri" /> UNC-путем.</summary>
        <value>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если экземпляр <see cref="T:System.Uri" /> является UNC-путем; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsUnc%2A> Свойство `true` Если указанного <xref:System.Uri> экземпляр является UNC-путь (например \\\server\folder или file://server/folder). Это свойство всегда возвращает `true` Если есть file:// схема URI и задает компонент узла.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и определяет, является ли путь в формате UNC.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberSignature Language="F#" Value="member this.IsWellFormedOriginalString : unit -&gt; bool" Usage="uri.IsWellFormedOriginalString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Указывает, является ли формат строки, использовавшейся для создания данного <see cref="T:System.Uri" />, правильным и не требующим дальнейшего преобразования в escape-последовательность.</summary>
        <returns>Значение <see langword="true" />, если строка имеет правильный формат; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строка считается правильным форматом в соответствии с RFC 2396 и RFC 2732 по умолчанию. Если включен международных идентификаторов ресурсов (IRI) или синтаксический анализ международных доменных имен (IDN), строка считается правильным форматом в соответствии с RFC 3986 и RFC 3987  
  
 Строка считается неправильным, в результате чего метод возвращает значение false, при возникновении любого из следующих условий.  
  
|Error|Пример|  
|-----------|-------------|  
|Строка экранировано неправильно.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Имя|  
|Строка является абсолютным <xref:System.Uri> , представляющий файл неявное <xref:System.Uri>.|c:\\\directory\filename|  
|Эта строка является абсолютным URI, не содержит косую черту перед путем.|file://c:/Directory/filename|  
|Строка содержит символы без escape-символов обратной косой черты, даже если они рассматриваются как символы косой черты.|http:\\\host/path/file|  
|Строка представляет иерархическую абсолютное <xref:System.Uri> и не содержит «://».|www.contoso.com/path/file|  
|Средство синтаксического анализа для <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> означает, что исходная строка не правильного формата.|Пример зависит от схемы URI.|  
  
 По умолчанию строки, использовавшейся для создания данного <xref:System.Uri> считаются правильно сформированными в соответствии с RFC 2396 и RFC 2732.  
  
 При включении международного кода ресурса (IRI) и поддержка международных доменных имен (IDN), строка, используемая для построения данного <xref:System.Uri> считаются правильно сформированными в соответствии с RFC 3986 и RFC 3987. Используется для поддержки IRI имена Punicode содержат только символы ASCII и всегда начинаются с префикса xn--.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" <xref:System.Uri> класса.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://www.ietf.org/">Internet Engineering Task Force (IETF)</related>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="static member IsWellFormedUriString : string * UriKind -&gt; bool" Usage="System.Uri.IsWellFormedUriString (uriString, uriKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uriKind" Type="System.UriKind" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uriString">Строка, используемая при попытке создания объекта <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Тип объекта <see cref="T:System.Uri" /> в параметре <paramref name="uriString" />.</param>
        <summary>Указывает, является ли правильным формат данной строки, пытаясь создать на ее основе универсальный код ресурса и проверяя, не требуется ли для нее дополнительное преобразование в escape-последовательность.</summary>
        <returns>Значение <see langword="true" />, если строка имеет правильный формат; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В версиях .NET до версии 4.5 по умолчанию строки считаются правильно сформированными в соответствии с RFC 2396 и RFC 2732. Если включены международных идентификаторов ресурсов (IRI) или синтаксический анализ международных доменных имен (IDN), строка считаются правильно сформированными в соответствии с RFC 3986 и RFC 3987.  
  
 Начиная с .NET 4.5, строки всегда считаются правильно сформированными в соответствии с RFC 3986 и RFC 3987, ли IRI и IDN включены. Обратите внимание, что это только значение true для приложений, предназначенных для .NET 4.5 или более поздней версии. Приложений, предназначенных для .NET 4.0 вызова кода совместимости, а старое поведение (версий до 4.5).  
  
 Строка считается неправильным, в результате чего метод возвращает значение false, при возникновении любого из следующих условий  
  
|Error|Пример|  
|-----------|-------------|  
|Строка экранировано неправильно.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Имя|  
|Строка является абсолютным <xref:System.Uri> , представляющий файл неявное <xref:System.Uri>.|c:\\\directory\filename|  
|Эта строка является абсолютным URI, не содержит косую черту перед путем.|file://c:/Directory/filename|  
|Строка содержит символы без escape-символов обратной косой черты, даже если они будут рассматриваться как символы косой черты|http:\\\host/path/file|  
|Строка представляет иерархическую абсолютное <xref:System.Uri> и не содержит «://»|www.contoso.com/path/file|  
|Средство синтаксического анализа для <xref:System.Uri.Scheme%2A> означает, что исходная строка не правильного формата.|Пример зависит от схемы URI.|  
|Начиная с .NET 4.5, относительные URI с запятой (":") в первом сегменте не учитываются правильного формата.|2013.05.29_14:33:41|  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" <xref:System.Uri> класса.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://www.ietf.org/">Internet Engineering Task Force (IETF)</related>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalPath : string" Usage="System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает представление имени файла в локальной операционной системе.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий представление имени файла в локальной операционной системе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством без escape-последовательности. Если путь является путем к файлу Windows, все символы косой черты (/) заменяются обратными косыми чертами (\\).  
  
 Для URI `file://computer/file.ext`, абсолютный путь является `/file.ext` и локальный путь `\\computer\file.ext`.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и выводит на консоль локальный путь.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelative : Uri -&gt; string" Usage="uri.MakeRelative toUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="toUri">Универсальный код ресурса для сравнения с текущим универсальным кодом ресурса.</param>
        <summary>Определяет разницу между двумя экземплярами класса <see cref="T:System.Uri" />.</summary>
        <returns>Если имена узлов и схемы данного экземпляра универсального кода ресурса и <paramref name="toUri" /> совпадают, этот метод возвращает объект <see cref="T:System.String" />, представляющий относительный универсальный код ресурса, добавление которого в конец текущего экземпляра универсального кода ресурса даст параметр <paramref name="toUri" />.  
  
Если имена узлов и схемы отличаются, этот метод возвращает объект <see cref="T:System.String" />, представляющий параметр <paramref name="toUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице показаны экземпляра универсального кода Ресурса, `toUri`и результат вызова метода <xref:System.Uri.MakeRelative%2A>.  
  
|Текущий экземпляр|`toUri`|Возвращаемое значение|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|Test/Test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 Сведения о пользователе, если они присутствуют в URI, учитывается.  
  
   
  
## Examples  
 В следующем примере создается 2 <xref:System.Uri> экземпляров. Разница в сведения о пути записывается в консоль.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toUri" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а этот метод допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelativeUri : Uri -&gt; Uri" Usage="uri.MakeRelativeUri uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri">Универсальный код ресурса для сравнения с текущим универсальным кодом ресурса.</param>
        <summary>Определяет разницу между двумя экземплярами класса <see cref="T:System.Uri" />.</summary>
        <returns>Если имя узла и схема данного экземпляра универсального кода ресурса и <paramref name="uri" /> совпадают, этот метод возвращает относительный <see cref="T:System.Uri" />, который при добавлении к его концу текущего экземпляра универсального кода ресурса превратится в <paramref name="uri" />.  
  
Если имена узлов и схемы отличаются, этот метод возвращает объект <see cref="T:System.Uri" />, представляющий параметр <paramref name="uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице показаны экземпляра универсального кода Ресурса, `toUri`и результат вызова метода <xref:System.Uri.MakeRelativeUri%2A>.  
  
|Текущий экземпляр|`toUri`|Возвращаемое значение|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|Test/Test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 Сведения о пользователе, если они присутствуют в URI, учитывается.  
  
   
  
## Examples  
 В следующем примере создается 2 <xref:System.Uri> экземпляров. Разница в сведения о пути записывается в консоль.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uri" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Uri * Uri -&gt; bool" Usage="uri1 = uri2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uri2" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri1">Экземпляр <see cref="T:System.Uri" /> для сравнения с <paramref name="uri2" />.</param>
        <param name="uri2">Экземпляр <see cref="T:System.Uri" /> для сравнения с <paramref name="uri1" />.</param>
        <summary>Определяет, равны ли значения двух экземпляров <see cref="T:System.Uri" />.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если экземпляры <see cref="T:System.Uri" /> эквивалентны; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка использует <xref:System.Uri.Equals%2A> метод для определения ли два <xref:System.Uri> экземпляра эквивалентны. <xref:System.Uri.UserInfo%2A> и <xref:System.Uri.Fragment%2A> содержимого учитывается при выполнении сравнения.  
  
   
  
## Examples  
 В этом примере создаются три <xref:System.Uri> экземпляров из строк и сравнивает их, чтобы определить, представляют ли они то же значение. `Address1` и `Address2` являются одинаковыми, поскольку <xref:System.Uri.Fragment%2A> часть, представляющая игнорируется для сравнения. Результат записывается в консоль.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Uri * Uri -&gt; bool" Usage="System.Uri.op_Inequality (uri1, uri2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uri2" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri1">Экземпляр <see cref="T:System.Uri" /> для сравнения с <paramref name="uri2" />.</param>
        <param name="uri2">Экземпляр <see cref="T:System.Uri" /> для сравнения с <paramref name="uri1" />.</param>
        <summary>Определяет, не равны ли значения двух экземпляров <see cref="T:System.Uri" />.</summary>
        <returns>Значение <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если два экземпляра <see cref="T:System.Uri" /> не равны; в противном случае — значение <see langword="false" />. Если значение одного из параметров равно <see langword="null" />, этот метод возвращает значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка использует <xref:System.Uri.Equals%2A> метод для определения ли два <xref:System.Uri> экземпляров не эквивалентны. <xref:System.Uri.UserInfo%2A> и <xref:System.Uri.Fragment%2A> содержимого учитывается при выполнении сравнения.  
  
   
  
## Examples  
 В этом примере создаются три <xref:System.Uri> экземпляров из строк и сравнивает их, чтобы определить, представляют ли они то же значение. `Address2` и `Address3` не совпадают, так как `Address3` содержит <xref:System.Uri.Query%2A> , не найден в `Address2`. Результат записывается в консоль.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalString : string" Usage="System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает исходную строку универсального кода ресурса, переданную в конструктор <see cref="T:System.Uri" />.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий точный универсальный код ресурса, указанный при создании этого экземпляра; в противном случае — <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если URI, указанного в конструктор содержит начальные или конечные пробелы, эти пробелы сохраняются.  
  
 Значение, возвращаемое этим свойством, отличается от <xref:System.Uri.ToString%2A> и <xref:System.Uri.AbsoluteUri%2A>. <xref:System.Uri.ToString%2A> Возвращает канонически escape-последовательность URI. <xref:System.Uri.AbsoluteUri%2A> Возвращает канонически escape-формате URI.  
  
 Если включена поддержка международного кода ресурса (IRI) и международных доменных имен (IDN), <xref:System.Uri.OriginalString%2A> Возвращает исходную не нормализованную строку с именем узла Punycode, если один, использовавшийся для инициализации <xref:System.Uri> экземпляра. Имена Punicode содержат только символы ASCII и всегда начинаются с префикса "xn--".  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" <xref:System.Uri> класса.  
  
 Когда <xref:System.Uri> объекта также сериализуется <xref:System.Uri.OriginalString%2A> не сохраняется. Процесс сериализации использует полностью escape- и канонический <xref:System.Uri.AbsoluteUri%2A> свойство при сериализации. Для <xref:System.Uri> , содержащей IPv6-адрес, IPv6-адреса и идентификатора области включены в сериализованной <xref:System.Uri> объекта.  
  
   
  
## Examples  
 В следующем примере создается новый <xref:System.Uri> экземпляр из строки. Этот пример иллюстрирует разницу между значение, возвращаемое из <xref:System.Uri.OriginalString%2A>, который возвращает строку, которая была передана в конструктор и из-за обращения к <xref:System.Uri.ToString%2A>, который возвращает каноническую форму строки.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; unit&#xA;override this.Parse : unit -&gt; unit" Usage="uri.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Анализирует универсальный код ресурса текущего экземпляра и проверяет, действительно ли этот код содержит все обязательные части допустимого универсального кода ресурса.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">Переданный из конструктора URI недопустим.</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathAndQuery : string" Usage="System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает свойства <see cref="P:System.Uri.AbsolutePath" /> и <see cref="P:System.Uri.Query" />, разделенные вопросительным знаком (?).</summary>
        <value>Объект <see cref="T:System.String" />, содержащий свойства <see cref="P:System.Uri.AbsolutePath" /> и <see cref="P:System.Uri.Query" />, разделенные вопросительным знаком (?).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.PathAndQuery%2A> Содержит абсолютный путь на сервере, а также данные запроса, отправленная с запросом. Она идентична объединения <xref:System.Uri.AbsolutePath%2A> и <xref:System.Uri.Query%2A> свойства.  
  
 <xref:System.Uri.PathAndQuery%2A> Свойство, экранируется в соответствии с RFC 2396 по умолчанию. Если включен международных идентификаторов ресурсов (IRI) или синтаксический анализ международных доменных имен (IDN), <xref:System.Uri.PathAndQuery%2A> свойство, экранируется в соответствии с RFC 3986 и RFC 3987.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" <xref:System.Uri> класса.  
  
   
  
## Examples  
 Следующий пример записывает пути URI (/ catalog/shownew.htm) и запросов (дата = сегодня) сведения на консоль.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Port : int" Usage="System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает номер порта данного универсального кода ресурса.</summary>
        <value>Значение типа <see cref="T:System.Int32" />, в котором содержится номер порта для данного универсального кода ресурса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Номер порта определяет порт, протокол, используемый для соединения с сервером, на который ссылается URI. Если порт не указан как часть URI, <xref:System.Uri.Port%2A> свойство возвращает значение по умолчанию для протокола. Если номер порта по умолчанию, это свойство возвращает значение -1.  
  
   
  
## Examples  
 Следующий пример записывает номер порта URI в консоль. В этом случае значение — номер порта по умолчанию для протокола HTTP, порт 80.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Query : string" Usage="System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает любые сведения запроса, включенные в заданный универсальный код ресурса.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий какие-либо сведения запроса, включенные в заданный универсальный код ресурса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Query%2A> Свойство содержит все сведения запроса, включенные в URI. Сведения о запросе отделяется от сведений пути знак вопроса (?) и продолжается до конца URI. Возвращаемые сведения запроса включают начальный вопросительный знак.  
  
 Данные запроса, экранируется в соответствии с RFC 2396 по умолчанию. Если выполняется синтаксический анализ международных доменных имен (IDN) или международных идентификаторов ресурсов (IRI), данные запроса преобразуются в соответствии с RFC 3986 и RFC 3987.  
  
 Дополнительные сведения о поддержке IRI см. в разделе "Примечания" <xref:System.Uri> класса.  
  
   
  
## Examples  
 Следующий пример записывает запрос? date = today на консоль.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя схемы для данного универсального кода ресурса.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий схему для данного универсального кода ресурса, преобразованного в нижний регистр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Scheme%2A> Свойство возвращает схему, используемую для инициализации <xref:System.Uri> экземпляра. Это свойство указывает, что схема, используемый для инициализации <xref:System.Uri> экземпляра был распознан.  
  
 В следующей таблице показаны примеры некоторых возможных значений, возвращенных <xref:System.Uri.Scheme%2A> свойство.  
  
|Схема|Описание|  
|------------|-----------------|  
|файл|Ресурс — это файл на локальном компьютере.|  
|ftp|Ресурсу осуществляется по протоколу FTP.|  
|gopher|Ресурсу осуществляется по протоколу Gopher.|  
|http|Ресурсу осуществляется по протоколу HTTP.|  
|https|Ресурсу осуществляется по протоколу HTTP с SSL-шифрованием.|  
|LDAP|Ресурсу осуществляется по протоколу LDAP.|  
|mailto|Ресурс является адресом электронной почты и получить доступ по протоколу SMTP.|  
|net.pipe|Ресурсу осуществляется по именованному каналу.|  
|net.tcp|Ресурс становится доступным из конечной точки TCP.|  
|news|Ресурсу осуществляется по протоколу NNTP.|  
|NNTP|Ресурсу осуществляется по протоколу NNTP.|  
|telnet|Ресурсу осуществляется по протоколу TELNET.|  
|uuid|Ресурсу осуществляется посредством уникального имени конечной точки UUID для взаимодействия со службой.|  
  
   
  
## Examples  
 В следующем примере имя схемы (http) записывается в консоль для http://www.contoso.com/ URI.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable SchemeDelimiter : string" Usage="System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет символы, отделяющие схему протокола передачи данных от адресной части универсального кода ресурса. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается строка из <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>и адрес. Объект <xref:System.Uri> затем создается экземпляр из строки.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Segments : string[]" Usage="System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает массив, содержащий сегменты пути, которые образуют указанный универсальный код ресурса.</summary>
        <value>Массив <see cref="T:System.String" />, содержащий сегменты пути, которые образуют указанный универсальный код ресурса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Segments%2A> Свойство возвращает массив строк, содержащий «сегменты» (подстроки), которые формируют абсолютный путь URI. Первый сегмент получается путем анализа абсолютного пути из ее первого символа, пока не достигнете косая черта (/) или в конце пути. Каждый дополнительный сегмент начинается с первого символа после предыдущего сегмента и заканчивается следующий символ косой черты или в конце пути. (Абсолютный путь URI содержит все, что после узла и порта и перед запросом и фрагментом).  
  
 В следующем примере абсолютные пути и сегменты двух URI. Во втором примере показано, что фрагмент и запрос не являются частью абсолютный путь и поэтому не являются сегментами.  
  
 Абсолютный URI:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 Абсолютный путь:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Сегменты:  
 - /
 - Главы /
 - Chapter1 /
 - Разделы /
 - Section1.htm  
  
 Абсолютный URI:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO  
  
 Абсолютный путь:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Сегменты:  
 - /
 - Главы /
 - Chapter1 /
 - Разделы /
 - Section1.htm  
  
 Обратите внимание, что поскольку абсолютный путь начинается с «/», первый сегмент содержит его и ничего более.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляр с 3 сегментов и выводятся на экран.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, который содержит сведения, требуемые для сериализации коллекции <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий исходный объект и объект назначения для сериализованного потока, связанного с коллекцией <see cref="T:System.Uri" />.</param>
        <summary>Возвращает данные, необходимые для сериализации текущего экземпляра.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы использовать методы сериализации. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uri.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает каноническое строковое представление заданного экземпляра <see cref="T:System.Uri" />.</summary>
        <returns>Экземпляр <see cref="T:System.String" />, содержащий каноническое представление экземпляра <see cref="T:System.Uri" /> без преобразования в escape-последовательность. В escape-последовательность преобразовываются только знаки #, ? и %.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строка, возвращаемая этим методом содержит сведения о порте при порт является портом по умолчанию для схемы.  
  
> [!NOTE]
>  Строка, возвращаемая <xref:System.Uri.ToString%2A> метод может содержать управляющие символы, которые могут привести к повреждению состояния консольного приложения. Можно использовать <xref:System.Uri.GetComponents%2A> метод с <xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType> формат для удаления управляющие символы из возвращаемой строки.  
  
   
  
## Examples  
 В следующем примере создается новый <xref:System.Uri> экземпляр из строки. Этот пример иллюстрирует разницу между значение, возвращаемое из <xref:System.Uri.OriginalString%2A>, который возвращает строку, которая была передана в конструктор и из-за обращения к <xref:System.Uri.ToString%2A>, который возвращает каноническую форму строки.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы запретить наследование от частично доверенного кода <see cref="T:System.Uri" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр <see cref="T:System.Uri" />. Не создает исключение, если не удается создать <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : string * UriKind *  -&gt; bool" Usage="System.Uri.TryCreate (uriString, uriKind, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uriKind" Type="System.UriKind" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Uri" RefType="out" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uriString">Объект типа <see cref="T:System.String" />, представляющий объект <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Тип универсального кода ресурса.</param>
        <param name="result">При возврате этим методом он содержит сконструированный <see cref="T:System.Uri" />.</param>
        <summary>Создает новый <see cref="T:System.Uri" />, используя заданный экземпляр <see cref="T:System.String" /> и <see cref="T:System.UriKind" />.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если <see cref="T:System.Uri" /> успешно создан; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод возвращает `true`, новый <xref:System.Uri> в `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * string *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="relativeUri" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Uri" RefType="out" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="baseUri">Базовый <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Относительный <see cref="T:System.Uri" />, представленный в виде <see cref="T:System.String" />, для добавления к базовому <see cref="T:System.Uri" />.</param>
        <param name="result">При возврате данным методом содержит <see cref="T:System.Uri" />, составленный из значений <paramref name="baseUri" /> и <paramref name="relativeUri" />. Этот параметр передается неинициализированным.</param>
        <summary>Создает новый <see cref="T:System.Uri" />, используя заданные экземпляры базового и относительного <see cref="T:System.String" />.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если <see cref="T:System.Uri" /> успешно создан; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод возвращает `true`, новый <xref:System.Uri> в `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * Uri *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="relativeUri" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Uri" RefType="out" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="baseUri">Базовый <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Относительный <see cref="T:System.Uri" /> для добавления к базовому <see cref="T:System.Uri" />.</param>
        <param name="result">При возврате данным методом содержит <see cref="T:System.Uri" />, составленный из значений <paramref name="baseUri" /> и <paramref name="relativeUri" />. Этот параметр передается неинициализированным.</param>
        <summary>Создает новый <see cref="T:System.Uri" />, используя заданные экземпляры базового и относительного <see cref="T:System.Uri" />.</summary>
        <returns>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если <see cref="T:System.Uri" /> успешно создан; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод возвращает `true`, новый <xref:System.Uri> в `result`.  
  
 Этот метод создает URI, помещает его в канонической форме и проверяет его. При возникновении необработанного исключения, этот метод перехватывает его. Если вы хотите создать <xref:System.Uri> и get исключения используйте один из <xref:System.Uri.%23ctor%2A> конструкторы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member Unescape : string -&gt; string&#xA;override this.Unescape : string -&gt; string" Usage="uri.Unescape path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Преобразуемый объект <see cref="T:System.String" />.</param>
        <summary>Преобразует указанную строку, заменив все escape-последовательности их представлениями, к которым не было применено escape-преобразование.</summary>
        <returns>Объект <see cref="T:System.String" />, содержащий значение параметра <paramref name="path" />, не преобразованное в escape-последовательность.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberSignature Language="F#" Value="static member UnescapeDataString : string -&gt; string" Usage="System.Uri.UnescapeDataString stringToUnescape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">Строка, для которой нужно отменить преобразование в escape-представление.</param>
        <summary>Отменяет преобразование строки в escape-представление.</summary>
        <returns>Структура <see cref="T:System.String" />, содержащая структуру <paramref name="stringToUnescape" />, для которой было отменено escape-преобразование.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать с осторожностью. Строка, которая была ранее, при этом может привести к неоднозначности и ошибки.  
  
 Многие веб-браузеры escape-преобразование пробелов внутри URI в знак плюс («"+»") символов. Тем не менее метод UnescapeDataString не преобразует знак плюс в пробелы, так как это поведение не является стандартным для всех схем URI.  
  
   
  
## Examples  
 В следующем примере кода отменяет преобразование преобразованных URI, а затем преобразует любой знак плюс («+») в пробелы.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToUnescape" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFile : string" Usage="System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что универсальный код ресурса является указателем на файл. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В .NET Framework версии 1.1 "`file:///path`«URI было преобразовано в»`file:/path`«. Эта проблема была исправлена в версии 2.0.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и определяет, является ли схема <xref:System.Uri.UriSchemeFile>.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFtp : string" Usage="System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса доступен по протоколу FTP. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и определяет, является ли схема <xref:System.Uri.UriSchemeFtp>.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeGopher : string" Usage="System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса доступен по протоколу Gopher. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и определяет, является ли схема <xref:System.Uri.UriSchemeGopher>.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttp : string" Usage="System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса доступен по протоколу HTTP. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и определяет, является ли схема <xref:System.Uri.UriSchemeHttp>.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttps : string" Usage="System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса доступен по протоколу HTTPS. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и определяет, является ли схема <xref:System.Uri.UriSchemeHttps>.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeMailto : string" Usage="System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса представляет адрес электронной почты и доступен по протоколу SMTP. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и определяет, является ли схема <xref:System.Uri.UriSchemeMailto>.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetPipe : string" Usage="System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что доступ к универсальному коду ресурса осуществляется через схему NetPipe, используемую Windows Communication Foundation (WCF). Это поле доступно только для чтения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetTcp : string" Usage="System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что доступ к универсальному коду ресурса осуществляется через схему NetTcp, используемую Windows Communication Foundation (WCF). Это поле доступно только для чтения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNews : string" Usage="System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса представляет группу новостей Интернета и доступен по протоколу NNTP. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и определяет, является ли схема <xref:System.Uri.UriSchemeNews>.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNntp : string" Usage="System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что данный универсальный код ресурса представляет группу новостей Интернета и доступен по протоколу NNTP. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NNTP <xref:System.Uri> ошибки синтаксического анализа в .NET Framework версии 1.1 были исправлены.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и определяет, является ли схема <xref:System.Uri.UriSchemeNntp>.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserEscaped : bool" Usage="System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на то, что строка универсального кода ресурса не была полностью преобразована в escape-последовательность перед созданием экземпляра класса <see cref="T:System.Uri" />.</summary>
        <value>Значение типа <see cref="T:System.Boolean" />, которое равно <see langword="true" />, если при создании экземпляра <paramref name="dontEscape" /> для параметра <see langword="true" /> было задано значение <see cref="T:System.Uri" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.UserEscaped%2A> Свойству `true` для указания, что строка, используемая для создания <xref:System.Uri> экземпляр был полностью escape-последовательность перед передачей в конструктор, то есть, `dontEscape` вызова конструктора имеет значение `true`.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и определяет ли он был полностью экранировать при его создании.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInfo : string" Usage="System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя пользователя, пароль или другие связанные с пользователем сведения, которые соответствуют заданному универсальному коду ресурса.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий сведения о пользователе, связанные с данным универсальным кодом ресурса. Возвращаемое значение не содержит знак "@", зарезервированный для отделения части универсального кода ресурса, в которой указываются сведения о пользователе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, обычно имеет формат «имя пользователя: пароль».  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Uri> экземпляра и записывает сведения о пользователе в консоль.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот экземпляр представляет относительный URI, а это свойство допустимо использовать только для абсолютных URI.</exception>
      </Docs>
    </Member>
  </Members>
</Type>