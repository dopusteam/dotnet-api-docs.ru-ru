<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ee56099641516cbb76418e5c30c6cb4a8ffe9098" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58462116" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет текст как последовательность из частей кода UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Строка является упорядоченной коллекции символов, который используется для представления текста. Объект <xref:System.String> объект является упорядоченной коллекции <xref:System.Char?displayProperty=nameWithType> объекты, представляющие строку; <xref:System.Char?displayProperty=nameWithType> соответствует единицу кода UTF-16. Значение <xref:System.String> объекта заключается в содержании упорядоченной коллекции <xref:System.Char?displayProperty=nameWithType> объекты, и что значение является неизменяемым (то есть это только для чтения). Дополнительные сведения о неизменность строк, см. в разделе [неизменность и класс StringBuilder](#Immutability) подразделе данного раздела. Максимальный размер <xref:System.String> объект в памяти — 2 ГБ, около 1 миллиарда символы.  
  
[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 Содержание  
  
 [Создание экземпляра объекта строки](#Instantiation)   
 [Объекты char и символы Юникода](#Characters)   
 [Строки и стандарт Юникода](#Unicode)   
 [Строки и внедренные символы null](#EmbeddedNulls)   
 [Строки и индексы](#Indexes)   
 [Строки NULL и пустые строки](#Nulls)   
 [Неизменность и класса StringBuilder](#Immutability)   
 [Порядковый номер и операций с учетом языка и региональных параметров](#CultureSensitive)   
 [Нормализация](#Normalization)   
 [Операции со строками по категориям](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Создание экземпляра объекта строки  
 Можно создать экземпляр <xref:System.String> объект одним из следующих способов:  
  
-   Назначив строковый литерал <xref:System.String> переменной. Это наиболее часто используемый метод для создания строки. В следующем примере присваивания используется для создания нескольких строк. Обратите внимание, что в C#, так как обратная косая черта (\\) является escape-символа, необходимо экранировать символы обратной косой черты, литерал в строке или вся строка должны быть @-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Путем вызова <xref:System.String> конструктора класса. В следующем примере создается строк путем вызова несколько конструкторов класса. Обратите внимание, что некоторые конструкторы включают указатели на массивы символов или байт со знаком массивов в качестве параметров. Visual Basic не поддерживает вызовы этих конструкторов. Подробные сведения о <xref:System.String> конструкторы, см. в разделе <xref:System.String.%23ctor%2A> конструктор сводки.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp-interactive[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   С помощью оператора объединения строк (+ в C# и & или + в Visual Basic) для создания одной строки из любого сочетания <xref:System.String> экземпляров и строковые литералы. Следующий пример иллюстрирует использование оператора объединения строк.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Путем получения свойства или вызов метода, который возвращает строку. В следующем примере используется методы класса <xref:System.String> класса для извлечения подстроки в строку большего размера.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   С помощью метода форматирования для преобразования значения или объекта в строковое представление. В следующем примере используется [составное форматирование](~/docs/standard/base-types/composite-formatting.md) возможность внедрить строковую презентацию два объекта в строку.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp-interactive[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Объекты char и символы Юникода  
 Каждый символ в строке определяется скалярное значение Юникод, которые также называют кодовую точку Юникода или порядковый номер (числовое) значение символа Юникода. Каждую кодовую точку кодируется, используя кодировку UTF-16, а числовое значение каждого элемента кодировки представлен <xref:System.Char> объекта.  
  
> [!NOTE]
>  Обратите внимание, что, поскольку <xref:System.String> экземпляра состоит из упорядоченной коллекции частей кода UTF-16, можно создать <xref:System.String> объект, который не является правильным форматом строки Юникода. Например можно создать строки, которая содержит младшим символом-заместителем без соответствующего старшим символом-заместителем. Несмотря на то что некоторые методы, такие как методы кодирования и декодирования объектов в <xref:System.Text> пространства имен, может выполняет проверку, чтобы убедиться, что строки сформированы, <xref:System.String> члены класса не гарантируют, что строка имеет правильный формат.  
  
 Один <xref:System.Char> объект обычно представляет отдельную кодовую точку, то есть числовое значение <xref:System.Char> равно кодовой точке. Например, кодовая точка для символа «» разрешается 0061 U +. Однако кодовую точку может потребоваться более одного элемента кодировки (более одного <xref:System.Char> объекта). Стандарт Юникод определяет два типа символов, которые соответствуют к нескольким <xref:System.Char> объектов: graphemes и добавочные кодовые позиции Юникода, соответствующие символы в плоскостей Юникода.  
  
-   Графем представляется базового символа, за которыми следует один или несколько символов объединения. Например, символ д представлен объект <xref:System.Char> объект, которого кодовая точка U + 0061 следуют объект <xref:System.Char> объект, которого кодовая точка U + 0308. Также этот символ можно определить с помощью одной <xref:System.Char> объект с кодовой точкой U + 00E4. Как в следующем примере показано, учитывающего культуру сравнения на равенство указывает, что эти два представления равны, несмотря на то, что обычные порядковое сравнение — нет. Тем не менее если две строки были нормализованы, порядковое сравнение также указывает, что они равны. (Дополнительные сведения о нормализации строк, см. в разделе [нормализации](#Normalization) разделе.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Юникода, представленный добавочную кодовую позицию (суррогатная пара) <xref:System.Char> объект которого кодовая точка является заместителем, за которым следует <xref:System.Char> объект которого кодовая точка является младшим символом-заместителем. Единицы кода высокой суррогаты в диапазоне от U + D800 до U + DBFF. Единицы кода низкой суррогаты в диапазоне от U + DC00 до U + DFFF. Суррогатные пары используются для представления символов в 16 плоскостей Юникода. В следующем примере символ-заместитель создает и передает его <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> метод, чтобы определить, является ли оно суррогатную пару.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Строки и стандарт Юникода  
 Символы в строке, представляются частей кода в кодировке UTF-16, которые соответствуют <xref:System.Char> значения.  
  
 Каждый символ в строке имеет категории символов связанные Юникода, представленный в .NET с <xref:System.Globalization.UnicodeCategory> перечисления. Категория символ или суррогатную пару можно определить путем вызова <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> метод.  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 Кроме того платформа .NET поддерживает сравнения строк и сортировку на основе Юникода стандарта. В версиях .NET Framework с помощью [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], .NET Framework поддерживает собственную таблицу строковых данных. Это справедливо также для версии платформы .NET Framework, начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)] под управлением Windows 7. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)] под управлением Windows 8 и более поздних версиях операционной системы Windows, среда выполнения делегаты строка сравнения и сортировки в операционную систему. Сравнение строк в .NET Core, и сортировка данных предоставляется компанией [International компоненты для Юникода](http://site.icu-project.org/) библиотеки. Ниже перечислены версии платформы .NET и версии стандарта Юникод, на какой символ основаны сравнение и сортировка.  
  
|Версия .NET|Версия стандарта Юникод|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Стандарт Юникод, версия 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Стандарт Юникод, версия 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Стандарт Юникод, версия 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Стандарт Юникод, версия 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] и более поздних версий на Windows 7|[Стандарт Юникод, версия 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] и более поздних версий на Windows 8 и более поздних операционных системах Windows|[Стандарт Юникод, версия 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET Core (все версии)|Зависит от версии стандарта Юникода, поддерживаемой базовой операционной системой.|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Строки и внедренные символы null  
 В .NET <xref:System.String> объект может содержать внедренные символы null, которые считаются частью длину строки. Тем не менее в некоторых языках, таких как C и C++, символ null указывает на конец строки; он не является частью строки и не считаются частью длину строки. Это означает, что следующие общие предположения, которые программисты C и C++ или библиотек, написанных на C или C++ могут сделать сведения о строках не непременно являются допустимыми при применении к <xref:System.String> объектов:  
  
-   Значение, возвращенное `strlen` или `wcslen` функций не обязательно равно <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   Строка, созданная по `strcpy_s` или `wcscpy_s` функций не обязательно идентичен строку, созданную путем <xref:System.String.Copy%2A?displayProperty=nameWithType> метод.  
  
 Следует убедиться, что машинного кода C и C++, создающий экземпляр <xref:System.String> объекты и код, который передается <xref:System.String> объектов посредством вызова, не следует предполагать, что внедренный символ null отмечает конец строки.  
  
 Когда строка сортировки (или по сравнению с), и при поиске строки внедренные символы null в строке также обрабатываются по-разному. Символы NULL учитываются при выполнении сравнения с учетом языка и региональных параметров между двумя строками, включая сравнение с использованием инвариантного языка и региональных параметров. Они учитываются только порядковые сравнения порядковыми, так и без учета регистра. С другой стороны, внедренные символы null всегда считаются при поиске строки с методами, например <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, и <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Строки и индексы  
 Индекс — это положение <xref:System.Char> объекта (а не символ Юникода) в <xref:System.String>. Индекс является неотрицательным число, которое начинается с первого знака в строке, равно нулю. Ряд методов поиска такие как <xref:System.String.IndexOf%2A> и <xref:System.String.LastIndexOf%2A>, возврата индекса символа или подстроки в экземпляре строки.  
  
 <xref:System.String.Chars%2A> Свойство позволяет получить доступ к отдельным <xref:System.Char> объекты по их позиции индекса в строке. Так как <xref:System.String.Chars%2A> свойство является свойством по умолчанию (в Visual Basic) или индексатор (для C#), вы можете получить доступ к отдельные <xref:System.Char> объектов в строке, используя следующий код. Этот код ищет пробелы или знаки препинания в строке, чтобы определить, сколько слов, строка содержит.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Так как <xref:System.String> класс реализует <xref:System.Collections.IEnumerable> интерфейс, можно также выполнить итерацию <xref:System.Char> объектов в строке с помощью `foreach` конструкцию, как показано в следующем примере.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Номер индекса может не соответствовать последовательных символов Юникода, так как знак Юникода может быть закодирован несколькими <xref:System.Char> объекта. В частности строка может содержать Многосимвольная единицы текста, которые образуются базовый символ, за следует один или несколько несамостоятельных символов или суррогатные пары. Для работы с символами Юникода, а не <xref:System.Char> объекты, используют <xref:System.Globalization.StringInfo?displayProperty=nameWithType> и <xref:System.Globalization.TextElementEnumerator> классы. В следующем примере показано различие между кодом, который работает с <xref:System.Char> объекты и код, который работает с символами Юникода. Он сравнивает число символов или элементов текста в каждое слово предложения. Строка состоит из двух последовательностей базового символа, за которым следует символ объединения.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 Этот пример работает с элементами текста с помощью <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> метод и <xref:System.Globalization.TextElementEnumerator> для перечисления всех текстовых элементов в строке. Можно также получить массив, содержащий начальный индекс каждого элемента текста, вызвав <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о работе с единицы текста, а не отдельные <xref:System.Char> значения, см. в разделе <xref:System.Globalization.StringInfo> класса.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Строки NULL и пустые строки  
 Строка, который был объявлен, но не было назначено значение `null`. Попытка вызова методов для этой строки вызывает <xref:System.NullReferenceException>. Строку null отличается от пустой строкой, который является строкой, значение которого равно «» или <xref:System.String.Empty?displayProperty=nameWithType>. В некоторых случаях передачи строку null или пустую строку в качестве аргумента в вызове метода вызывает исключение. Например, передав строку "null", чтобы <xref:System.Int32.Parse%2A?displayProperty=nameWithType> вызывает метод <xref:System.ArgumentNullException>и передать пустую строку, возникает исключение <xref:System.FormatException>. В других случаях аргумента метода может быть пустой строкой или пустой строкой. Например, если вы предоставляете <xref:System.IFormattable> реализацию для класса, вы хотите сравнить строку null и указана пустая строка с Описатель общего формата («G»).  
  
 <xref:System.String> Класс включает следующие два удобных методов, которые позволяют проверить, является ли строка `null` или пуст:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, который указывает, является ли строка либо `null` или равно <xref:System.String.Empty?displayProperty=nameWithType>. Этот метод исключает необходимость использовать следующий код:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, который указывает, является ли строка `null`, равно <xref:System.String.Empty?displayProperty=nameWithType>, или содержит только пробелы. Этот метод исключает необходимость использовать следующий код:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 В следующем примере используется <xref:System.String.IsNullOrEmpty%2A> метод в <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> реализация пользовательского `Temperature` класса. Метод поддерживает строки формата «G», «C», «F» и «K». Если формат или пустой строкой формата строка, значение которого является `null` передается в метод, его значение изменяется строки формата «G».  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Неизменность и класса StringBuilder  
 Объект <xref:System.String> объект называется неизменяемый (только для чтения), так как его значение нельзя изменить после ее создания. Методы, которые могут изменить <xref:System.String> объект на самом деле возвращается новый <xref:System.String> объект, содержащий изменения.  
  
 Поскольку строки являются неизменяемыми, процедуры обработки строки, которые выполняют повторяющиеся добавлений или удалений для отображается одна строка может точные к значительному снижению производительности. Например следующий код использует генератор случайных чисел для создания строки с 1000 символов в диапазоне 0x0001 для 0x052F. Несмотря на то, что код будет использовать объединение строк для добавления нового символа в существующую строку с именем `str`, фактически создает новый <xref:System.String> объект для каждой операции объединения.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Можно использовать <xref:System.Text.StringBuilder> вместо класса <xref:System.String> класс для операций, которые вносят изменения в нескольких значения строки. В отличие от экземпляров <xref:System.String> класс, <xref:System.Text.StringBuilder> объекты являются изменяемыми; при объединения, добавления или удаления подстрок из строки, операции выполняются на одну строку. После завершения изменения значения <xref:System.Text.StringBuilder> объекта, можно вызвать его <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> метод для преобразования его в строку. В следующем примере заменяется <xref:System.String> используется в предыдущем примере для объединения 1000 случайные символы в диапазоне в 0x0001, чтобы 0x052F с <xref:System.Text.StringBuilder> объекта.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Порядковый номер и операций с учетом языка и региональных параметров  
 Членами <xref:System.String> класс оперируют порядковый номер или культуры (лингвистические) <xref:System.String> объекта. Порядковые операции выполняются над числовыми значениями каждого <xref:System.Char> объекта. Операция с учетом языка и региональных параметров при обнаружении значение <xref:System.String> объекта и принимает о регистре, сортировку, форматирование и правила синтаксического анализа в учетную запись. Операций с учетом языка и региональных параметров, выполняются в контексте объявленные явным образом языка и региональных параметров или неявное текущего языка и региональных параметров. Два вида операций может дать очень разные результаты, если они выполняются в ту же строку.  
  
.NET также поддерживает операции со строками без учета языка и региональных параметров лингвистические с использованием инвариантных региональных параметров (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), который слабо зависит от региональных параметров зависит от региона английский язык. В отличие от других <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> параметров, параметров инвариантного языка и региональных параметров будут гарантированно остаются согласованными на одном компьютере, из системы к системе и всех версий платформы .NET. Инвариантного языка и региональных параметров может быть материал в качестве своего рода черным ящиком, который обеспечивает стабильность сравнения строк и упорядочения для всех языков и региональных параметров.  
  
> [!IMPORTANT]
>  Если приложение принимает решение безопасности о символического идентификатора, такие как имя файла или именованный канал, или о материализованных данных, таких как текстовые данные в XML-файл, операцию следует использовать сравнение по порядковому номеру вместо сравнение с учетом языка и региональных параметров. Это обусловлено тем, учитывающего культуру сравнения могут выдавать различные результаты в зависимости от языка и региональных параметров, по сути, тогда как порядковое сравнение зависит только от двоичное значение сравниваемых символом.  
  
> [!IMPORTANT]
>  Большинство методов, которые выполняют операции со строками включают перегрузку, имеющую параметр типа <xref:System.StringComparison>, который позволяет указать, выполняет ли метод операцию порядковыми, так и от культуры. Как правило следует вызывать эту перегрузку, чтобы сделать назначение метода вызова. Советы и рекомендации по использованию порядковый номер, с учетом языка и региональных параметров операции со строками, см. в разделе [советы и рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 Операции для [регистр](#casing), [синтаксического анализа и форматирования](#parsing), [сравнение и сортировка](#comparison), и [проверка на равенство](#equality) может быть либо порядковый номер или зависящие от культуры. В следующих разделах рассматриваются каждой категории операции.  
  
> [!TIP]
>  Следует всегда вызывать перегрузки метода, который делает назначение метода вызова. Например, вместо вызова метода <xref:System.String.Compare%28System.String%2CSystem.String%29> метод, чтобы выполнить сравнение с учетом языка и региональных параметров двух строк с помощью правил текущего языка и региональных параметров, следует вызывать <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> метод со значением <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> для `comparisonType` аргумент. Дополнительные сведения см. в разделе [Рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  

Можно скачать [таблицы коэффициентов сортировки](https://www.microsoft.com/en-us/download/details.aspx?id=10921) — набор текстовых файлов, которые содержат сведения о весовых коэффициентах символов, используемых в операциях сортировки и сравнения для операционных систем Windows, а также [таблицу параметров сортировки по умолчанию для элементов Юникод](https://www.unicode.org/Public/UCA/latest/allkeys.txt) — таблицу весовых коэффициентов сортировки для Linux и macOS.

<a name="casing"></a>   
### <a name="casing"></a>Регистр  
 Правила определения регистра для определения способа изменить регистр символа Юникода; например из нижнего регистра в верхний регистр. Часто операция регистр выполняется перед сравнения строк. Например строки могут быть преобразованы в верхний регистр, таким образом, чтобы его можно сравнить с другим строку в верхнем регистре. Можно преобразовать символы в строке в нижний регистр, вызвав <xref:System.String.ToLower%2A> или <xref:System.String.ToLowerInvariant%2A> метод и их можно преобразовать в верхний регистр, вызвав <xref:System.String.ToUpper%2A> или <xref:System.String.ToUpperInvariant%2A> метод. Кроме того, можно использовать <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> метод для преобразования строки в заглавные символы.  

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]  
  
 Регистр операций может быть на основе правил текущего языка и региональных параметров, заданных региональных параметров или инвариантного языка и региональных параметров. Поскольку сопоставление регистра могут различаться в зависимости от языка и региональных параметров, результатов операций регистр зависит от языка и региональных параметров. Фактический различия в регистре ключевых имеют три типа:  
  
-   Различия в сопоставления в LATIN CAPITAL LETTER I (U + 0049), LATIN НЕБОЛЬШОЙ буква I (U + 0069), LATIN CAPITAL LETTER I с ТОЧКОЙ выше (U + 0130) и LATIN НЕБОЛЬШОЙ буквы без ТОЧКИ I (U + 0131). В az-Latn-AZ (латиница, Азербайджан) языков и региональных параметров и tr-TR (турецкий (Турция)), tr, az и az-Latn нейтральные культуры, эквивалент LATIN ЗАГЛАВНОЙ буквы I в нижнем регистре — LATIN НЕБОЛЬШОЙ буквы без ТОЧКИ I и эквивалент регистре LATIN НЕБОЛЬШОЙ буквы I – ПРОПИСНЫЕ ЛАТИНСКИЕ БУКВЫ I С ТОЧКОЙ ВЫШЕ. В других культурах в том числе инвариантных региональных параметров, LATIN НЕБОЛЬШОЙ буквы I и я являются эквивалентами строчные и прописные буквы LATIN.  
  
     В следующем примере показано как сравнения строк предназначен для предотвращения доступа к файловой системе может завершиться ошибкой, если он основывается на сравнении регистр с учетом языка и региональных параметров. (Правила регистра инвариантного языка и региональных параметров должно быть использовано.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Различия в сопоставление регистра инвариантного языка и региональных параметров и всех других языков и региональных параметров. В таких случаях с помощью правила учета регистра инвариантного языка и региональных параметров, чтобы изменить символ в верхний или нижний возвращает тот же символ. Для всех других языков и региональных параметров он возвращает другой символ. В следующей таблице перечислены некоторые из затронутых символов.  
  
    |Знак|При изменении|Returns|  
    |---------------|-------------------|-------------|  
    |МКМ ВХОДА (U + 00B5)|Прописные буквы|ЦЕНТР ОБНОВЛЕНИЯ МАЙКРОСОФТ ЗАГЛАВНУЮ ГРЕЧЕСКУЮ БУКВУ (U +-39C)|  
    |ПРОПИСНЫЕ ЛАТИНСКИЕ БУКВЫ I С ТОЧКОЙ ВЫШЕ (U + 0130)|Строчные буквы|ЛАТИНИЦА МАЛОГО БУКВЫ I (U + 0069)|  
    |КРАТКУЮ ЛАТИНСКАЯ СТРОЧНАЯ БУКВА I (U + 0131)|Прописные буквы|ПРОПИСНЫЕ ЛАТИНСКИЕ БУКВЫ I (U + 0049)|  
    |ЛАТИНСКАЯ СТРОЧНАЯ БУКВА LONG S (U + 017F)|Прописные буквы|ПРОПИСНАЯ ЛАТИНСКАЯ БУКВА S (U + 0053)|  
    |ПРОПИСНАЯ ЛАТИНСКАЯ БУКВА D С СТРОЧНАЯ БУКВА Z С ГАЛОЧКОЙ (U + 01C 5)|Строчные буквы|ЛАТИНСКАЯ СТРОЧНАЯ БУКВА DZ С ГАЛОЧКОЙ (U + 01C 6)|  
    |ГРЕЧЕСКИЙ YPOGEGRAMMENI ОБЪЕДИНЕНИЯ (U + 0345)|Прописные буквы|IOTA ЗАГЛАВНУЮ ГРЕЧЕСКУЮ БУКВУ (U + 0399)|  
  
-   Различия в сопоставление регистра из пары заглавных букв в диапазоне символов ASCII. В большинстве языков и региональных параметров пару заглавных букв равно эквивалентное пар верхний или нижний регистр букв. Это не относится к пары следующих языков и региональных параметров, в следующих двух букв, так как в каждом случае они сравниваются с диграф:  
  
    -   «lJ» и «nJ» в культуре, hr-HR (Хорватский (Хорватия)).  
  
    -   «cH» в cs-CZ (чешский (Чешская Республика)) и sk-SK (словацкий (Словакия)) языков и региональных параметров.  
  
    -   «aA» в культуре da-DK (датский (Дания)).  
  
    -   «cS», «dZ», «dZS», «nY», «sZ», «tY» и «zS» в культуре, hu-HU (Венгерский (Венгрия)).  
  
    -   «cH» и «lL» в язык и региональные параметры es-ES_tradnl (испанский (Испания, традиционная сортировка)).  
  
    -   «cH», «gI», «kH», «nG» «центр уведомлений», «pH», «qU ", «tH» и «tR» в культуре vi-VN (вьетнамский (Вьетнам)).  
  
     Тем не менее не передается столкнуться с ситуацией, в котором учитывающего культуру сравнения этих пар создает проблемы, в том случае, поскольку эти пары происходят нечасто в фиксированных строк или идентификаторов.  
  
 Следующий пример иллюстрирует некоторые различия в правила определения регистра для языков и региональных параметров при преобразовании строки в верхний регистр.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>Синтаксического анализа и форматирования  
 Форматирование и разбор — это обратная операции. Правила форматирования определяют способ преобразования значение, например даты и времени или номер, в строковое представление, в то время как синтаксического анализа правила определяют способ преобразования строкового представления в значение даты и времени. Форматирования и разбора правила зависят от национальные стандарты. В следующем примере показано неоднозначности, которые могут возникнуть при интерпретации строки даты конкретного языка и региональных параметров. Не зная соглашений для языка и региональных параметров, который использовался для создания строки даты, не сможете узнать ли 03/01/2011 г., 3/1/2011 и 01/03/2011 представляют 3 января 2011 г. или 1 марта 2011 г.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 Точно так же как показано в следующем примере, одну строку может привести к другие дни, в зависимости от языка и региональных параметров, соглашения о которых используются в операции синтаксического анализа.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Сравнение и сортировка строк  
 Соглашения для сравнения и сортировки строк зависят от языка и региональных параметров для языка и региональных параметров. Например порядок сортировки может основываться на Фонетическое название или визуальным представлением символов. В восточно-азиатских языков символы являются отсортированный обводкой и корнями идеограмм. Также сортировки зависит от порядка языков и использовать языки и региональные параметры для алфавита. Например датского языка есть символ «Æ», который в алфавите после «Z». Кроме того может быть сравнение зависеть от регистра символов, и в некоторых случаях правила определения регистра также отличаются языка и региональных параметров. Порядковое сравнение, с другой стороны, использует кодовые позиции Юникода, отдельных символов в строки при сравнения и сортировки строк.  
  
 Правила сортировки определяют алфавитный порядок символов Юникода и как две строки сравнивать друг с другом. Например <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> метод сравнивает две строки, на основе <xref:System.StringComparison> параметра. Если значение параметра не <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, метод выполняет лингвистического сравнения, который использует соглашения текущих региональных параметров; Если значение параметра не <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, метод выполняет порядковое сравнение. Следовательно, как показано в следующем примере, если текущий язык — американский английский Английский, первый вызов <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> метод (с помощью сравнение с учетом языка и региональных параметров) рассматривает «» меньше, чем «A», но второй вызов на тот же метод (с помощью порядковое сравнение) рассматривает «a» больше «A».  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 Платформа .NET поддерживает word, строка и правила сортировки по порядковому номеру.  
  
-   Сортировка по словам выполняет сравнение строк с учетом языка и региональных параметров, в котором некоторые символы Юникода могут иметь особые весовые коэффициенты. Например дефис (-) может иметь очень низкий весовой «coop» и «co-op» отображаются рядом друг с другом в сортированном списке. Список <xref:System.String> методы, которые сравнивают две строки, word, используя правила сортировки см. в разделе [строковые операции по категориям](#ByCategory) раздел.  
  
-   Сортировка по строкам также выполняет сравнение с учетом языка и региональных параметров. Она аналогична Сортировка по словам, за исключением того, что существует особых случаев нет, и все символы не алфавитно-цифровым предшествуют буквенно-цифровые символы. Можно сравнить две строки с помощью правила сортировки строк путем вызова <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> перегрузок метода, имеющих `options` параметр, который имеет указанное значение <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>. Обратите внимание, что это единственный метод, платформа .NET предоставляет для сравнения двух строк, используя правила сортировки строк.  
  
-   Сортировки по порядковому номеру строки сравниваются на основе числовое значение каждого из них <xref:System.Char> объекта в строку. Порядковое сравнение автоматически с учетом регистра, так как в нижнем и верхнем регистре символа имеют разные кодовые точки. Тем не менее если регистр не имеет значения, можно указать порядковое сравнение, которое не учитывает регистр. Это эквивалентно преобразованию строки в верхний регистр с помощью инвариантного языка и региональных параметров и выполнению порядкового сравнения результатов. Список <xref:System.String> методы, которые сравнивают две строки, используя правила сортировки по порядковому номеру, см. в разделе [строковые операции по категориям](#ByCategory) раздел.  
  
 Сравнение с учетом языка и региональных параметров является любое сравнение, которое явно или неявно использующая <xref:System.Globalization.CultureInfo> объекта, включая инвариантного языка и региональных параметров, который задается параметром <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> свойство. Неявное языка и региональных параметров является текущим языком, который задается путем <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> и <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> свойства. Есть значительные отклонения в порядке сортировки букв (то есть символы, для которого <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> возвращает `true`) различных региональных параметров. Можно указать сравнение с учетом языка и региональных параметров, который использует правила конкретного языка и региональных параметров, указав <xref:System.Globalization.CultureInfo> объекта в метод сравнения строк, таких как <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. Можно указать сравнение с учетом языка и региональных параметров, который использует соглашения текущих региональных параметров, указав <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, или любой член <xref:System.Globalization.CompareOptions> перечисления, отличное от <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> или <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> — соответствующую перегруженная версия <xref:System.String.Compare%2A> метод. Сравнение с учетом языка и региональных параметров обычно подходит для сортировки, тогда как порядковое сравнение — нет. Порядковое сравнение, как правило, подходят для определения, равны ли две строки (то есть для определения удостоверений) в то время как не является сравнение с учетом языка и региональных параметров.  
  
 В следующем примере показано различие между сравнения с учетом языка и региональных параметров и порядковый номер. Пример возвращает три строки, «Apple», «Æble» и «AEble», используя порядковое сравнение и соглашений для языков и региональных параметров da-DK "и" en US (каждый из которых является языком по умолчанию во время <xref:System.String.Compare%2A> вызывается метод). Поскольку датского языка воспринимает символ «Æ» отдельной буквой и сортирует его после «Z» в алфавите, строка «Æble» больше, чем «Apple». Тем не менее «Æble» не считаются эквивалентными «AEble», поэтому «Æble» также больше, чем «AEble». Отсутствует буква «Æ» en-US, но считает, что эквивалентно «AE», что объясняет, почему «Æble» меньше, чем «Apple», но равным «AEble». Порядковое сравнение, с другой стороны, считает, что «Apple», чтобы быть меньше, чем «Æble» и «Æble» должно быть больше «AEble».  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Используйте следующие общие рекомендации для выбора соответствующего метода сравнения сортировки или строки:  
  
-   Если требуется строки, которые следует упорядочить зависимости от языка и региональных параметров пользователя, следует упорядочить их на основе соглашений текущих региональных параметров. При изменении языка и региональных параметров пользователя, порядок сортировки строк также изменится соответствующим образом. Например приложение тезауруса следует всегда сортировки слов, в зависимости от языка и региональных параметров пользователя.  
  
-   Если требуется строки, которые следует упорядочить зависимости от соглашений для конкретного языка и региональных параметров, следует упорядочить их, указав <xref:System.Globalization.CultureInfo> объект, представляющий этот язык для метода сравнения. Например в приложение, предназначенное для обучения определенного языка, вы можете строки заказываемого зависимости от соглашения одного из языков и региональных параметров, которые произносит этого языка.  
  
-   Если требуется, чтобы порядок строк остаются неизменными в разных языках, следует упорядочить их на основе соглашений инвариантного языка и региональных параметров или используют порядковое сравнение. Например будет использовать порядковую сортировку для организации имен файлов, процессов, взаимные исключения или именованные каналы.  
  
-   Для сравнения, который включает в себя решение безопасности (например, допустим ли имя пользователя), всегда следует выполнять порядковый номер проверка на равенство, вызвав перегрузку <xref:System.String.Equals%2A> метод.  
  
> [!NOTE]
>  Сортировка с учетом языка и региональных параметров и правил, используемых в сравнении строк регистр зависят от версии платформы .NET. В .NET Framework 4.5 и более поздних версий на [!INCLUDE[win8](~/includes/win8-md.md)] операционной системы, сортировку, регистр, нормализации и сведений о символах Юникода соответствует стандарту Юникод 6.0. В других операционных системах Windows он соответствует стандартной Unicode 5.0. В .NET Core она зависит от версии стандарта Юникод, поддерживаемых операционной системы. 
  
 Дополнительные сведения о word, строка и правила сортировки по порядковому номеру, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> раздела. См. Дополнительные рекомендации по использованию каждого правила [советы и рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 Как правило, вы не вызываете строковое сравнение методов, таких как <xref:System.String.Compare%2A> напрямую, чтобы определить порядок сортировки строк. Вместо этого вызываются методы сравнения, таких как методы сортировки <xref:System.Array.Sort%2A?displayProperty=nameWithType> или <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. В следующем примере выполняется четыре различных сортировки операций (с использованием текущего языка и региональных параметров, сортировки word с использованием инвариантных региональных параметров, порядковый номер сортировки и сортировка по строкам с использованием инвариантных региональных параметров сортировки word) без явного вызова метода сравнения строк, Несмотря на то, что их следует указывать тип сравнения для использования. Обратите внимание на то, что каждый тип сортировки создает уникальный упорядочение строк в его массив.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  На внутреннем уровне .NET использует ключи сортировки для поддержки сравнение сортировок, зависящих от строк. Каждый символ в строке дается несколько категорий весового значения сортировки, включая буквы, регистра и диакритических знаков. Ключ сортировки, представленный <xref:System.Globalization.SortKey> класса, предоставляет хранилищем этих значений для определенной строки. Если приложение выполняет большое количество поиска и сортировки тот же набор строк, может повысить его производительность, создавая и сохраняя ключи сортировки для всех строк, которые он использует. Если требуется операция сортировки или сравнения, ключи сортировки используется вместо строк. Дополнительные сведения см. в описании класса <xref:System.Globalization.SortKey>.  
  
 Если вы не укажете соглашение сравнения строки, методы сортировки например <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> выполнения сортировки с учетом языка и региональных параметров символов, с учетом регистра строк. В следующем примере показано, как изменение текущего языка и региональных параметров влияет на порядок сортировки строк в массиве. Он создает массив из трех строк. Во-первых, он задает `System.Threading.Thread.CurrentThread.CurrentCulture` значение en US и вызовы <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> метод. Полученный порядок сортировки основан на правилах сортировки для английского языка (США). Далее в этом примере `System.Threading.Thread.CurrentThread.CurrentCulture` свойство da-DK и вызовы <xref:System.Array.Sort%2A?displayProperty=nameWithType> метод снова. Обратите внимание на то, как полученный порядок сортировки отличается от результатов en US, так как он использует правила сортировки для датский (Дания).  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Если ваша основная цель в сравнении строк — чтобы определить, равны ли они, следует вызвать <xref:System.String.Equals%2A?displayProperty=nameWithType> метод. Как правило, следует использовать <xref:System.String.Equals%2A> для выполняют порядковое сравнение. <xref:System.String.Compare%2A?displayProperty=nameWithType> Метод предназначен главным образом для сортировки строк.  
  
 Строка, методы поиска, такие как <xref:System.String.StartsWith%2A?displayProperty=nameWithType> и <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, также можно выполнять сравнение строк с учетом языка и региональных параметров или порядковый номер. В следующем примере показано различия между сравнения порядкового номера, с учетом языка и региональных параметров, с использованием <xref:System.String.IndexOf%2A> метод. Поиск зависящих от языка и региональных параметров, в котором текущий язык — Русский (Россия) считает, что подстрока «обозревателя объектов» в соответствии с лигатуры «œ». Поскольку мягкий перенос (U + 00AD) является символом нулевой ширины, поиск считает мягкий перенос эквивалентно <xref:System.String.Empty> и поиск совпадения в начале строки. Поиск по порядковым номерам, с другой стороны, не найден в любом случае.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Поиск строк  
 Строка, методы поиска, такие как <xref:System.String.StartsWith%2A?displayProperty=nameWithType> и <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, также можно выполнить от культуры или сравнения строк по порядковому номеру, чтобы определить, является ли символ или подстроку находится в указанной строке.  
  
 Методы поиска в <xref:System.String> класса, такие как найти отдельный символ, <xref:System.String.IndexOf%2A> метода или один из набора символов, таких как <xref:System.String.IndexOfAny%2A> метод, выполняет поиск по порядковым номерам. Чтобы выполнить поиск с учетом языка и региональных параметров для символа, необходимо вызвать <xref:System.Globalization.CompareInfo> метода, такого как <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> или <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Обратите внимание на то, что результаты поиска для символов, с помощью сравнения порядкового номера, с учетом языка и региональных параметров могут оказаться совершенно другими. Например, при поиске составной знак Юникода, например лигатура «?» (U + 00 C 6) может соответствовать любой из его компонентов в правильной последовательности, например «AE» экземпляров (U + 041U + 0045), в зависимости от языка и региональных параметров. В следующем примере показано различие между <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> и <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> методы при поиске отдельный символ. Лигатура «?» (U + 00E6) находится в строке «воздушный» при использовании правил языка en US, но не в том случае, когда с помощью соглашений культуры da-DK или при выполнении порядкового сравнения.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 С другой стороны <xref:System.String> методы, найдите строку, а не символ выполнения поиска с учетом языка и региональных параметров, если параметры поиска не заданы явным образом с помощью параметра типа класса <xref:System.StringComparison>. Единственное исключение — <xref:System.String.Contains%2A>, который выполняет поиск по порядковым номерам.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Проверка на равенство  
 Используйте <xref:System.String.Compare%2A?displayProperty=nameWithType> метод, чтобы определить связь между двумя строками в порядке сортировки. Как правило это операция с учетом языка и региональных параметров. Напротив, вызовите <xref:System.String.Equals%2A?displayProperty=nameWithType> метод для проверки на равенство. Так как проверка на равенство обычно сравнивает входные данные пользователя с некоторых известных строка, такая как допустимое имя пользователя, пароль или путь файловой системы, это обычно порядковые операции.  
  
> [!WARNING]
>  Возможно, для проверки на равенство, вызвав <xref:System.String.Compare%2A?displayProperty=nameWithType> метод и определить, является ли возвращаемое значение ноль. Тем не менее это не рекомендуется. Чтобы определить, равны ли две строки, следует вызвать один из перегруженных версий <xref:System.String.Equals%2A?displayProperty=nameWithType> метод. Предпочтительный перегрузки для вызова является либо экземпляром <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> метод или статический <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> метод, так как оба метода включают <xref:System.StringComparison?displayProperty=nameWithType> параметр, который явно указывает тип сравнения.  
  
 В следующем примере показано опасности выполнения учитывающего культуру сравнения на равенство, когда один из них следует использовать вместо этого порядкового номера. В этом случае назначение кода — запретить доступ к файловой системе с URL-адресов, которые начинаются с «FILE://» или «file://», выполнив сравнение без учета регистра, начиная со строки «FILE://» URL-адреса. Тем не менее если сравнение с учетом языка и региональных параметров выполняется с помощью турецкий (Турция) языка и региональных параметров в URL-адрес, который начинается с «file://», сравнение на предмет равенства завершается ошибкой, так как эквивалент турецкого регистре нижний регистр «i» — «i» вместо «I». Таким образом случайно разрешен доступ к файловой системе. С другой стороны Если выполняется порядковое сравнение, сравнение на равенство успешно и запрещен доступ к файловой системе.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Нормализация  
 Некоторые символы Юникода, имеют несколько представлений. Например любой из следующих кодовых точек может представлять имя символа «ắ»:  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Несколько представлений для одного символа усложнить поиск, сортировка, сопоставления и других операций со строками.  
  
 В стандарте Юникод определяет процесс, называемый нормализация, которая возвращает одно двоичное представление символа Юникода для любого из его эквивалентных представлений. Нормализация можно использовать несколько алгоритмов, вызывается нормализации, появившиеся формы разные правила. Платформа .NET поддерживает формы нормализации Юникода C, D, KC и KD. Когда строки были нормализованы по той же форме нормализации, их можно проверять с помощью порядковое сравнение.  
  
 Порядковое сравнение — это двоичное сравнение скалярного значения Юникода, из соответствующего <xref:System.Char> объектов в каждой строке. <xref:System.String> Содержит ряд методов, которые можно выполнить порядковое сравнение, включая следующие:  
  
-   Любой перегрузки <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, и <xref:System.String.LastIndexOf%2A> методы, которые включает в себя <xref:System.StringComparison> параметра. Этот метод выполняет порядковое сравнение, если указать значение <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> или <xref:System.StringComparison.OrdinalIgnoreCase> для этого параметра.  
  
-   Перегрузки <xref:System.String.CompareOrdinal%2A> метод.  
  
-   Методы, которые используют порядковое сравнение по умолчанию, такие как <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, и <xref:System.String.Split%2A>.  
  
-   Методы, которые выполняют поиск <xref:System.Char> значение или для элементов в <xref:System.Char> массива в экземпляре строки. Такие методы включают <xref:System.String.IndexOf%28System.Char%29> и <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 Можно определить нормализуется ли строка в форме нормализации Юникода C, вызвав <xref:System.String.IsNormalized?displayProperty=nameWithType> метод, либо вызвать <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> метод, чтобы определить, является ли строка нормализованным в форму нормализации, указанной. Можно также вызвать <xref:System.String.Normalize?displayProperty=nameWithType> можно вызвать метод для преобразования строки в форме нормализации Юникода C, или <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> метод для преобразования строки в указанной форму. Пошаговые инструкции по нормализация и сравнения строк см. в разделе <xref:System.String.Normalize> и <xref:System.String.Normalize%28System.Text.NormalizationForm%29> методы.  
  
 Следующий простой пример иллюстрирует нормализацией строк. Он определяет букву «ố» тремя разными способами в трех разных строк и использует порядковое сравнение на предмет равенства, чтобы определить, что каждая строка отличается от других двух строк. Затем преобразует каждую строку в формах поддерживаемых нормализации и снова выполняет порядковое сравнение каждой строки в форме нормализации, указанной. В каждом случае второй тест для проверки на равенство показано, что строки равны.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Дополнительные сведения о нормализации и формы нормализации, см. в разделе <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, а также [Unicode Standard Annex #15: Формы нормализации Юникода](https://unicode.org/reports/tr15/) и [нормализация часто задаваемые вопросы о](https://www.unicode.org/faq/normalization.html) кодовые веб-сайта.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Операции со строками по категориям  
 <xref:System.String> Класс предоставляет члены для сравнения строк, проверка строк на равенство, поиска символов или подстроки в строке, изменения строки, извлечение подстрок из строки, объединения строк, форматирование значений, копирования строки, и Нормализация строки.  
  
### <a name="comparing-strings"></a>Сравнение строк  
 Можно сравнивать строки, чтобы определить их относительное положение в порядке сортировки, с помощью следующих <xref:System.String> методы:  
  
-   <xref:System.String.Compare%2A> Возвращает целое число, показывающее связь между одной строки в строку второй в порядке сортировки.  
  
-   <xref:System.String.CompareOrdinal%2A> Возвращает целое число, показывающее связь между одной строки на второй строку на основе сравнения кодовых позиций.  
  
-   <xref:System.String.CompareTo%2A> Возвращает целое число, показывающее связь между текущего экземпляра строки в строку второй в порядке сортировки. <xref:System.String.CompareTo%28System.String%29> Предоставляет метод <xref:System.IComparable> и <xref:System.IComparable%601> реализации для <xref:System.String> класса.  
  
### <a name="testing-strings-for-equality"></a>Проверка строк на равенство  
 Вы вызываете <xref:System.String.Equals%2A> метод, чтобы определить, равны ли две строки. Экземпляр <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> и статических <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> перегрузки позволяют задать ли сравнение с учетом языка и региональных параметров символов или порядковый номер, и считается или учитывается регистр. Является порядковым большинство тестов на предмет равенства и сравнения на равенство, которые определяют доступ к ресурсу системы (например, объект файловой системы) всегда должны быть порядковый номер.  
  
### <a name="finding-characters-in-a-string"></a>Поиск символов в строке  
 <xref:System.String> Класс включает два вида методов поиска:  
  
-   Методы, возвращающие <xref:System.Boolean> значение, указывающее, присутствует ли в экземпляре строка определенной подстрокой. К ним относятся <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, и <xref:System.String.StartsWith%2A> методы.  
  
-   Методы, которые указывают Начальная позиция подстроки в экземпляре строки. К ним относятся <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, и <xref:System.String.LastIndexOfAny%2A> методы.  
  
> [!WARNING]
>  Если вам требуется выполнить поиск строки определенный шаблон, а не конкретной подстроки, следует использовать регулярные выражения. Дополнительные сведения см. в разделе [регулярных выражений .NET](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Изменения строки  
 <xref:System.String> Класс включает следующие методы, которые могут изменить значение строки:  
  
-   <xref:System.String.Insert%2A> Вставляет строку в текущую <xref:System.String> экземпляра.  
  
-   <xref:System.String.PadLeft%2A> Вставляет один или несколько вхождений указанный символ в начале строки.  
  
-   <xref:System.String.PadRight%2A> Вставляет один или несколько вхождений указанного символа в конце строки.  
  
-   <xref:System.String.Remove%2A> Удаляет из текущего подстроки <xref:System.String> экземпляра.  
  
-   <xref:System.String.Replace%2A> заменяет подстроку другой подстрокой в текущем <xref:System.String> экземпляра.  
  
-   <xref:System.String.ToLower%2A> и <xref:System.String.ToLowerInvariant%2A> преобразования всех символов в строке в нижний регистр.  
  
-   <xref:System.String.ToUpper%2A> и <xref:System.String.ToUpperInvariant%2A> преобразования всех символов в строке в верхний регистр.  
  
-   <xref:System.String.Trim%2A> Удаляет все вхождения знака в начале и конце строки.  
  
-   <xref:System.String.TrimEnd%2A> Удаляет все вхождения знака в конце строки.  
  
-   <xref:System.String.TrimStart%2A> Удаляет все вхождения знака с начала строки.  
  
> [!IMPORTANT]
>  Все методы изменения строк возвращают новый <xref:System.String> объекта. Они не изменяют значение текущего экземпляра.  
  
### <a name="extracting-substrings-from-a-string"></a>Извлечение подстрок из строки  
 <xref:System.String.Split%2A?displayProperty=nameWithType> Метод разделяет одну строку на несколько строк. Перегрузки метода позволяют указать несколько разделителей, чтобы определить максимальное число подстрок, метод извлекает и для определения, включены ли пустые строки (которые происходят, когда разделители являются смежными) между возвращенные строки.  
  
### <a name="combining-strings"></a>Объединение строк  
 Следующие <xref:System.String> методы могут использоваться для объединения строк:  
  
-   <xref:System.String.Concat%2A> объединяет один или несколько подстрок в одну строку.  
  
-   <xref:System.String.Join%2A> объединяет один или несколько подстрок в один элемент и добавляет разделитель между каждой подстроке.  
  
### <a name="formatting-values"></a>Форматирование значений  
 <xref:System.String.Format%2A?displayProperty=nameWithType> Метод использует составное форматирование, чтобы заменить один или несколько заполнителей в строке строковым представлением некоторые объект или значение. <xref:System.String.Format%2A> Метод часто используется для следующих целей:  
  
-   Для внедрения строковое представление числового значения в строку.  
  
-   Для внедрения строковое представление значения даты и времени в строку.  
  
-   Для внедрения строковое представление значения перечисления в строку.  
  
-   Для внедрения строковым представлением некоторый объект, который поддерживает <xref:System.IFormattable> интерфейс в строке.  
  
-   К правому краю или по ширине слева подстроки в поле в строку большего размера.  
  
 Подробные сведения о форматировании операций и примеры см. в разделе <xref:System.String.Format%2A> перегружать Сводка.  
  
### <a name="copying-a-string"></a>Копирование строки  
 Вы можете вызвать следующий <xref:System.String> методы, чтобы скопировать строки:  
  
-   <xref:System.String.Clone%2A> Возвращает ссылку на существующий <xref:System.String> объекта.  
  
-   <xref:System.String.Copy%2A> Создает копию существующей строки.  
  
-   <xref:System.String.CopyTo%2A> копирует часть строки в массив символов.  
  
### <a name="normalizing-a-string"></a>Нормализация строки  
 В кодировке Юникод один символ может иметь несколько кодовых точек. Нормализация преобразует эти эквивалентные им знаки в том же двоичное представление. <xref:System.String.Normalize%2A?displayProperty=nameWithType> Метод выполняет, нормализация и <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> метод определяет, является ли строка нормализованным.  
  
 Дополнительные сведения и пример см. в разделе [нормализации](#Normalization) подразделе данного раздела.  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/en-us/download/details.aspx?id=10921">Сортировка таблицы вес для Windows операционных систем</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">По умолчанию Юникода параметры сортировки Elemeent таблицы, для Linux и macOS</related>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Рекомендации по использованию строк в .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Содержание  
  
 [Синтаксис перегруженный конструктор](#Syntax)   
 [Параметры](#Params)   
 [Исключения](#Exceptions)   
 [Какой метод следует вызывать?](#Tasks)   
 [Создание строк](#Creating_Strings)   
 [Обработка повторяющихся строк](#Repetitive)   
 Примеры создания экземпляров строк:   
 [С помощью присваивание строк](#Ctor1_Example)  
 [С помощью массива символов](#Ctor2_Example)  
 [Используя часть массив символов и повторение один символ](#Ctor3_Example)  
 [Используя указатель на массив символов](#Ctor4_Example)  
 [С помощью указателя и диапазона массива](#Ctor5_Example)  
 [Используя указатель на массив байтов со знаком](#Ctor6_Example)  
[Сведения о версии](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Синтаксис перегруженный конструктор  
 Конструкторы строки делятся на две категории: без параметров указатель и с параметрами указатель. Конструкторы, которые используют указатели, не являются CLS-совместимыми. Кроме того Visual Basic не поддерживает использование указателей и C# требует код, который использует указатели для выполнения в небезопасном контексте. Дополнительные сведения см. в разделе [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Дополнительные рекомендации по выбору перегрузки см. в разделе [вызываемого метода какие?](#Tasks)  
  
 `String(Char[] value)`  
 Инициализирует новый экземпляр значением, заданным массивом знаков Юникода. Этот конструктор копирует символов Юникода ([пример](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Инициализирует новый экземпляр значением, заданным массивом знаков Юникода, начальной позицией знака в пределах данного массива и длиной ([пример](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Инициализирует новый экземпляр значение обозначается заданного знака Юникода повторяется указанное число раз ([пример](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(Не является CLS-совместимым)**  Инициализирует новый экземпляр значением, определенным указателем на массив знаков Юникода, завершается нуль-символом (U + 0000 или «\0»). ([пример](#Ctor4_Example)).  
  
 Разрешение: <xref:System.Security.SecurityCriticalAttribute>, требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Не является CLS-совместимым)**  Инициализирует новый экземпляр значением, определенным указателем на массив знаков Юникода, начальной позицией знака в пределах данного массива и длиной. Конструктор копирует символы Юникода из `value` начиная с индекса `startIndex` и заканчивая индекс `startIndex`  +  `length` - 1 ([пример](#Ctor5_Example)).  
  
 Разрешение: <xref:System.Security.SecurityCriticalAttribute>, требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.  
  
 `String(SByte* value)`  
 **(Не является CLS-совместимым)**  Инициализирует новый экземпляр значением, определенным указателем на массив 8-разрядных целых чисел со знаком. Массив предполагается представляет строку, закодированную с помощью текущей кодовой странице системы (то есть кодировку, заданную <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Конструктор обрабатывает символы из `value` начиная с позиции, определяемой заданным указателем, пока не будет достигнут нуль-символом (0x00) ([пример](#Ctor6_Example)).  
  
 Разрешение: <xref:System.Security.SecurityCriticalAttribute>, требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Не является CLS-совместимым)**  Инициализирует новый экземпляр значением, определенным указателем на массив 8-разрядных целых чисел со знаком, начальной позицией в пределах данного массива и длиной.  Массив предполагается представляет строку, закодированную с помощью текущей кодовой странице системы (то есть кодировку, заданную <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Конструктор обрабатывает символы из значения, начиная с `startIndex` и заканчивая `startIndex`  +  `length` - 1 ([пример](#Ctor6_Example)).  
  
 Разрешение: <xref:System.Security.SecurityCriticalAttribute>, требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Не является CLS-совместимым)**  Инициализирует новый экземпляр значением, определенным указателем на массив 8-разрядных целых чисел со знаком, начальной позицией в пределах этого массива, длиной и <xref:System.Text.Encoding> объекта.  
  
 Разрешение: <xref:System.Security.SecurityCriticalAttribute>, требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Параметры  
 Ниже приведен полный список параметров, используемых <xref:System.String> конструкторы, не включающие параметр-указатель. Параметры, используемые каждой перегрузке см. приведенный выше синтаксис перегрузки.  
  
|Параметр|Тип|Описание|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Массив знаков Юникода.|  
|`c`|<xref:System.Char>|Знак Юникода.|  
|`startIndex`|<xref:System.Int32>|Начальная позиция в `value` первого символа в новой строке.<br /><br /> Значение по умолчанию: 0|  
|`length`|<xref:System.Int32>|Число символов в `value` для включения в новую строку.<br /><br /> Значение по умолчанию: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|Символ, сколько раз `c` повторяется в новой строке. Если `count` равно нулю, возвращается новый объект <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Ниже приведен полный список параметров, используемых <xref:System.String> конструкторов, содержащих параметр-указатель. Параметры, используемые каждой перегрузке см. приведенный выше синтаксис перегрузки.  
  
|Параметр|Тип|Описание|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> -или-<br /><br /> <xref:System.SByte>\*|Указатель на строку символов Юникода, завершающуюся null или массив 8-разрядных целых чисел со знаком. Если `value` — `null` , или пустой массив, значение новой строки <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|Индекс элемента массива, который определяет первый символ в новой строке.<br /><br /> Значение по умолчанию: 0|  
|`length`|<xref:System.Int32>|Число элементов массива, использовать для создания новой строки. Если длина равна нулю, конструктор создает строку, значение которого равно <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Значение по умолчанию: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Объект, задающий как `value` кодируется массива.<br /><br /> Значение по умолчанию: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, или текущей кодовой страницы ANSI системы|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Исключения  
 Вот список исключений, генерируемых конструкторы, которые не содержат параметры указателя.  
  
|Исключение|Условие|Вызванное|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` — `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, или `count` меньше нуля.<br /><br /> -или-<br /><br /> Сумма `startIndex` и `length` больше, чем число элементов в `value`.<br /><br /> -или-<br /><br /> Значение параметра `count` меньше нуля.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Вот список исключений, генерируемых конструкторов, содержащих параметры-указатели.  
  
|Исключение|Условие|Вызванное|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` Указывает массив, содержащий недопустимый символ Юникода.<br /><br /> -или-<br /><br /> `value` или `value`  +  `startIndex` определяет адрес меньше 64 КБ.<br /><br /> -или-<br /><br /> Новый <xref:System.String> не удалось инициализировать экземпляр из `value` байтового массива, так как `value` не использовать кодировку по умолчанию код страницы.|Все конструкторы с указателями.|  
|<xref:System.ArgumentNullException>|Параметр `value` имеет значение null.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|Текущий процесс не имеет доступа на чтение ко всем рассматриваемым символам.<br /><br /> -или-<br /><br /> `startIndex` или `length` меньше нуля, `value` + `startIndex` приводит к переполнению указателя, или текущий процесс не имеет доступа на чтение ко всем адресуемым символам.<br /><br /> -или-<br /><br /> Длина новой строки слишком велика для выделения.|Все конструкторы с указателями.|  
|<xref:System.AccessViolationException>|`value`, или `value`  +  `startIndex`  +  `length` -1, указывает недопустимый адрес.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Какой метод следует вызывать?  
  
|Кому|Звонок или используйте|  
|--------|-----------------|  
|Создайте строку.|Назначение из строкового литерала или существующей строки ([пример](#Ctor1_Example))|  
|Создайте строку из массива целого символа.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([пример](#Ctor2_Example))|  
|Создайте строку из фрагмента массива символов.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([пример](#Ctor3_Example))|  
|Создайте строку, которая повторяется несколько раз и тот же символ.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([пример](#Ctor3_Example))|  
|Создайте строку из указателя в Юникоде или массив расширенных символов.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Создайте строку из части Юникода или массив расширенных символов с помощью ее указатель.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Создание строки из C++ `char` массива.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> -или-<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Создайте строку из символов ASCII.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Создание строк  
 Наиболее часто используемые метод для создания строк программным способом — простое присваивание, как показано в [в этом примере](#Ctor1_Example). <xref:System.String> Класс также включает четыре типа перегрузки конструктора, которые позволяют создавать строки из следующих значений:  
  
-   Из массива символов (массив символов в кодировке UTF-16). Вы можете создать новую <xref:System.String> объект из символов в массиве или его части. <xref:System.String.%23ctor%28System.Char%5B%5D%29> Конструктор копирует все символы новой строки в массиве. <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Конструктор копирует знаки из индекса `startIndex` индекс `startIndex`  +  `length` -1 в новой строке. Если `length` равно нулю, возвращается новая строка <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Если ваш код повторно создает экземпляр строки, которые имеют одинаковое значение, можно повысить производительность приложения с помощью альтернативный способ создания строки. Дополнительные сведения см. в разделе [обработка повторяющихся строк](#Repetitive).  
  
-   Из одного символы, повторяющийся ноль, один, или более раз, с помощью <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> конструктор. Если `count` равно нулю, возвращается новая строка <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Из указателя на массив символов с завершающим нулем, с помощью <xref:System.String.%23ctor%28System.Char%2A%29> или <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> конструктор. Для инициализации строки можно использовать весь массив или указанный интервал. Конструктор копирует последовательность символов Юникода начиная с заданного указателя или заданный указатель плюс `startIndex` и до конца массива или для `length` символов. Если `value` является пустым указателем или `length` равен нулю, конструктор создает строку, значение которого равно <xref:System.String.Empty?displayProperty=nameWithType>. Если операция копирования продолжается до конца массива и массив не является нулевым байтом, поведением конструктора зависит от системы. Такое состояние может вызвать нарушение прав доступа.  
  
     Если массив содержит все внедренные символы null (U + 0000 или «\0») и <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> перегрузка вызывается, содержит экземпляр строки `length` символов, включая все внедренные значения NULL. В следующем примере показано, что произойдет, если передается указатель на массив из 10 элементов, включающий двумя символами null <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> метод. Так как адрес первого элемента массива и все элементы в массиве, должны быть добавлены к строке, конструктор создает строку с десять символов, включая два внедренные значения NULL. С другой стороны, если передается тот же массив <xref:System.String.%23ctor%28System.Char%2A%29> конструктор, результат является 4 символьная строка, которая не включает первого пустого знака.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     Этот массив должен содержать символы Юникода. В C++, это означает, что массив символов должен быть определен как управляемый <xref:System.Char>типа [] или неуправляемой`wchar_t`тип [].  
  
     Если <xref:System.String.%23ctor%28System.Char%2A%29> перегрузка вызывается и массив не является нулевым байтом, или если <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> перегрузка вызывается и `startIndex`  +  `length`-1 включает диапазон, который за пределами памяти, выделенные для последовательности символов, поведение конструктора по не зависящую от системы и может возникнуть нарушение прав доступа. Кроме того, на процессоре Intel Itanium, вызывает <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> конструктор может вызывать исключение <xref:System.DataMisalignedException> исключение. В этом случае вызов <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> вместо этого.  
  
-   Из указателя в массив байт со знаком. Для инициализации строки можно использовать весь массив или указанный интервал. Последовательность байтов, которую можно интерпретировать с помощью кодирования кодовой страницей по умолчанию, или кодировку могут быть указаны в вызове конструктора. Если конструктор пытается создать экземпляр строку из весь массив, который не является нулем или диапазон для массива из `value`  +  `startIndex` для `value`  +  `startIndex`  +  `length` -1 выходит за пределы памяти, выделенной для массива, поведение этого конструктора не зависящую от системы и может возникнуть нарушение прав доступа.  
  
     Три конструктора, которые включают в качестве параметра массив байт со знаком предназначены главным образом для преобразования C++ `char` массива в строку, как показано в следующем примере:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Если массив содержит символы null («\0») или байт, значение которого равно 0 и <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> перегрузка вызывается, содержит экземпляр строки `length` символов, включая все внедренные значения NULL. В следующем примере показано, что произойдет, если передается указатель на массив из 10 элементов, включающий двумя символами null <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> метод. Так как адрес первого элемента массива и все элементы в массиве, должны быть добавлены к строке, конструктор создает строку с десять символов, включая два внедренные значения NULL. С другой стороны, если передается тот же массив <xref:System.String.%23ctor%28System.SByte%2A%29> конструктор, результат является 4 символьная строка, которая не включает первого пустого знака.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Так как <xref:System.String.%23ctor%28System.SByte%2A%29> и <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> интерпретировать конструкторы `value` кодовую страницу ANSI по умолчанию вызова этих конструкторов одинаковые байтовые массивы могут создать, строки, которые имеют разные значения в различных системах.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Обработка повторяющихся строк  
 Приложения, которые проанализировать или декодировать потоки текста, часто используют <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> конструктор или <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод для преобразования последовательности символов в строку. Несколько раз, создание новых строк с тем же значением, вместо создания и использования одной строки занимает много памяти. Если вы, скорее всего несколько раз создать тот же строковый параметр, вызвав <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> конструктор, даже если вы не знаете, в переместить эти идентичные строковые значения, которые могут быть, вместо этого можно использовать таблицу уточняющих запросов.  
  
 Например предположим, прочитать и проанализировать поток символов из файла, который содержит XML-теги и атрибуты. При синтаксическом анализе потока, постоянно встречаются определенные токены (то есть последовательности символов, которые имеют определенное значение). Маркеры, эквивалентные строкам «0», «1», «true» и «false», скорее всего, часто встречаются в поток XML.  
  
 Вместо преобразования каждого маркера в новую строку, можно создать <xref:System.Xml.NameTable?displayProperty=nameWithType> объект для хранения часто встречающиеся строки. <xref:System.Xml.NameTable> Объекта увеличивает производительность, так как он извлекает сохраненные строки без выделения памяти. При возникновении маркер, используйте <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод для получения маркера из таблицы. Если существует маркер, метод возвращает соответствующую строку. Если маркер не существует, используйте <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод, чтобы добавить маркер в таблицу и для получения соответствующей строки.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Пример 1: С помощью присваивание строк  
 В следующем примере создается новая строка, назначив ей строкового литерала. Он создает строку второго, следует назначить первой строки к нему. Ниже приведены два наиболее распространенных способов для создания нового <xref:System.String> объекта.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Пример 2: С помощью массива символов  
 В следующем примере показано, как для создания нового <xref:System.String> объекта из массива символов.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Пример 3. Используя часть массив символов и повторение один символ  
 В следующем примере показано, как для создания нового <xref:System.String> объекта из части массива символов и как создать новый <xref:System.String> объект, который содержит несколько экземпляров одного символа.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Пример 4. Используя указатель на массив символов  
 В следующем примере показано, как для создания нового <xref:System.String> объекта из указателя на массив символов. В примере C# должны компилироваться с помощью `/unsafe` параметр компилятора.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Пример 5. Создание экземпляра строки из указателя и диапазона массива  
 В приведенном ниже примере проверяются элементы массива знаков для одной или восклицательным знаком. Если он найден, он создает строку из символов в массиве, предшествующие знак пунктуации. В противном случае он создает строку с все содержимое массива. В примере C# должно быть скомпилировано с использованием `/unsafe` параметр компилятора.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Пример 6. Создание экземпляра строки из указателя в массив байт со знаком  
 В следующем примере показано, как можно создать экземпляр <xref:System.String> класса <xref:System.String.%23ctor%28System.SByte%2A%29> конструктор.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Сведения о версии  
 .NET Framework  
 Все перегрузки поддерживаются в: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework (клиентский профиль)  
 Все перегрузки поддерживаются в: 4, 3.5 С ПАКЕТОМ ОБНОВЛЕНИЯ 1  
  
 Переносимая библиотека классов  
 Все перегрузки без <xref:System.SByte> `*` поддерживаются параметр  
  
 Приложения .NET для Магазина Windows  
 Все перегрузки без <xref:System.SByte> `*` параметра поддерживаются в: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на строку знаков в кодировке Юникод, завершающуюся нулевым значением.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, определенным указателем на массив знаков Юникода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и информация об этом и других комплексную использовании `String` перегрузки конструктора, см. в разделе <xref:System.String.%23ctor%2A> конструктор сводки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий процесс не имеет доступа на чтение ко всем рассматриваемым символам.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> указывает массив, содержащий недопустимый символ Юникода, или <paramref name="value" /> определяет адрес меньше 64 000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Массив знаков Юникода.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, заданным в виде массива знаков Юникода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и информация об этом и других комплексную использовании `String` перегрузки конструктора, см. в разделе <xref:System.String.%23ctor%2A> конструктор сводки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на массив 8-разрядных целых чисел со знаком, завершающийся нулевым значением. Целые числа интерпретируются с использованием текущей системы кодировки страницы системным кодом (то есть, кодировки, заданной <see cref="P:System.Text.Encoding.Default" />).</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, определенным указателем на массив 8-разрядных целых чисел со знаком.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и информация об этом и других комплексную использовании `String` перегрузки конструктора, см. в разделе <xref:System.String.%23ctor%2A> конструктор сводки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Не удалось инициализировать новый экземпляр <see cref="T:System.String" /> с помощью <paramref name="value" />, если предполагается, что <paramref name="value" /> представлен в кодировке ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина новой инициализируемой строки, определяемая символом, завершающимся нулевым значением <paramref name="value" />, слишком велика для выделения.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" /> указывает недопустимый адрес.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Знак Юникода.</param>
        <param name="count">Количество повторов <paramref name="c" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, полученным путем повторения заданного знака Юникода указанное число раз.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и информация об этом и других комплексную использовании `String` перегрузки конструктора, см. в разделе <xref:System.String.%23ctor%2A> конструктор сводки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="count" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на массив знаков Юникода.</param>
        <param name="startIndex">Начальная позиция в <paramref name="value" />.</param>
        <param name="length">Используемое количество знаков в <paramref name="value" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, которое определяется заданным указателем на массив знаков Юникода, начальной позицией знака в этом массиве и длиной.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и информация об этом и других комплексную использовании `String` перегрузки конструктора, см. в разделе <xref:System.String.%23ctor%2A> конструктор сводки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> или <paramref name="length" /> меньше нуля, <paramref name="value" /> + <paramref name="startIndex" /> приводит к переполнению указателя, или текущий процесс не имеет доступа на чтение ко всем адресуемым символам.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> указывает массив, содержащий недопустимый символ Юникода, или <paramref name="value" /> + <paramref name="startIndex" /> определяет адрес меньше 64 000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Массив знаков Юникода.</param>
        <param name="startIndex">Начальная позиция в <paramref name="value" />.</param>
        <param name="length">Используемое количество знаков в <paramref name="value" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, заданным массивом знаков Юникода, начальной позицией знака в пределах данного массива и длиной.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и информация об этом и других комплексную использовании `String` перегрузки конструктора, см. в разделе <xref:System.String.%23ctor%2A> конструктор сводки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.  
  
-или- 
Сумма <paramref name="startIndex" /> и <paramref name="length" /> больше, чем число элементов в <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на массив 8-разрядных целых чисел со знаком. Целые числа интерпретируются с использованием текущей системы кодировки страницы системным кодом (то есть, кодировки, заданной <see cref="P:System.Text.Encoding.Default" />).</param>
        <param name="startIndex">Начальная позиция в <paramref name="value" />.</param>
        <param name="length">Используемое количество знаков в <paramref name="value" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, определяемым заданным указателем на массив 8-разрядных целых чисел со знаком, начальной позицией в пределах массива и длиной.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и информация об этом и других комплексную использовании `String` перегрузки конструктора, см. в разделе <xref:System.String.%23ctor%2A> конструктор сводки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.  
  
-или- 
Адрес, указанный значениями <paramref name="value" /> + <paramref name="startIndex" />, слишком велик для текущей платформы, то есть при вычислении адреса произошло переполнение.  
  
-или- 
Длина новой инициализируемой строки слишком велика для выделения.</exception>
        <exception cref="T:System.ArgumentException">Адрес, указанный значениями <paramref name="value" /> + <paramref name="startIndex" />, меньше 64 000.  
  
-или- 
Не удалось инициализировать новый экземпляр <see cref="T:System.String" /> с помощью <paramref name="value" />, исходя из предположения, что значение <paramref name="value" /> представлено в кодировке ANSI.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> и <paramref name="length" /> совместно определяют недопустимый адрес.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на массив 8-разрядных целых чисел со знаком.</param>
        <param name="startIndex">Начальная позиция в <paramref name="value" />.</param>
        <param name="length">Используемое количество знаков в <paramref name="value" />.</param>
        <param name="enc">Объект, определяющий способ кодировки массива, на который указывает параметр <paramref name="value" />. Если значением параметра <paramref name="enc" /> является <see langword="null" />, предполагается кодировка ANSI.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.String" /> значением, определенным заданным указателем на массив 8-разрядных целых чисел со знаком, начальной позицией в пределах этого массива, длиной и объектом <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Примеры и информация об этом и других комплексную использовании `String` перегрузки конструктора, см. в разделе <xref:System.String.%23ctor%2A> конструктор сводки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.  
  
-или- 
Адрес, указанный значениями <paramref name="value" /> + <paramref name="startIndex" />, слишком велик для текущей платформы, то есть при вычислении адреса произошло переполнение.  
  
-или- 
Длина новой инициализируемой строки слишком велика для выделения.</exception>
        <exception cref="T:System.ArgumentException">Адрес, указанный значениями <paramref name="value" /> + <paramref name="startIndex" />, меньше 64 000.  
  
-или- 
Не удалось инициализировать новый экземпляр <see cref="T:System.String" /> с помощью <paramref name="value" />, если предполагается, что <paramref name="value" /> представлен в кодировке <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> и <paramref name="length" /> совместно определяют недопустимый адрес.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Index) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[Index] { char get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Index) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в текущей строке.</param>
        <summary>Возвращает объект <see cref="T:System.Char" /> в указанной позиции в текущем объекте <see cref="T:System.String" />.</summary>
        <value>Объект в позиции <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Параметр отсчитывается от нуля.  
  
 Это свойство возвращает <xref:System.Char> объект, находящийся в позиции, заданной параметром `index` параметр. Тем не менее, символ Юникода могут быть представлены в более чем одной <xref:System.Char>. Используйте <xref:System.Globalization.StringInfo?displayProperty=nameWithType> работе с Юникодом знаков вместо <xref:System.Char> объектов. Дополнительные сведения см. в разделе «Char объектов и символы Юникода» в <xref:System.String> Общие сведения о классе.  
  
 В C# <xref:System.String.Chars%2A> свойство является индексатором. В Visual Basic, это свойство по умолчанию <xref:System.String> класса. Каждый <xref:System.Char> доступ к объекту в строке можно получить, используя следующий код.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 Ниже приведен пример, как можно использовать этот индексатор в подпрограмме для проверки строки.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Значение <paramref name="index" /> больше или равно длине данного объекта или меньше нуля.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public string this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Chars(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(range As Range) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[Range] { System::String ^ get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Range) : string" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ссылку на данный экземпляр класса <see cref="T:System.String" />.</summary>
        <returns>Этот экземпляр <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемое значение не является независимая копия данного экземпляра; Это просто другое представление тех же данных. Используйте <xref:System.String.Copy%2A> или <xref:System.String.CopyTo%2A> метод для создания отдельного <xref:System.String> объект с тем же значением, что и данный экземпляр.  
  
 Так как <xref:System.String.Clone%2A> метод просто возвращает существующий экземпляр строки, не имеет практического смысла для прямого вызова.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сравнивает два указанных объекта <see cref="T:System.String" /> и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все перегрузки метода <xref:System.String.Compare%2A> возвращают 32-разрядное целое число со знаком, выражающее лексическое соотношение двух сравниваемых значений.  
  
|Значение|Условие|  
|-----------|---------------|  
|Меньше нуля|Первую подстроку предшествует подстроке второй в порядке сортировки.|  
|Нуль|Подстроки появляются в той же позиции в порядке сортировки, или параметр `length` равен нулю.|  
|Больше нуля|Первую подстроку следует за второй подстроки в порядке сортировки.|  
  
> [!WARNING]
>  По возможности следует вызывать перегрузку <xref:System.String.Compare%2A> метод, который включает в себя <xref:System.StringComparison> параметра. Дополнительные сведения см. в разделе [Рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Рекомендации по использованию строк в .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Первая сравниваемая строка.</param>
        <param name="strB">Вторая сравниваемая строка.</param>
        <summary>Сравнивает два указанных объекта <see cref="T:System.String" /> и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description><paramref name="strA" /> предшествует <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="strA" /> занимает ту же позицию в порядке сортировки, что и объект <paramref name="strB" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description><paramref name="strA" /> следует за <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сравнение выполняется с помощью текущего языка и региональных параметров для получения сведения об особенностях языка и региональных параметров, таких как правила учета регистра и алфавитный порядок отдельных символов. Например, языка и региональных параметров может указать, что определенные сочетания знаков рассматриваться как один символ, или прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символов, которые предшествуют или Перейдите по нему.  
  
 Сравнение выполняется с помощью правил сортировки слов. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  При сравнении строк следует вызывать <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> метод, который необходимо явно указать тип выполняемого сравнения строк, который использует метод. Дополнительные сведения см. в разделе [Рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 Один или оба сравниваемых значения могут быть `null`. По определению, любая строка, включая пустую строку ("»), сравнивает больше, чем ссылкой на null; и два указателя null равны друг с другом.  
  
 Сравнение заканчивается, когда встречается неравенство или обе строки уже обработаны. Тем не менее если две строки считаются равными окончание одной строки, а другая строка имеет осталось символов, затем строка с символами оставшиеся считается большей. Возвращается результат последнего выполненного сравнения.  
  
 Когда влияют на результаты сравнений правила определения регистра для конкретного языка и региональных параметров, это может привести к непредвиденным результатам. Например, в турецком языке, следующий пример вызывает неверных результатов, так как файловой системы в турецком языке не использует регистр по правилам языка правил для буквы «i» в «файл».  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Сравните имя пути «файл», используя порядковое сравнение. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.String.Compare%28System.String%2CSystem.String%29> метод для сравнения трех наборов строк.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 В следующем примере `ReverseStringComparer` класс демонстрирует, как можно сравнить две строки с <xref:System.String.Compare%2A> метод.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. <see cref="M:System.String.Compare(System.String,System.String)" /> Метод не учитывает такие символы, когда он выполняет сравнение с учетом языка и региональных параметров. Например, если следующий код выполняется на [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, сравнение с учетом языка и региональных параметров «Animal» с «ani использовать» (с помощью мягкий перенос или 00AD U +) указывает, что две строки равны.  
  
[!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
Для распознавания игнорируемые символы в сравнении строк, вызвать <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> метод и задать значение либо <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для `comparisonType` параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Первая сравниваемая строка.</param>
        <param name="strB">Вторая сравниваемая строка.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при сравнении; в противном случае — значение <see langword="false" />.</param>
        <summary>Сравнивает два указанных объекта <see cref="T:System.String" /> (с учетом или без учета регистра) и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description><paramref name="strA" /> предшествует <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="strA" /> занимает ту же позицию в порядке сортировки, что и объект <paramref name="strB" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description><paramref name="strA" /> следует за <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сравнение выполняется с помощью текущего языка и региональных параметров для получения сведения об особенностях языка и региональных параметров, таких как правила учета регистра и алфавитный порядок отдельных символов. Например, языка и региональных параметров может указать, что определенные сочетания знаков рассматриваться как один символ, или прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символов, которые предшествуют или Перейдите по нему.  
  
 Сравнение выполняется с помощью правил сортировки слов. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  При сравнении строк следует вызывать <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> метод, который необходимо явно указать тип выполняемого сравнения строк, который использует метод. Дополнительные сведения см. в разделе [Рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 Один или оба сравниваемых значения могут быть `null`. По определению, любая строка, включая пустую строку ("»), сравнивает больше, чем ссылкой на null; и два указателя null равны друг с другом.  
  
 Сравнение заканчивается, когда встречается неравенство или обе строки уже обработаны. Тем не менее если две строки считаются равными окончание одной строки, а другая строка имеет осталось символов, затем строка с символами оставшиеся считается большей. Возвращается результат последнего выполненного сравнения.  
  
 Когда влияют на результаты сравнений правила определения регистра для конкретного языка и региональных параметров, это может привести к непредвиденным результатам. Например, в турецком языке, следующий пример вызывает неверных результатов, так как файловой системы в турецком языке не использует регистр по правилам языка правил для буквы «i» в «файл».  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Сравните имя пути «файл», используя порядковое сравнение. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 В следующем примере показано, что <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> метод равнозначно использованию <xref:System.String.ToUpper%2A> или <xref:System.String.ToLower%2A> при сравнении строк.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> Метод не учитывает такие символы, когда он выполняет сравнение с учетом языка и региональных параметров. Например, если следующий код выполняется на [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, культуры, без учета регистра сравнение «animal» с «Ani использовать» (с помощью мягкий перенос или 00AD U +) указывает, что две строки равны.  
  
[!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
Для распознавания игнорируемые символы в сравнении строк, вызвать <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> метод и задать значение либо <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для <paramref name="comparisonType" /> параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Первая сравниваемая строка.</param>
        <param name="strB">Вторая сравниваемая строка.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее используемые при сравнении правила.</param>
        <summary>Сравнивает два указанных объекта <see cref="T:System.String" /> с использованием заданных правил и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description><paramref name="strA" /> предшествует <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="strA" /> занимает ту же позицию в порядке сортировки, что и объект <paramref name="strB" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description><paramref name="strA" /> следует за <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` Задаёт ли при сравнении следует использовать текущие или инвариантные язык и региональные параметры, учитывает или без учета регистра сравниваемых объектов, а использовать word (язык и региональные параметры с учетом) или правила сортировки по порядковому номеру (без учета языка и региональных параметров).  
  
 Один или оба сравниваемых значения могут быть `null`. По определению, любая строка, включая пустую строку ("»), сравнивает больше, чем ссылкой на null; и два указателя null равны друг с другом.  
  
 Сравнение заканчивается, когда встречается неравенство или обе строки уже обработаны. Тем не менее если две строки считаются равными окончание одной строки, а другая строка имеет осталось символов, строка с символами оставшиеся считается большей. Возвращается результат последнего выполненного сравнения.  
  
 Когда влияют на результаты сравнений правила определения регистра для конкретного языка и региональных параметров, это может привести к непредвиденным результатам. Например, в турецком языке, следующий пример вызывает неверных результатов, так как файловой системы в турецком языке не использует регистр по правилам языка правил для буквы «i» в «файл».  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Сравните имя пути «файл», используя порядковое сравнение. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 В следующем примере сравниваются три версии буквы «I». Результаты зависят от выбора языка и региональных параметров, учитывается ли регистр и выполняется ли порядковое сравнение.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является значением <see cref="T:System.StringComparison" />.</exception>
        <exception cref="T:System.NotSupportedException">Тип <see cref="T:System.StringComparison" /> не поддерживается.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> Метод не учитывает такие символы, когда он выполняет сравнение с учетом языка и региональных параметров. Для распознавания игнорируемые символы в сравнение, укажите в качестве параметра <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> для <paramref name="comparisonType" /> параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Первая сравниваемая строка.</param>
        <param name="strB">Вторая сравниваемая строка.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при сравнении; в противном случае — значение <see langword="false" />.</param>
        <param name="culture">Объект, предоставляющий сведения об особенностях сравнения, определяемых языком и региональными параметрами.</param>
        <summary>Сравнивает два указанных объекта <see cref="T:System.String" /> (с учетом или без учета регистра), используя сведения о языке и региональных параметрах, и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description><paramref name="strA" /> предшествует <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="strA" /> занимает ту же позицию в порядке сортировки, что и объект <paramref name="strB" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description><paramref name="strA" /> следует за <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сравнение выполняется с помощью `culture` параметр, чтобы получить сведения об особенностях языка и региональных параметров, таких как правила учета регистра и алфавитный порядок отдельных символов. Например, языка и региональных параметров может указать, что определенные сочетания знаков рассматриваться как один символ, или прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символов, которые предшествуют или Перейдите по нему.  
  
 Сравнение выполняется с помощью правил сортировки слов. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Один или оба сравниваемых значения могут быть `null`. По определению, любая строка, включая пустую строку ("»), сравнивает больше, чем ссылкой на null; и два указателя null равны друг с другом.  
  
 Сравнение заканчивается, когда встречается неравенство или обе строки уже обработаны. Тем не менее если две строки считаются равными окончание одной строки, а другая строка имеет осталось символов, затем строка с символами оставшиеся считается большей. Возвращается результат последнего выполненного сравнения.  
  
 Когда влияют на результаты сравнений правила определения регистра для конкретного языка и региональных параметров, это может привести к непредвиденным результатам. Например, в турецком языке, следующий пример вызывает неверных результатов, так как файловой системы в турецком языке не использует регистр по правилам языка правил для буквы «i» в «файл».  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Сравните имя пути «файл», используя порядковое сравнение. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 В следующем примере показано, как язык и региональные параметры могут повлиять на сравнение. Чешский — Чешская Республика языка и региональных параметров «ch» при один символ, который больше, чем «d». Тем не менее в английский — США языка и региональных параметров «ch» состоит из двух символов, и «c» меньше, чем «d».  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> — <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> Метод не учитывает такие символы, когда он выполняет сравнение с учетом языка и региональных параметров. Например, если следующий код выполняется на [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, без учета регистра сравнение «animal» с «Ani использовать» (с помощью мягкий перенос или U + 00AD) с помощью инвариантный язык и региональные параметры указывает, что две строки равны.  
  
[!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
Для распознавания игнорируемые символы в сравнении строк, вызвать <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> метод и задать значение либо <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для <paramref name="options" /> параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Первая сравниваемая строка.</param>
        <param name="strB">Вторая сравниваемая строка.</param>
        <param name="culture">Язык и региональные параметры, которые предоставляют сведения об особенностях сравнения с учетом языка и региональных параметров.</param>
        <param name="options">Параметры, которые используются во время сравнения (например, игнорирование регистра или символов).</param>
        <summary>Сравнивает два заданных объекта <see cref="T:System.String" />, используя указанные параметры сравнения и сведения о языке и региональных параметрах, которые влияют на сравнение, и возвращает целое число, показывающее связь между двумя строками в порядке сортировки.</summary>
        <returns>32-разрядное целое число со знаком, которое указывает на лексические отношения между <paramref name="strA" /> и <paramref name="strB" />, как показано в следующей таблице. 
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description><paramref name="strA" /> предшествует <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description><paramref name="strA" /> занимает ту же позицию в порядке сортировки, что и объект <paramref name="strB" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description><paramref name="strA" /> следует за <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сравнение выполняется с помощью `culture` параметр для получения сведений о культуре, такие как правила определения регистра и алфавитный порядок отдельных символов. Например, определенного языка и региональных параметров указать, что определенные сочетания знаков рассматриваться как один символ, что определенным образом сравниваться прописные и строчные буквы, или, порядок сортировки символа зависит от символов, Введите перед или после него.  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Метод предназначен главным образом для использования в сортировке или операции сортировки в алфавитном порядке. Он не должен использоваться, при основной целью вызова метода для определения эквивалентности двух строк (то есть, при вызове метода предназначена для проверки на возвращаемое значение 0). Чтобы определить, эквивалентны ли две строки, вызовите <xref:System.String.Equals%2A> метод.  
  
 Можно дополнительно указать сравнения с `options` параметр, который состоит из одного или нескольких членов из <xref:System.Globalization.CompareOptions> перечисления. Тем не менее, так как этот метод предназначен для проведения сравнение строк с учетом языка и региональных параметров, <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> и <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> значения не оказывают влияния.  
  
 Один или два сравниваемых значения могут быть `null`. По определению, любая строка, включая <xref:System.String.Empty?displayProperty=nameWithType>, сравнивает больше, чем пустая ссылка, а две пустые ссылки равны друг с другом.  
  
 Сравнение заканчивается, когда встречается неравенство или обе строки уже обработаны. Тем не менее если две строки считаются равными окончание одной строки, а другая строка имеет осталось символов, строка с остальные символы считается большей.  
  
   
  
## Examples  
 В следующем примере сравниваются две строки тремя разными способами: с помощью лингвистического сравнения для региональных параметров en US; с помощью лингвистического сравнения с учетом регистра для региональных параметров en US; и с помощью порядковое сравнение. Здесь показано, как три метода сравнения дают три разные результаты.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> не является значением <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> — <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Метод не учитывает такие символы, когда он выполняет сравнение с учетом языка и региональных параметров. Для распознавания игнорируемые символы в сравнение, укажите в качестве параметра <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для <paramref name="options" /> параметра.</para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Первая из сравниваемых строк.</param>
        <param name="indexA">Позиция подстроки в <paramref name="strA" />.</param>
        <param name="strB">Вторая из сравниваемых строк.</param>
        <param name="indexB">Позиция подстроки в <paramref name="strB" />.</param>
        <param name="length">Максимальное число сравниваемых знаков в подстроках.</param>
        <summary>Сравнивает подстроки двух указанных объектов <see cref="T:System.String" /> и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-разрядное целое число со знаком, выражающее лексическое соотношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Подстрока в <paramref name="strA" /> предшествует подстроке в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description> Подстроки появляются в той же позиции в порядке сортировки, или параметр <paramref name="length" /> равен нулю.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Подстрока в <paramref name="strA" /> следует за подстрокой в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запуск подстроках в `strA` в `indexA` и в `strB` в `indexB`. Оба `indexA` и `indexB` являются отсчитываемый от нуля, то есть первый символ в `strA` и `strB` равен нулю. Длина первой подстроки равна длине `strA` минус `indexA` плюс один. Длина второй подстроки равна длине `strB` минус `indexB` плюс один.  
  
 Число сравниваемых символов равно меньшему из длин подстрок и `length`. `indexA`, `indexB`, И `length` параметры должны быть неотрицательными.  
  
 Сравнение выполняется с помощью текущего языка и региональных параметров для получения сведения об особенностях языка и региональных параметров, таких как правила учета регистра и алфавитный порядок отдельных символов. Например, языка и региональных параметров может указать, что определенные сочетания знаков рассматриваться как один символ, или прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символов, которые предшествуют или Перейдите по нему.  
  
 Сравнение выполняется с помощью правил сортировки слов. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  При сравнении строк следует вызывать <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> метод, который необходимо явно указать тип выполняемого сравнения строк, который использует метод. Дополнительные сведения см. в разделе [Рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 Один или оба сравниваемых значения могут быть `null`. По определению, любая строка, включая пустую строку ("»), сравнивает больше, чем ссылкой на null; и два указателя null равны друг с другом.  
  
 Сравнение заканчивается, когда встречается неравенство или обоих подстроки уже обработаны. Тем не менее если две строки считаются равными окончание одной строки, а другая строка имеет осталось символов, затем строка с символами оставшиеся считается большей. Возвращается результат последнего выполненного сравнения.  
  
 Когда влияют на результаты сравнений правила определения регистра для конкретного языка и региональных параметров, это может привести к непредвиденным результатам. Например, в турецком языке, следующий пример вызывает неверных результатов, так как файловой системы в турецком языке не использует регистр по правилам языка правил для буквы «i» в «файл».  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Сравните имя пути «файл», используя порядковое сравнение. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 В следующем примере сравниваются две подстроки.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="indexA" /> больше значения <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
-или- 
 Значение <paramref name="indexB" /> больше значения <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
-или- 
 <paramref name="indexA" />, <paramref name="indexB" /> или <paramref name="length" /> является отрицательным значением.  
  
-или- 
<paramref name="indexA" /> или <paramref name="indexB" /> равно <see langword="null" />, а <paramref name="length" /> больше нуля.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> Метод не учитывает эти символы при выполнении лингвистического или зависящих от языка и региональных параметров сравнения. Для распознавания игнорируемые символы в сравнение, вызовите <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> метод и указать значение <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для <paramref name="comparisonType" /> параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Первая из сравниваемых строк.</param>
        <param name="indexA">Позиция подстроки в <paramref name="strA" />.</param>
        <param name="strB">Вторая из сравниваемых строк.</param>
        <param name="indexB">Позиция подстроки в <paramref name="strB" />.</param>
        <param name="length">Максимальное число сравниваемых знаков в подстроках.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при сравнении; в противном случае — значение <see langword="false" />.</param>
        <summary>Сравнивает подстроки двух заданных объектов <see cref="T:System.String" /> (с учетом или без учета регистра) и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Подстрока в <paramref name="strA" /> предшествует подстроке в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description> Подстроки появляются в той же позиции в порядке сортировки, или параметр <paramref name="length" /> равен нулю.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Подстрока в <paramref name="strA" /> следует за подстрокой в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запуск подстроках в `strA` в `indexA`и в `strB` в `indexB`. Оба `indexA` и `indexB` являются отсчитываемый от нуля, то есть первый символ в `strA` и `strB` равен нулю. Длина первой подстроки равна длине `strA` минус `indexA` плюс один. Длина второй подстроки равна длине `strB` минус `indexB` плюс один.  
  
 Число сравниваемых символов равно меньшему из длин подстрок и `length`. `indexA`, `indexB`, И `length` параметры должны быть неотрицательными.  
  
 Сравнение выполняется с помощью текущего языка и региональных параметров для получения сведения об особенностях языка и региональных параметров, таких как правила учета регистра и алфавитный порядок отдельных символов. Например, языка и региональных параметров может указать, что определенные сочетания знаков рассматриваться как один символ, или прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символов, которые предшествуют или Перейдите по нему.  
  
 Сравнение выполняется с помощью правил сортировки слов. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  При сравнении строк следует вызывать <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> метод, который необходимо явно указать тип выполняемого сравнения строк, который использует метод. Дополнительные сведения см. в разделе [Рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md).  
  
 Один или оба сравниваемых значения могут быть `null`. По определению, любая строка, включая пустую строку ("»), сравнивает больше, чем ссылкой на null; и два указателя null равны друг с другом.  
  
 Сравнение заканчивается, когда встречается неравенство или обоих подстроки уже обработаны. Тем не менее если две строки считаются равными окончание одной строки, а другая строка имеет осталось символов, затем строка с символами оставшиеся считается большей. Возвращается результат последнего выполненного сравнения.  
  
 Когда влияют на результаты сравнений правила определения регистра для конкретного языка и региональных параметров, это может привести к непредвиденным результатам. Например, в турецком языке, следующий пример вызывает неверных результатов, так как файловой системы в турецком языке не использует регистр по правилам языка правил для буквы «i» в «файл».  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 Имя пути должно сравниваться инвариантным способом. Правильный код для этого выглядит следующим образом.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 В следующем примере выполняется два сравнения двух подстрок, которые различаются только регистром. Первое сравнение не учитывает регистр, а второй — учитывается.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="indexA" /> больше значения <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
-или- 
 Значение <paramref name="indexB" /> больше значения <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
-или- 
 <paramref name="indexA" />, <paramref name="indexB" /> или <paramref name="length" /> является отрицательным значением.  
  
-или- 
<paramref name="indexA" /> или <paramref name="indexB" /> равно <see langword="null" />, а <paramref name="length" /> больше нуля.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> Метод не учитывает эти символы при выполнении лингвистического или зависящих от языка и региональных параметров сравнения. Для распознавания игнорируемые символы в сравнение, вызовите <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> метод и указать значение <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для <paramref name="comparisonType" /> параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Первая из сравниваемых строк.</param>
        <param name="indexA">Позиция подстроки в <paramref name="strA" />.</param>
        <param name="strB">Вторая из сравниваемых строк.</param>
        <param name="indexB">Позиция подстроки в <paramref name="strB" />.</param>
        <param name="length">Максимальное число сравниваемых знаков в подстроках.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее используемые при сравнении правила.</param>
        <summary>Сравнивает подстроки двух указанных объектов <see cref="T:System.String" /> с использованием заданных правил и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Подстрока в <paramref name="strA" /> предшествует подстроке в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description> Подстроки появляются в одной и той же позиции в порядке сортировки, или параметр <paramref name="length" /> равен нулю.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Подстрока в <paramref name="strA" /> следует за подстрокой в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запуск подстроках в `strA` в `indexA` и в `strB` в `indexB`. Оба `indexA` и `indexB` являются отсчитываемый от нуля, то есть первый символ в `strA` и `strB` — в позицию ноль, размещает один. Длина первой подстроки равна длине `strA` минус `indexA` плюс один. Длина второй подстроки равна длине `strB` минус `indexB` плюс один.  
  
 Число сравниваемых символов равно меньшему из длин подстрок и `length`. `indexA`, `indexB`, И `length` параметры должны быть неотрицательными.  
  
 `comparisonType` Задаёт ли при сравнении следует использовать текущие или инвариантные язык и региональные параметры, учитывает или без учета регистра сравниваемых объектов, а использовать word (язык и региональные параметры с учетом) или правила сортировки по порядковому номеру (без учета языка и региональных параметров).  
  
 Один или оба сравниваемых значения могут быть `null`. По определению, любая строка, включая пустую строку ("»), сравнивает больше, чем ссылкой на null; и два указателя null равны друг с другом.  
  
 Сравнение заканчивается, когда встречается неравенство или обоих подстроки уже обработаны. Тем не менее если две строки считаются равными окончание одной строки, а другая строка имеет осталось символов, строка с символами оставшиеся считается большей. Возвращается результат последнего выполненного сравнения.  
  
 Когда влияют на результаты сравнений правила определения регистра для конкретного языка и региональных параметров, это может привести к непредвиденным результатам. Например, в турецком языке, следующий пример вызывает неверных результатов, так как файловой системы в турецком языке не использует регистр по правилам языка правил для буквы «i» в «файл».  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Сравните имя пути «файл», используя порядковое сравнение. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 В следующем примере сравниваются две подстроки.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="indexA" /> больше значения <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
-или- 
 Значение <paramref name="indexB" /> больше значения <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
-или- 
 <paramref name="indexA" />, <paramref name="indexB" /> или <paramref name="length" /> является отрицательным значением.  
  
-или- 
<paramref name="indexA" /> или <paramref name="indexB" /> равно <see langword="null" />, а <paramref name="length" /> больше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> Метод не учитывает эти символы при выполнении лингвистического или зависящих от языка и региональных параметров сравнения. Для распознавания игнорируемые символы в сравнение, укажите в качестве параметра <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> для <paramref name="comparisonType" /> параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Первая из сравниваемых строк.</param>
        <param name="indexA">Позиция подстроки в <paramref name="strA" />.</param>
        <param name="strB">Вторая из сравниваемых строк.</param>
        <param name="indexB">Позиция подстроки в <paramref name="strB" />.</param>
        <param name="length">Максимальное число сравниваемых знаков в подстроках.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при сравнении; в противном случае — значение <see langword="false" />.</param>
        <param name="culture">Объект, предоставляющий сведения об особенностях сравнения, определяемых языком и региональными параметрами.</param>
        <summary>Сравнивает подстроки двух заданных объектов <see cref="T:System.String" /> (с учетом или без учета регистра), используя сведения о языке и региональных параметрах, и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</summary>
        <returns>Целое число, выражающее лексическое соотношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Подстрока в <paramref name="strA" /> предшествует подстроке в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description> Подстроки появляются в той же позиции в порядке сортировки, или параметр <paramref name="length" /> равен нулю.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Подстрока в <paramref name="strA" /> следует за подстрокой в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запуск подстроках в `strA` в `indexA`и в `strB` в `indexB`. Оба `indexA` и `indexB` являются отсчитываемый от нуля, то есть первый символ в `strA` и `strB` — в позицию ноль, размещает один. Длина первой подстроки равна длине `strA` минус `indexA` плюс один. Длина второй подстроки равна длине `strB` минус `indexB` плюс один.  
  
 Число сравниваемых символов равно меньшему из длин подстрок и `length`. `indexA`, `indexB`, И `length` параметры должны быть неотрицательными.  
  
 Сравнение выполняется с помощью `culture` параметр, чтобы получить сведения об особенностях языка и региональных параметров, таких как правила учета регистра и алфавитный порядок отдельных символов. Например, языка и региональных параметров может указать, что определенные сочетания знаков рассматриваться как один символ, или прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символов, которые предшествуют или Перейдите по нему.  
  
 Сравнение выполняется с помощью правил сортировки слов. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Один или оба сравниваемых значения могут быть `null`. По определению, любая строка, включая пустую строку ("»), сравнивает больше, чем ссылкой на null; и два указателя null равны друг с другом.  
  
 Сравнение заканчивается, когда встречается неравенство или обоих подстроки уже обработаны. Тем не менее если две строки считаются равными окончание одной строки, а другая строка имеет осталось символов, затем строка с символами оставшиеся считается большей. Возвращается результат последнего выполненного сравнения.  
  
 Когда влияют на результаты сравнений правила определения регистра для конкретного языка и региональных параметров, это может привести к непредвиденным результатам. Например, в турецком языке, следующий пример вызывает неверных результатов, так как файловой системы в турецком языке не использует регистр по правилам языка правил для буквы «i» в «файл».  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Сравните имя пути «файл», используя порядковое сравнение. Правильный код для этого выглядит следующим образом:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 Приведенный ниже сравниваются две подстроки, с помощью разных языков и региональных параметров и без учета регистра подстроки. Выбор языка и региональных параметров влияет на способ буква «I» — по сравнению с.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="indexA" /> больше значения <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
-или- 
 Значение <paramref name="indexB" /> больше значения <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
-или- 
 <paramref name="indexA" />, <paramref name="indexB" /> или <paramref name="length" /> является отрицательным значением.  
  
-или- 
<paramref name="strA" /> или <paramref name="strB" /> равно <see langword="null" />, а <paramref name="length" /> больше нуля.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> — <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> Метод не учитывает эти символы при выполнении лингвистического или зависящих от языка и региональных параметров сравнения. Для распознавания игнорируемые символы в сравнение, вызовите <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> метод и указать значение <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для <paramref name="options" /> параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Первая из сравниваемых строк.</param>
        <param name="indexA">Начальная позиция подстроки в пределах <paramref name="strA" />.</param>
        <param name="strB">Вторая из сравниваемых строк.</param>
        <param name="indexB">Начальная позиция подстроки в пределах <paramref name="strB" />.</param>
        <param name="length">Максимальное число сравниваемых знаков в подстроках.</param>
        <param name="culture">Объект, предоставляющий сведения об особенностях сравнения, определяемых языком и региональными параметрами.</param>
        <param name="options">Параметры, которые используются во время сравнения (например, игнорирование регистра или символов).</param>
        <summary>Сравнивает подстроки двух заданных объектов <see cref="T:System.String" />, используя указанные параметры сравнения и сведения о языке и региональных параметрах, которые влияют на сравнение, и возвращает целое число, показывающее связь между двумя подстроками в порядке сортировки.</summary>
        <returns>Целое число, которое указывает на лексические отношения между двумя подстроками, как показано в следующей таблице.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Подстрока в <paramref name="strA" /> предшествует подстроке в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item><item><term> Нуль 
 </term><description> Подстроки появляются в той же позиции в порядке сортировки, или параметр <paramref name="length" /> равен нулю.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Подстрока в <paramref name="strA" /> следует за подстрокой в <paramref name="strB" /> в порядке сортировки.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запуск подстроках в `strA` позиции `indexA` и в `strB` позиции `indexB`. Длина первой подстроке, представляет собой длину `strA` минус `indexA`. Длина подстроки, вторая — длина `strB` минус `indexB`.  
  
 Число сравниваемых символов равно меньшему из длин подстрок и `length`. `indexA`, `indexB`, И `length` параметры должны быть неотрицательными.  
  
 Сравнение выполняется с помощью `culture` параметр для получения сведений о культуре, такие как правила определения регистра и алфавитный порядок отдельных символов. Например, определенного языка и региональных параметров указать, что определенные сочетания знаков рассматриваться как один символ, что определенным образом сравниваться прописные и строчные буквы, или, порядок сортировки символа зависит от символов, Введите перед или после него.  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Метод предназначен главным образом для использования в сортировке или операции сортировки в алфавитном порядке. Он не должен использоваться, при основной целью вызова метода для определения эквивалентности двух подстроки (то есть, при вызове метода предназначена для проверки на возвращаемое значение 0). Чтобы определить, эквивалентны ли две строки, вызовите <xref:System.String.Equals%2A> метод.  
  
 Один или оба `strA` и `strB` может быть `null`. По определению, любая строка, включая <xref:System.String.Empty?displayProperty=nameWithType>, сравнивает больше, чем пустая ссылка, а две пустые ссылки равны друг с другом.  
  
 Можно дополнительно указать сравнения с `options` параметр, который состоит из одного или нескольких членов из <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> перечисления. Тем не менее, так как этот метод предназначен для проведения сравнение строк с учетом языка и региональных параметров, <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> и <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> значения не оказывают влияния.  
  
 Сравнение заканчивается, когда встречается неравенство или обоих подстроки уже обработаны. Тем не менее если две строки считаются равными окончание одной строки, а другая строка имеет осталось символов, строка с остальные символы считается большей. Возвращается результат последнего выполненного сравнения.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> метод для сравнения фамилий два человека. Затем он размещает их в алфавитном порядке.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> не является значением <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="indexA" /> больше значения <paramref name="strA" /><see langword=".Length" />.  
  
-или- 
 Значение <paramref name="indexB" /> больше значения <paramref name="strB" /><see langword=".Length" />.  
  
-или- 
 <paramref name="indexA" />, <paramref name="indexB" /> или <paramref name="length" /> является отрицательным значением.  
  
-или- 
<paramref name="strA" /> или <paramref name="strB" /> равно <see langword="null" />, а <paramref name="length" /> больше нуля.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> — <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Метод не учитывает эти символы при выполнении лингвистического или зависящих от языка и региональных параметров сравнения. Для распознавания игнорируемые символы в сравнение, укажите в качестве параметра <see cref="F:System.Globalization.CompareOptions.Ordinal" /> или <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> для <paramref name="options" /> параметра.</para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сравнивает два объекта <see cref="T:System.String" />, оценивая числовые значения соответствующих объектов <see cref="T:System.Char" /> в каждой строке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Первая сравниваемая строка.</param>
        <param name="strB">Вторая сравниваемая строка.</param>
        <summary>Сравнивает два указанных объекта <see cref="T:System.String" />, оценивая числовые значения соответствующих объектов <see cref="T:System.Char" /> в каждой строке.</summary>
        <returns>Целое число, выражающее лексическое соотношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description>Значение <paramref name="strA" /> меньше <paramref name="strB" />.  
  
 </description></item><item><term> Нуль 
 </term><description>Значения параметров <paramref name="strA" /> и <paramref name="strB" /> равны.  
  
 </description></item><item><term> Больше нуля 
 </term><description>Значение <paramref name="strA" /> больше значения <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение с учетом регистра, используя правила сортировки по порядковому номеру. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Чтобы выполнить сравнение без учета регистра, используя правила сортировки по порядковому номеру, вызовите <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> метод с `comparisonType` аргумент значение <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Так как <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> — это статический метод `strA` и `strB` может быть `null`. Если оба значения равны `null`, метод возвращает 0 (ноль), которое указывает, что `strA` и `strB` равны. Если только одно из значений `null`, метод учитывает ненулевое значение, большее.  
  
   
  
## Examples  
 В следующем примере выполняется и порядковое сравнение двух строк, отличаются только регистром.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Первая из сравниваемых строк.</param>
        <param name="indexA">Начальный индекс подстроки в <paramref name="strA" />.</param>
        <param name="strB">Вторая из сравниваемых строк.</param>
        <param name="indexB">Начальный индекс подстроки в <paramref name="strB" />.</param>
        <param name="length">Максимальное число сравниваемых знаков в подстроках.</param>
        <summary>Сравнивает подстроки двух указанных объектов <see cref="T:System.String" />, вычисляя числовые значения соответствующих объектов <see cref="T:System.Char" /> в каждой подстроке.</summary>
        <returns>32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Подстрока в <paramref name="strA" /> меньше, чем подстрока в <paramref name="strB" />.  
  
 </description></item><item><term> Нуль 
 </term><description> Подстроки равны, или значение параметра <paramref name="length" /> равно нулю.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Подстрока в <paramref name="strA" /> больше, чем подстрока в <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indexA`, `indexB`, И `length` параметры должны быть неотрицательными.  
  
 Число сравниваемых знаков равно меньшему из длину `strA` меньше `indexA`, длина `strB` меньше `indexB`, и `length`.  
  
 Этот метод выполняет сравнение с учетом регистра, используя правила сортировки по порядковому номеру. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Чтобы выполнить сравнение без учета регистра, используя правила сортировки по порядковому номеру, вызовите <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> метод с `comparisonType` аргумент значение <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Так как <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> — это статический метод `strA` и `strB` может быть `null`. Если оба значения равны `null`, метод возвращает 0 (ноль), которое указывает, что `strA` и `strB` равны. Если только одно из значений `null`, метод учитывает ненулевое значение, большее.  
  
   
  
## Examples  
 В следующем примере показано, что <xref:System.String.CompareOrdinal%2A> и <xref:System.String.Compare%2A> использовать различные порядки сортировки.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strA" /> не имеет значение <see langword="null" />, и значение <paramref name="indexA" /> больше <paramref name="strA" />,<see cref="P:System.String.Length" />.  
  
-или- 
 <paramref name="strB" /> не имеет значение <see langword="null" />, и значение <paramref name="indexB" /> больше <paramref name="strB" />,<see cref="P:System.String.Length" />.  
  
-или- 
 <paramref name="indexA" />, <paramref name="indexB" /> или <paramref name="length" /> является отрицательным значением.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сравнивает данный экземпляр с заданным объектом или строкой <see cref="T:System.String" /> и возвращает целое число, которое показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и заданный объект или строка <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обе перегрузки <xref:System.String.CompareTo%2A> метода выполняют сравнение с учетом языка и региональных параметров и регистра. Этот метод нельзя использовать для сравнения без учета языка и региональных параметров или порядковый номер. Для ясности кода рекомендуется избегать <xref:System.String.CompareTo%2A> метод и вызвать <xref:System.String.Compare%2A> метод вместо этого.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Объект, имеющий значение <see cref="T:System.String" />.</param>
        <summary>Сравнивает данный экземпляр с указанным объектом <see cref="T:System.Object" /> и показывает, расположен ли экземпляр перед, после или в той же позиции в порядке сортировки, что и заданный объект <see cref="T:System.Object" />.</summary>
        <returns>32-битовое целое число со знаком, которое показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и параметр <paramref name="value" />.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Данный экземпляр предшествует параметру <paramref name="value" />.  
  
 </description></item><item><term> Нуль 
 </term><description> Данный экземпляр имеет ту же позицию в порядке сортировки, что и <paramref name="value" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Данный экземпляр стоит после параметра <paramref name="value" />.  
  
-или- 
 <paramref name="value" /> — <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` должен быть <xref:System.String> объекта.  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> Метод был разработан в первую очередь для использования в сортировке или выстраивания в алфавитном порядке операций. Он не должен использоваться, при основной целью вызова метода для определения эквивалентности двух строк. Чтобы определить, эквивалентны ли две строки, вызовите <xref:System.String.Equals%2A> метод.  
  
 Этот метод выполняет сравнение по словам (с учетом регистра и культуры) с использованием текущего языка и региональных параметров. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Дополнительные сведения о поведении этого метода см. в разделе "Примечания" <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.String.CompareTo%2A> метод с <xref:System.Object>. Так как оно пытается сравнить <xref:System.String> экземпляр `TestClass` объекта, метод вызывает <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> не является объектом <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. <see cref="M:System.String.CompareTo(System.Object)" /> Метод не учитывает такие символы, когда он выполняет сравнение с учетом языка и региональных параметров. Например, если следующий код выполняется на [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, сравнение «animal» с «ani использовать» (с помощью мягкий перенос или 00AD U +) указывает, что две строки равны.  
  
[!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
Для распознавания игнорируемые символы в сравнении строк, вызвать <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> метод.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Строка, сравниваемая с данным экземпляром.</param>
        <summary>Сравнивает данный экземпляр с заданным объектом <see cref="T:System.String" /> и показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и заданная строка.</summary>
        <returns>32-битовое целое число со знаком, которое показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и параметр <paramref name="strB" />.  
  
 <list type="table"><listheader><term> Значение 
 </term><description> Условие 
 </description></listheader><item><term> Меньше нуля 
 </term><description> Данный экземпляр предшествует параметру <paramref name="strB" />.  
  
 </description></item><item><term> Нуль 
 </term><description> Данный экземпляр имеет ту же позицию в порядке сортировки, что и <paramref name="strB" />.  
  
 </description></item><item><term> Больше нуля 
 </term><description> Данный экземпляр стоит после параметра <paramref name="strB" />.  
  
-или- 
 <paramref name="strB" /> — <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение по словам (с учетом регистра и культуры) с использованием текущего языка и региональных параметров. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> Метод был разработан в первую очередь для использования в сортировке или выстраивания в алфавитном порядке операций. Он не должен использоваться, при основной целью вызова метода для определения эквивалентности двух строк. Чтобы определить, эквивалентны ли две строки, вызовите <xref:System.String.Equals%2A> метод.  
  
 Дополнительные сведения о поведении этого метода см. в разделе "Примечания" <xref:System.String.Compare%28System.String%2CSystem.String%29> метод.  
  
 Этот метод реализует <xref:System.IComparable%601?displayProperty=nameWithType> интерфейс, а также выполняет немного лучше, чем <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> метод, так как он имеет для определения ли `strB` аргумент имеет тип изменяемого значения, должны быть упакованы, и его не приходилось приводить его параметр из <xref:System.Object> для <xref:System.String>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.String.CompareTo%2A> метод для сравнения текущего экземпляра строки другой строкой.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 Ниже приведен пример универсальных и неуниверсальных версии метода CompareTo для нескольких типов значений и ссылочных типов.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Наборы символов содержат символы, которые могут игнорироваться. <see cref="M:System.String.CompareTo(System.String)" /> Метод не учитывает такие символы, когда он выполняет сравнение с учетом языка и региональных параметров. Например, если следующий код выполняется на [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, сравнение «animal» с «ani использовать» (с помощью мягкий перенос или 00AD U +) указывает, что две строки равны.  
  
[!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
Для распознавания игнорируемые символы в сравнении строк, вызвать <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> метод.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Объединяет один или несколько экземпляров класса <see cref="T:System.String" /> или представления в виде <see cref="T:System.String" /> значений одного или нескольких экземпляров <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values">Объект коллекции, реализующий интерфейс <see cref="T:System.Collections.Generic.IEnumerable`1" /> и имеющий аргумент универсального типа <see cref="T:System.String" />.</param>
        <summary>Сцепляет элементы созданной коллекции <see cref="T:System.Collections.Generic.IEnumerable`1" /> типа <see cref="T:System.String" />.</summary>
        <returns>Сцепленные строки в параметре <paramref name="values" />. Или <see cref="F:System.String.Empty" />, если <paramref name="values" /> — это пустой элемент <see langword="IEnumerable(Of String)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод сцепляет каждый объект в `values`; разделители не добавляются. Для указания разделителя между каждым членом `values`, вызовите <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> метод.  
  
 <xref:System.String.Empty> Строки используется вместо любой элемент null в `values`.  
  
 Если `values` — это пустой `IEnumerable(Of String)`, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>. Если `values` — `null`, метод вызывает <xref:System.ArgumentNullException> исключение.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> — Это удобный метод, который позволяет сцеплять каждого элемента в `IEnumerable(Of String)` коллекции без предварительного преобразования элементов в массив строк. Это особенно полезно, с помощью выражения запроса Language-Integrated Query (LINQ). В следующем примере передается `List(Of String)` , содержащий прописные или строчные буквы алфавита в лямбда-выражение, который выбирает букв, которые находятся равным или больше, чем буквы (который, в примере «M»). `IEnumerable(Of String)` Коллекции, который возвращается <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> методу передается <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> метод для отображения результата в виде одной строки.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 Следующий пример использует алгоритм решета Эратосфена для вычисления простых чисел, которые меньше или равно 100. Результат для <xref:System.Collections.Generic.List%601> объект типа <xref:System.String>, который затем передается <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> метод.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Объект для представления или значение <see langword="null" />.</param>
        <summary>Создает строковое представление указанного объекта.</summary>
        <returns>Строковое представление значения параметра <paramref name="arg0" /> или <see cref="F:System.String.Empty" />, если значение параметра <paramref name="arg0" /> равно <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Concat%28System.Object%29> Представляет метод `arg0` как строку путем вызова его без параметров `ToString` метод.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.Concat%2A> метод.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Массив объектов, содержащий элементы, которые требуется сцепить.</param>
        <summary>Сцепляет строковые представления элементов указанного массива <see cref="T:System.Object" />.</summary>
        <returns>Сцепленные строковые представления значений элементов параметра <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод сцепляет каждый объект в `args` путем вызова без параметров `ToString` метод этого объекта; разделители не добавляются.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> используется вместо любого пустого объекта в массиве.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.String.Concat%2A> метод с <xref:System.Object> массива.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> — <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти.</exception>
        <block subset="none" type="usage"><para>Этот метод не вызывается кодом C++. Компилятор C++ разрешает вызовы к <see cref="Overload:System.String.Concat" /> , имеющие четыре или более параметров объекта как вызов <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Массив строк.</param>
        <summary>Сцепляет элементы указанного массива <see cref="T:System.String" />.</summary>
        <returns>Сцепленные элементы <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод сцепляет каждый объект в `values`; разделители не добавляются.  
  
 <xref:System.String.Empty> Строки используется вместо любого пустого объекта в массиве.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.String.Concat%2A> метод с <xref:System.String> массива.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> — <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Первый из сцепляемых объектов.</param>
        <param name="arg1">Второй из сцепляемых объектов.</param>
        <summary>Сцепляет строковые представления двух указанных объектов.</summary>
        <returns>Сцепленные строковые представления значений <paramref name="arg0" /> и <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет `arg0` и `arg1` путем вызова без параметров `ToString` метод `arg0` и `arg1`; разделители не добавляются.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> используется вместо любой аргумент null.  
  
 Если аргумент является ссылкой на массив, метод объединяет строковое представление этого массива, а не его члены (например, «System.String[]")").  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.Concat%2A> метод.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Первая из сцепляемых строк.</param>
        <param name="str1">Вторая из сцепляемых строк.</param>
        <summary>Сцепляет два указанных экземпляра <see cref="T:System.String" />.</summary>
        <returns>Сцепление <paramref name="str0" /> и <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет `str0` и `str1`; разделители не добавляются.  
  
> [!NOTE]
>  Можно также использовать оператор объединения строк языка, такие как `+` в C# или `&` и `+` в Visual Basic)  
>   
>  , для объединения строк.  
  
 <xref:System.String.Empty> Строки используется вместо любой аргумент null.  
  
   
  
## Examples  
 В приведенном ниже примере сцепляются имя, отчество и фамилию человека.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Первый из сцепляемых объектов.</param>
        <param name="arg1">Второй из сцепляемых объектов.</param>
        <param name="arg2">Третий из сцепляемых объектов.</param>
        <summary>Сцепляет строковые представления трех указанных объектов.</summary>
        <returns>Сцепленные строковые представления значений <paramref name="arg0" />, <paramref name="arg1" /> и <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет `arg0`, `arg1`, и `arg2` путем вызова без параметров `ToString` каждого объекта; разделители не добавляются.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> используется вместо любой аргумент null.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.Concat%2A> метод.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <param name="str2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Первая из сцепляемых строк.</param>
        <param name="str1">Вторая из сцепляемых строк.</param>
        <param name="str2">Третья из сцепляемых строк.</param>
        <summary>Сцепляет три указанных экземпляра <see cref="T:System.String" />.</summary>
        <returns>Сцепление <paramref name="str0" />, <paramref name="str1" /> и <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет `str0`, `str1`, и `str2`; разделители не добавляются.  
  
> [!NOTE]
>  Можно также использовать оператор объединения строк языка, такие как `+` в C# или `&` и `+` в Visual Basic)  
>   
>  , для объединения строк.  
  
 <xref:System.String.Empty> Строки используется вместо любой аргумент null.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.String.Concat%2A> метод для сцепления трех строк и отображает результат.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">Первый из сцепляемых объектов.</param>
        <param name="arg1">Второй из сцепляемых объектов.</param>
        <param name="arg2">Третий из сцепляемых объектов.</param>
        <param name="arg3">Четвертый из сцепляемых объектов.</param>
        <summary>Сцепляет строковые представления четырех указанных объектов и любые объекты, заданные в необязательном списке параметров переменной длины.</summary>
        <returns>Сцепленное строковое представление каждого значения в списке параметров.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот интерфейс API CLS-несовместим. CLS-совместимая альтернатива — <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. Компиляторы C# и Visual Basic автоматически разрешать вызов этого метода, как вызов <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Метод сцепляет каждый объект в списке параметров, вызвав его без параметров `ToString` метода; разделители не добавляются.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> используется вместо любой аргумент null.  
  
> [!NOTE]
>  В последнем параметре <xref:System.String.Concat%2A> метод — необязательный список с разделителями запятыми из одного или нескольких дополнительных объектов для сцепления.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> метод сцепляемых список переменных параметров. В этом случае метод вызывается с девятью параметрами.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Этот метод помечен атрибутом <see langword="vararg" /> ключевое слово, которое означает, что он поддерживает переменное количество параметров. Метод может вызываться из Visual C++, но он не может вызываться из кода C# или Visual Basic. Компиляторы C# и Visual Basic разрешить вызовы <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> как вызов <see cref="M:System.String.Concat(System.Object[])" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <param name="str2">To be added.</param>
        <param name="str3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Первая из сцепляемых строк.</param>
        <param name="str1">Вторая из сцепляемых строк.</param>
        <param name="str2">Третья из сцепляемых строк.</param>
        <param name="str3">Четвертая из сцепляемых строк.</param>
        <summary>Сцепляет четыре указанных экземпляра <see cref="T:System.String" />.</summary>
        <returns>Сцепление <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> и <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет `str0`, `str1`, `str2`, и `str3`; разделители не добавляются.  
  
> [!NOTE]
>  Можно также использовать оператор объединения строк языка, такие как `+` в C# или `&` и `+` в Visual Basic)  
>   
>  , для объединения строк.  
  
 <xref:System.String.Empty> Строки используется вместо любого пустого объекта в массиве.  
  
   
  
## Examples  
 В следующем примере определяется массив четырехбуквенных слов и сохраняет отдельные буквы в массив строк для их шифрования. Затем он вызывает <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> метод, чтобы воссоздать скремблированных слова.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов параметра <paramref name="values" />.</typeparam>
        <param name="values">Объект коллекции, реализующий интерфейс <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Сцепляет элементы реализации <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Сцепленные элементы в параметре <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод сцепляет каждый объект в `values`; разделители не добавляются.  
  
 <xref:System.String.Empty> Строки используется вместо любой аргумент null.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> — Это удобный метод, который позволяет сцеплять каждого элемента в <xref:System.Collections.Generic.IEnumerable%601> коллекции без предварительного преобразования элементов в строки. Это особенно полезно, выражения запросов Language-Integrated Query (LINQ), как показано в примере. Строковое представление каждого объекта в <xref:System.Collections.Generic.IEnumerable%601> коллекции извлекается путем вызова этого объекта `ToString` метод.  
  
   
  
## Examples  
 В следующем примере определяется очень простой `Animal` класс, содержащий имя животного и порядок, к которой он принадлежит. Затем он определяет <xref:System.Collections.Generic.List%601> объект, содержащий ряд `Animal` объектов. <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> Метод расширения вызывается для извлечения `Animal` объектов, `Order` свойство имеет значение «Грызун». Результат передается <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> метод и выводится на консоль.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <summary>Возвращает значение, указывающее, встречается ли указанная подстрока внутри этой строки.</summary>
        <returns><see langword="true" />, если параметр <paramref name="value" /> встречается в строке или <paramref name="value" /> является пустой строкой (""); в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров). Поиск начинается с позиции первого символа строки и продолжается до последней позиции символа.  
  
 Чтобы определить, является ли строка содержит заданной подстроки, используя отличные от порядкового сравнения (например, сравнение с учетом языка и региональных параметров или порядковое сравнение без учета регистра), вы можете создать пользовательский метод. В следующем примере показано один такой новый подход. Он определяет <xref:System.String> метод расширения, который включает в себя <xref:System.StringComparison> параметр и указывает, содержит ли строка подстроку, при использовании указанной формы сравнения строк.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 В следующем примере затем вызывается `Contains` метод расширения, чтобы определить, находится ли в строке подстроку, при использовании порядкового сравнения и порядковое сравнение без учета регистра.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Если вы заинтересованы в позицию подстроки `value` в текущем экземпляре, можно вызвать <xref:System.String.IndexOf%2A> можно вызвать метод, чтобы получить начальную позицию первого найденного или <xref:System.String.LastIndexOf%2A> метод для получения начальное положение элемента его последнее вхождение. В пример включен вызов <xref:System.String.IndexOf%28System.String%29> метод, если найден подстрока в экземпляре строки.  
  
   
  
## Examples  
 В следующем примере определяется, является ли строка «fox» подстроки знакомые предложения. Если «fox» найдено в строке, она также отображает его начальной позиции.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="str">Строка для копирования.</param>
        <summary>Создает экземпляр <see cref="T:System.String" />, имеющий то же значение, что и указанный экземпляр <see cref="T:System.String" />.</summary>
        <returns>Новая строка с тем же значением, что и <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Copy%2A> Возвращает метод <xref:System.String> объект, который имеет то же значение, что исходная строка, но представляет ссылку на другой объект. Он отличается от операция присваивания, который назначает существующую ссылку на строку дополнительных объектной переменной. Пример демонстрирует различие.  
  
   
  
## Examples  
 В следующем примере создается два строковых объекта с разными значениями. При вызове метода <xref:System.String.Copy%2A> метод назначения первое значение вторая строка выходных данных указывает, что эти строки представляют различные ссылки на, несмотря на то, что теперь равны значения их. С другой стороны при назначении первая строка второй строкой, две строки имеют одинаковые значения, так как они представляют одну и ту же ссылку объекта.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Индекс первого символа в этом экземпляре, который необходимо скопировать.</param>
        <param name="destination">Массив символов Юникода, в который копируются символы в этом экземпляре.</param>
        <param name="destinationIndex">Индекс в массиве <paramref name="destination" />, с которого начинается копирование.</param>
        <param name="count">Число знаков в этом экземпляре, копируемых в <paramref name="destination" />.</param>
        <summary>Копирует заданное число знаков, начиная с указанной позиции в этом экземпляре до указанной позиции в массиве знаков Юникода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует `count` символы `sourceIndex` позицию данного экземпляра для `destinationIndex` положение элемента `destination` массив символов. Этот метод не изменяется `destination` массив символов; он должен иметь достаточное количество элементов для хранения скопированных символов или вызывает метод <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex` и `destinationIndex` отсчитываются от нуля.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.CopyTo%2A> метод.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" /> или <paramref name="count" /> является отрицательным значением. 
-или- 
 <paramref name="sourceIndex" /> не определяет позицию в текущем экземпляре.  
  
-или- 
 <paramref name="destinationIndex" /> не определяет допустимый индекс в массиве <paramref name="destination" />.  
  
-или- 
 <paramref name="count" /> больше, чем длина подстроки от <paramref name="sourceIndex" /> до конца данного экземпляра. 
-или- 
 <paramref name="count" /> больше, чем длина подмассива от <paramref name="destinationIndex" /> до конца массива <paramref name="destination" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет пустую строку. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого поля является строкой нулевой длины, «».  
  
 В коде приложения это поле чаще всего используется в назначениях инициализировать строковую переменную на пустую строку. Чтобы проверить, является ли значение строки `null` или <xref:System.String.Empty?displayProperty=nameWithType>, используйте <xref:System.String.IsNullOrEmpty%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, совпадает ли конец данного экземпляра строки с указанной строкой.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка, которую необходимо сравнить с подстрокой, расположенной в конце этого экземпляра.</param>
        <summary>Определяет, совпадает ли конец данного экземпляра строки с указанной строкой.</summary>
        <returns><see langword="true" />, если конец этого экземпляра совпадает с <paramref name="value" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод сравнивает `value` подстрокой, расположенной в конце данного экземпляра, имеют одинаковую длину как `value`и возвращает значение, указывающее, равны ли они. Равными, `value` должен ссылаться на тот же экземпляр или соответствует концу данного экземпляра.  
  
 Этот метод выполняет сравнение по словам (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.  
  
   
  
## Examples  
 Следующий пример показывает, заканчивается ли каждой строки в массиве с точкой (».»).  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 В следующем примере определяется `StripEndTags` метод, который использует <xref:System.String.EndsWith%28System.String%29> способ удаления закрывающие теги HTML в конце строки. Обратите внимание, что `StripEndTags` метод вызывается рекурсивно для убедитесь, что удалены несколько закрывающие теги HTML в конце строки.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Как описано в [советы и рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методы сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывать методы, которые нужны параметры, чтобы указать явно. Чтобы определить, заканчивается ли строка определенной подстрокой, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> перегрузку метода со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его <paramref name="comparisonType" /> параметра.</para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка, которую необходимо сравнить с подстрокой, расположенной в конце этого экземпляра.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее способ сравнения данной строки со значением <paramref name="value" />.</param>
        <summary>Определяет, совпадает ли конец экземпляра строки с заданной строкой при сравнении с учетом заданного параметра сравнения.</summary>
        <returns><see langword="true" />, если параметр <paramref name="value" /> соответствует концу данной строки; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.EndsWith%2A> Метод сравнивает `value` параметр подстрокой, расположенной в конце этой строки и возвращает значение, указывающее, равны ли они. Равными, `value` должен быть ссылкой на ту же строку, должно быть пустой строкой ("»), или необходимо соответствует концу данной строки. Тип сравнения, выполняемые <xref:System.String.EndsWith%2A> метод зависит от значения `comparisonType` параметра.  
  
   
  
## Examples  
 Следующий пример определяет, заканчивается ли строка определенной подстрокой. Результаты зависят от выбора языка и региональных параметров, учитывается ли регистр и выполняется ли порядковое сравнение.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является значением <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка, которую необходимо сравнить с подстрокой, расположенной в конце этого экземпляра.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при сравнении; в противном случае — значение <see langword="false" />.</param>
        <param name="culture">Связанные с языком и региональными параметрами сведения, определяющие, как выполняется сравнение этого экземпляра и <paramref name="value" />. Если значением параметра <paramref name="culture" /> является <see langword="null" />, используется текущий язык и региональные параметры.</param>
        <summary>Определяет, совпадает ли конец данного экземпляра строки с заданной строкой при сравнении с учетом заданного языка и региональных параметров.</summary>
        <returns><see langword="true" />, если параметр <paramref name="value" /> соответствует концу данной строки; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод сравнивает `value` параметр подстрокой, расположенной в конце данной строки, имеют одинаковую длину как `value`и возвращает значение, указывающее, равны ли они. Равными, `value` должен ссылаться на тот же экземпляр или соответствует концу данной строки.  
  
 Этот метод выполняет сравнение слов (язык и региональные параметры с учетом), с помощью указанного регистра и языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере определяется, содержится ли строка в конце другой строки. <xref:System.String.EndsWith%2A> Был вызван несколько раз, используя чувствительность к регистру, учет регистра и различных языков и региональных параметров, которые влияют на результаты поиска.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, равны ли значения двух объектов <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Строка для сравнения с данным экземпляром.</param>
        <summary>Определяет, равны ли значения этого экземпляра и указанного объекта, который также должен быть объектом <see cref="T:System.String" />.</summary>
        <returns><see langword="true" />, если объект <paramref name="obj" /> имеет тип <see cref="T:System.String" /> и его значение совпадает со значением данного экземпляра; в противном случае — <see langword="false" />.  Если значением параметра <paramref name="obj" /> является <see langword="null" />, метод возвращает <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.Equals%2A> метод.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка для сравнения с данным экземпляром.</param>
        <summary>Определяет, равны ли значения этого экземпляра и указанного объекта <see cref="T:System.String" />.</summary>
        <returns><see langword="true" />, если значение параметра <paramref name="value" /> совпадает со значением данного экземпляра; в противном случае — <see langword="false" />. Если значением параметра <paramref name="value" /> является <see langword="null" />, метод возвращает <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.Equals%2A> метод. Он сравнивает стиле title слова «File» с помощью эквивалентных должен быть словом, его эквивалент в нижнем регистре, эквивалентный символ верхнего регистра и слово, которое содержит LATIN НЕБОЛЬШОЙ буквы без ТОЧКИ I (U + 0131) вместо LATIN НЕБОЛЬШОЙ буква I (U + 0069). Так как <xref:System.String.Equals%28System.String%29> метод выполняет порядковое сравнение, возвращает только сравнение идентичные слово `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Первая сравниваемая строка или значение <see langword="null" />.</param>
        <param name="b">Вторая сравниваемая строка или значение <see langword="null" />.</param>
        <summary>Определяет, совпадают ли значения двух указанных объектов <see cref="T:System.String" />.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="a" /> совпадает со значением <paramref name="b" />; в противном случае — значение <see langword="false" />. Если оба параметра <paramref name="a" /> и <paramref name="b" /> имеют значение <see langword="null" />, метод возвращает значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.Equals%2A> метод.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для сравнения с данным экземпляром.</param>
        <param name="comparisonType">Одно из значений перечисления, задающее способ сравнения строк.</param>
        <summary>Определяет, равны ли значения этой строки и указанного объекта <see cref="T:System.String" />. Параметр определяет язык и региональные параметры, учет регистра и правила сортировки, используемые при сравнении.</summary>
        <returns><see langword="true" />, если значение параметра <paramref name="value" /> совпадает со значением данной строки; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` Задаёт ли при сравнении следует использовать текущие или инвариантные язык и региональные параметры, учитывает или игнорировать регистр двух сравниваемых строк либо word или правил.  
  
   
  
## Examples  
 В следующем примере создается массив строк, состоящий из заглавных букв, «I», символ «i» нижнего регистра и без точки «ı». Затем он вызывает <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> метод, чтобы сравнить их с помощью каждое возможное <xref:System.StringComparison> значение перечисления.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 В следующем примере сравниваются четыре набора слов с помощью каждого члена <xref:System.StringComparison> перечисления.  Сравнение использования соглашений для английского (США) и Саамский (верхний Швеция) языков и региональных параметров. Обратите внимание на то, что строки «encyclopædia» и «энциклопедии» считаются эквивалент в культуре en US, но не в Саамский (Северный Швеция) языка и региональных параметров.  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является значением <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a">Первая сравниваемая строка или значение <see langword="null" />.</param>
        <param name="b">Вторая сравниваемая строка или значение <see langword="null" />.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила сравнения.</param>
        <summary>Определяет, совпадают ли значения двух указанных объектов <see cref="T:System.String" />. Параметр определяет язык и региональные параметры, учет регистра и правила сортировки, используемые при сравнении.</summary>
        <returns><see langword="true" />, если значения параметров <paramref name="a" /> и <paramref name="b" /> совпадают; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` Задаёт ли при сравнении следует использовать текущие или инвариантные язык и региональные параметры, учитывает или игнорировать регистр двух сравниваемых строк либо word или правил.  
  
   
  
## Examples  
 В следующем примере сравниваются четыре набора слов с помощью каждого члена <xref:System.StringComparison> перечисления.  Сравнение использования соглашений для английского (США) и Саамский (верхний Швеция) языков и региональных параметров. Обратите внимание на то, что строки «encyclopædia» и «энциклопедии» считаются эквивалент в культуре en US, но не в Саамский (Северный Швеция) языка и региональных параметров.  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является значением <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует значения объектов в строки на основе указанных форматов и вставляет их в другую строку.  
  
Если вы не знакомы с методом `String.Format`, см. краткие сведения в разделе [Начало работы с методом String.Format](#Starting).  
  
В разделе [Примечания](#remarks-top) приводится общая документация для метода `String.Format`.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 Содержание  
  
 [Начало работы с методом String.Format](#Starting)   
 [Какой метод следует вызывать?](#FTaskList)   
 [Метод Format краткое описание](#Format_Brief)   
 [Элемент формата](#FormatItem)   
 [Каким образом форматируются аргументов](#HowFormatted)   
 [Формат элементы, имеющие тот же индекс](#SameIndex)   
 [Форматирование и языка и региональных параметров](#Format_Culture)   
 [Настраиваемое форматирование операций](#Format_Custom)   
 [String.Format Q & A](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Начало работы с методом String.Format  
 Используйте <xref:System.String.Format%2A?displayProperty=nameWithType> Если вам нужно вставить значение из объекта, переменной или выражения в другой строке. Например, можно вставить значение <xref:System.Decimal> значение в строку, чтобы отобразить ее пользователю как одну строку:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 И вы можете управлять форматированием это значение:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Помимо форматирование, можно также управлять интервал и выравнивание.  
  
 ### <a name="inserting-a-string"></a>Вставка строки  

 <xref:System.String.Format%2A?displayProperty=nameWithType> начинается с объекта строки формата, за которым следует один или несколько объектов, или выражений, которые будут преобразованы в строки и вставить в указанном месте в строке формата. Например:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 `{0}` В формат строки — это элемент формата. `0` — Это индекс объекта, значение которого строка будет вставлен в этой позиции. (Индексы начинаются с 0). Если вставляемый объект не является строкой, его `ToString` метод вызывается для преобразования его на позицию перед вставкой в результирующей строке.  
  
 Вот другой пример, использующий два формата элемента и два объекта в списке объектов:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Может иметь столько элементов формата, и количество объектов в списке объектов, как вы хотите, пока индекс каждый элемент форматирования имеет соответствующий объект в списке объектов. Вы также не нужно беспокоиться о какую перегрузку метода. компилятор будет выберите наиболее подходящий для вас.  
  
 ### <a name="controlling-formatting"></a>Управление форматированием  
 Вы можете следовать индекс в элементе форматирования строку формата для управления форматированием объекта. Например `{0:d}` применяет строки формата «d» для первого объекта в списке объектов. Ниже приведен пример с одним объектом и два форматирования элементов:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Ряд типов поддержки строк формата, включая все числовые типы (оба [стандартный](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательских](~/docs/standard/base-types/custom-numeric-format-strings.md) форматирования строк), все значения даты и времени (оба [стандартный](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательских](~/docs/standard/base-types/custom-date-and-time-format-strings.md) строки форматов) и интервалы времени (оба [стандартный](~/docs/standard/base-types/standard-timespan-format-strings.md) и [пользовательских](~/docs/standard/base-types/custom-timespan-format-strings.md) строки форматов), всех типов перечислений [типы перечисления ](~/docs/standard/base-types/enumeration-format-strings.md), и [идентификаторы GUID](https://msdn.microsoft.com/library/97af8hh4.aspx). Также можно добавить поддержку для строки формата для собственных типов.  
  
 ### <a name="controlling-spacing"></a>Управление интервал  
 Вы можете определить ширину строки, который вставляется в результирующую строку с помощью синтаксиса, такие как `{0,12}`, который вставляет строка 12 символов. В этом случае строковое представление первого объекта по правому краю поля 12 символов.  (Если строковое представление первого объекта больше 12 символов, однако желательной ширины поля учитывается и вся строка вставляется в результирующую строку.)  
  
 В следующем примере определяется 6-символьное поле для хранения строки «Год» и некоторые строки год, а также 15-символьного поля для хранения строки «Заполнение» и некоторые данные о населении. Обратите внимание на то, что символы являются по правому краю поля.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Управление выравнивания  
 По умолчанию строки по правому краю в своей сфере Если вы укажите ширину поля. Чтобы выровнять строки в поле слева, в начале ширина поля со знаком минус, такие как `{0,-12}` определение поля по левому краю 12 символов.  
  
 Следующий пример аналогичен предыдущему, за исключением того, что он по левому краю и метки и данные.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> используется составное форматирование. Дополнительные сведения см. в разделе [Составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Какой метод следует вызывать?  
  
|Кому|Call|  
|--------|----------|  
|Форматировать один или несколько объектов с помощью правил текущего языка и региональных параметров.|За исключением перегрузки, включающие `provider` параметра, оставшиеся <xref:System.String.Format%2A> включают перегрузки <xref:System.String> параметр следуют один или несколько параметров объекта. По этой причине не нужно определить, какие <xref:System.String.Format%2A> вызываемая перегрузка. Языковой компилятор выбирает соответствующую перегрузку из перегрузок, у которых нет `provider` параметру, основанному на ваш список аргументов. Например, если ваш список аргументов содержит пять аргументов, компилятор вызывает <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> метод.|  
|Форматировать один или несколько объектов с помощью правил конкретного языка и региональных параметров.|Каждый <xref:System.String.Format%2A> перегрузку, которая начинается с `provider` следуют параметр <xref:System.String> параметр и один или несколько объектов параметров. По этой причине не нужно определить, какие конкретно <xref:System.String.Format%2A> вызываемая перегрузка. Языковой компилятор выбирает соответствующую перегрузку из перегрузок, имеющих `provider` параметру, основанному на ваш список аргументов. Например, если ваш список аргументов содержит пять аргументов, компилятор вызывает <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> метод.|  
|Выполнять пользовательские операции форматирования, либо с <xref:System.ICustomFormatter> реализации или <xref:System.IFormattable> реализации.|Любой из четырех перегрузок `provider` параметра. Компилятор выбирает соответствующую перегрузку из перегрузок, имеющих `provider` параметру, основанному на ваш список аргументов.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Метод Format краткое описание 

 Каждая перегрузка <xref:System.String.Format%2A> использует метод [составного форматирования](~/docs/standard/base-types/composite-formatting.md) для включения отсчитываемый от нуля индексированные местозаполнители, *форматирования элементов*, в строке составного формата. Во время выполнения каждый элемент формата заменяется строковым представлением соответствующего аргумента в списке параметров. Если значение аргумента равно `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Например, следующий вызов <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> метод включает строку формата с тремя элементами форматирования, {0}, {1}, и {2}и список аргументов с тремя элементами.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>Элемент формата  
 Элемент форматирования имеет следующий синтаксис:  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Квадратные скобки обозначают необязательные элементы. Требуются открывающей и закрывающей фигурными скобками. (Для включения литерала открывающий или закрывающая фигурная скобка в строке формата, см. в разделе [экранирование фигурных скобок](~/docs/standard/base-types/composite-formatting.md#escaping-braces) статьи [составное форматирование](~/docs/standard/base-types/composite-formatting.md) статьи.)  
  
 Например элемент форматирования для форматирования значения валюты может отображаться следующим образом:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Элемент форматирования имеет следующие элементы:  
  
 *Индекс*  
 Отсчитываемый от нуля индекс аргумента, строковое представление которого должен быть включен в этой позиции в строке. Если этот аргумент равен `null`, пустая строка будет включен в этой позиции в строке.  
  
 *Выравнивание*  
 Необязательный параметр. Знаковое целое число, которое указывает общую длину поля, в которое вставляется аргумент и по правому краю (положительное целое число) или по левому краю (отрицательное целое число). Если опустить *выравнивание*, строковым представлением соответствующего аргумента вставляется в поле без начальных или конечных пробелов.  
  
 Если значение *выравнивание* меньше, чем длина аргумента должны быть вставлены, *выравнивание* игнорируется и длина строкового представления для аргумента используется в качестве значения ширины поля.  
  
 *formatString*  
 Необязательный параметр. Строка, указывающая формат строки соответствующего аргумента результат. Если опустить *formatString*, соответствующего аргумента без параметров `ToString` метод вызывается для получения строкового представления. Если указать *formatString*, аргумент, который ссылается элемент форматирования должен реализовывать <xref:System.IFormattable> интерфейс. Типы, которые поддерживают формат строки:  
  
-   Все типы с плавающей точкой. (См. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime> и <xref:System.DateTimeOffset>. (См. в разделе [стандартных форматов даты и времени строки](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [настраиваемых форматов даты и времени строки](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Все типы перечислений. (См. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   значения типа <xref:System.TimeSpan>. (См. в разделе [строки стандартного формата TimeSpan](~/docs/standard/base-types/standard-timespan-format-strings.md) и [строки пользовательского формата TimeSpan](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   Идентификаторы GUID. (См. в разделе <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> метод.)  
  
 Тем не менее, обратите внимание, что любой пользовательский тип можно реализовать <xref:System.IFormattable> или расширить существующий тип <xref:System.IFormattable> реализации.  
  
 В следующем примере используется `alignment` и `formatString` аргументы для создания Форматированные выходные данные.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>Каким образом форматируются аргументов  
 Элементы форматирования обрабатываются последовательно от начала строки. Каждый элемент формата имеет индекс, соответствующий объект в списке аргументов метода. <xref:System.String.Format%2A> Метод получает аргумент и наследует его строковое представление следующим образом:  
  
-   Если аргумент является `null`, то метод вставляет <xref:System.String.Empty?displayProperty=nameWithType> в результирующую строку. У вас нет необходимости заботиться о обработки <xref:System.NullReferenceException> для аргументов, значение null. 
  
-   При вызове метода <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> перегрузки и `provider` объекта <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> реализация возвращает ненулевой <xref:System.ICustomFormatter> , аргумент передается реализация его <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод. Если элемент формата включает *formatString* аргумент, он передается в качестве первого аргумента метода. Если <xref:System.ICustomFormatter> реализация доступна и создает строку, отличных от null, которая строковое представление аргумента, возвращается строка; в противном случае выполняет следующий шаг.  
  
-   Если аргумент реализует <xref:System.IFormattable> интерфейс, его <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> вызывается реализация.  
  
-   С аргументом-по без параметров `ToString` вызывается метод, который переопределяет или наследует от реализации базового класса,.  
  
 Например, который перехватывает вызовы <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> метод и позволяет увидеть, какие сведения <xref:System.String.Format%2A> передает метод в метод форматирования для каждого элемента форматирования в строке составного формата, см. в разделе [пример: Поставщик отсекаемый отрезок и модуль форматирования римские цифры](#Format7_Example).  

 Дополнительные сведения см. в разделе [порядок обработки](~/docs/standard/base-types/composite-formatting.md##processing-order) статьи [составное форматирование](~/docs/standard/base-types/composite-formatting.md) статьи.  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Формат элементы, имеющие тот же индекс  
 <xref:System.String.Format%2A> Вызывает метод <xref:System.FormatException> исключение, если индекс элемента индекс больше или равно числу аргументов в списке аргументов. Тем не менее `format` может включать несколько элементов формата, превышает количество аргументов, поскольку несколько элементов формата имеют тот же индекс. В вызове <xref:System.String.Format%28System.String%2CSystem.Object%29> метод в следующем примере список аргументов имеет один аргумент, но строка форматирования содержит два элемента форматирования: один отображается десятичное значение для числа, а другой шестнадцатеричное значение.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Форматирование и языка и региональных параметров  
 Как правило, объекты в списке аргументов, преобразуются в их строковые представления с помощью правил текущего языка и региональных параметров, который возвращается методом <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> свойство. Этим поведением можно управлять путем вызова одной из перегрузок <xref:System.String.Format%2A> , включающий `provider` параметра. `provider` Параметр <xref:System.IFormatProvider> обрабатывать реализацию, которая предоставляет пользовательские и зависящие от языка и региональных параметров информации форматирования, которая используется средний форматирование.  
  
 <xref:System.IFormatProvider> Интерфейс содержит только один член — <xref:System.IFormatProvider.GetFormat%2A>, который отвечает за возвращение объект, предоставляющий сведения о форматировании. .NET имеет три <xref:System.IFormatProvider> реализациями, которые предоставляют форматирования, зависящего от языка и региональных параметров:  
  
-   <xref:System.Globalization.CultureInfo>. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> метод возвращает конкретный язык и региональные параметры <xref:System.Globalization.NumberFormatInfo> объект для форматирования числовых значений и зависящих от языка и региональных параметров <xref:System.Globalization.DateTimeFormatInfo> объект для форматирования значений даты и времени.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, используемый для форматирования значений даты и времени, зависящего от языка и региональных параметров. Его <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> метод возвращает сам себя.  
  
-   <xref:System.Globalization.NumberFormatInfo>, который используется для форматирования числовых значений, зависящего от языка и региональных параметров. Его <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> свойство возвращает сам себя. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Настраиваемое форматирование операций  
 Можно также вызвать любой из перегрузок <xref:System.String.Format%2A> метода, который имеет `provider` параметр типа <xref:System.IFormatProvider> для выполнения пользовательских операций форматирования. Например вы форматирования целого числа, как идентификатор или номер телефона. Для выполнения пользовательского форматирования вашей `provider` аргумент следует реализовать и <xref:System.IFormatProvider> и <xref:System.ICustomFormatter> интерфейсов. Когда <xref:System.String.Format%2A> методу передается <xref:System.ICustomFormatter> реализации в качестве `provider` аргумент, <xref:System.String.Format%2A> вызовы методов его <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> реализации и запрашивает объект типа <xref:System.ICustomFormatter>. Затем он вызывает возвращенного <xref:System.ICustomFormatter> объекта <xref:System.ICustomFormatter.Format%2A> переданного ему метод, чтобы каждый элемент формата в строке составного формата.  
  
 Дополнительные сведения о предоставлении пользовательских решений форматирования см. в разделе [как: Определение и использование настраиваемых поставщиков числовых форматов](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) и <xref:System.ICustomFormatter>. Пример, преобразует пользовательские числа целых чисел, см. в разделе [пример: Пользовательские операции форматирования](#Format6_Example). Пример, который преобразует римские цифры байтов без знака, см. в разделе [пример: Поставщик отсекаемый отрезок и модуль форматирования римские цифры](#Format7_Example).  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a>Пример Пользовательские операции форматирования  
 В этом примере определяется поставщик формата, который форматирует целочисленное значение в виде номера счета заказчика в форме x-xxxxx-xx.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Пример Поставщик отсекаемый отрезок и модуль форматирования римские цифры  
 В этом примере определяется поставщик настраиваемого формата, который реализует <xref:System.ICustomFormatter> и <xref:System.IFormatProvider> интерфейсов, чтобы сделать две вещи:  
  
-   Он отображает параметры, передаваемые его <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> реализации. Это позволяет нам знать, какие параметры <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> метод передает на пользовательскую реализацию форматирования для каждого объекта, он пытается форматирования. Это может быть полезно при отладке приложения.  
  
-   Если объект форматируемое значение типа byte без знака, необходимо отформатировать с помощью строки стандартного формата «R», пользовательский модуль форматирования форматирует числовое значение в виде римские цифры.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format Q & A  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>Почему вы рекомендуете интерполяция между вызовами `String.Format` метод?

Интерполяция строк предоставляет:

- Более гибким. Данное свойство можно использовать в любой строке, не обращаясь к методу, поддерживающему составное форматирование. В противном случае необходимо вызвать <xref:System.String.Format%2A> метода или другого метода, который поддерживает составное форматирование, такими как <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>. 

- Более удобном для чтения. Поскольку содержится это выражение для вставки в строку в интерполированное выражение, а не в списке аргументов, интерполированные строки являются гораздо проще для кода и для чтения. Из-за их улучшения удобочитаемости интерполированные строки можно заменить не только вызовы методов составного формата, но они могут также использоваться в операциях объединения строк для создания более кратким и чистый код. 

Сравнение в следующих двух примерах кода показано superiority интерполированные строки через объединение строк и вызовы методов составного форматирования. Использование нескольких операций объединения строк, в следующем примере создается код verbose и трудный для чтения.

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

С другой стороны, использование интерполированные строки в следующем примере создают намного яснее и более понятного кода, чем оператор объединения строки и вызов <xref:System.String.Format%2A> метод в предыдущем примере.

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Где можно найти список стандартных строк форматирования, которые могут использоваться с элементами форматирования?  
  
-   Для всех типов с плавающей точкой, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Значения даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [Custom Date и Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Для значений перечисления, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Для <xref:System.TimeSpan> значения, см. в разделе [строки стандартного формата TimeSpan](~/docs/standard/base-types/standard-timespan-format-strings.md) и [строки пользовательского формата TimeSpan](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Для <xref:System.Guid> значения, см. в разделе "Примечания" <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> справочной странице.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Как контролировать выравнивание строки результатов, которые замены элементов форматирования?  
 Ниже приведен общий синтаксис элемента формата.  
  
```  
{index[,alignment][: formatString]}  
```  
  
 где *выравнивание* является целое число со знаком, которое определяет ширину поля. Если указано отрицательное значение, текст в поле по левому краю. Если оно положительное, текст по правому краю.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Как контролировать количество цифр после десятичного разделителя?  
 Все [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) , кроме «D» (который используется только целые числа), «G», «R», а «X» разрешить описатель точности, которое определяет количество цифр дробной части в результирующей строке. В следующем примере строки стандартных числовых форматов для управления количеством десятичных цифр в результирующей строке.  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Если вы используете [настраиваемого числового формата](~/docs/standard/base-types/custom-numeric-format-strings.md), позволяет контролировать количество цифр дробной части в результирующей строке, как показано в следующем примере описатель формата «0».  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Как контролировать число цифр целой части?  
 По умолчанию операций форматирования отображать только цифры целой части значения ненулевое значение. При форматировании целые числа, можно использовать описатель точности строки стандартного формата «X» и «D» для управления количеством цифр.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Целое число или число с плавающей запятой с ведущими нулями для создания результирующую строку с указанным количеством цифр целой части с помощью «0» можно добавлять [описатель настраиваемого числового формата](~/docs/standard/base-types/custom-numeric-format-strings.md), как показано в следующем примере.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Количество элементов, можно включить в список формата?  
 Нет практических ограничений. Второй параметр <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> методы, помеченные с помощью <xref:System.ParamArrayAttribute> атрибут, который позволяет включать список с разделителями или массив объектов как список формата.  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Как включить литерала фигурные скобки ("{» и «}») в результирующей строке?  
 Например, как это не позволит следующий вызов метода возникновения <xref:System.FormatException> исключение?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Единый открывающей или закрывающей фигурной скобкой всегда интерпретируется как начало или конец элемента форматирования. Следует интерпретировать буквально, ее следует экранировать. Экранировать фигурную скобку путем добавления другого фигурную скобку ("{{» и «}}» вместо «{» и «}»), как показано в следующем вызове метода:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Однако даже скобок, легко misinterpreted. Мы рекомендуем включать квадратные скобки в списке формат и использовать элементы формата вставить их в результирующую строку, как показано в следующем примере.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Почему мой вызов метода String.Format исключение FormatException?  
 Наиболее распространенной причиной исключения является то, что индекс элемента формата не соответствует объект в списке формат. Обычно это означает, что misnumbered индексы элементов формата или забыли включить объект в списке формат. Попытка включить без escape-последовательности левую или правую скобку символов также создает исключение <xref:System.FormatException>. В некоторых случаях исключение является результатом опечатка; Например, типичный встречается ошиблись «[» (левая скобка) вместо «{» (открывающая фигурная скобка).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Если метод Format(System.IFormatProvider,System.String,System.Object[]) поддерживает массивы параметров, почему мой код вызова исключения, когда я использую массив?  
 Например, в следующем коде возникает исключение <xref:System.FormatException> исключение:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Это проблема разрешения перегрузки компилятор. Так как компилятор не может преобразовать массив целых чисел в массив объектов, он рассматривает массив целых чисел как один аргумент, поэтому он вызывает <xref:System.String.Format%28System.String%2CSystem.Object%29> метод. Исключение, так как существуют четыре формата элементы, но только один элемент в списке формат.  
  
 Так как Visual Basic, ни C# можно преобразовать массив целых чисел в массив объектов, необходимо самостоятельно выполнить преобразование, перед вызовом <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> метод. Следующий пример предоставляет одну реализацию.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Многочисленные примеры, которые вызывают <xref:System.String.Format%2A> метод смешиваются через ["Примечания"](#remarks) этой статьи.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

Вы также можете скачать полный набор `String.Format` примеры, которые входят в [проект .NET Core 2.0 для C#](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) и [проект .NET Core 2.0 для Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), из [dotnet / репозитории примеров GitHub](https://github.com/dotnet/samples).

Ниже приведены некоторые примеры, включенные в статью.

### <a name="create-a-format-string"></a>Создать строку формата

[Вставка строки](#inserting-a-string)  
[Элемент формата](#the-format-item)  
[Формат элементы, имеющие тот же индекс](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Элемент управления Форматированные выходные данные

[Управление форматированием](#controlling-formatting)  
[Управление интервал](#controlling-spacing)  
[Управление выравнивания](#controlling-alignment)  
[Управление количеством цифр целой части](#how-do-i-control-the-number-of-integral-digits)  
[Управление количеством цифр после десятичного разделителя](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[Включая фигурные скобки литерала в результирующую строку](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Сделать строки формата языка и региона

[Форматирование с учетом языка и региональных параметров](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Настройка операции форматирования

[Пользовательские операции форматирования](#example-a-custom-formatting-operation)  
[Поставщик отсекаемый отрезок и модуль форматирования римские цифры](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Объект для форматирования.</param>
        <summary>Заменяет один или более элементов формата в строке строковым представлением указанного объекта.</summary>
        <returns>Копия <paramref name="format" />, в которой все элементы формата заменены строковыми представлениями <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) преобразовать значение выражения в строковое представление и встроить это представление в строку. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Пример Форматирование один аргумент  
 
 В следующем примере используется <xref:System.String.Format%28System.String%2CSystem.Object%29> метод для внедрения возраст человека в середине строки.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимый элемент формата в <paramref name="format" />.  
  
-или- 
Индекс элемента формата не равен нулю.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Массив объектов, содержащий нуль или более форматируемых объектов.</param>
        <summary>Заменяет элемент формата в указанной строке строковым представлением соответствующего объекта в указанном массиве.</summary>
        <returns>Копия <paramref name="format" />, в которой элементы формата заменены строковыми представления соответствующих объектов в <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования значения четырех или более выражений в их строковые представления и для внедрения этих представлений в строку. Так как `args` параметр помечается <xref:System.ParamArrayAttribute?displayProperty=nameWithType> атрибут, можно передать объекты в метод как отдельные аргументы или <xref:System.Object> массива. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Пример Форматирование больше трех аргументов  
 
 В этом примере создается строка, содержащая данные на высокой и низкой температуре в определенный день. Строка составного формата имеет пять элементов формата в примере C# и шесть в примере Visual Basic. Два элемента форматирования определяют ширину соответствующего значения строковое представление, а первый элемент форматирования также включают стандартные формата даты и времени.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 Можно также передать объекты отформатирован в виде массива, а не как список аргументов.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="format" /> или <paramref name="args" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше либо равен длине массива <paramref name="args" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Объект для форматирования.</param>
        <summary>Заменяет элементы формата в указанной строке строковым представлением соответствующего объекта. Параметр предоставляет сведения об особенностях форматирования, связанных с языком и региональными параметрами.</summary>
        <returns>Копия <paramref name="format" />, в которой элементы форматирования были заменены строковым представлением <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) преобразовать значение выражения в строковое представление и встроить это представление в строку. При выполнении преобразования, данный метод использует форматирование, зависящее от языка и региональных параметров или пользовательский модуль форматирования. Метод преобразует `arg0` в строковое представление, вызвав его **ToString(IFormatProvider)** метода или, если объект, соответствующая элемент форматирования, включающий строку формата, вызвав его **ToString () String, IFormatProvider)** метод. Если эти методы не существует, он вызывает метод объекта без параметров **ToString** метод.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата не равен нулю.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Массив объектов, содержащий нуль или более форматируемых объектов.</param>
        <summary>Заменяет элементы формата в строке строковым представлениями соответствующих объектов в указанном массиве. Параметр предоставляет сведения об особенностях форматирования, связанных с языком и региональными параметрами.</summary>
        <returns>Копия <paramref name="format" />, в которой элементы формата заменены строковыми представления соответствующих объектов в <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования четырех или более выражений в их строковые представления и для внедрения этих представлений в строку. При выполнении преобразования, данный метод использует форматирование, зависящее от языка и региональных параметров или пользовательский модуль форматирования. Метод преобразует каждый <xref:System.Object> аргумент в строковое представление, вызвав его **ToString(IFormatProvider)** метода или, если объект, соответствующая элемент форматирования, включающий строку формата, вызвав его **ToString(String,IFormatProvider)** метод. Если эти методы не существует, он вызывает метод объекта без параметров **ToString** метод.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>Пример Форматирование с учетом языка и региональных параметров  
 В этом примере используется <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> метод для отображения строкового представления некоторых значений даты и времени и числовых значений с помощью нескольких различных языков и региональных параметров.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="format" /> или <paramref name="args" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше либо равен длине массива <paramref name="args" />.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <summary>Заменяет элементы формата в строке строковым представлением двух указанных объектов.</summary>
        <returns>Копия <paramref name="format" />, в которой все элементы формата заменены строковыми представлениями <paramref name="arg0" /> и <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования значения из двух выражений в их строковые представления и для внедрения этих представлений в строку. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Пример Форматирование два аргумента  
 
 В этом примере используется <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> метод для отображения данных температуры и времени, хранящиеся в универсальной <xref:System.Collections.Generic.Dictionary%602> объекта. Обратите внимание на то, что строка формата имеет три элемента форматирования, несмотря на то, что имеется только два объекта для форматирования. Это, так как первый объект в списке (значение даты и времени) используются элементы два формата: Первый формат элемента отображает время, а вторая отображает дату.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата не равен нулю или единице.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <summary>Заменяет элементы формата в строке строковым представлением двух указанных объектов. Параметр предоставляет сведения об особенностях форматирования, связанных с языком и региональными параметрами.</summary>
        <returns>Копия <paramref name="format" />, в которой все элементы формата заменены строковыми представлениями <paramref name="arg0" /> и <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования в их строковые представления двух выражений и внедрить эти представления в строку. При выполнении преобразования, данный метод использует форматирование, зависящее от языка и региональных параметров или пользовательский модуль форматирования. Метод преобразует каждый <xref:System.Object> аргумент в строковое представление, вызвав его **ToString(IFormatProvider)** метода или, если объект, соответствующая элемент форматирования, включающий строку формата, вызвав его **ToString(String,IFormatProvider)** метод. Если эти методы не существует, он вызывает метод объекта без параметров **ToString** метод.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата не равен нулю или единице.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <param name="arg2">Третий объект для форматирования.</param>
        <summary>Заменяет элементы формата в строке строковым представлением трех указанных объектов.</summary>
        <returns>Копия <paramref name="format" />, в которой все элементы формата заменены строковыми представлениями <paramref name="arg0" />, <paramref name="arg1" /> и <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования значения из трех выражений в их строковые представления и для внедрения этих представлений в строку. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Пример Форматирование три аргумента  
 
 В этом примере используется <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> метод, чтобы создать строку, которая иллюстрирует результат логического значения `And` операцию с двумя целочисленными значениями. Обратите внимание, строка формата содержит шесть элементов форматирования, что метод имеет только три элемента в списке параметров, поскольку каждый элемент форматируется двумя разными способами.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше двух.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">[Строка составного форматирования](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <param name="arg2">Третий объект для форматирования.</param>
        <summary>Заменяет элементы формата в строке строковым представлением трех указанных объектов. Параметр предоставляет сведения об особенностях форматирования, связанных с языком и региональными параметрами.</summary>
        <returns>Копия <paramref name="format" />, в которой все элементы формата заменены строковыми представлениями <paramref name="arg0" />, <paramref name="arg1" /> и <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) для преобразования три выражения строковыми представлениями и внедрять эти представления в строку. При выполнении преобразования, данный метод использует форматирование, зависящее от языка и региональных параметров или пользовательский модуль форматирования. Метод преобразует каждый <xref:System.Object> аргумент в строковое представление, вызвав его **ToString(IFormatProvider)** метода или, если объект, соответствующая элемент форматирования, включающий строку формата, вызвав его **ToString(String,IFormatProvider)** метод. Если эти методы не существует, он вызывает метод объекта без параметров **ToString** метод.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше двух.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает объект, который может выполнять итерацию отдельных знаков данной строки.</summary>
        <returns>Объект перечислителя.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> Вместо вызова метода <xref:System.String.GetEnumerator%2A> метод для извлечения <xref:System.CharEnumerator> объект затем используется для перечисления строки, следует использовать конструкцию итерации языка (в C#, в C + +/ CLR и в Visual Basic). [по каждому элементу](~/docs/csharp/language-reference/keywords/foreach-in.md) в C# [для каждого](/cpp/dotnet/for-each-in) в C + +/ CLR, и [для каждого](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) в Visual Basic).
  
 Этот метод позволяет выполнять итерацию отдельных знаков в строке. Например, Visual Basic `For Each` и C# `foreach` инструкции вызвать этот метод для возврата <xref:System.CharEnumerator> объект, способный предоставлять доступ только для чтения к символам в данного экземпляра строки.  
  
   
  
## Examples  
 В следующем примере выполняется итерация символы в нескольких строках и отображает сведения об их отдельных символов. Она использует языковой конструкции итерации, а не вызов <xref:System.String.GetEnumerator%2A> метод.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для этой строки.</summary>
        <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поведение <xref:System.String.GetHashCode%2A> зависит от его реализации, которая может изменяться от одной версии среды CLR в другой. Причина, почему это может случиться — повышение производительности <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Если два строковых объекта равны, <xref:System.String.GetHashCode%2A> метод возвращает одинаковые значения. Тем не менее не уникальный хэш-кодом для каждого уникального строкового значения. Различные строки могут возвращать одинаковый хэш-код.  
>   
>  Хэш-код, сам не обязательно быть нестабильным. Хэш-коды для одинаковых строк может отличаться в разных реализациях .NET, в версиях .NET и платформ .NET (например, 32-разрядных и 64-разрядные) в одной версии платформы .NET. В некоторых случаях они могут даже отличаться по домену приложения. Это означает, что два последующих запусках той же программы могут возвращать разные хэш-коды.  
>   
>  В результате хэш кодов никогда не должно использоваться за пределами домена приложения, в котором они были созданы, они никогда не должны использоваться как ключевые поля в коллекции, и они никогда не должны сохраняться.  
>   
>  Наконец не используйте хэш-код вместо значения, возвращаемого функцией шифрования хэширования, при необходимости криптостойкой хэш. Для криптографических хэшей, используйте класс, производный от <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> или <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> класса.  
>   
>  Дополнительные сведения о хэш-кодов, см. в разделе <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 В классических приложениях можно использовать [ \<UseRandomizedStringHashAlgorithm > элемент](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) создания уникальный хэш-кодов для каждого домена приложения. Это может уменьшить количество конфликтов и повысить общую производительность операций вставки и уточняющих запросов, использующих хэш-таблицы. В следующем примере показано, как использовать [ \<UseRandomizedStringHashAlgorithm > элемент](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Он определяет создания уникальный хэш-кодов для каждого домена приложения. Это может уменьшить количество конфликтов и повысить общую производительность операций вставки и уточняющих запросов, использующих хэш-таблицы. В следующем примере показано, как использовать. Он определяет `DisplayString` класс, который включает закрытую строковую константу, `s`, значение которого равно «This is a string». Он также включает метод `ShowStringHashCode`, который отображает значение строки и ее хэш-код вместе с именем домена приложения, в котором метод выполняется.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 При выполнении примера без указания файла конфигурации он отображает подобный следующему вывод. Обратите внимание, что хэш-коды для строки идентичны в обоих доменах приложений.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 Однако при добавлении следующего файла конфигурации в каталог примеров и запуске примера, хэш-коды для той же строки будут отличаться по домену приложения.  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 Если файл конфигурации существует, пример отображает следующие выходные данные:  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  Хэш-кодов используются для вставки и извлечения объектов с ключом из хэш-таблицы эффективно. Тем не менее хэш-коды не уникальной идентификации строки. Одинаковые строки имеют равно хэш-коды, но среда CLR также может назначать одинаковый хэш-код для разных строк. Кроме того хэш-коды могут различаться по версии платформы .NET, платформы в одну версию и доменом приложения. По этой причине не следует сериализовать или сохранить значения хэш-кода, а также следует использовать их как ключи в хэш-таблицу или словарь.  
  
 Дополнительные сведения об использовании хэш-кодов и `GetHashCode` метод, см. в разделе <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.GetHashCode%2A> метод с использованием различных входных строк.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Значение, возвращенное <see cref="M:System.String.GetHashCode" /> зависит от платформы. Он отличается в 32-разрядных и 64-разрядных версиях платформы .NET Framework. Он также могут различаться в разных версиях .NET Framework и .NET Core.</para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; элемент</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.TypeCode" /> для класса <see cref="T:System.String" />.</summary>
        <returns>Константа перечислимого типа, <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере отображается <xref:System.TypeCode> константы перечислимого типа для <xref:System.String> типа.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанного символа Юникода или строки в пределах данного экземпляра. Метод возвращает -1, если знак или строка не найдена в данном экземпляре.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Искомый знак Юникода.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанного символа Юникода в данной строке.</summary>
        <returns>Отсчитываемое от нуля значение индекса параметра <paramref name="value" />, если этот знак найден; в противном случае — значение -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля.  
  
 Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде. Для выполнения поиска с учетом языка и региональных параметров используйте <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> метод, где скалярное значение Юникод, представляющее составной знак, например лигатура «?» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения символа компонентов в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере показано, как можно выполнить поиск <xref:System.String> для символов с помощью <xref:System.String.IndexOf%2A> метод.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения значения указанной строки в данном экземпляре.</summary>
        <returns>Положение в индексе (начиная с нуля) параметра <paramref name="value" />, если эта строка найдена, или значение -1, если она не найдена. Если значение <paramref name="value" /> равно <see cref="F:System.String.Empty" />, то возвращаемое значение равно 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля.  
  
 Этот метод выполняет поиск слова (с учетом регистра и культуры) с использованием текущего языка и региональных параметров. Поиск начинается с позиции первого символа этого экземпляра и продолжается до последней позиции знака.  
  
 Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров параметр `value` содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если `value` состоит только из одного или нескольких символов можно игнорировать, <xref:System.String.IndexOf%28System.String%29> метод всегда возвращает 0 (ноль), чтобы указать, что совпадения в начале текущего экземпляра. В следующем примере <xref:System.String.IndexOf%28System.String%29> метод используется для поиска подстроки три (мягкий перенос (U + 00AD), Мягкий перенос перед буквой «n» и мягкий перенос перед буквой «m») в двух строках. Только одна из строк содержит мягкий перенос. Если пример выполняется [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в каждом из случаев, поскольку мягкий перенос является игнорируемым символом, результат аналогичен так, как если бы мягкий перенос не были включены в `value`. При поиске мягкий перенос, метод возвращает 0 (ноль), чтобы указать, что он найдено совпадение в начале строки.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 Следующий пример выполняет поиск «n» в «animal». Так как строка индексы отсчитываются с нуля, а не один, <xref:System.String.IndexOf%28System.String%29> метод указывает, что «n» в позиции 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 В следующем примере используется <xref:System.String.IndexOf%2A> метод, чтобы определить начальную позицию имени животного в предложение. Затем используется этой позиции для вставки прилагательного, которое описывает животное в предложении.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Как описано в [советы и рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методы сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывать методы, которые нужны параметры, чтобы указать явно. Чтобы найти первый индекс подстроки в пределах экземпляра строки, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> перегрузку метода со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его `comparisonType` параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Искомый знак Юникода.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанного символа Юникода в данной строке. Поиск начинается с указанной позиции знака.</summary>
        <returns>Отсчитываемая от нуля позиция индекса параметра <paramref name="value" /> с начала строки, если символ найден. Значение –1, если символ не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с 0. Параметр `startIndex` может иметь значение в диапазоне от 0 до длины экземпляра строки. Если `startIndex` равно сумме длины экземпляра строки, метод возвращает значение -1.  
  
 Поиск в диапазоне от `startIndex` до конца строки.  
  
 Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде. Для выполнения поиска с учетом языка и региональных параметров используйте <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> метод, где скалярное значение Юникод, представляющее составной знак, например лигатура «?» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения символа компонентов в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.IndexOf%2A> метод.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> имеет значение меньше нуля или больше длины строки.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Символ для поиска.</param>
        <param name="comparisonType">Значение перечисления, определяющее правила поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанного символа Юникода в данной строке. Параметр определяет тип поиска заданного символа.</summary>
        <returns>Отсчитываемое от нуля значение индекса параметра <paramref name="value" />, если этот знак найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Индексация начинается с нуля.  
  
`comparisonType` Параметр <xref:System.StringComparison> член перечисления, указывающее ли поиск `value` аргумент использует текущие или инвариантные язык и региональные параметры, с учетом или без учета регистра или используется word или порядковым номерам.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения значения указанной строки в данном экземпляре. Поиск начинается с указанной позиции знака.</summary>
        <returns>Отсчитываемая от нуля позиция индекса параметра <paramref name="value" /> с начала текущего экземпляра, если строка найдена. Значение –1, если строка не найдена. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с 0. Параметр `startIndex` может иметь значение в диапазоне от 0 до длины экземпляра строки. Если `startIndex` равно сумме длины экземпляра строки, метод возвращает значение -1.  
  
 Этот метод выполняет поиск слова (с учетом регистра и культуры) с использованием текущего языка и региональных параметров. Поиск начинается с `startIndex` символ позицию данного экземпляра и продолжается до последней позиции знака.  
  
 Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров параметр `value` содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если `value` состоит только из одного или нескольких символов можно игнорировать, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> метод всегда возвращает `startIndex`, который является позицию символа, с которого начинается поиск. В следующем примере <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> метод позволяет найти позицию мягкий перенос (U + 00AD) следуют «m» в двух строках. Только одна из строк содержит требуемую подстроку. Если пример выполняется [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемым символом, метод возвращает индекс «m» в строке. Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m".  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 Следующий пример просматривает все вхождения указанной строки в целевой строке.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> имеет значение меньше нуля или больше длины этой строки.</exception>
        <block subset="none" type="usage"><para>Как описано в [советы и рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методы сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывать методы, которые нужны параметры, чтобы указать явно. Чтобы найти первый индекс подстроки, происходит после определенной позиции, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> перегрузку метода со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его `comparisonType` параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанной строки в текущем объекте <see cref="T:System.String" />. Параметр определяет тип поиска заданной строки.</summary>
        <returns>Индекс позиции строки, заданной в параметре <paramref name="value" />, если она найдена, и -1, если нет. Если значение <paramref name="value" /> равно <see cref="F:System.String.Empty" />, то возвращаемое значение равно 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля.  
  
 `comparisonType` Параметр указывает искомый `value` параметра, используя текущие или инвариантные язык и региональные параметры, с помощью поиска с учетом или без учета регистра и с помощью word или порядковым номерам.  
  
   
  
## Examples  
 В следующем примере показано три перегрузки <xref:System.String.IndexOf%2A> метод, который поиска первого экземпляра строки внутри другой строки с использованием различных значений свойства <xref:System.StringComparison> перечисления.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров (то есть, если параметр <paramref name="comparisonType" /> не имеет значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) параметр <paramref name="value" /> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если <paramref name="value" /> состоит только из одного или нескольких символов можно игнорировать, <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> метод всегда возвращает 0 (ноль), чтобы указать, что совпадения в начале текущего экземпляра.  
  
В следующем примере <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> метод используется для поиска подстроки три (мягкий перенос (U + 00AD), Мягкий перенос перед буквой «n» и мягкий перенос перед буквой «m») в двух строках. Только одна из строк содержит мягкий перенос. Если пример выполняется [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, поскольку мягкий перенос является игнорируемым символом, поиск с учетом языка и региональных параметров возвращает значение, оно возвратит, если мягкий перенос не были включены в строку поиска. Поиск по порядковым номерам, однако успешно находит мягкий перенос в одной строке и сообщает, что он отсутствует из второй строки.  
  
[!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Искомый знак Юникода.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанного символа в данном экземпляре. Поиск начинается с указанной позиции знака; проверяется заданное количество позиций.</summary>
        <returns>Отсчитываемая от нуля позиция индекса параметра <paramref name="value" /> с начала строки, если символ найден. Значение –1, если символ не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск начинается с `startIndex` и продолжает `startIndex`  +  `count` -1. Символ в `startIndex`  +  `count` не включается в поиск.  
  
 Индексация начинается с 0 (ноль). Параметр `startIndex` может иметь значение в диапазоне от 0 до длины экземпляра строки.  
  
 Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде. Для выполнения поиска с учетом языка и региональных параметров используйте <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> метод, где скалярное значение Юникод, представляющее составной знак, например лигатура «?» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения символа компонентов в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.IndexOf%2A> метод.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> или <paramref name="startIndex" /> является отрицательным значением.  
  
-или- 
 <paramref name="startIndex" /> больше длины этой строки.  
  
-или- 
 <paramref name="count" /> больше, чем длина этой строки минус <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения значения указанной строки в данном экземпляре. Поиск начинается с указанной позиции знака; проверяется заданное количество позиций.</summary>
        <returns>Отсчитываемая от нуля позиция индекса параметра <paramref name="value" /> с начала текущего экземпляра, если строка найдена. Значение –1, если строка не найдена. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с 0 (ноль). Параметр `startIndex` может иметь значение в диапазоне от 0 до длины экземпляра строки.  
  
 Этот метод выполняет поиск слова (с учетом регистра и культуры) с использованием текущего языка и региональных параметров. Поиск начинается с `startIndex` и продолжает `startIndex`  +  `count` -1. Символ в `startIndex`  +  `count` не включается в поиск.  
  
 Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров параметр `value` содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если `value` состоит только из одного или нескольких символов можно игнорировать, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> метод всегда возвращает `startIndex`, который является позицию символа, с которого начинается поиск. В следующем примере <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> метод позволяет найти позицию мягкий перенос (U + 00AD) следуют «m», начиная с третьего по шестой позиций знаков в две строки. Только одна из строк содержит требуемую подстроку. Если пример выполняется [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемым символом, метод возвращает индекс «m» в строке при выполнении учитывающего культуру сравнения. Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m".  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 В следующем примере вычисляется всех вхождений строки «he» в подстроке другой строки. Обратите внимание на то, что количество символов для поиска должен вычисляться для каждой итерации поиска.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> или <paramref name="startIndex" /> является отрицательным значением.  
  
-или- 
 <paramref name="startIndex" /> больше длины этой строки.  
  
-или- 
 <paramref name="count" /> больше, чем длина этой строки минус <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage"><para>Как описано в [советы и рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методы сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывать методы, которые нужны параметры, чтобы указать явно. Чтобы использовать правила сравнения строк для текущего языка и региональных параметров для этой операции, вызовите <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> перегрузку метода со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его `comparisonType` параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанной строки в текущем объекте <see cref="T:System.String" />. Параметры задают начальную позицию поиска в текущей строке и тип поиска.</summary>
        <returns>Отсчитываемая от нуля позиция параметра <paramref name="value" /> с начала текущего экземпляра, если строка найдена, или -1, если нет. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с 0. Параметр `startIndex` может иметь значение в диапазоне от 0 до длины экземпляра строки. Если `startIndex` равно сумме длины экземпляра строки, метод возвращает значение -1.  
  
 `comparisonType` Параметр указывает искомый `value` параметра, используя текущие или инвариантные язык и региональные параметры, с помощью поиска с учетом или без учета регистра и с помощью word или порядковым номерам.  
  
   
  
## Examples  
 Следующие exampledemonstrates три перегрузки <xref:System.String.IndexOf%2A> метод, который поиска первого экземпляра строки внутри другой строки с использованием различных значений свойства <xref:System.StringComparison> перечисления.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> имеет значение меньше нуля или больше длины этой строки.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров (то есть, если параметр <paramref name="comparisonType" /> не имеет значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) параметр <paramref name="value" /> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если <paramref name="value" /> состоит только из одного или нескольких символов можно игнорировать, <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> метод всегда возвращает <paramref name="startIndex" />, который является позицию символа, с которого начинается поиск.  
  
В следующем примере <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> метод позволяет найти позицию мягкий перенос (U + 00AD) следуют «m», начиная с третьей позиции символа в двух строках. Только одна из строк содержит требуемую подстроку. Если пример выполняется [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемым символом, метод возвращает индекс «m» в строке при выполнении учитывающего культуру сравнения. Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m". Этот метод возвращает индекс мягкого переноса в первой строке только при выполнении порядкового сравнения.  
  
[!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого вхождения указанной строки в текущем объекте <see cref="T:System.String" />. Параметры задают начальную позицию поиска в текущей строке, количество проверяемых знаков текущей строки и тип поиска.</summary>
        <returns>Отсчитываемая от нуля позиция параметра <paramref name="value" /> с начала текущего экземпляра, если строка найдена, или -1, если нет. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с 0 (ноль). Параметр `startIndex` может иметь значение в диапазоне от 0 до длины экземпляра строки.  
  
 Поиск начинается с `startIndex` и продолжает `startIndex`  +  `count` -1. Символ в `startIndex`  +  `count` не включается в поиск.  
  
 `comparisonType` Параметр указывает искомый `value` параметра, используя текущие или инвариантные язык и региональные параметры, с помощью поиска с учетом или без учета регистра и с помощью word или порядковым номерам.  
  
   
  
## Examples  
 Следующие exampledemonstrates три перегрузки <xref:System.String.IndexOf%2A> метод, который поиска первого экземпляра строки внутри другой строки с использованием различных значений свойства <xref:System.StringComparison> перечисления.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> или <paramref name="startIndex" /> является отрицательным значением.  
  
-или- 
 <paramref name="startIndex" /> больше длины этого экземпляра.  
  
-или- 
 <paramref name="count" /> больше, чем длина этой строки минус <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров (то есть, если параметр <paramref name="comparisonType" /> не имеет значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) параметр <paramref name="value" /> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если <paramref name="value" /> состоит только из одного или нескольких символов можно игнорировать, <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> метод всегда возвращает <paramref name="startIndex" />, который является позицию символа, с которого начинается поиск.  
  
В следующем примере <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> метод позволяет найти позицию мягкий перенос (U + 00AD) следуют «m», начиная с третьего по шестой позиций знаков в две строки. Только одна из строк содержит требуемую подстроку. Если пример выполняется [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемым символом, метод возвращает индекс «m» в строке при выполнении учитывающего культуру сравнения. Когда он выполняет порядковое сравнение, однако она находит подстрока только в первой строке. Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой «m», метод возвращает не индекс мягкого переноса, но вместо этого возвращает индекс «m», когда он выполняет сравнение с учетом языка и региональных параметров. Этот метод возвращает индекс мягкого переноса в первой строке только при выполнении порядкового сравнения.  
  
[!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает индекс первого обнаруженного в данном экземпляре знака из указанного массива знаков Юникода. Метод возвращает -1, если знаки массива не найдены в этом экземпляре.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Массив знаков Юникода, содержащий один или несколько искомых знаков.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого обнаруженного в данном экземпляре символа из указанного массива символов Юникода.</summary>
        <returns>Начинающееся с нуля значение индекса первого вхождения какого-либо знака из <paramref name="anyOf" /> в данном экземпляре; -1, если не найден ни один знак из <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля.  
  
 Поиск `anyOf` чувствителен к регистру. Если `anyOf` — пустой массив, метод находит совпадение с началом строки (то есть в нулевом индексе).  
  
 Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде. Для выполнения поиска с учетом языка и региональных параметров используйте <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> метод, где скалярное значение Юникод, представляющее составной знак, например лигатура «?» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения символа компонентов в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 Следующий пример находит первый гласные в строке.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Массив знаков Юникода, содержащий один или несколько искомых знаков.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого обнаруженного в данном экземпляре символа из указанного массива символов Юникода. Поиск начинается с указанной позиции знака.</summary>
        <returns>Начинающееся с нуля значение индекса первого вхождения какого-либо знака из <paramref name="anyOf" /> в данном экземпляре; -1, если не найден ни один знак из <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля. `startIndex` Параметра могут варьироваться от 0 до единицу меньше, чем длина экземпляра строки.  
  
 Поиск в диапазоне от `startIndex` до конца строки.  
  
 Поиск `anyOf` чувствителен к регистру.  
  
 Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярное значение Юникод. Для выполнения поиска с учетом языка и региональных параметров используйте <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> метод, где скалярное значение Юникод, представляющее составной знак, например лигатура «?» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения символа компонентов в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере вычисляется индекс вхождение любого символа строки «is» в подстроке другой строки.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> является отрицательным значением.  
  
-или- 
 <paramref name="startIndex" /> больше, чем количество символов в данном экземпляре.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Массив знаков Юникода, содержащий один или несколько искомых знаков.</param>
        <param name="startIndex">Позиция, с которой начинается поиск.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <summary>Возвращает индекс с отсчетом от нуля первого обнаруженного в данном экземпляре символа из указанного массива символов Юникода. Поиск начинается с указанной позиции знака; проверяется заданное количество позиций.</summary>
        <returns>Начинающееся с нуля значение индекса первого вхождения какого-либо знака из <paramref name="anyOf" /> в данном экземпляре; -1, если не найден ни один знак из <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск начинается с `startIndex` и продолжает `startIndex`  +  `count` -1. Символ в `startIndex`  +  `count` не включается в поиск.  
  
 Индексация начинается с нуля. `startIndex` Параметра могут варьироваться от 0 до единицу меньше, чем длина экземпляра строки.  
  
 Поиск `anyOf` чувствителен к регистру.  
  
 Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярное значение Юникод. Для выполнения поиска с учетом языка и региональных параметров используйте <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> метод, где скалярное значение Юникод, представляющее составной знак, например лигатура «?» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения символа компонентов в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере вычисляется индекс вхождение любого символа строки «aid» в подстроке другой строки.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> или <paramref name="startIndex" /> является отрицательным значением.  
  
-или- 
 <paramref name="count" /> + <paramref name="startIndex" /> больше, чем количество символов в этом экземпляре.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">Положение отсчитываемого от нуля индекса вставки.</param>
        <param name="value">Строка, которую требуется вставить.</param>
        <summary>Возвращает новую строку, в которой указанная строка вставляется в указанной позиции индекса в данном экземпляре.</summary>
        <returns>Новая строка, эквивалентная данному экземпляру, но с тем отличием, что в положение <paramref name="value" /> помещено значение <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `startIndex` равно длине данного экземпляра, `value` добавляется в конец этого экземпляра.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в котором `value` вставляется в текущий экземпляр.  
  
 Например, возвращаемое значение `"abc".Insert(2, "XYZ")` является «abXYZc».  
  
   
  
## Examples  
 Следующий пример вставляет символ пробела в четвертой позиции символа (знак с индексом 3) строки.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 Следующее консольное приложение предлагает пользователю ввести один или несколько прилагательные для описания двух животных. Затем он вызывает <xref:System.String.Insert%2A> метод для вставки текста, введенного пользователем в строку.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> имеет отрицательное значение или больше длины этого экземпляра.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="str">Строка для поиска в пуле интернирования.</param>
        <summary>Извлекает системную ссылку на указанный объект <see cref="T:System.String" />.</summary>
        <returns>Системная ссылка на значение <paramref name="str" />, если оно уже интернировано; в противном случае возвращается новая ссылка на строку со значением <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда CLR экономит пространство для хранения строки, за счет создания таблицы, называемой пуле интернирования, которая содержит по одной ссылке на каждый уникальный строковый литерал, объявленный или созданный в программе. Следовательно экземпляр строкового литерала с конкретным значением существует только один раз в системе.  
  
 Например если несколько переменных назначается тот же строковый литерал, среда выполнения извлекает ту же ссылку на строковый литерал в пуле интернирования и назначает его каждой переменной.  
  
 <xref:System.String.Intern%2A> Метод использует пуле интернирования для поиска строки, равное значению `str`. Если такая строка существует, возвращается его ссылка в пуле интернирования. Если строка не существует, ссылку на `str` добавляется в пуле интернирования, а затем эта ссылка возвращается.  
  
 В следующем примере строка s1, который имеет значение «MyTest», уже интернировано, так как она является литералом в программе. <xref:System.Text.StringBuilder?displayProperty=nameWithType> Класс создает новый строковый объект, имеющий то же значение, что s1. Ссылка на эту строку присваивается s2. <xref:System.String.Intern%2A> Метод выполняет поиск строки, которая содержит то же значение, что s2. Поскольку такая строка существует, метод возвращает ту же ссылку, присвоенный s1. Такая ссылка затем присваивается s3. Ссылки s1 и s2 не считаются равными, поскольку они ссылаются на разные объекты; Ссылки s1 и s3 равны, поскольку они ссылаются на ту же строку.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Этот метод, чтобы сравнить <xref:System.String.IsInterned%2A> метод.  
  
## <a name="version-considerations"></a>Описание версии  
 В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], <xref:System.String.Intern%2A> метод возвращается к его поведение в .NET Framework 1.0 и 1.1 по отношению к интернирования пустая строка. В следующем примере переменная `str1` назначается ссылку <xref:System.String.Empty>и переменная `str2` назначается ссылка <xref:System.String.Empty> , возвращается путем вызова <xref:System.String.Intern%2A> метод после преобразования <xref:System.Text.StringBuilder>объект, значение которого равно <xref:System.String.Empty> в строку. Затем ссылки, содержащиеся в `str1` и `str2` сравниваются на предмет равенства.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 В [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], и [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` и `str2` равны. В [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] и [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` и `str2` не равны.  
  
## <a name="performance-considerations"></a>Особенности производительности  
 Если вы пытаетесь сократить общий объем памяти выделяет приложения, имейте в виду, что интернирование строки имеет два нежелательные побочные эффекты. Во-первых, память, выделенная для интернировано <xref:System.String> объекты скорее всего, не должна освобождаться до завершения общеязыковой среды выполнения (CLR). Причина в том, что CLR ссылка интернировано <xref:System.String> объект могут сохраняться после вашего приложения или даже домена приложения, завершается. Во-вторых для интернирования строки, необходимо сначала создать строку. Память, занятая <xref:System.String> объект по-прежнему назначается, несмотря на то, что память будет в конечном итоге удален сборщиком мусора.  
  
 В .NET Framework версии 2.0 вводит <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> член перечисления. <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> Член помечает сборку как не требующую интернирования строковых литералов. Можно применить <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> в сборку с помощью <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> атрибута. Кроме того, при использовании [Ngen.exe (генератор образов в машинном)](~/docs/framework/tools/ngen-exe-native-image-generator.md) для компиляции сборки до времени выполнения, строки не интернирование другим модулям.  
  
   
  
## Examples  
 В следующем примере используется три строки с равными значениями, чтобы определить, является ли вновь созданная и строку интернировано равны.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="str">Строка для поиска в пуле интернирования.</param>
        <summary>Извлекает ссылку на указанный объект <see cref="T:System.String" />.</summary>
        <returns>Ссылка на значение <paramref name="str" />, если оно находится в пуле интернирования среды CLR; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда CLR автоматически поддерживает таблицу, в пуле интернирования, который содержит один экземпляр каждого уникального строкового литерала константе, объявленной в программы, а также любой уникальный экземпляр называется <xref:System.String> программным способом добавить путем вызова <xref:System.String.Intern%2A> метод.  
  
 В пуле интернирования экономит пространство для хранения строки. Если вы назначаете символьная константа несколько переменных, каждой переменной присваивается ссылаются на той же константы в пуле интернирования вместо ссылки на несколько различных экземпляров <xref:System.String> , имеют одинаковые значения.  
  
 Этот метод выполняет поиск `str` в пуле интернирования. Если `str` уже интернировано, ссылку на этот экземпляр, возвращаемый; в противном случае — значение `null` возвращается.  
  
 Этот метод, чтобы сравнить <xref:System.String.Intern%2A> метод.  
  
 Этот метод не возвращает логическое значение. Если вызвать метод, так как требуется логическое значение, указывающее, является ли интернировано определенной строки, можно использовать следующий код.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  Начиная с .NET Framework версии 2.0, можно переопределить использование пуле интернирования при использовании [Ngen.exe (генератор образов в машинном)](~/docs/framework/tools/ngen-exe-native-image-generator.md) для установки сборки в кэш образов в машинном коде на локальном компьютере. Дополнительные сведения см. в разделе вопросы производительности в разделе "Примечания" <xref:System.String.Intern%2A> свойство.  
  
   
  
## Examples  
 В следующем примере показано, что компилятор автоматически интернируются строковых литералов.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Указывает, находится ли данная строка в определенной форме нормализации Юникода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Указывает, находится ли данная строка в форме нормализации Юникода C.</summary>
        <returns><see langword="true" />, если данная строка находится в форме нормализации Юникода C; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые символы Юникода, имеют несколько эквивалентных двоичных представлений, состоящий из объединения наборов и/или составные символы Юникода. Наличие нескольких представлений одного символа затрудняет поиск, сортировка, сопоставления и других операций.  
  
 В стандарте Юникод определяет процесс, называемый нормализация, которая возвращает одно двоичное представление, при наличии нескольких эквивалентных представлений символа. Нормализация может выполняться с использованием нескольких алгоритмов, вызывается формы нормализации, которые следуют различным правилам. В настоящее время платформа .NET поддерживает формы нормализации C, D, KC и KD.  
  
 Описание поддерживаемых формы нормализации Юникода, см. в разделе <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере определяется, является ли строка успешно нормализуется в различные формы нормализации.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий экземпляр содержит недопустимые символы Юникода.</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" /> Возвращает метод <see langword="false" /> как только он встречает первый символ, не было нормализовано в строке. Таким образом, если строка содержит символы, не было нормализовано следуют недопустимые символы Юникода, <see cref="Overload:System.String.Normalize" /> метод вызывает исключение <see cref="T:System.ArgumentException" /> несмотря на то что <see cref="Overload:System.String.IsNormalized" /> возвращает <see langword="false" />.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Форма нормализации Юникода.</param>
        <summary>Указывает, находится ли данная строка в заданной форме нормализации Юникода.</summary>
        <returns><see langword="true" />, если строка находится в форме нормализации, указанной в параметре <paramref name="normalizationForm" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые символы Юникода, имеют несколько эквивалентных двоичных представлений, состоящий из объединения наборов и/или составные символы Юникода. Наличие нескольких представлений одного символа затрудняет поиск, сортировка, сопоставления и других операций.  
  
 В стандарте Юникод определяет процесс, называемый нормализация, которая возвращает одно двоичное представление, при наличии нескольких эквивалентных представлений символа. Нормализация может выполняться с использованием нескольких алгоритмов, вызывается формы нормализации, которые следуют различным правилам. В настоящее время платформа .NET поддерживает формы нормализации C, D, KC и KD.  
  
 Описание поддерживаемых формы нормализации Юникода, см. в разделе <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.IsNormalized%2A> и <xref:System.String.Normalize%2A> методы.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий экземпляр содержит недопустимые символы Юникода.</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" /> Возвращает метод <see langword="false" /> как только он встречает первый символ, не было нормализовано в строке. Таким образом, если строка содержит символы, не было нормализовано следуют недопустимые символы Юникода, <see cref="Overload:System.String.Normalize" /> метод вызывает исключение <see cref="T:System.ArgumentException" /> несмотря на то что <see cref="Overload:System.String.IsNormalized" /> возвращает <see langword="false" />.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для проверки.</param>
        <summary>Указывает, действительно ли указанная строка является строкой <see langword="null" /> или пустой строкой ("").</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> равен <see langword="null" /> или пустой строке (""); в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> — Это удобный метод, который позволяет одновременно тестировать ли <xref:System.String> — `null` или имеет значение <xref:System.String.Empty?displayProperty=nameWithType>. Это аналогично следующему коду:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Можно использовать <xref:System.String.IsNullOrWhiteSpace%2A> способ проверить, является ли строка `null`, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>, или он содержит только пробелы.  
  
## <a name="what-is-a-null-string"></a>Что такое строку null?

Строка, такая `null` если ей не было назначено значение (в C++ и Visual Basic) или если ей явно было назначено значение `null`. Несмотря на то что [составное форматирование](~/docs/standard/base-types/composite-formatting.md) функции можно правильной обработки пустой строки, как показано в следующем примере, попытка вызовите один, если его члены создает <xref:System.NullReferenceException>.  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>Что представляет собой пустую строку?  

Строка пуста, если его явным образом присваивается пустая строка ("») или <xref:System.String.Empty?displayProperty=nameWithType>. Пустая строка имеет <xref:System.String.Length%2A> 0.  В следующем примере создается пустая строка и отображает его значение и его длины.  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 В следующем примере рассматриваются три строки и определяет, каждая строка имеет значение, является пустой строкой или является `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для проверки.</param>
        <summary>Указывает, имеет ли указанная строка значение <see langword="null" />, является ли она пустой строкой или строкой, состоящей только из символов-разделителей.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> имеет значение <see langword="null" /> или <see cref="F:System.String.Empty" />, либо если параметр <paramref name="value" /> содержит только символы-разделители.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> — Это удобный метод, который похож на следующий код, за исключением того, что она предлагает более высокую производительность:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Пробельные символы определены в стандарте Юникода. <xref:System.String.IsNullOrWhiteSpace%2A> Метод интерпретирует любой символ, который возвращает значение `true` при его передаче <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> метод как символ пробела.  
  
   
  
## Examples  
 В следующем примере создается массив строк и затем передает каждый элемент массива в <xref:System.String.IsNullOrWhiteSpace%2A> метод.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сцепляет элементы указанного массива или элементы коллекции, помещая между ними заданный разделитель.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Строка для использования в качестве разделителя.<paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="values" /> более одного элемента.</param>
        <param name="values">Коллекция, содержащая сцепляемые строки.</param>
        <summary>Сцепляет элементы созданной коллекции <see cref="T:System.Collections.Generic.IEnumerable`1" /> типа <see cref="T:System.String" />, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из элементов <paramref name="values" />, разделяемых строками <paramref name="separator" />. Если <paramref name="values" /> не содержит членов, метод возвращает <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `separator` — `null`, пустая строка (<xref:System.String.Empty?displayProperty=nameWithType>) вместо него используется. Если любой член `values` является `null`, вместо него используется пустая строка.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> — Это удобный метод, который позволяет сцеплять каждого элемента в `IEnumerable(Of String)` коллекции без предварительного преобразования элементов в массив строк. Это особенно полезно, с помощью выражения запроса Language-Integrated Query (LINQ). В следующем примере передается `List(Of String)` , содержащий прописные или строчные буквы алфавита в лямбда-выражение, который выбирает букв, которые находятся равным или больше, чем буквы (который, в примере «M»). `IEnumerable(Of String)` Коллекцию, возвращаемую <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> методу передается <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> метод для отображения результата в виде одной строки.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 Следующий пример использует алгоритм решета Эратосфена для вычисления простых чисел, которые меньше или равно 100. Результат для <xref:System.Collections.Generic.List%601> объект типа <xref:System.String>, который затем передается <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> метод.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Строка для использования в качестве разделителя. <paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="values" /> более одного элемента.</param>
        <param name="values">Массив, содержащий элементы, которые требуется сцепить.</param>
        <summary>Сцепляет элементы массива объектов, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из элементов <paramref name="values" />, разделяемых строками <paramref name="separator" />. Если <paramref name="values" /> равен пустому массиву, метод возвращает значение <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `separator` — `null` или, если какой-либо элемент `values` отличный первый элемент — `null`, пустая строка (<xref:System.String.Empty?displayProperty=nameWithType>) вместо него используется. См. в примечаниях раздела вызывающих объектов, если первый элемент `values` является `null`.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> — Это удобный метод, который позволяет сцеплять каждого элемента в массиве объектов без явного преобразования строки его элементов. Строковое представление каждого объекта в массиве является производным путем вызова этого объекта `ToString` метод.  
  
   
  
## Examples  
 Следующий пример использует алгоритм решета Эратосфена для вычисления простых чисел, которые меньше или равно 100. Присваивает результат целочисленный массив, который затем передается <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> метод.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> — <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Если первый элемент <paramref name="values" /> — <see langword="null" />, <see cref="M:System.String.Join(System.String,System.Object[])" /> метод не осуществляйте объединение элементов в <paramref name="values" /> , но вместо этого возвращает <see cref="F:System.String.Empty" />. Доступны несколько решений этой проблемы. Проще всего, — присвоить значение <see cref="F:System.String.Empty" /> на первый элемент массива, как показано следующем примере.  
  
[!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Строка для использования в качестве разделителя. <paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="value" /> более одного элемента.</param>
        <param name="value">Массив, содержащий элементы, которые требуется сцепить.</param>
        <summary>Сцепляет все элементы массива строк, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из элементов <paramref name="value" />, разделяемых строками <paramref name="separator" />. Если <paramref name="value" /> равен пустому массиву, метод возвращает значение <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например если `separator` является «,» и элементы `value` : «apple», «orange», «виноград» и «pear», `Join(separator, value)` возвращает «apple, orange, виноград, груша».  
  
 Если `separator` — `null`, пустая строка (<xref:System.String.Empty?displayProperty=nameWithType>) вместо него используется. Если любой элемент в `value` является `null`, вместо него используется пустая строка.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.Join%2A> метод.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Строка для использования в качестве разделителя. <paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="value" /> более одного элемента.</param>
        <param name="value">Массив, содержащий элементы, которые требуется сцепить.</param>
        <param name="startIndex">Первый используемый элемент массива <paramref name="value" />.</param>
        <param name="count">Число используемых элементов массива <paramref name="value" />.</param>
        <summary>Сцепляет указанные элементы массива строк, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из строк из параметра <paramref name="value" />, разделяемых строками <paramref name="separator" />.  
  
-или- 
 <see cref="F:System.String.Empty" />, если параметр <paramref name="count" /> равен нулю, параметр <paramref name="value" /> не содержит элементов или параметр <paramref name="separator" /> и все элементы параметра <paramref name="value" /> равны <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например если `separator` является «,» и элементы `value` : «apple», «orange», «виноград» и «pear», `Join(separator, value, 1, 2)` возвращает «orange, виноград».  
  
 Если `separator` — `null`, пустая строка (<xref:System.String.Empty?displayProperty=nameWithType>) вместо него используется. Если любой элемент в `value` является `null`, вместо него используется пустая строка.  
  
   
  
## Examples  
 Следующий пример Сцепляет два элемента массива названий фруктов.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="count" /> меньше 0.  
  
-или- 
 <paramref name="startIndex" /> плюс <paramref name="count" /> больше, чем число элементов в <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов параметра <paramref name="values" />.</typeparam>
        <param name="separator">Строка для использования в качестве разделителя.<paramref name="separator" /> включается в возвращаемую строку, только если в <paramref name="values" /> более одного элемента.</param>
        <param name="values">Коллекция, содержащая сцепляемые объекты.</param>
        <summary>Сцепляет элементы созданной коллекции, помещая между ними заданный разделитель.</summary>
        <returns>Строка, состоящая из элементов <paramref name="values" />, разделяемых строками <paramref name="separator" />. Если <paramref name="values" /> не содержит членов, метод возвращает <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `separator` — `null`, пустая строка (<xref:System.String.Empty?displayProperty=nameWithType>) вместо него используется. Если любой член `values` является `null`, вместо него используется пустая строка.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> — Это удобный метод, который позволяет сцеплять каждым членом <xref:System.Collections.Generic.IEnumerable%601> коллекции без предварительного преобразования их в строки. Строковое представление каждого объекта в <xref:System.Collections.Generic.IEnumerable%601> коллекции извлекается путем вызова этого объекта `ToString` метод.  
  
 Этот метод является полезным для выражения запросов Language-Integrated Query (LINQ). Например, следующий код определяет очень простой `Animal` класс, содержащий имя животного и порядок, к которой он принадлежит. Затем он определяет <xref:System.Collections.Generic.List%601> , содержащий ряд `Animal` объектов. <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> Метод расширения вызывается для извлечения `Animal` объектов, `Order` свойство имеет значение «Грызун». Результат передается <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> метод.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 Следующий пример использует алгоритм решета Эратосфена для вычисления простых чисел, которые меньше или равно 100. Результат для <xref:System.Collections.Generic.List%601> объект целочисленного типа, который затем передается <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> метод.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанного символа Юникода или строки в пределах данного экземпляра. Метод возвращает -1, если знак или строка не найдена в данном экземпляре.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Знак Юникода, который необходимо найти.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанного символа Юникода в пределах данного экземпляра.</summary>
        <returns>Отсчитываемое от нуля значение индекса параметра <paramref name="value" />, если этот знак найден; в противном случае — значение -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля. То есть первый символ в строке с нулевого индекса, последней равен <xref:System.String.Length%2A> - 1.  
  
 Этот метод начинает поиск с позиции последнего знака данного экземпляра и выполняется в обратном направлении до начала либо до `value` найден или проверит позицию первого символа. При поиске учитывается регистр.  
  
 Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде. Для выполнения поиска с учетом языка и региональных параметров используйте <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> метод, где скалярное значение Юникод, представляющее составной знак, например лигатура «?» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения символа компонентов в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере определяется `ExtractFilename` метод, который использует <xref:System.String.LastIndexOf%28System.Char%29> метод для поиска последнего символом разделителя каталогов в строке и для извлечения имени файла строки. Если файл существует, метод возвращает имя файла без пути.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанной строки в данном экземпляре.</summary>
        <returns>Положение в отсчитываемом от нуля индексе параметра <paramref name="value" />, если эта строка найдена, или значение -1, если она не найдена. Если параметр <paramref name="value" /> равен <see cref="F:System.String.Empty" />, возвращаемым значением является последняя позиция в индексе данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля. То есть первый символ в строке с нулевого индекса, последней равен <xref:System.String.Length%2A> - 1.  
  
 Поиск начинается с позиции последнего знака данного экземпляра и выполняется в обратном направлении до начала либо до `value` найден или проверит позицию первого символа.  
  
 Этот метод выполняет поиск слова (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.  
  
 Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров параметр `value` содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если `value` состоит только из одного или нескольких символов можно игнорировать, <xref:System.String.LastIndexOf%28System.String%29> метод всегда возвращает <xref:System.String.Length%2A?displayProperty=nameWithType> -1, представляющее последнего значения индекса в текущем экземпляре. В следующем примере <xref:System.String.LastIndexOf%28System.String%29> метод используется для поиска подстроки три (мягкий перенос (U + 00AD), Мягкий перенос перед буквой «n» и мягкий перенос перед буквой «m») в двух строках. Только одна из строк содержит мягкий перенос. Если пример выполняется [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в каждом из случаев, поскольку мягкий перенос является игнорируемым символом, результат аналогичен так, как если бы мягкий перенос не были включены в `value`. При поиске мягкий перенос, метод возвращает 6 и 5. Эти значения соответствуют индекс последнего символа в две строки.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 В следующем примере удаляется открывающих и закрывающих тегов HTML из строки, если они находятся в начале и конце строки. Если строка заканчивается закрывающей скобкой символ (">»), в примере используется <xref:System.String.LastIndexOf%2A> метод необходимо найти начало закрывающего тега.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Как описано в [советы и рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методы сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывать методы, которые нужны параметры, чтобы указать явно. Чтобы найти последний индекс подстроки в пределах экземпляра строки, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> перегрузку метода со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его <paramref name="comparisonType" /> параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Знак Юникода, который необходимо найти.</param>
        <param name="startIndex">Начальное положение поиска. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанного символа Юникода в пределах данного экземпляра. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки.</summary>
        <returns>Отсчитываемая от нуля позиция параметра <paramref name="value" /> в индексе, если этот символ найден, или значение -1, если он не найден или текущий экземпляр равен <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля. То есть первый символ в строке с нулевого индекса, последней равен <xref:System.String.Length%2A> -1. Этот метод начинает поиск `startIndex` позиции этого экземпляра и назад к началу текущего экземпляра, пока продолжается знака `value` найден или проверит позицию первого символа. Например если `startIndex` — <xref:System.String.Length%2A> - 1, метод выполняет поиск каждого символа из последнего символа строки в начало. При поиске учитывается регистр.  
  
 Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде. Для выполнения поиска с учетом языка и региональных параметров используйте <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> метод, где скалярное значение Юникод, представляющее составной знак, например лигатура «?» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения символа компонентов в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 Следующий пример производится поиск всех вхождений знака в строке от конца строки в начало строки.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> меньше нуля либо равно или превышает длину этого экземпляра.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанной строки в данном экземпляре. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки.</summary>
        <returns>Отсчитываемая от нуля начальная позиция индекса параметра <paramref name="value" />, если строка найдена; значение -1, если строка не найдена или значение текущего экземпляра равно <see cref="F:System.String.Empty" />. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является наименьшее значение из <paramref name="startIndex" /> и последнего значения индекса в данном экземпляре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля. То есть первый символ в строке с нулевого индекса, последней равен <xref:System.String.Length%2A> - 1.  
  
 Поиск начинается с `startIndex` позиции этого экземпляра и назад к началу, пока продолжается знака `value` найден или проверит позицию первого символа. Например если `startIndex` — <xref:System.String.Length%2A> - 1, метод выполняет поиск каждого символа из последнего символа строки в начало.  
  
 Этот метод выполняет поиск слова (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.  
  
 Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров параметр `value` содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если `value` состоит только из одного или нескольких символов можно игнорировать, <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> метод всегда возвращает `startIndex`, который является позицию символа, с которого начинается поиск. В следующем примере <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> метод используется для поиска подстроки, включающий мягкий перенос (U + 00AD) и предшествует или включает последний «m» в строке. Если пример выполняется [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, поскольку мягкий перенос в строке поиска учитывается, вызвав метод найти подстроку, состоящую из мягкий перенос и «m» возвращает позицию «m» в строке, в то время как вызов, чтобы найти substrin g, состоящий из мягкий перенос и «n» возвращает позицию «n». Строка поиска должна содержать только мягкий перенос, метод возвращает индекс «m», который представляет значение `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 Следующий пример выполняет поиск всех вхождений строки в целевой строке в конце целевой строки до начала целевой строки.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> меньше нуля или больше длины текущего экземпляра.  
  
-или- 
Текущий экземпляр равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> меньше –1 или больше нуля.</exception>
        <block subset="none" type="usage"><para>Как описано в [советы и рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методы сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывать методы, которые нужны параметры, чтобы указать явно. Чтобы найти индекс подстроки, предшествует определенной позиции, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> перегрузку метода со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его <paramref name="comparisonType" /> параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля последнего вхождения указанной строки в текущем объекте <see cref="T:System.String" />. Параметр определяет тип поиска заданной строки.</summary>
        <returns>Начальное положение в отсчитываемом от нуля индексе параметра <paramref name="value" />, если эта строка найдена, или значение -1, если она не найдена. Если параметр <paramref name="value" /> равен <see cref="F:System.String.Empty" />, возвращаемым значением является последняя позиция в индексе данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля. То есть первый символ в строке с нулевого индекса, последней равен <xref:System.String.Length%2A> - 1.  
  
 `comparisonType` Параметр указывает искомый `value` параметра, используя текущие или инвариантные язык и региональные параметры, с помощью поиска с учетом или без учета регистра и с помощью word или порядковым номерам.  
  
 Поиск начинается с позиции последнего знака данного экземпляра и выполняется в обратном направлении до начала либо до `value` найден или проверит позицию первого символа.  
  
   
  
## Examples  
 Следующие exampledemonstrates три перегрузки <xref:System.String.LastIndexOf%2A> метод, который поиска последнего вхождения строки внутри другой строки с использованием различных значений свойства <xref:System.StringComparison> перечисления.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров (то есть, если параметр <paramref name="options" /> не имеет значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) параметр <paramref name="value" /> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если <paramref name="value" /> состоит только из одного или нескольких символов можно игнорировать, <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> метод всегда возвращает <see cref="P:System.String.Length" /> -1, представляющее последнего значения индекса в текущем экземпляре.  
  
В следующем примере <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> метод используется для поиска подстроки три (мягкий перенос (U + 00AD), Мягкий перенос перед буквой «n» и мягкий перенос перед буквой «m») в двух строках. Только одна из строк содержит мягкий перенос. Если пример выполняется [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, поскольку мягкий перенос является игнорируемым символом, поиск с учетом языка и региональных параметров возвращает значение, оно возвратит, если мягкий перенос не были включены в строку поиска. Поиск по порядковым номерам, однако успешно находит мягкий перенос в одной строке и сообщает, что он отсутствует из второй строки.  
  
[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Знак Юникода, который необходимо найти.</param>
        <param name="startIndex">Начальное положение поиска. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанного символа Юникода в подстроке в пределах данного экземпляра. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки для заданного числа позиций символов.</summary>
        <returns>Отсчитываемая от нуля позиция параметра <paramref name="value" /> в индексе, если этот символ найден, или значение -1, если он не найден или текущий экземпляр равен <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля. То есть первый символ в строке с нулевого индекса, последней равен <xref:System.String.Length%2A> - 1.  
  
 Этот метод начинает поиск `startIndex` символ в позиции и переходит назад к началу этого экземпляра, пока `value` найден или `count` будет проверена. Например если `startIndex` — <xref:System.String.Length%2A> - 1, метод ищет в обратном направлении `count` символов из последнего символа в строке. При поиске учитывается регистр.  
  
 Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярное значение Юникод. Для выполнения поиска с учетом языка и региональных параметров используйте <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> метод, где скалярное значение Юникод, представляющее составной знак, например лигатура «?» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения символа компонентов в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 Следующий пример производится поиск всех вхождений символа в подстроке от конца подстроки в начало подстроки.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> меньше нуля либо равно или превышает длину этого экземпляра.  
  
-или- 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> - <paramref name="count" /> + 1 является отрицательным числом.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанной строки в данном экземпляре. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки для заданного числа позиций символов.</summary>
        <returns>Отсчитываемая от нуля начальная позиция индекса параметра <paramref name="value" />, если строка найдена; значение -1, если строка не найдена или значение текущего экземпляра равно <see cref="F:System.String.Empty" />. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является наименьшее значение из <paramref name="startIndex" /> и последнего значения индекса в данном экземпляре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля. То есть первый символ в строке с нулевого индекса, последней равен <xref:System.String.Length%2A> - 1.  
  
 Поиск начинается с `startIndex` позиции этого экземпляра и назад к началу, пока продолжается знака `value` найден или `count` будет проверена. Например если `startIndex` — <xref:System.String.Length%2A> - 1, метод ищет в обратном направлении `count` символов из последнего символа в строке.  
  
 Этот метод выполняет поиск слова (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.  
  
 Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров параметр `value` содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если `value` состоит только из одного или нескольких символов можно игнорировать, <xref:System.String.LastIndexOf%2A> метод всегда возвращает `startIndex`, который является позицию символа, с которого начинается поиск. В следующем примере <xref:System.String.LastIndexOf%2A> метод позволяет найти позицию мягкий перенос (U + 00AD) в двух символы перед последней «m» двух строк. Только одна из строк содержит требуемую подстроку. Если пример выполняется [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемым символом, метод возвращает индекс «m» в строке при выполнении учитывающего культуру сравнения. Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m".  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 Следующий пример выполняет поиск всех вхождений строки в подстроке от конца подстроки в начало подстроки.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> является отрицательным значением.  
  
-или- 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> является отрицательным.  
  
-или- 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> превышает длину этого экземпляра.  
  
-или- 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> - <paramref name="count" /> + 1 указывает позицию вне пределов данного экземпляра.  
  
-или- 
Текущий экземпляр равен <see cref="F:System.String.Empty" />, а <paramref name="start" /> меньше -1 или больше нуля.  
  
-или- 
Текущий экземпляр равен <see cref="F:System.String.Empty" />, а <paramref name="count" /> больше 1.</exception>
        <block subset="none" type="usage"><para>Как описано в [советы и рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методы сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывать методы, которые нужны параметры, чтобы указать явно. Чтобы выполнить эту операцию, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> перегрузку метода со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его <paramref name="comparisonType" /> параметра.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила поиска.</param>
        <summary>Возвращает индекс с отсчетом от нуля последнего вхождения указанной строки в текущем объекте <see cref="T:System.String" />. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки. Параметр определяет тип сравнения для выполнения во время поиска заданной строки.</summary>
        <returns>Отсчитываемая от нуля начальная позиция индекса параметра <paramref name="value" />, если эта строка найдена, или значение -1, если строка не найдена или текущий экземпляр равен <see cref="F:System.String.Empty" />. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является наименьшее значение из <paramref name="startIndex" /> и последнего значения индекса в данном экземпляре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля. То есть первый символ в строке с нулевого индекса, последней равен <xref:System.String.Length%2A> - 1.  
  
 Поиск начинается с `startIndex` символ в позиции и переходит обратно, либо до `value` найден или проверит позицию первого символа. Например если `startIndex` — <xref:System.String.Length%2A> - 1, метод выполняет поиск каждого символа из последнего символа строки в начало.  
  
 `comparisonType` Параметр указывает искомый `value` параметра, используя текущие или инвариантные язык и региональные параметры, с помощью поиска с учетом или без учета регистра и с помощью word или порядковым номерам.  
  
   
  
## Examples  
 Следующие exampledemonstrates три перегрузки <xref:System.String.LastIndexOf%2A> метод, который поиска последнего вхождения строки внутри другой строки с использованием различных значений свойства <xref:System.StringComparison> перечисления.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> меньше нуля или больше длины текущего экземпляра.  
  
-или- 
Текущий экземпляр равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> меньше -1 или больше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров (то есть, если параметр <paramref name="comparisonType" /> не имеет значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) параметр <paramref name="value" /> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если <paramref name="value" /> состоит только из одного или нескольких символов можно игнорировать, <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> метод всегда возвращает <paramref name="startIndex" />, который является позицию символа, с которого начинается поиск.  
  
В следующем примере <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> метод позволяет найти позицию мягкий перенос (U + 00AD) следуют «m», начиная с последней «m» в двух строках. Только одна из строк содержит требуемую подстроку. Если пример выполняется [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемым символом, метод возвращает индекс «m» в строке при выполнении учитывающего культуру сравнения. Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m". Этот метод возвращает индекс мягкого переноса в первой строке только при выполнении порядкового сравнения.  
  
[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка для поиска.</param>
        <param name="startIndex">Позиция, с которой начинается поиск. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее правила поиска.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанной строки в данном экземпляре. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки для заданного числа позиций символов. Параметр определяет тип сравнения для выполнения во время поиска заданной строки.</summary>
        <returns>Отсчитываемая от нуля начальная позиция индекса параметра <paramref name="value" />, если эта строка найдена, или значение -1, если строка не найдена или текущий экземпляр равен <see cref="F:System.String.Empty" />. Если значение параметра <paramref name="value" /> равно <see cref="F:System.String.Empty" />, возвращаемым значением является наименьшее значение из <paramref name="startIndex" /> и последнего значения индекса в данном экземпляре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля. То есть первый символ в строке с нулевого индекса, последней равен <xref:System.String.Length%2A> - 1.  
  
 Поиск начинается с `startIndex` символ в позиции и переходит обратно, либо до `value` найден или `count` будет проверена. Например если `startIndex` — <xref:System.String.Length%2A> - 1, метод ищет в обратном направлении `count` символов из последнего символа в строке.  
  
 `comparisonType` Параметр указывает искомый `value` параметра, используя текущие или инвариантные язык и региональные параметры, с помощью поиска с учетом или без учета регистра и с помощью word или порядковым номерам.  
  
   
  
## Examples  
 Следующие exampledemonstrates три перегрузки <xref:System.String.LastIndexOf%2A> метод, который поиска последнего вхождения строки внутри другой строки с использованием различных значений свойства <xref:System.StringComparison> перечисления.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> является отрицательным значением.  
  
-или- 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> является отрицательным.  
  
-или- 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> превышает длину этого экземпляра.  
  
-или- 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> – <paramref name="count" /> + 1 указывает позицию вне пределов данного экземпляра.  
  
-или- 
Текущий экземпляр равен <see cref="F:System.String.Empty" />, а <paramref name="start" /> меньше -1 или больше нуля.  
  
-или- 
Текущий экземпляр равен <see cref="F:System.String.Empty" />, а <paramref name="count" /> больше 1.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является допустимым значением <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров. Если при поиске с учетом языка и региональных параметров (то есть, если параметр <paramref name="comparisonType" /> не имеет значение <see cref="F:System.StringComparison.Ordinal" /> или <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) параметр <paramref name="value" /> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом. Если <paramref name="value" /> состоит только из одного или нескольких символов можно игнорировать, <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> метод всегда возвращает <paramref name="startIndex" />, который является позицию символа, с которого начинается поиск.  
  
В следующем примере <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> метод используется для поиска следуют «m» во всех позиций мягкий перенос (U + 00AD), но месте первого символа перед последней «m» в двух строках. Только одна из строк содержит требуемую подстроку. Если пример выполняется [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемым символом, метод возвращает индекс «m» в строке при выполнении учитывающего культуру сравнения. Когда он выполняет порядковое сравнение, однако она находит подстрока только в первой строке. Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой «m», метод возвращает не индекс мягкого переноса, но вместо этого возвращает индекс «m», когда он выполняет сравнение с учетом языка и региональных параметров. Этот метод возвращает индекс мягкого переноса в первой строке только при выполнении порядкового сравнения.  
  
[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения в данном экземпляре какого-либо одного или нескольких символов, указанных в массиве символов Юникода. Метод возвращает -1, если знаки массива не найдены в этом экземпляре.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Массив знаков Юникода, содержащий один или несколько искомых знаков.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения в данном экземпляре какого-либо одного или нескольких символов, указанных в массиве символов Юникода.</summary>
        <returns>Значение индекса последнего вхождения какого-либо знака из <paramref name="anyOf" /> в данном экземпляре; -1, если ни один знак из <paramref name="anyOf" /> не был найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля.  
  
 Этот метод начинает поиск с позиции последнего знака данного экземпляра и выполняется в обратном направлении до начала пока в `anyOf` найден или проверит позицию первого символа. При поиске учитывается регистр.  
  
 Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде. Для выполнения поиска с учетом языка и региональных параметров используйте <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> метод, где скалярное значение Юникод, представляющее составной знак, например лигатура «?» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения символа компонентов в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере вычисляется индекс последнего вхождения любого символа в строке «is» внутри другой строки.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Массив знаков Юникода, содержащий один или несколько искомых знаков.</param>
        <param name="startIndex">Позиция, с которой начинается поиск. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения в данном экземпляре какого-либо одного или нескольких символов, указанных в массиве символов Юникода. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки.</summary>
        <returns>Значение индекса последнего вхождения какого-либо знака из <paramref name="anyOf" /> в данном экземпляре; -1, если ни один знак из <paramref name="anyOf" /> не был найден или текущий экземпляр равен <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля.  
  
 Этот метод начинает поиск `startIndex` данный экземпляр и переход назад к началу, пока символ в позиции знака `anyOf` найден или проверит позицию первого символа. При поиске учитывается регистр.  
  
 Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде. Для выполнения поиска с учетом языка и региональных параметров используйте <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> метод, где скалярное значение Юникод, представляющее составной знак, например лигатура «?» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения символа компонентов в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере вычисляется индекс последнего вхождения любого символа в строке «is» в подстроке другой строки.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="startIndex" /> указывает позицию вне пределов данного экземпляра.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Массив знаков Юникода, содержащий один или несколько искомых знаков.</param>
        <param name="startIndex">Позиция, с которой начинается поиск. Поиск выполняется от индекса, заданного параметром <paramref name="startIndex" />, до начала данного экземпляра.</param>
        <param name="count">Количество позиций знаков для проверки.</param>
        <summary>Возвращает позицию индекса с отсчетом от нуля последнего вхождения в данном экземпляре какого-либо одного или нескольких символов, указанных в массиве символов Юникода. Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки для заданного числа позиций символов.</summary>
        <returns>Значение индекса последнего вхождения какого-либо знака из <paramref name="anyOf" /> в данном экземпляре; -1, если ни один знак из <paramref name="anyOf" /> не был найден или текущий экземпляр равен <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индексация начинается с нуля.  
  
 Этот метод начинает поиск `startIndex` данный экземпляр и переход назад к началу, пока символ в позиции знака `anyOf` найден или `count` будет проверена. При поиске учитывается регистр.  
  
 Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде. Для выполнения поиска с учетом языка и региональных параметров используйте <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> метод, где скалярное значение Юникод, представляющее составной знак, например лигатура «?» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения символа компонентов в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере вычисляется индекс последнего знака строки «aid» в подстроке другой строки.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а <paramref name="count" /> или <paramref name="startIndex" /> является отрицательным числом.  
  
-или- 
Текущий экземпляр не равен <see cref="F:System.String.Empty" />, а разность <paramref name="startIndex" /> и <paramref name="count" /> + 1 меньше нуля.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает число знаков в текущем объекте <see cref="T:System.String" />.</summary>
        <value>Количество знаков в текущей строке.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Length%2A> Свойство возвращает количество <xref:System.Char> объектов в данном экземпляре, не число символов Юникода. Причина в том, что символ Юникода могут быть представлены в более чем одной <xref:System.Char>. Используйте <xref:System.Globalization.StringInfo?displayProperty=nameWithType> класс для работы с каждым знаком Юникода вместо каждого <xref:System.Char>.  
  
 В некоторых языках, таких как C и C++ символ null указывает на конец строки. В .NET можно внедрить нуль-символом в строке. Если строка содержит один или несколько символов null, они включаются в длину всего строки. Например в следующей строке подстроки «abc» и «def» разделены символом null. <xref:System.String.Length%2A> Свойство возвращает 7, что означает, что он включает шесть букв, а также нуль-символ.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.Length%2A> свойство.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает новую строку, двоичное представление которой находится в определенной нормализованной форме Юникода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает новую строку, текстовое значение которой совпадает с данной строкой, а двоичное представление находится в нормализованной форме C Юникода.</summary>
        <returns>Новая нормализованная строка, текстовое значение которой совпадает с данной строкой, а двоичное представление находится в нормализованной форме C Юникода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые символы Юникода, имеют несколько эквивалентных двоичных представлений, состоящий из объединения наборов и/или составные символы Юникода. Например любой из следующих кодовых точек может представлять имя символа «ắ»:  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Наличие нескольких представлений одного символа затрудняет поиск, сортировка, сопоставления и других операций.  
  
 В стандарте Юникод определяет процесс, называемый нормализация, которая возвращает одно двоичное представление, при наличии нескольких эквивалентных представлений символа. Нормализация может выполняться с использованием нескольких алгоритмов, вызывается формы нормализации, которые следуют различным правилам. Платформа .NET поддерживает четырех форм (C, D, KC и KD), которые определены в стандарте Юникода. Если две строки представлены в той же форме нормализации, их можно проверять с помощью порядковое сравнение.  
  
 Для нормализации и сравнивают две строки, сделайте следующее:  
  
1.  Получите строки для сравнения из источника входных данных, например файл или устройство ввода пользователя.  
  
2.  Вызовите <xref:System.String.Normalize> метод для строки следует нормализовать в нормализованной форме c Юникода  
  
3.  Для сравнения двух строк, вызвать метод, поддерживающий сравнение строк по порядковому номеру, такие как <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> метод и укажите в качестве параметра <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> или <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> как <xref:System.StringComparison> аргумент. Чтобы сортировать массив нормализованными строками, передайте `comparer` значение <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> или <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> в соответствующую перегрузку <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Выведите строки в сортировку на выводе на основе порядка, указанного на предыдущем шаге.  
  
 Описание поддерживаемых формы нормализации Юникода, см. в разделе <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Следующий пример нормализация строкового типа к каждому из четырех форм нормализации, строки были нормализованы по форме нормализации, указанной, а затем список кодовых точек в нормализованную строку.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий экземпляр содержит недопустимые символы Юникода.</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" /> Возвращает метод <see langword="false" /> как только он встречает первый символ, не было нормализовано в строке. Таким образом, если строка содержит символы, не было нормализовано следуют недопустимые символы Юникода, <see cref="Overload:System.String.Normalize" /> метод вызывает исключение <see cref="T:System.ArgumentException" /> несмотря на то что <see cref="Overload:System.String.IsNormalized" /> возвращает <see langword="false" />.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Форма нормализации Юникода.</param>
        <summary>Возвращает новую строку, текстовое значение которой совпадает с данной строкой, а двоичное представление находится в заданной нормализованной форме Юникода.</summary>
        <returns>Новая строка, текстовое значение которой совпадает с данной строкой, а двоичное представление находится в форме нормализации, заданной в параметре <paramref name="normalizationForm" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые символы Юникода, имеют несколько эквивалентных двоичных представлений, состоящий из объединения наборов и/или составные символы Юникода. Наличие нескольких представлений одного символа затрудняет поиск, сортировка, сопоставления и других операций.  
  
 В стандарте Юникод определяет процесс, называемый нормализация, которая возвращает одно двоичное представление, при наличии нескольких эквивалентных представлений символа. Нормализация может выполняться с использованием нескольких алгоритмов, вызывается формы нормализации, которые следуют различным правилам. Платформа .NET поддерживает четырех форм (C, D, KC и KD), которые определены в стандарте Юникода. Если две строки представлены в той же форме нормализации, их можно проверять с помощью порядковое сравнение.  
  
 Для нормализации и сравнивают две строки, сделайте следующее:  
  
1.  Получите строки для сравнения из источника входных данных, например файл или устройство ввода пользователя.  
  
2.  Вызовите <xref:System.String.Normalize%28System.Text.NormalizationForm%29> метод для нормализации строк в указанной форму.  
  
3.  Для сравнения двух строк, вызвать метод, поддерживающий сравнение строк по порядковому номеру, такие как <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> метод и укажите в качестве параметра <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> или <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> как <xref:System.StringComparison> аргумент. Чтобы сортировать массив нормализованными строками, передайте `comparer` значение <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> или <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> в соответствующую перегрузку <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Выведите строки в сортировку на выводе на основе порядка, указанного на предыдущем шаге.  
  
 Описание поддерживаемых формы нормализации Юникода, см. в разделе <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Следующий пример нормализация строкового типа к каждому из четырех форм нормализации, строки были нормализованы по форме нормализации, указанной, а затем список кодовых точек в нормализованную строку.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий экземпляр содержит недопустимые символы Юникода.</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" /> Возвращает метод <see langword="false" /> как только он встречает первый символ, не было нормализовано в строке. Таким образом, если строка содержит символы, не было нормализовано следуют недопустимые символы Юникода, <see cref="Overload:System.String.Normalize" /> метод может генерировать <see cref="T:System.ArgumentException" /> несмотря на то что <see cref="Overload:System.String.IsNormalized" /> возвращает <see langword="false" />.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Первая сравниваемая строка или значение <see langword="null" />.</param>
        <param name="b">Вторая сравниваемая строка или значение <see langword="null" />.</param>
        <summary>Определяет, равны ли значения двух указанных строк.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="a" /> совпадает со значением <paramref name="b" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Equality%2A> Метод определяет операцию от оператора равенства для <xref:System.String> класса. Он позволяет коду, как показано в разделе "Пример". Оператор, в свою очередь, вызывает статический <xref:System.String.Equals%28System.String%2CSystem.String%29> метод, который выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).  
  
> [!NOTE]
>  Компилятор Visual Basic не разрешает оператора равенства как вызов <xref:System.String.op_Equality%2A> метод. Вместо этого оператор равенства создает оболочку для вызова <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 Ниже приведен пример оператора равенства.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Первая сравниваемая строка или значение <see langword="null" />.</param>
        <param name="b">Вторая сравниваемая строка или значение <see langword="null" />.</param>
        <summary>Определяет, различаются ли значения двух указанных строк.</summary>
        <returns>Значение <see langword="true" />, если значение <paramref name="a" /> отличается от значения <paramref name="b" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Inequality%2A> Метод определяет операцию неравенства для <xref:System.String> класса.   Он позволяет коду, подобном показанному в подразделе «примеры».  
  
 <xref:System.String.op_Inequality%2A> Оператор, в свою очередь, вызывает статический <xref:System.String.Equals%28System.String%2CSystem.String%29> метод, который выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).  
  
> [!NOTE]
>  Компилятор Visual Basic не разрешить оператор неравенства, как вызов <xref:System.String.op_Inequality%2A> метод. Вместо этого оператор неравенства создает оболочку для вызова <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 Ниже приведен пример оператора неравенства.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает новую строку указанной длины, в которой начало текущей строки заполняется пробелами или указанным знаком Юникода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Количество знаков в полученной строке, равное числу исходных знаков плюс некоторое количество добавленных для заполнения знаков.</param>
        <summary>Возвращает новую строку, в которой знаки данного экземпляра выровнены по правому краю путем добавления слева символов-разделителей до указанной общей длины.</summary>
        <returns>Новая строка, эквивалентная данному экземпляру, но с выравниванием по правому краю и с добавленными слева пробелами, необходимыми для достижения длины <paramref name="totalWidth" />. Однако если значение параметра <paramref name="totalWidth" /> меньше длины данного экземпляра, метод возвращает ссылку на имеющийся экземпляр. Если значение параметра <paramref name="totalWidth" /> равно длине данного экземпляра, метод возвращает новую строку, идентичную данному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пробел в Юникоде определен как шестнадцатеричное 0x0020.  
  
 <xref:System.String.PadLeft%28System.Int32%29> Метод дополняет начало возвращаемой строки. Это означает, что при использовании с языками справа налево, он дополняет правой части строки.  
  
> [!NOTE]
>  Если <xref:System.String.PadLeft%2A> метод дополняет текущий экземпляр с символы-разделители, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, дополняется начальные пробелы, чтобы общая длина строки составляет `totalWidth` символов.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.PadLeft%2A> метод.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="totalWidth" /> меньше нуля.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Количество знаков в полученной строке, равное числу исходных знаков плюс некоторое количество добавленных для заполнения знаков.</param>
        <param name="paddingChar">Добавляемый в качестве заполнителя знак Юникода.</param>
        <summary>Возвращает новую строку, в которой знаки данного экземпляра выровнены по правому краю путем добавления слева пробелов или указанного знака Юникода до указанной общей длины.</summary>
        <returns>Новая строка, эквивалентная данному экземпляру, но с выравниванием по правому краю и с добавленными слева знаками <paramref name="paddingChar" />, необходимыми для достижения длины <paramref name="totalWidth" />. Однако если значение параметра <paramref name="totalWidth" /> меньше длины данного экземпляра, метод возвращает ссылку на имеющийся экземпляр. Если значение параметра <paramref name="totalWidth" /> равно длине данного экземпляра, метод возвращает новую строку, идентичную данному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> Метод дополняет начало возвращаемой строки. Это означает, что при использовании с языками справа налево, он дополняет правой части строки.  
  
> [!NOTE]
>  Если <xref:System.String.PadLeft%2A> метод дополняет текущий экземпляр с символы-разделители, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, дополняется стоящими в начале `paddingChar` символами, чтобы общая длина строки составляет `totalWidth` символов.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.PadLeft%2A> метод.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="totalWidth" /> меньше нуля.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает новую строку указанной длины, в которой конец текущей строки заполняется символами-разделителями или указанным знаком Юникода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Количество знаков в полученной строке, равное числу исходных знаков плюс некоторое количество добавленных для заполнения знаков.</param>
        <summary>Возвращает новую строку, в которой знаки данной строки выровнены по левому краю путем добавления справа пробелов до указанной общей длины.</summary>
        <returns>Новая строка, эквивалентная данному экземпляру, но с выравниванием по левому краю и с добавленными справа пробелами, необходимыми для достижения длины <paramref name="totalWidth" />. Однако если значение параметра <paramref name="totalWidth" /> меньше длины данного экземпляра, метод возвращает ссылку на имеющийся экземпляр. Если значение параметра <paramref name="totalWidth" /> равно длине данного экземпляра, метод возвращает новую строку, идентичную данному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пробел в Юникоде определен как шестнадцатеричное 0x0020.  
  
 <xref:System.String.PadRight%28System.Int32%29> Метод дополняет конец возвращаемой строки. Это означает, что при использовании с языками справа налево, строка дополняется пробелами левой строки.  
  
> [!NOTE]
>  Если <xref:System.String.PadRight%2A> метод дополняет текущий экземпляр с символы-разделители, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, дополняется конечными пробелами, таким образом, общая длина `totalWidth` символов.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.PadRight%2A> метод.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="totalWidth" /> меньше нуля.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Количество знаков в полученной строке, равное числу исходных знаков плюс некоторое количество добавленных для заполнения знаков.</param>
        <param name="paddingChar">Добавляемый в качестве заполнителя знак Юникода.</param>
        <summary>Возвращает новую строку, в которой знаки данной строки выровнены по левому краю путем добавления справа пробелов или указанного знака Юникода до указанной общей длины.</summary>
        <returns>Новая строка, эквивалентная данному экземпляру, но с выравниванием по левому краю и с добавленными справа знаками <paramref name="paddingChar" />, необходимыми для достижения длины <paramref name="totalWidth" />. Однако если значение параметра <paramref name="totalWidth" /> меньше длины данного экземпляра, метод возвращает ссылку на имеющийся экземпляр. Если значение параметра <paramref name="totalWidth" /> равно длине данного экземпляра, метод возвращает новую строку, идентичную данному экземпляру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> Метод дополняет конец возвращаемой строки. Это означает, что при использовании с языками справа налево, строка дополняется пробелами левой строки.  
  
> [!NOTE]
>  Если <xref:System.String.PadRight%2A> метод дополняет текущий экземпляр с символы-разделители, этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка, дополняется конечными `paddingChar` символами, чтобы общая длина строки составляет `totalWidth` символов.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.PadRight%2A> метод.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="totalWidth" /> меньше нуля.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает новую строку, в которой удалено указанное число знаков текущей строки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">Отсчитываемая от нуля позиция, с которой начинается удаление знаков.</param>
        <summary>Возвращает новую строку, в которой были удалены все символы, начиная с указанной позиции и до конца в текущем экземпляре.</summary>
        <returns>Новая строка, эквивалентная данной строке за минусом удаленных знаков.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], строки отсчитываются от нуля. Значение `startIndex` параметра варьируются от 0 до 1 или меньше длины экземпляра строки.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка в какие все символы с позиции `startIndex` в конец исходной строки будут удалены.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.Remove%2A> метод. Так далее до конца удаляет весь текст, начиная с заданного индекса и до конца строки. В последнем случае удаляются трех символов, начиная с указанного индекса.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> указывает положение, которое находится за пределами этой строки.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Отсчитываемая от нуля позиция, с которой начинается удаление знаков.</param>
        <param name="count">Число символов для удаления.</param>
        <summary>Возвращает новую строку, в которой было удалено указанное число символов в указанной позиции.</summary>
        <returns>Новая строка, эквивалентная данному экземпляру за минусом удаленных знаков.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], строки отсчитываются от нуля. Значение `startIndex` параметра варьируются от 0 до 1 или меньше длины экземпляра строки.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в котором определяется количество символов `count` параметра были удалены. Символы удаляются в позиции, заданной параметром `startIndex`.  
  
   
  
## Examples  
 Ниже приведен пример, как можно удалить отчество из полного имени.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> плюс <paramref name="count" /> указывает позицию за пределами этого экземпляра.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает новую строку, в которой все вхождения заданного знака Юникода или <see cref="T:System.String" /> в текущей строке заменены другим заданным знаком Юникода или <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Заменяемый знак Юникода.</param>
        <param name="newChar">Знак Юникода для замены всех обнаруженных вхождений <paramref name="oldChar" />.</param>
        <summary>Возвращает новую строку, в которой все вхождения заданного знака Юникода в текущем экземпляре заменены другим заданным знаком Юникода.</summary>
        <returns>Строка, эквивалентная данному экземпляру, но с тем отличием, что все вхождения <paramref name="oldChar" /> заменены на <paramref name="newChar" />. Если <paramref name="oldChar" /> не обнаружен в текущем экземпляре метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск по порядковым номерам (с учетом регистра и без учета языка и региональных параметров) для поиска `oldChar`.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой все вхождения `oldChar` заменяются `newChar`.  
  
 Так как этот метод возвращает измененной строки, вы можете объединить в цепочку последовательные вызовы <xref:System.String.Replace%2A> метод для выполнения нескольких замены исходной строки. Вызовы методов выполняются слева направо. Ниже приведен пример.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 В следующем примере создается список значений с разделителями-запятыми, путем замены пробелов между рядами чисел запятыми.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Строка, которую требуется заменить.</param>
        <param name="newValue">Строка для замены всех вхождений <paramref name="oldValue" />.</param>
        <summary>Возвращает новую строку, в которой все вхождения заданной строки в текущем экземпляре заменены другой заданной строкой.</summary>
        <returns>Строка, эквивалентная текущей строке, но с тем отличием, что все вхождения <paramref name="oldValue" /> заменены на <paramref name="newValue" />. Если <paramref name="oldValue" /> не обнаружен в текущем экземпляре метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `newValue` — `null`, все вхождения `oldValue` удаляются.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой все вхождения `oldValue` заменяются `newValue`.  
  
 Этот метод выполняет поиск по порядковым номерам (с учетом регистра и без учета языка и региональных параметров) для поиска `oldValue`.  
  
 Так как этот метод возвращает измененной строки, вы можете объединить в цепочку последовательные вызовы <xref:System.String.Replace%2A> метод для выполнения нескольких замены исходной строки. Вызовы методов выполняются слева направо. Ниже приведен пример.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 В следующем примере показано, как можно использовать <xref:System.String.Replace%2A> способ исправления орфографических ошибок.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> является пустой строкой ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает строковый массив, содержащий подстроки данного экземпляра, разделенные элементами заданной строки или массива знаков Юникода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> используется для разбиения на подстроки в строку с разделителями. Массив символов можно использовать для указания ноль, один или несколько символы-разделители ( <xref:System.String.Split%28System.Char%5B%5D%29> метод), или массив символов можно использовать для указания ноль, один или несколько разделителей строк. Перегруженные версии <xref:System.String.Split%2A> метод позволяют ограничить количество подстрок, возвращаемый методом ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> метод), чтобы определить, включаются ли пустые строки в возвращаемых подстрок ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> и <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> методов, или для другого ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> и <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> методов).  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>Альтернативы String.Split

 <xref:System.String.Split%2A> Метод не всегда является лучшим способом разбиение подстроки в строку с разделителями. Если вы не хотите извлечь все подстрок строку с разделителями или если требуется синтаксический анализ строки на основе шаблона, а не набор символов-разделителей, рассмотрим следующие варианты.  
  
### <a name="regular-expressions"></a>Регулярные выражения  
 Если строки соответствуют фиксированный шаблон, можно использовать регулярное выражение для извлечения и обработки их элементов. Например, если строки имеют вид "*номер* *операнд* *номер*" можно использовать [регулярное выражение](~/docs/standard/base-types/regular-expressions.md) для извлечения и обработки элементы строки. Ниже приведен пример:  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Шаблон регулярного выражения `(\d+)\s+([-+*/])\s+(\d+)` определяется следующим образом:  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(\d+)`|Совпадение с одной или несколькими десятичными цифрами. Это первая группа записи.|  
|`\s+`|Совпадение один или несколько символов пробела.|  
|`([-+*/])`|Соответствует знаку арифметический оператор (+, -, *, или /). Это вторая группа записи.|  
|`\s+`|Совпадение один или несколько символов пробела.|  
|`(\d+)`|Совпадение с одной или несколькими десятичными цифрами. Это третья группа записи.|  
  
 Можно также использовать регулярное выражение извлечения подстрок из строки на основе шаблона, а не фиксированный набор символов. Это распространенный сценарий, когда происходит одно из этих условий:  
  
-   Один или несколько символов-разделителей не всегда использовать в качестве разделителя в <xref:System.String> экземпляра.  
  
-   Порядок и число символов-разделителей, переменной или неизвестен.  
  
 Например <xref:System.String.Split%2A> метод не может использоваться для разбиения следующие строки, так как число `\n` (в C#) или `vbCrLf` (в Visual Basic), символы — переменная, и они не всегда выступают в качестве разделителей.  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 Регулярное выражение можно разделить эту строку легко, как показано в следующем примере.  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Шаблон регулярного выражения `\[([^\[\]]+)\]` определяется следующим образом:  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\[`|Соответствует открывающую квадратную скобку.|  
|`([^\[\]]+)`|Соответствует любому символу, не является открывающей или закрывающей квадратной скобки один или несколько раз. Это первая группа записи.|  
|`\]`|Соответствует закрывающая скобка.|  
  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Метод почти идентичен методу <xref:System.String.Split%2A?displayProperty=nameWithType>, за исключением того, что он разбивает строку, шаблон регулярного выражения вместо основных кодировки. Например, в следующем примере используется <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> метод для разбиения строки, содержащий подстроки, разделяемых строками различных комбинаций дефисы и другие символы.  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Шаблон регулярного выражения `\s-\s?[+*]?\s?-\s` определяется следующим образом:  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\s-`|Соответствует символу пробела, следуют дефис.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`[+*]?`|Совпадение с нулем или одним вхождением либо + или * символ.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`-\s`|Выделение дефиса, за которым следует символ пробела.|  
  
### <a name="search-methods-and-the-substring-method"></a>Методы поиска и метода Substring  
 Если вы не требуются все возможности подстроки в строке, вы можете работать с одним из используемые методы сравнения строк, которые возвращает индекс, с которого начинается соответствие. Затем можно вызвать <xref:System.String.Substring%2A> метод для извлечения подстроки, которую вы хотите. Ниже перечислены используемые методы сравнения строк.  
  
-   <xref:System.String.IndexOf%2A>, который возвращает отсчитываемый от нуля индекс первого вхождения символа или строки в экземпляре строки.  
  
-   <xref:System.String.IndexOfAny%2A>, который возвращает отсчитываемый от нуля индекс в текущем экземпляре строки первого вхождения любого символа в массив символов.  
  
-   <xref:System.String.LastIndexOf%2A>, который возвращает отсчитываемый от нуля индекс последнего вхождения символа или строки в экземпляре строки.  
  
-   <xref:System.String.LastIndexOfAny%2A>, который возвращает отсчитываемый от нуля индекс в текущем экземпляре строки от последнее вхождение любого символа, в массив символов.  
  
 В следующем примере используется <xref:System.String.IndexOf%2A> способ поиска периоды в строке. Затем он использует <xref:System.String.Substring%2A> метод для возврата полного предложения.  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Массив символов, разделяющий подстроки в данной строке, пустой массив, не содержащий разделителей, или <see langword="null" />.</param>
        <summary>Разбивает строку на подстроки в зависимости от символов в массиве.</summary>
        <returns>Массив, элементы которого содержат подстроки из этого экземпляра, разделенные символами из <paramref name="separator" />. Дополнительные сведения см. в разделе "Примечания".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если строка отделена с набором известных символов, можно использовать <xref:System.String.Split%28System.Char%5B%5D%29> метод, чтобы отделить его на подстроки.   
  
### <a name="return-value-details"></a>Сведения о возвращаемом значении  
 Символы-разделители не включаются в возвращаемый массив элементов. Например, если массив разделителя включает символ «-» и «aa bb cc» имеет значение текущего экземпляра строки, метод возвращает массив, содержащий три элемента: «aa», «bb» и «cc».  
  
 Если этот экземпляр не содержит символы, входящие в `separator`, возвращаемый массив состоит из одного элемента, содержащего данный экземпляр.  
  
 Каждый элемент `separator` определяет отдельный знак-разделитель. Если разделитель находится в начале или в конце этого экземпляра двумя разделителями являются смежными, соответствующий элемент в возвращенном массиве содержит <xref:System.String.Empty>. Далее приводятся некоторые примеры.  
  
|Строковое значение|Separator|Возвращаемый массив|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|New Char [] {',', ' '} (C#)<br /><br /> Char() = {«,» c ««c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|New Char [] {"."} (C#)<br /><br /> Char() = {».» c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|«Banana»|New Char [] {"."} (C#)<br /><br /> Char() = {».» c} (Visual Basic)|{«Banana»}|  
|«Darb\nSmarba» (C#)<br /><br /> «Darb» & vbLf & «Smarba» (Visual Basic)|New Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|{«Darb», «Smarba»}|  
|«Darb\nSmarba» (C#)<br /><br /> «Darb» & vbLf & «Smarba» (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{«Darb», «Smarba»}|  
  
### <a name="the-separator-array"></a>Массив разделителя  
 Каждый элемент разделителя, который определяет отдельный разделитель, который состоит из одного символа. Если `separator` аргумент является `null` или не содержит знаков, метод рассматривает пробелы как разделители. Символы-разделители определяются Unicode standard. они возвращают `true` если они передаются в <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> метод.  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>Разрешение перегрузки String.Split(Char[]) и компилятора  
 Несмотря на то что один параметр для перегруженного <xref:System.String.Split%2A?displayProperty=nameWithType> является массив символов, его можно вызвать с помощью одного символа, как показано в следующем примере.  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Так как `separator` параметр декорирован с <xref:System.ParamArrayAttribute> атрибут, компиляторы будет интерпретировать один символ как массив символов одного элемента. Это не так для других <xref:System.String.Split%2A?displayProperty=nameWithType> перегрузки, включающие `separator` параметр; необходимо явно передать эти перегрузки массив символов как `separator` аргумент.  
  
### <a name="comparison-details"></a>Сведения о сравнении  
 <xref:System.String.Split%28System.Char%5B%5D%29> Метод извлекает подстроки данной строки, разделенные один или несколько символов в `separator` массиве и возвращает эти подстроки в виде элементов в массиве.  
  
 <xref:System.String.Split%28System.Char%5B%5D%29> Метод ищет разделители, выполняя сравнения, используя правила сортировки по порядковому номеру с учетом регистра. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> перечисления.  
  
### <a name="performance-considerations"></a>Особенности производительности  
 <xref:System.String.Split%2A> Методы выделить память для возвращаемого массива объекта и <xref:System.String> объекта для каждого элемента массива. Если приложению требуется оптимальной производительности или распределением памяти является критически важным в приложении, рассмотрите возможность использования <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод. У вас также есть возможность использовать <xref:System.String.Compare%2A> метод для поиска подстроки в строку.  
  
 Чтобы разбить строку на символ-разделитель, используйте <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод необходимо найти знаков-разделителей в строке. Чтобы разделить строку в строку разделителя, используйте <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод для обнаружения первого символа строки разделителя. Затем с помощью <xref:System.String.Compare%2A> метод, чтобы определить, равны ли знаки после первого знака остальные символы строки-разделителя.  
  
 Кроме того, если же набор символов используется для разделения строк в нескольких <xref:System.String.Split%2A> вызовы методов, рекомендуется создать один массив и ссылающихся на него в каждом вызове метода. Это значительно снижает дополнительную нагрузку, каждый вызов метода.  
  
## Examples  
 Ниже приведен пример, как извлечь отдельные слова из блока текста, рассматривая пробелы и знаки пунктуации как разделители. Массив символов, передаваемый `separator` параметр <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> метод состоит из пробела и символа табуляции, а также некоторые распространенные символы пунктуации.  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] и более ранних версий, если <see cref="M:System.String.Split(System.Char[])" /> методу передается <paramref name="separator" /> то есть <see langword="null" /> или не содержит знаков, метод использует немного другой набор символов для разбиения строки чем <see cref="M:System.String.Trim(System.Char[])" /> выполняет метод, чтобы усекает строку. Начиная с .NET Framework 4, в обоих методах используется идентичный набор пробельные символы Юникода.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Массив символов, разделяющий подстроки в данной строке, пустой массив, не содержащий разделителей, или <see langword="null" />.</param>
        <param name="count">Максимальное число возвращаемых подстрок.</param>
        <summary>Разбивает строку на максимальное число подстрок в зависимости от символов в массиве. Можно также указать максимальное число возвращаемых подстрок.</summary>
        <returns>Массив, элементы которого содержат подстроки данного экземпляра, разделенные одним или более знаками из <paramref name="separator" />. Дополнительные сведения см. в разделе "Примечания".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Символы-разделители не включаются в возвращаемый массив элементов.  
  
 Если этот экземпляр не содержит символы, входящие в `separator`, возвращаемый массив состоит из одного элемента, содержащего данный экземпляр. Если `count` равно нулю, возвращается пустой массив.  
  
 Если `separator` параметр `null` или не содержит символы, пробелы считаются разделителями. Символы-разделители определяются Unicode standard и возврата `true` если они передаются в <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> метод.  
  
 Каждый элемент `separator` определяет отдельный знак-разделитель. Если разделитель находится в начале или в конце этого экземпляра двумя разделителями являются смежными, соответствующий элемент массива содержит <xref:System.String.Empty>.  
  
 При наличии более чем `count` подстроки данного экземпляра, первый `count` минус 1 подстрок возвращаются в первом `count` возвращается минус 1 элементах возвращаемого значения, а остальные символы в этом экземпляре за последние элемент возвращаемого значения.  
  
 Если `count` больше, чем число подстрок, возвращаются доступные подстрок и исключение не создается.  
  
 В следующей таблице приведены примеры.  
  
|Строковое значение|Separator|Количество|Возвращаемый массив|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|New Char [] {',', ' '} (C#)<br /><br /> Char() = {«,» c ««c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|New Char [] {"."} (C#)<br /><br /> Char() = {».» c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|«Banana»|New Char [] {"."} (C#)<br /><br /> Char() = {».» c} (Visual Basic)|2|{«Banana»}|  
|«Darb\nSmarba» (C#)<br /><br /> «Darb» & vbLf & «Smarba» (Visual Basic)|New Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|1|{«Darb\nSmarba»} (C#)<br /><br /> «Darb» & vbLf & «Smarba» (Visual Basic)|  
|«Darb\nSmarba» (C#)<br /><br /> «Darb» & vbLf & «Smarba» (Visual Basic)|новый Char [] null (C#)<br /><br /> Char() = Nothing|2|{«Darb», «Smarba»}|  
|«Darb\nSmarba» (C#)<br /><br /> «Darb» & vbLf & «Smarba» (Visual Basic)|новый Char [] null (C#)<br /><br /> Char() = Nothing|100|{«Darb», «Smarba»}|  
  
### <a name="performance-considerations"></a>Особенности производительности  
 <xref:System.String.Split%2A> Методы выделить память для возвращаемого массива объекта и <xref:System.String> объекта для каждого элемента массива. Если приложению требуется оптимальной производительности или распределением памяти является критически важным в приложении, рассмотрите возможность использования <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод и при необходимости <xref:System.String.Compare%2A> метод для поиска подстроки в строку.  
  
 Если вы разделяете строка с символа разделителя, используйте <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод необходимо найти знаков-разделителей в строке. Если вы разделяете строку в строку разделителя, используйте <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод для обнаружения первого символа строки разделителя. Затем с помощью <xref:System.String.Compare%2A> метод, чтобы определить, равны ли знаки после первого знака остальные символы строки-разделителя.  
  
 Кроме того, если же набор символов используется для разделения строк в нескольких <xref:System.String.Split%2A> вызовы методов, рекомендуется создать один массив и ссылающихся на него в каждом вызове метода. Это значительно снижает дополнительную нагрузку, каждый вызов метода.  
  
   
  
## Examples  
 В следующем примере показано, как `count` влияет на число строк, возвращаемых <xref:System.String.Split%2A>.  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> является отрицательным значением.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] и более ранних версий, если <see cref="M:System.String.Split(System.Char[])" /> методу передается <paramref name="separator" /> то есть <see langword="null" /> или не содержит знаков, метод использует немного другой набор символов для разбиения строки чем <see cref="M:System.String.Trim(System.Char[])" /> выполняет метод, чтобы усекает строку. Начиная с .NET Framework 4, в обоих методах используется идентичный набор пробельные символы Юникода.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Массив символов, разделяющий подстроки в данной строке, пустой массив, не содержащий разделителей, или <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, чтобы исключить пустые элементы из возвращаемого массива; или <see cref="F:System.StringSplitOptions.None" /> для включения пустых элементов в возвращаемый массив.</param>
        <summary>Разбивает строку на подстроки в зависимости от символов в массиве. Можно указать, включают ли подстроки пустые элементы массива.</summary>
        <returns>Массив, элементы которого содержат подстроки данной строки, разделенные одним или более знаками из <paramref name="separator" />. Дополнительные сведения см. в разделе "Примечания".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Сведения о возвращаемом значении  
 Символы-разделители (символы в `separator` массива) не включаются в возвращаемый массив элементов. Например если `separator` массив содержит символ «-» и «aa bb cc» имеет значение текущего экземпляра строки, метод возвращает массив, содержащий три элемента: «aa», «bb» и «cc».  
  
 Если этот экземпляр не содержит символы, входящие в `separator`, возвращаемый массив состоит из одного элемента, содержащего данный экземпляр.  
  
 Если `options` параметр <xref:System.StringSplitOptions.RemoveEmptyEntries> и длину этого экземпляра равно нулю, метод возвращает пустой массив.  
  
 Каждый элемент `separator` определяет отдельный разделитель, который состоит из одного символа. Если `options` аргумент <xref:System.StringSplitOptions.None>и двумя разделителями являются смежными или разделитель находится в начале или в конце данного экземпляра, соответствующий элемент массива содержит <xref:System.String.Empty?displayProperty=nameWithType>. Например если `separator` входят два элемента, «-» и "\_«, значение экземпляра строки «-\_aa -\_«и значение `options` аргумент <xref:System.StringSplitOptions.None>, метод возвращает массив строк, содержащий следующие пять элементов:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, который представляет пустую строку, которая предшествует «-» знак с индексом 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, который представляет пустую строку между «-» знак с индексом 0 и символа «_» с индексом 1.  
  
3.  «aa»,  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, который представляет пустую строку, которая соответствует по индексу 4 символа «_».  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, который представляет пустую строку, которая следует за «-» знак с индексом 5.  
  
### <a name="the-separator-array"></a>Массив разделителя  
 Если `separator` параметр `null` или не содержит символы, пробелы считаются разделителями. Символы-разделители определяются Unicode standard и возврата `true` если они передаются в <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> метод.  
  
 Если `separator` параметр в вызове этой перегрузки метода является `null`, разрешение перегрузки компилятора оканчивается неудачей. Чтобы однозначно идентифицировать вызываемому методу, код должен указать тип `null`. В следующем примере показано несколько способов однозначно идентифицирует эту перегрузку.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>Сведения о сравнении  
 <xref:System.String.Split%2A> Метод извлекает подстроки данной строки, разделенные один или несколько символов в `separator` параметра и возвращает эти подстроки в виде элементов в массиве.  
  
 <xref:System.String.Split%2A> Метод ищет разделители, выполняя сравнения, используя правила сортировки по порядковому номеру с учетом регистра. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> перечисления.  
  
### <a name="performance-considerations"></a>Особенности производительности  
 <xref:System.String.Split%2A> Методы выделить память для возвращаемого массива объекта и <xref:System.String> объекта для каждого элемента массива. Если приложению требуется оптимальной производительности или распределением памяти является критически важным в приложении, рассмотрите возможность использования <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод и при необходимости <xref:System.String.Compare%2A> метод для поиска подстроки в строку.  
  
 Если вы разделяете строка с символа разделителя, используйте <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод необходимо найти знаков-разделителей в строке. Если вы разделяете строку в строку разделителя, используйте <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод для обнаружения первого символа строки разделителя. Затем с помощью <xref:System.String.Compare%2A> метод, чтобы определить, равны ли знаки после первого знака остальные символы строки-разделителя.  
  
 Кроме того, если же набор символов используется для разделения строк в нескольких <xref:System.String.Split%2A> вызовы методов, рекомендуется создать один массив и ссылающихся на него в каждом вызове метода. Это значительно снижает дополнительную нагрузку, каждый вызов метода.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.StringSplitOptions> перечисления для включения или исключения подстрок, создаваемые <xref:System.String.Split%2A> метод.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> не является одним из значений <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] и более ранних версий, если <see cref="M:System.String.Split(System.Char[])" /> методу передается <paramref name="separator" /> то есть <see langword="null" /> или не содержит знаков, метод использует немного другой набор символов для разбиения строки чем <see cref="M:System.String.Trim(System.Char[])" /> выполняет метод, чтобы усекает строку. Начиная с .NET Framework 4, в обоих методах используется идентичный набор пробельные символы Юникода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Массив строк, разделяющих подстроки в данной строке, пустой массив, не содержащий разделителей, или <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, чтобы исключить пустые элементы из возвращаемого массива; или <see cref="F:System.StringSplitOptions.None" /> для включения пустых элементов в возвращаемый массив.</param>
        <summary>Разбивает строку на подстроки в зависимости от строк в массиве. Можно указать, включают ли подстроки пустые элементы массива.</summary>
        <returns>Массив, элементы которого содержат подстроки данной строки, разделенные одной или более строками из <paramref name="separator" />. Дополнительные сведения см. в разделе "Примечания".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если строка отделена с набором известных строк, можно использовать <xref:System.String.Split%2A> метод, чтобы отделить его на подстроки.  
  
### <a name="return-value-details"></a>Сведения о возвращаемом значении  
 Строки-разделители не включаются в возвращаемый массив элементов. Например если `separator` массив содержит строку «--» и «aa — копия bb» имеет значение текущего экземпляра строки, метод возвращает массив, содержащий три элемента: «aa», «bb» и «cc».  
  
 Если этот экземпляр не содержит любой из строк в `separator`, возвращаемый массив состоит из одного элемента, содержащего данный экземпляр.  
  
 Если `options` параметр <xref:System.StringSplitOptions.RemoveEmptyEntries> и длину этого экземпляра равно нулю, метод возвращает пустой массив.  
  
 Каждый элемент `separator` определяет отдельный разделитель, который состоит из одного или нескольких символов. Если `options` аргумент <xref:System.StringSplitOptions.None>и двумя разделителями являются смежными или разделитель находится в начале или в конце данного экземпляра, соответствующий элемент массива содержит <xref:System.String.Empty?displayProperty=nameWithType>. Например если `separator` входят два элемента, «-» и "\_«, значение экземпляра строки «-\_aa -\_«и значение `options` аргумент <xref:System.StringSplitOptions.None>, метод возвращает массив строки с следующие пять элементов:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, который представляет пустую строку, которая предшествует «-» подстроку по индексу 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, который представляет пустую строку между «-» substring с индексом 0 и подстрока «_» с индексом 1.  
  
3.  «aa»,  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, который представляет пустую строку, которая следует за подстрокой «_» с индекса 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, который представляет пустую строку, которая следует за «-» подстроку по индексу 5.  
  
### <a name="the-separator-array"></a>Массив разделителя  
 Если какие-либо элементы в `separator` состоит из нескольких символов всю подстроку считается разделитель. Например, если один из элементов в `separator` «10», для разбиения строки «This10is10a10string.» Возвращает массив следующих четырех элементов: {«This», «is», «», «string». }.  
  
 Если `separator` параметр `null` или не содержит символы, пробелы считаются разделителями. Символы-разделители определяются Unicode standard и возврата `true` если они передаются в <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> метод.  
  
 Если `separator` параметр в вызове этой перегрузки метода является `null`, разрешение перегрузки компилятора оканчивается неудачей. Чтобы однозначно идентифицировать вызываемому методу, код должен указать тип `null`. В следующем примере показано несколько способов однозначно идентифицирует эту перегрузку.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>Сведения о сравнении  
 <xref:System.String.Split%2A> Метод извлекает подстроки данной строки, разделенные один или несколько строк в `separator` параметра и возвращает эти подстроки в виде элементов в массиве.  
  
 <xref:System.String.Split%2A> Метод ищет разделители, выполняя сравнения, используя правила сортировки по порядковому номеру с учетом регистра. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> перечисления.  
  
 <xref:System.String.Split%2A> Метод игнорирует любой элемент `separator` , значение которого равно `null` или является пустой строкой (»»).  
  
 Чтобы избежать неоднозначных результаты при строки в `separator` имеют общие, символы <xref:System.String.Split%2A> операции переходит от начала к концу значения экземпляра и находит первый элемент в `separator` равный разделитель в экземпляр. Порядок обнаружения подстрок в экземпляре имеет приоритет над порядком элементов в `separator`.  
  
 Например рассмотрим экземпляр, значение которого является «abcdef». Если первый элемент в `separator` «ef», а второй элемент — «bcde», и результат операции разделения, будет иметь строковый массив, содержащий два элемента, «a» и «f». Это обусловлено подстроки в экземпляре, «bcde», обнаружении и соответствующий элемент в `separator` прежде, чем подстрока «f» встречается.  
  
 Тем не менее если первый элемент `separator` «bcd», а второй элемент — «bc», и результат операции разделения, будет иметь строковый массив, содержащий два элемента, «a» и «ef». Это обусловлено «bcd» является первым разделителем в `separator` , соответствует разделителю в экземпляре. Если порядок разделители была отменена, так что первый элемент «bc», а вторым — «bcd», результат будет иметь строковый массив, содержащий два элемента, «a» и «def».  
  
### <a name="performance-considerations"></a>Особенности производительности  
 <xref:System.String.Split%2A> Методы выделить память для возвращаемого массива объекта и <xref:System.String> объекта для каждого элемента массива. Если приложению требуется оптимальной производительности или распределением памяти является критически важным в приложении, рассмотрите возможность использования <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод и при необходимости <xref:System.String.Compare%2A> метод для поиска подстроки в строку.  
  
 Если вы разделяете строка с символа разделителя, используйте <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод необходимо найти знаков-разделителей в строке. Если вы разделяете строку в строку разделителя, используйте <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод для обнаружения первого символа строки разделителя. Затем с помощью <xref:System.String.Compare%2A> метод, чтобы определить, равны ли знаки после первого знака остальные символы строки-разделителя.  
  
 Кроме того, если же набор символов используется для разделения строк в нескольких <xref:System.String.Split%2A> вызовы методов, рекомендуется создать один массив и ссылающихся на него в каждом вызове метода. Это значительно снижает дополнительную нагрузку, каждый вызов метода.  
  
   
  
## Examples  
 В следующем примере демонстрируется разница в массивы, возвращаемые вызовом строки <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> метод с его `options` параметра равным <xref:System.StringSplitOptions.None?displayProperty=nameWithType> и <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 В следующем примере определяется массив разделители, включающих знаки пунктуации и пробелы. Передача этого массива, а также значение <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> для <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> метод возвращает массив, состоящий из отдельные слова из строки.  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Обратите внимание, что метод вызывается с `options` аргумент значение <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>. Это предотвращает включая возвращаемый массив <xref:System.String.Empty?displayProperty=nameWithType> значения, представляющие пустые подстроки соответствия между пунктуации и пробелы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> не является одним из значений <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] и более ранних версий, если <see cref="M:System.String.Split(System.Char[])" /> методу передается <paramref name="separator" /> то есть <see langword="null" /> или не содержит знаков, метод использует немного другой набор символов для разбиения строки чем <see cref="M:System.String.Trim(System.Char[])" /> выполняет метод, чтобы усекает строку. Начиная с .NET Framework 4, в обоих методах используется идентичный набор пробельные символы Юникода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Массив символов, разделяющий подстроки в данной строке, пустой массив, не содержащий разделителей, или <see langword="null" />.</param>
        <param name="count">Максимальное число возвращаемых подстрок.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, чтобы исключить пустые элементы из возвращаемого массива; или <see cref="F:System.StringSplitOptions.None" /> для включения пустых элементов в возвращаемый массив.</param>
        <summary>Разбивает строку на максимальное число подстрок в зависимости от символов в массиве.</summary>
        <returns>Массив, элементы которого содержат подстроки данной строки, разделенные одним или более знаками из <paramref name="separator" />. Дополнительные сведения см. в разделе "Примечания".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Символы-разделители не включаются в возвращаемый массив элементов.  
  
 Если этот экземпляр не содержит символы, входящие в `separator`, или `count` параметр имеет значение 1, возвращаемый массив состоит из одного элемента, содержащего данный экземпляр. Если `separator` параметр `null` или не содержит символы, пробелы считаются разделителями. Символы-разделители определяются Unicode standard и возврата `true` если они передаются в <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> метод. Тем не менее если `separator` параметр в вызове этой перегрузки метода является `null`, разрешение перегрузки компилятора оканчивается неудачей. Чтобы однозначно идентифицировать вызываемому методу, код необходимо указать тип значение null. В следующем примере показано несколько способов однозначно идентифицирует эту перегрузку.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Если `count` равно нулю, или `options` параметр <xref:System.StringSplitOptions.RemoveEmptyEntries> и длину этого экземпляра равно нулю, возвращается пустой массив.  
  
 Каждый элемент `separator` определяет отдельный знак-разделитель. Если `options` параметр <xref:System.StringSplitOptions.None>и двумя разделителями являются смежными или разделитель находится в начале или в конце данного экземпляра, соответствующий элемент массива содержит <xref:System.String.Empty>.  
  
 При наличии более чем `count` подстроки данного экземпляра, первый `count` минус 1 подстрок возвращаются в первом `count` возвращается минус 1 элементах возвращаемого значения, а остальные символы в этом экземпляре за последние элемент возвращаемого значения.  
  
 Если `count` больше, чем число подстрок, возвращаются доступные подстрок и исключение не создается.  
  
### <a name="performance-considerations"></a>Особенности производительности  
 <xref:System.String.Split%2A> Методы выделить память для возвращаемого массива объекта и <xref:System.String> объекта для каждого элемента массива. Если приложению требуется оптимальной производительности или распределением памяти является критически важным в приложении, рассмотрите возможность использования <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод и при необходимости <xref:System.String.Compare%2A> метод для поиска подстроки в строку.  
  
 Если вы разделяете строка с символа разделителя, используйте <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод необходимо найти знаков-разделителей в строке. Если вы разделяете строку в строку разделителя, используйте <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод для обнаружения первого символа строки разделителя. Затем с помощью <xref:System.String.Compare%2A> метод, чтобы определить, равны ли знаки после первого знака остальные символы строки-разделителя.  
  
 Кроме того, если же набор символов используется для разделения строк в нескольких <xref:System.String.Split%2A> вызовы методов, рекомендуется создать один массив и ссылающихся на него в каждом вызове метода. Это значительно снижает дополнительную нагрузку, каждый вызов метода.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.StringSplitOptions> перечисления для включения или исключения подстрок, создаваемые <xref:System.String.Split%2A> метод.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> не является одним из значений <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] и более ранних версий, если <see cref="M:System.String.Split(System.Char[])" /> методу передается <paramref name="separator" /> то есть <see langword="null" /> или не содержит знаков, метод использует немного другой набор символов для разбиения строки чем <see cref="M:System.String.Trim(System.Char[])" /> выполняет метод, чтобы усекает строку. Начиная с .NET Framework 4, в обоих методах используется идентичный набор пробельные символы Юникода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Массив строк, разделяющих подстроки в данной строке, пустой массив, не содержащий разделителей, или <see langword="null" />.</param>
        <param name="count">Максимальное число возвращаемых подстрок.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, чтобы исключить пустые элементы из возвращаемого массива; или <see cref="F:System.StringSplitOptions.None" /> для включения пустых элементов в возвращаемый массив.</param>
        <summary>Разбивает строку на максимальное число подстрок в зависимости от строк в массиве. Можно указать, включают ли подстроки пустые элементы массива.</summary>
        <returns>Массив, элементы которого содержат подстроки данной строки, разделенные одной или более строками из <paramref name="separator" />. Дополнительные сведения см. в разделе "Примечания".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Сведения о возвращаемом значении  
 Строки-разделители не включаются в возвращаемый массив элементов.  
  
 Если этот экземпляр не содержит любой из строк в `separator`, или `count` параметр имеет значение 1, возвращаемый массив состоит из одного элемента, содержащего данный экземпляр. Если `separator` параметр `null` или не содержит символы, пробелы считаются разделителями. Символы-разделители определяются Unicode standard и возврата `true` если они передаются в <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> метод. Тем не менее если `separator` параметр в вызове этой перегрузки метода является `null`, разрешение перегрузки компилятора оканчивается неудачей. Чтобы однозначно идентифицировать вызываемому методу, код должен указать тип `null`. В следующем примере показано несколько способов однозначно идентифицирует эту перегрузку.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Если `count` равно нулю, или `options` параметр <xref:System.StringSplitOptions.RemoveEmptyEntries> и длину этого экземпляра равно нулю, возвращается пустой массив.  
  
 Каждый элемент `separator` определяет отдельный разделитель, который состоит из одного или нескольких символов. Если `options` параметр <xref:System.StringSplitOptions.None>и двумя разделителями являются смежными или разделитель находится в начале или в конце данного экземпляра, соответствующий элемент массива содержит <xref:System.String.Empty>.  
  
 При наличии более чем `count` подстроки данного экземпляра, первый `count` минус 1 подстрок возвращаются в первом `count` возвращается минус 1 элементах возвращаемого значения, а остальные символы в этом экземпляре за последние элемент возвращаемого значения.  
  
 Если `count` больше, чем число подстрок, возвращаются доступные подстрок и исключение не создается.  
  
### <a name="the-separator-array"></a>Массив разделителя  
 Если какие-либо элементы в `separator` состоит из нескольких символов всю подстроку считается разделитель. Например, если один из элементов в `separator` «10», для разбиения строки «This10is10a10string.» Возвращает исходный массив четырех элементов: {«This», «is», «», «string». }.  
  
### <a name="comparison-details"></a>Сведения о сравнении  
 <xref:System.String.Split%2A> Метод извлекает подстроки данной строки, разделенные один или несколько строк в `separator` параметра и возвращает эти подстроки в виде элементов в массиве.  
  
 <xref:System.String.Split%2A> Метод ищет разделители, выполняя сравнения, используя правила сортировки по порядковому номеру с учетом регистра. Дополнительные сведения о word, строка и порядковым номерам, см. в разделе <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> перечисления.  
  
 <xref:System.String.Split%2A> Метод игнорирует любой элемент `separator` , значение которого равно `null` или является пустой строкой (»»).  
  
 Чтобы избежать неоднозначных результаты при строки в `separator` имеют общие, символы <xref:System.String.Split%2A> метод переходит от начала к концу значения экземпляра и находит первый элемент в `separator` равный разделитель в экземпляр. Порядок обнаружения подстрок в экземпляре имеет приоритет над порядком элементов в `separator`.  
  
 Например рассмотрим экземпляр, значение которого является «abcdef». Если первый элемент в `separator` «ef», а второй элемент — «bcde», и результат операции разделения будет иметь «a» и «f». Это обусловлено подстроки в экземпляре, «bcde», обнаружении и соответствующий элемент в `separator` прежде, чем подстрока «f» встречается.  
  
 Тем не менее если первый элемент `separator` «bcd», а второй элемент — «bc», и результат операции разделения будет иметь «a» и «ef». Это обусловлено «bcd» является первым разделителем в `separator` , соответствует разделителю в экземпляре. Если порядок разделители была отменена, так что первый элемент «bc», а вторым — «bcd», результат будет иметь «a» и «def».  
  
### <a name="performance-considerations"></a>Особенности производительности  
 <xref:System.String.Split%2A> Методы выделить память для возвращаемого массива объекта и <xref:System.String> объекта для каждого элемента массива. Если приложению требуется оптимальной производительности или распределением памяти является критически важным в приложении, рассмотрите возможность использования <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод и при необходимости <xref:System.String.Compare%2A> метод для поиска подстроки в строку.  
  
 Если вы разделяете строка с символа разделителя, используйте <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод необходимо найти знаков-разделителей в строке. Если вы разделяете строку в строку разделителя, используйте <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A> метод для обнаружения первого символа строки разделителя. Затем с помощью <xref:System.String.Compare%2A> метод, чтобы определить, равны ли знаки после первого знака остальные символы строки-разделителя.  
  
 Кроме того, если же набор символов используется для разделения строк в нескольких <xref:System.String.Split%2A> вызовы методов, рекомендуется создать один массив и ссылающихся на него в каждом вызове метода. Это значительно снижает дополнительную нагрузку, каждый вызов метода.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.StringSplitOptions> перечисления для включения или исключения подстрок, создаваемые <xref:System.String.Split%2A> метод.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> не является одним из значений <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] и более ранних версий, если <see cref="M:System.String.Split(System.Char[])" /> методу передается <paramref name="separator" /> то есть <see langword="null" /> или не содержит знаков, метод использует немного другой набор символов для разбиения строки чем <see cref="M:System.String.Trim(System.Char[])" /> выполняет метод, чтобы усекает строку. Начиная с .NET Framework 4, в обоих методах используется идентичный набор пробельные символы Юникода.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, совпадает ли начало данного экземпляра строки с указанной строкой.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка, подлежащая сравнению.</param>
        <summary>Определяет, совпадает ли начало данного экземпляра строки с указанной строкой.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="value" /> соответствует началу данной строки; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод сравнивает `value` подстрокой, расположенной в начало данного экземпляра, который имеет такую же длину, как `value`и возвращает значение, указывающее, равны ли они. Равными, `value` должна быть пустой строкой (<xref:System.String.Empty?displayProperty=nameWithType>), должен быть ссылкой на тот же экземпляр или должны соответствовать начало данного экземпляра.  
  
 Этот метод выполняет сравнение по словам (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере определяется `StripStartTags` метод, который использует <xref:System.String.StartsWith%28System.String%29> способ удаления HTML открывающие теги в начале строки. Обратите внимание, что `StripStartTags` метод вызывается рекурсивно для убедитесь, что удалены несколько открывающие теги HTML в начале строки. Пример не удаляет HTML-теги, внедренных в строку.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Как описано в [советы и рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методы сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывать методы, которые нужны параметры, чтобы указать явно. Чтобы определить, начинается ли строка определенной подстрокой, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> перегрузку метода со значением <see cref="F:System.StringComparison.CurrentCulture" /> для его <paramref name="comparisonType" /> параметра.</para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка, подлежащая сравнению.</param>
        <param name="comparisonType">Одно из значений перечисления, определяющее способ сравнения данной строки со значением <paramref name="value" />.</param>
        <summary>Определяет, совпадает ли начало этого экземпляра строки с заданной строкой при сравнении с учетом заданного параметра сравнения.</summary>
        <returns>Значение <see langword="true" />, если данный экземпляр начинается со значения <paramref name="value" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.StartsWith%2A> Метод сравнивает `value` параметр подстрокой, расположенной в начало этой строки и возвращает значение, указывающее, равны ли они. Равными, `value` должен быть ссылкой на ту же строку, должно быть пустой строкой ("»), или необходимо соответствует началу данной строки. Тип сравнения, выполняемые <xref:System.String.StartsWith%2A> метод зависит от значения `comparisonType` параметра. Сравнения можно использовать соглашения текущих региональных параметров (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> и <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) или инвариантного языка и региональных параметров (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> и <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), или он может включать символ за символом сравнения кодовых позиций (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> или <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). Сравнение может выполняться с учетом регистра (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, или <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), или он может не учитывать регистр (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 Следующий пример выполняет поиск строки «» в начале более длинной строки, которая начинается со слова «». Как видно в результатах показано в примере, вызов <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> метод, который выполняет сравнение без учета языка и региональных параметров, но с учетом регистра не соответствует строке, во время вызова, который выполняет сравнение языка и региональных параметров и case insensitive соответствует строке.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 В следующем примере определяется, начинается ли строка определенной подстрокой. Он инициализирует двухмерный массив объектов. Первого элемента во втором измерении содержит строку, а второй элемент строку для поиска в начале первой строки. Результаты зависят от выбора языка и региональных параметров, учитывается ли регистр и выполняется ли порядковое сравнение. Обратите внимание, что если экземпляре строки содержит лигатур, сравнения с учетом языка и региональных параметров с помощью его последовательные символы успешно соответствовать.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> не является значением <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка, подлежащая сравнению.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы не учитывать регистр при сравнении; в противном случае — значение <see langword="false" />.</param>
        <param name="culture">Связанные с языком и региональными параметрами сведения, определяющие, как выполняется сравнение этой строки и <paramref name="value" />. Если значением параметра <paramref name="culture" /> является <see langword="null" />, используется текущий язык и региональные параметры.</param>
        <summary>Определяет, совпадает ли начало экземпляра строки с заданной строкой при сравнении с учетом заданного языка и региональных параметров.</summary>
        <returns><see langword="true" />, если параметр <paramref name="value" /> соответствует началу данной строки; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод сравнивает `value` параметр подстрокой, расположенной в начале данной строки, имеют одинаковую длину как `value`и возвращает значение, указывающее, равны ли они. Равными, `value` должна быть пустой строкой (<xref:System.String.Empty?displayProperty=nameWithType>), должен быть ссылкой на тот же экземпляр или должны соответствовать начало данного экземпляра.  
  
 Этот метод выполняет сравнение с помощью указанного регистра и языка и региональных параметров.  
  
   
  
## Examples  
 В следующем примере определяется, содержится ли строка в начале другой строки. <xref:System.String.StartsWith%2A> Был вызван несколько раз, используя чувствительность к регистру, учет регистра и различных языков и региональных параметров, которые влияют на результаты поиска.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Извлекает подстроку из данного экземпляра.  
  
Этот член перегружен. Для получения полной информации о данном члене, включая синтаксис, использование и примеры, щелкните имя в списке перегрузок.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Index) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : Index -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Отсчитываемая от нуля позиция первого знака подстроки в данном экземпляре.</param>
        <summary>Извлекает подстроку из данного экземпляра. Подстрока начинается в указанном положении символов и продолжается до конца строки.</summary>
        <returns>Строка, эквивалентная подстроке, которая начинается с <paramref name="startIndex" /> в данном экземпляре, или <see cref="F:System.String.Empty" />, если значение <paramref name="startIndex" /> равно длине данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы вызываете <xref:System.String.Substring%28System.Int32%29> метод для извлечения подстроки из строки, которая начинается с указанной позиции символа и заканчивается в конце строки. Положение начального знака отсчитывается от нуля; Другими словами первый символ в строке находится по индексу 0, а не индекс 1. Чтобы извлечь подстроку, которая начинается с указанной позиции символа и заканчивается до конца строки, вызовите <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> метод.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, которая начинается с `startIndex` позиция в текущей строке.  
  
 Чтобы извлечь подстроку, которая начинается с определенный символ или последовательность символов, вызвать метод, такой как <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOf%2A> для получения значения `startIndex`. Во втором примере показано это; он извлекает значение ключа, который начинается на одну позицию символа после символа «=».  
  
 Если `startIndex` равен нулю, этот метод возвращает исходную строку без изменений.  
   
  
## Examples  
 В следующем примере выполняется получение подстроку из строки.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 В следующем примере используется <xref:System.String.Substring%2A> метод для разделения пар "ключ значение", которые разделены с помощью знака равенства («=») символ.  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A> Метод используется для получения позиции знака равенства в строке. Вызов <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> метод извлекает имя ключа, которое начинается с первого символа в строке и расширяет число символов, возвращаемых вызовом <xref:System.String.IndexOf%2A> метод. Вызов <xref:System.String.Substring%28System.Int32%29> метод затем извлекает значение, присваиваемое ключ. Он начинается с символа позиции, следующей за знак равенства и расширяет его до конца строки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Range range);" />
      <MemberSignature Language="F#" Value="member this.Substring : Range -&gt; string" Usage="string.Substring range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Отсчитываемая от нуля позиция первого знака подстроки в данном экземпляре.</param>
        <param name="length">Число символов в подстроке.</param>
        <summary>Извлекает подстроку из данного экземпляра. Подстрока начинается с указанной позиции знака и имеет указанную длину.</summary>
        <returns>Строка, эквивалентная подстроке длиной <paramref name="length" />, которая начинается с <paramref name="startIndex" /> в данном экземпляре, или <see cref="F:System.String.Empty" />, если значение <paramref name="startIndex" /> равно длине данного экземпляра, а значение <paramref name="length" /> равно нулю.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы вызываете <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> метод для извлечения подстроки из строки, которая начинается с указанной позиции символа и заканчивается перед концом строки. Положение начального знака отсчитывается от нуля; Другими словами первый символ в строке находится по индексу 0, а не индекс 1. Чтобы извлечь подстроку, которая начинается с указанной позиции символа и продолжается до конца строки, вызовите <xref:System.String.Substring%28System.Int32%29> метод.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого возвращается новая строка с `length` символов начиная с `startIndex` позиция в текущей строке.  
  
 `length` Параметр представляет общее число символов, извлекаемых из текущего экземпляра строки. Сюда входят начальный символ найден по индексу `startIndex`.  Другими словами <xref:System.String.Substring%2A> метод пытается извлечь символы из индекса `startIndex` индекс `startIndex`  +  `length` - 1.  
  
 Чтобы извлечь подстроку, которая начинается с определенный символ или последовательность символов, вызвать метод, такой как <xref:System.String.IndexOf%2A> или <xref:System.String.LastIndexOf%2A> для получения значения `startIndex`.  
  
 Если подстрока, начиная с позиции `startIndex` в последовательность указанный символ можно вызвать метод такой как <xref:System.String.IndexOf%2A> или <xref:System.String.LastIndexOf%2A> необходимо получить индекс конечный символ или последовательность символов.  Можно затем преобразовать это значение индекса позиции в строке следующим образом:  
  
-   При поиске для один символ, который является для обозначения конца подстроки, `length` равняется `endIndex`  -  `startIndex` + 1, где `endIndex` является возвращаемым значением из <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOf%2A> метод. Следующий пример извлекает непрерывный блок «b» символов из строки.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   При поиске для нескольких символов, которые являются для обозначения конца подстроки, `length` равняется `endIndex`  +  `endMatchLength`  -  `startIndex`, где `endIndex` является возвращаемым значением <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOf%2A> метод, и `endMatchLength` длина последовательности символов, отмечающий конец подстроки. Следующий пример извлекает блок текста, который содержит XML `<definition>` элемент.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Если символ или последовательность символов не включается в конце подстроки, `length` равняется `endIndex`  -  `startIndex`, где `endIndex` является возвращаемым значением из <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOf%2A> метод.  
  
 Если `startIndex` равно нулю и equals, длина текущей строки, метод возвращает исходную строку без изменений.  
  
   
  
## Examples  
 В следующем примере показан простой вызов <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> метод, который извлекает двух символов из строки, начиная с шестой позиции символа (то есть в индексе пять).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 В следующем примере используется <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> метод в следующих трех случаях для изоляции подстроки в строке. В двух случаях подстроки используются при сравнении, а в третьем случае создается исключение, так как указаны недопустимые параметры.  
  
-   Он извлекает один символ и третьей позиции в строке (с индексом 2) и сравнивает его с «c». Это сравнение возвращает `true`.  
  
-   Он извлекает нуль символов, начиная с четвертой позиции в строке (с индексом 3) и передает его <xref:System.String.IsNullOrEmpty%2A> метод. Это значение true, так как вызов <xref:System.String.Substring%2A> возвращает метод <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Предпринимается попытка извлечь один знак, начиная с четвертой позиции в строке. Поскольку в этой позиции символ отсутствует, вызов метода создает <xref:System.ArgumentOutOfRangeException> исключение.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 В следующем примере используется <xref:System.String.Substring%2A> метод для разделения пар "ключ значение", которые разделены с помощью знака равенства («=») символ.  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A> Метод используется для получения позиции знака равенства в строке. Вызов <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> метод извлекает имя ключа, которое начинается с первого символа в строке и расширяет число символов, возвращаемых вызовом <xref:System.String.IndexOf%2A> метод. Вызов <xref:System.String.Substring%28System.Int32%29> метод затем извлекает значение, присваиваемое ключ. Он начинается с символа позиции, следующей за знак равенства и расширяет его до конца строки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> плюс <paramref name="length" /> указывает на позицию за пределами данного экземпляра.  
  
-или- 
 Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, выполняющий перебор элементов текущего объекта <see cref="T:System.String" />.</summary>
        <returns>Строго типизированный перечислитель, который можно использовать для перебора элементов текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только тогда, когда <xref:System.String> экземпляр приводится к <xref:System.Collections.Generic.IEnumerable%601> объект интерфейса. Дополнительные сведения см. в описании метода <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, выполняющий перебор элементов текущего объекта <see cref="T:System.String" />.</summary>
        <returns>Перечислитель, который можно использовать для перебора элементов текущей строки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.Collections.IEnumerable>. Дополнительные сведения см. в описании метода <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" />, если значение текущей строки равно <see cref="F:System.Boolean.TrueString" />; <see langword="false" />, если значение текущей строки равно <see cref="F:System.Boolean.FalseString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущей строки не равно <see cref="F:System.Boolean.TrueString" /> или <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число больше <see cref="F:System.Byte.MaxValue" /> или меньше <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Знак с индексом 0 в текущем объекте <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число меньше <see cref="F:System.Decimal.MinValue" /> или больше <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число меньше <see cref="F:System.Double.MinValue" /> или больше <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число больше <see cref="F:System.Int16.MaxValue" /> или меньше <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число больше <see cref="F:System.SByte.MaxValue" /> или меньше <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Тип возвращаемого объекта.</param>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ChangeType%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Значение текущего объекта <see cref="T:System.String" /> нельзя преобразовать в тип, заданный параметром <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число больше <see cref="F:System.UInt16.MaxValue" /> или меньше <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Значение текущего объекта <see cref="T:System.String" /> нельзя проанализировать.</exception>
        <exception cref="T:System.OverflowException">Значение текущего объекта <see cref="T:System.String" /> представляет собой число больше <see cref="F:System.UInt32.MaxValue" /> или меньше <see cref="F:System.UInt32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Преобразованное значение текущего объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.String> приведен к типу интерфейса <xref:System.IConvertible>. Рекомендуемой альтернативой является вызов <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует знаки данного экземпляра в массив знаков Юникода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Копирует знаки данного экземпляра в массив знаков Юникода.</summary>
        <returns>Массив знаков Юникода, элементами которого являются отдельные знаки из данного экземпляра. Если этот экземпляр является пустой строкой, то возвращаемый массив пуст и его длина равна нулю.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует каждый символ (то есть каждый <xref:System.Char> объект) в виде строки в массив символов. Первый символ копируются, — с нулевым индексом массива возвращаемых знаков; последний скопированный знак является индексом <xref:System.Array.Length%2A?displayProperty=nameWithType> - 1.  
  
 Чтобы создать строку из символов в массиве символов, вызовите <xref:System.String.%23ctor%28System.Char%5B%5D%29> конструктор.  
  
 Чтобы создать массив байтов, содержащий закодированные символы в строке, следует создать соответствующий <xref:System.Text.Encoding> и вызовите его <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> метод. Ниже приведены некоторые стандартные кодировки, доступные в .NET:  
  
|кодировка|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Дополнительные сведения см. в разделе [кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.String.ToCharArray%2A> метод для извлечения символов в строке в массив символов. Затем он отобразит исходную строку и элементы в массиве.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 В следующем примере определяется строка, содержащая символы, которые служат в качестве разделителей в строку с разделителями. Затем он вызывает <xref:System.String.ToCharArray%2A> метод, чтобы создать массив символов, который может быть передан в <xref:System.String.Split%28System.Char%5B%5D%29> способ разделить строку с разделителями на его отдельные подстроки.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Начальная позиция подстроки в данном экземпляре.</param>
        <param name="length">Длина подстроки в данном экземпляре.</param>
        <summary>Копирует знаки из указанной подстроки данного экземпляра в массив знаков Юникода.</summary>
        <returns>Массив знаков Юникода, элементами которого являются <paramref name="length" /> знаков данного экземпляра начиная с позиции <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует знаки в часть строки в массив символов. Чтобы создать строку из диапазона символов из массива символов, вызовите <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> конструктор.  
  
 `startIndex` Параметр отсчитывается от нуля. То есть индекс первого символа в экземпляре строки равен нулю.  
  
 Если `length` равно нулю, возвращаемый массив является пустым и имеет нулевую длину. Если этот экземпляр `null` или является пустой строкой ("»), возвращаемый массив является пустым и имеет нулевую длину.  
  
 Чтобы создать массив байтов, содержащий закодированные символы в часть строки, следует создать соответствующий <xref:System.Text.Encoding> и вызовите его <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> метод. Ниже перечислены некоторые из стандартных кодировок в .NET.  
  
|кодировка|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Дополнительные сведения см. в разделе [кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 В следующем примере преобразует подстроку в строку в массив символов, а затем перечисляет и отображает элементы массива.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> + <paramref name="length" /> больше длины этого экземпляра.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает копию этой строки, переведенную в нижний регистр.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает копию этой строки, переведенную в нижний регистр.</summary>
        <returns>Строка в нижнем регистре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод учитывает правила учета регистра текущего языка и региональных параметров.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой все символы в текущем экземпляре преобразуются в нижний регистр.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Операции смены регистра, полученный в результате вызова метода <xref:System.String.ToLower> метод учитывает соглашения о регистре текущих региональных параметров. Если вам нужна версия верхний или нижний регистр идентификатора операционной системы, такие как имя файла с именем канала, или раздел реестра, используйте <xref:System.String.ToLowerInvariant%2A> или <xref:System.String.ToUpperInvariant%2A> методы. Это дает тот же результат, в каждый язык и региональные параметры (в отличие от <xref:System.String.ToLower> метод) и более эффективное выполнение.  
  
   
  
## Examples  
 В следующем примере преобразуется несколько строк со смешанным регистром в нижний регистр.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Как описано в [советы и рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методов преобразования регистра строк, которые заменяют значения по умолчанию и вместо этого вызывать методы, которые нужны параметры, чтобы указать явно. Чтобы преобразовать символ в нижний регистр, используя соглашения о регистре текущих региональных параметров, вызовите <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> перегрузку метода со значением <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> для его <paramref name="culture" /> параметра.</para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="culture">Объект, задающий правила определения регистра для языка и региональных параметров.</param>
        <summary>Возвращает копию этой строки, переведенную в нижний регистр, используя правила определения регистра заданного языка и региональных параметров.</summary>
        <returns>Эквивалент текущей строки в нижнем регистре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Правила учета регистра, языка и региональных параметров, заданные `culture` параметр определить способ изменения регистра строки изменяется.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой все символы в текущем экземпляре преобразуются в нижний регистр.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Если передать <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> метод <xref:System.Globalization.CultureInfo> отличное от объекта <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, операции смены регистра будет учтена правил, зависящих от языка и региональных параметров. Если вам нужна версия верхний или нижний регистр идентификатора операционной системы, такие как имя файла с именем канала, или раздел реестра, используйте <xref:System.String.ToLowerInvariant%2A> или <xref:System.String.ToUpperInvariant%2A> метод. Это дает тот же результат, в каждый язык и региональные параметры и выполняет более эффективно.  
  
   
  
## Examples  
 В следующем примере две строки символов верхнего регистра в нижний регистр с использованием языков и региональных параметров Английский (США) и турецкий-Турция, а затем сравнивает строки в нижнем регистре. Верхний регистр строки идентичны, за исключением того, что для каждого вхождения Юникода LATIN CAPITAL LETTER I в одной строке, вторая строка содержит LATIN CAPITAL LETTER I с ТОЧКОЙ выше.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает копию этого объекта <see cref="T:System.String" />, переведенную в нижний регистр, используя правила учета регистра инвариантного языка и региональных параметров.</summary>
        <returns>Эквивалент текущей строки в нижнем регистре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Инвариантный язык и региональные параметры представляет язык и региональные параметры без учета языка и региональных параметров. Он связан с английским языком, но не с конкретной страны или региона. Дополнительные сведения см. в описании свойства <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Если приложение зависит от регистра строки, изменяемого предсказуемым способом, не зависящим от текущего языка и региональных параметров, используйте <xref:System.String.ToLowerInvariant%2A> метод. <xref:System.String.ToLowerInvariant%2A> Метод эквивалентен `ToLower(CultureInfo.InvariantCulture)`. Метод рекомендуется в том случае, если коллекция строк должны отображаться в определенном порядке элемента управления пользовательского интерфейса.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой все символы в текущем экземпляре преобразуются в нижний регистр.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Если вам нужна версия верхний или нижний регистр идентификатора операционной системы, такие как имя файла с именем канала, или раздел реестра, используйте <xref:System.String.ToLowerInvariant%2A> или <xref:System.String.ToUpperInvariant%2A> методы.  
  
   
  
## Examples  
 В следующем примере определяется массив строк, содержащий одно слово на нескольких языках. <xref:System.String.ToLowerInvariant%2A> Метод используется для заполнения элементов массива параллельные версии каждого слова без учета регистра. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Метод используется для сортировки массива с учетом регистра, на основе порядка элементов в массиве нижний регистр, чтобы убедиться, что элементы отображаются в том же порядке, независимо от языка.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует значение данного экземпляра в <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает этот экземпляр <see cref="T:System.String" />; реальное преобразование не осуществляется.</summary>
        <returns>Текущая строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Так как этот метод просто возвращает текущую строку без изменений, нет необходимости вызывать его напрямую. Обычно она вызывается неявно в составного форматирования операции, как показано в примере.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.String.ToString%2A> метод. Обратите внимание, что пример не вызывает явно <xref:System.String.ToString%2A> метод. Вместо этого метод неявно вызывается [составное форматирование](~/docs/standard/base-types/composite-formatting.md) функции.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">(Зарезервирован.) Объект, предоставляющий сведения о форматировании, связанные с определенным языком и региональными параметрами.</param>
        <summary>Возвращает этот экземпляр <see cref="T:System.String" />; реальное преобразование не осуществляется.</summary>
        <returns>Текущая строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` зарезервирован и не участвует в настоящее время в данной операции.  
  
 Так как этот метод просто возвращает текущую строку без изменений, нет необходимости вызывать его напрямую.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает копию этой строки, переведенную в верхний регистр.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает копию этой строки, переведенную в верхний регистр.</summary>
        <returns>Эквивалент текущей строки в верхнем регистре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует правила учета регистра текущего языка и региональных параметров для преобразования каждого символа в текущем экземпляре в его эквивалент в верхнем регистре. Если символ не имеет эквивалента в верхнем регистре, он добавляется в возвращаемую строку без изменений.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой все символы в текущем экземпляре преобразуются в верхний регистр.  
  
 <xref:System.String.ToUpper%2A> Метод часто используется для преобразования строки в верхний регистр, так что он может использоваться при сравнении без учета регистра. Чтобы выполнить сравнение без учета регистра рекомендуется вызывать метод сравнения строк, который имеет <xref:System.StringComparison> параметр, значение которого задано значение <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> сравнение с учетом языка и региональных параметров, без учета регистра.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Операции смены регистра, полученный в результате вызова метода <xref:System.String.ToUpper> метод учитывает соглашения о регистре текущих региональных параметров. Если вам нужна версия верхний или нижний регистр идентификатора операционной системы, такие как имя файла с именем канала, или раздел реестра, используйте <xref:System.String.ToLowerInvariant%2A> или <xref:System.String.ToUpperInvariant%2A> метод. Это дает тот же результат, в каждый язык и региональные параметры (в отличие от <xref:System.String.ToUpper> метод) и более эффективное выполнение.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.String.ToUpper%2A> метод для преобразования ряда Односимвольная строк, содержащих каждый символ в наборы символов расширенного-A Basic Latin, дополнительная латиница-1 и латиницы. Затем отображается каждая строка которого символов верхнего регистра отличается от его символ нижнего регистра.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Как описано в [советы и рекомендации по использованию строк](~/docs/standard/base-types/best-practices-strings.md), рекомендуется избегать вызова методов преобразования регистра строк, которые заменяют значения по умолчанию и вместо этого вызывать методы, которые нужны параметры, чтобы указать явно. Чтобы преобразовать строку в верхний регистр с помощью соглашения о регистре текущих региональных параметров, вызовите <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> перегрузку метода со значением <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> для его <paramref name="culture" /> параметра.</para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="culture">Объект, задающий правила определения регистра для языка и региональных параметров.</param>
        <summary>Возвращает копию этой строки, переведенную в верхний регистр, используя правила определения регистра заданного языка и региональных параметров.</summary>
        <returns>Эквивалент текущей строки в верхнем регистре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Правила учета регистра, языка и региональных параметров, заданные `culture` параметр определить способ регистра строки.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой все символы в текущем экземпляре преобразуются в верхний регистр.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Если передать <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> метод <xref:System.Globalization.CultureInfo> отличное от объекта <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, операции смены регистра будет учтена правил, зависящих от языка и региональных параметров. Если вам нужна версия верхний или нижний регистр идентификатора операционной системы, такие как имя файла с именем канала, или раздел реестра, используйте <xref:System.String.ToLowerInvariant%2A> или <xref:System.String.ToUpperInvariant%2A> метод. Это дает тот же результат, в каждый язык и региональные параметры и выполняет более эффективно.  
  
   
  
## Examples  
 Следующий пример преобразует строку в символы нижнего регистра в символы верхнего регистра, с помощью языков и региональных параметров Английский (США) и турецкий-Турция две строки, а затем сравниваются строки в верхний регистр. Верхний регистр строки идентичны, за исключением того, что для каждого вхождения Юникода LATIN CAPITAL LETTER I в одной строке, вторая строка содержит LATIN CAPITAL LETTER I с ТОЧКОЙ выше.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает копию этого объекта <see cref="T:System.String" />, переведенную в верхний регистр, используя правила учета регистра инвариантного языка и региональных параметров.</summary>
        <returns>Эквивалент текущей строки в верхнем регистре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Инвариантный язык и региональные параметры представляет язык и региональные параметры без учета языка и региональных параметров. Он связан с английским языком, но не с конкретной страны или региона. Дополнительные сведения см. в описании свойства <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Если приложение зависит от регистра строки, изменяемого предсказуемым способом, не зависящим от текущего языка и региональных параметров, используйте <xref:System.String.ToUpperInvariant%2A> метод. <xref:System.String.ToUpperInvariant%2A> Метод эквивалентен `ToUpper(CultureInfo.InvariantCulture)`. Метод рекомендуется в том случае, если коллекция строк должны отображаться в определенном порядке элемента управления пользовательского интерфейса.  
  
> [!NOTE]
>  Этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой все символы в текущем экземпляре преобразуются в верхний регистр.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Если вам нужна версия верхний или нижний регистр идентификатора операционной системы, такие как имя файла с именем канала, или раздел реестра, используйте <xref:System.String.ToLowerInvariant%2A> или <xref:System.String.ToUpperInvariant%2A> методы.  
  
   
  
## Examples  
 В следующем примере определяется массив строк, содержащий одно слово на нескольких языках. <xref:System.String.ToUpperInvariant%2A> Метод используется для заполнения элементов массива параллельные версии каждого слова без учета регистра. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Метод используется для сортировки массива с учетом регистра, на основе порядка элементов в массиве верхний регистр, чтобы убедиться, что элементы отображаются в том же порядке, независимо от языка.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает новую строку, в которой удалены все начальные и конечные вхождения заданного набора знаков из текущего объекта <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все начальные и конечные символы-разделители из текущего объекта <see cref="T:System.String" />.</summary>
        <returns>Строка, оставшаяся после удаления всех знаков пробела из начала и конца текущей строки. Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A> Метод удаляет из текущей строки все начальные и конечные пробелы. Операции удаления каждого начальные и конечные прекращается, когда встречается символ без пробелов. Например, если текущей строки «abc "xyz» <xref:System.String.Trim%2A> метод возвращает «abc xyz». Чтобы удалить символы пробелов между словами в строке, используйте [регулярных выражений .NET](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  Если <xref:System.String.Trim%2A> метод удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой удалены все начальные и конечные символы пробелов, найдены в текущем экземпляре.  
  
 Если значение текущей строки равно <xref:System.String.Empty> или все символы в текущем экземпляре состоят из символов разделителей, метод возвращает <xref:System.String.Empty>.  
  
 Пробельные символы определены в стандарте Юникода. <xref:System.String.Trim> Метод удаляет все начальные и конечные символы, которые создают возвращаемое значение `true` когда они передаются в <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.String.Trim?displayProperty=nameWithType> метод для удаления лишних пробелов из строки, вводимые пользователем, перед их объединения.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] И более ранних версиях Ведение внутреннего списка символы-разделители, этот метод удаляет. Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], метод удаляет все символы-разделители в Юникоде (то есть символы, создающие <see langword="true" /> вернуть значение, если они передаются в <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> метод). Из-за этого изменения <see cref="M:System.String.Trim" /> метод в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версий удаляет два символа, ПРОСТРАНСТВО НУЛЕВОЙ ШИРИНЫ (U + 200B) и НУЛЕВОЙ ШИРИНЫ неразрывный пробел (U + FEFF), который <see cref="M:System.String.Trim" /> метод в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]и более поздних версий не удалять. Кроме того <see cref="M:System.String.Trim" /> метод в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версий не усекает три пробельные символы Юникода: MONGOLIAN ГЛАСНЫЕ РАЗДЕЛИТЕЛЯ (U + 180E), УЗКИЙ неразрывный пробел (U + 202F) и средний МАТЕМАТИЧЕСКИЕ пробел (U + 205F).</para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Массив удаляемых знаков Юникода или <see langword="null" />.</param>
        <summary>Удаляет все начальные и конечные вхождения набора знаков, заданного в виде массива, из текущего объекта <see cref="T:System.String" />.</summary>
        <returns>Строка, оставшаяся после удаления всех вхождений символов, заданных в параметре <paramref name="trimChars" />, из начала и конца текущей строки. Если значением параметра <paramref name="trimChars" /> является <see langword="null" /> или пустой массив, удаляются символы-разделители. Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A> Метод удаляет из текущей строки все начальные и конечные символы, которые находятся в `trimChars` параметра. Каждый начальные и конечные trim операция прекращается, когда символ, который не находится в `trimChars` встречается. Например, если текущая строка является «123abc456xyz789» и `trimChars` состоит из цифр от «1» до «9», <xref:System.String.Trim%2A> метод возвращает «abc456xyz».  
  
> [!NOTE]
>  Если <xref:System.String.Trim%2A> метод удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой все начальные и конечные `trimChars` символов, найденных в текущем экземпляре будут удалены.  
  
 Если значение текущей строки равно <xref:System.String.Empty> или все символы в текущем экземпляре состоят из символов в `trimChars` массива, метод возвращает <xref:System.String.Empty>.  
  
 Если `trimChars` — `null` или пустой массив, этот метод удаляет все начальные и конечные символы, возникающих при возврате метода `true` когда они передаются в <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> метода,  
  
   
  
## Examples  
 В следующем примере используется <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> способ удаления пробел, символ звездочки (*) и апостроф (') символов из строки.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] И более ранние версии поддерживают внутренний список символов пробела, этот метод удаляет Если <paramref name="trimChars" /> является <see langword="null" /> или пустой массив. Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], если <paramref name="trimChars" /> — <see langword="null" /> или пустой массив, метод удаляет все символы-разделители в Юникоде (то есть символы, создающие <see langword="true" /> вернуть значение, если они передаются в <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> метод). Из-за этого изменения <see cref="M:System.String.Trim" /> метод в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версий удаляет два символа, ПРОСТРАНСТВО НУЛЕВОЙ ШИРИНЫ (U + 200B) и НУЛЕВОЙ ШИРИНЫ неразрывный пробел (U + FEFF), который <see cref="M:System.String.Trim" /> метод в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]и более поздних версий не удалять. Кроме того <see cref="M:System.String.Trim" /> метод в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версий не усекает три пробельные символы Юникода: MONGOLIAN ГЛАСНЫЕ РАЗДЕЛИТЕЛЯ (U + 180E), УЗКИЙ неразрывный пробел (U + 202F) и средний МАТЕМАТИЧЕСКИЕ пробел (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Массив удаляемых знаков Юникода или <see langword="null" />.</param>
        <summary>Удаляет все конечные вхождения набора знаков, заданного в виде массива, из текущего объекта <see cref="T:System.String" />.</summary>
        <returns>Строка, оставшаяся после удаления всех вхождений символов, заданных в параметре <paramref name="trimChars" />, из конца текущей строки. Если значением параметра <paramref name="trimChars" /> является <see langword="null" /> или пустой массив, удаляются символы-разделители в Юникоде. Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimEnd%2A> Метод удаляет из текущей строки все конечные символы, которые находятся в `trimChars` параметра. Выполнение операции сокращения прекращается после первого символа, не находящегося в `trimChars` обнаруживается в конце строки. Например, если текущая строка является «123abc456xyz789» и `trimChars` состоит из цифр от «1» до «9», <xref:System.String.TrimEnd%2A> метод возвращает «123abc456xyz».  
  
> [!NOTE]
>  Если <xref:System.String.TrimEnd%2A> метод удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку в какой всех конечных символов, найденных в `trimChars` удаляются из текущей строки.  
  
   
  
## Examples  
 В следующем примере показано, как можно использовать <xref:System.String.TrimEnd%28System.Char%5B%5D%29> метод для обрезки пробелы или знаки препинания в конце строки.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] И более ранние версии поддерживают внутренний список символов пробела, этот метод удаляет Если <paramref name="trimChars" /> является <see langword="null" /> или пустой массив. Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], если <paramref name="trimChars" /> — <see langword="null" /> или пустой массив, метод удаляет все символы-разделители в Юникоде (то есть символы, создающие <see langword="true" /> вернуть значение, если они передаются в <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> метод). Из-за этого изменения <see cref="M:System.String.Trim" /> метод в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версий удаляет два символа, ПРОСТРАНСТВО НУЛЕВОЙ ШИРИНЫ (U + 200B) и НУЛЕВОЙ ШИРИНЫ неразрывный пробел (U + FEFF), который <see cref="M:System.String.Trim" /> метод в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и более поздних версий не удалять. Кроме того <see cref="M:System.String.Trim" /> метод в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версий не усекает три пробельные символы Юникода: MONGOLIAN ГЛАСНЫЕ РАЗДЕЛИТЕЛЯ (U + 180E), УЗКИЙ неразрывный пробел (U + 202F) и средний МАТЕМАТИЧЕСКИЕ пробел (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Массив удаляемых знаков Юникода или <see langword="null" />.</param>
        <summary>Удаляет все начальные вхождения набора знаков, заданного в виде массива, из текущего объекта <see cref="T:System.String" />.</summary>
        <returns>Строка, оставшаяся после удаления всех вхождений символов, заданных в параметре <paramref name="trimChars" />, из начала текущей строки. Если значением параметра <paramref name="trimChars" /> является <see langword="null" /> или пустой массив, удаляются символы-разделители.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimStart%2A> Метод удаляет из текущей строки все начальные символы, которые находятся в `trimChars` параметра. Операции удаления прекращается, когда символ, который не находится в `trimChars` встречается. Например, если текущая строка является «123abc456xyz789» и `trimChars` состоит из цифр от «1» до «9», <xref:System.String.TrimStart%2A> метод возвращает «abc456xyz789».  
  
> [!NOTE]
>  Если <xref:System.String.TrimStart%2A> метод удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра. Вместо этого он возвращает новую строку, в которой удалены все начальные символы пробелов, найдены в текущем экземпляре.  
  
   
  
## Examples  
 В следующем примере демонстрируется базовая функциональность <xref:System.String.TrimStart%2A> метод:

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 В следующем примере используется <xref:System.String.TrimStart%2A> метод для обрезки, пробелы и символы комментария из строк исходного кода. `StripComments` Метод создает оболочку для вызова <xref:System.String.TrimStart%2A> и передает его в массив символов, содержит пробел и знак комментария, который является апостроф (') в Visual Basic и косая черта (/) в C#. <xref:System.String.TrimStart%2A> Также осуществляется вызов метода для удаления начальных пробелов при оценке, является ли строка комментария.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 В следующем примере показан вызов метода `StripComments`.  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] И более ранние версии поддерживают внутренний список символов пробела, этот метод удаляет Если <paramref name="trimChars" /> является <see langword="null" /> или пустой массив. Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], если <paramref name="trimChars" /> — <see langword="null" /> или пустой массив, метод удаляет все символы-разделители в Юникоде (то есть символы, создающие <see langword="true" /> вернуть значение, если они передаются в <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> метод). Из-за этого изменения <see cref="M:System.String.Trim" /> метод в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версий удаляет два символа, ПРОСТРАНСТВО НУЛЕВОЙ ШИРИНЫ (U + 200B) и НУЛЕВОЙ ШИРИНЫ неразрывный пробел (U + FEFF), который <see cref="M:System.String.Trim" /> метод в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] и более поздних версий не удалять. Кроме того <see cref="M:System.String.Trim" /> метод в [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] и более ранних версий не усекает три пробельные символы Юникода: MONGOLIAN ГЛАСНЫЕ РАЗДЕЛИТЕЛЯ (U + 180E), УЗКИЙ неразрывный пробел (U + 202F) и средний МАТЕМАТИЧЕСКИЕ пробел (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>