<Type Name="ToolBar" FullName="System.Windows.Controls.ToolBar">
  <Metadata><Meta Name="ms.openlocfilehash" Value="50a3263b3b6082b79028cbb793d5693344bef5ad" /><Meta Name="ms.sourcegitcommit" Value="22744e2f9d07a51900a968efffd9e390117d64a1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="02/03/2019" /><Meta Name="ms.locfileid" Value="55672530" /></Metadata><TypeSignature Language="C#" Value="public class ToolBar : System.Windows.Controls.HeaderedItemsControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ToolBar extends System.Windows.Controls.HeaderedItemsControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.ToolBar" />
  <TypeSignature Language="VB.NET" Value="Public Class ToolBar&#xA;Inherits HeaderedItemsControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class ToolBar : System::Windows::Controls::HeaderedItemsControl" />
  <TypeSignature Language="F#" Value="type ToolBar = class&#xA;    inherit HeaderedItemsControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.HeaderedItemsControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_ToolBarPanel", Type=typeof(System.Windows.Controls.Primitives.ToolBarPanel))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_ToolBarOverflowPanel", Type=typeof(System.Windows.Controls.Primitives.ToolBarOverflowPanel))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет контейнер для группы команд или элементов управления.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ToolBar> элементы управления обеспечивают механизм переполнения, в который помещаются элементы, которые не помещаются на <xref:System.Windows.Controls.ToolBar> в области переполнения. Только элементы панели инструментов в родительском элементе <xref:System.Windows.Controls.ToolBarTray> можно перемещать и изменение размера пользователем.  
  
 <xref:System.Windows.Controls.ToolBar> — <xref:System.Windows.Controls.HeaderedItemsControl>, то есть его заголовок и коллекцию объектов могут быть любого типа (например, строки, изображения или панели). Дополнительные сведения см. в описании класса <xref:System.Windows.Controls.HeaderedItemsControl>.  
  
## <a name="customizing-the-toolbar-control"></a>Настройка панели инструментов  
 Чтобы применить значения свойств к нескольким <xref:System.Windows.Controls.ToolBar> можно использовать элементы управления <xref:System.Windows.FrameworkElement.Style%2A> свойство. Вы можете изменить значение по умолчанию <xref:System.Windows.Controls.ControlTemplate> предоставить уникальный внешний вид элемента управления. Дополнительные сведения о создании <xref:System.Windows.Controls.ControlTemplate>, см. в разделе [Настройка внешнего вида существующего элемента управления путем создания объекта ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Чтобы увидеть части и состояния, относящиеся к <xref:System.Windows.Controls.ToolBar>, см. в разделе [инструментов стили и шаблоны](~/docs/framework/wpf/controls/toolbar-styles-and-templates.md).  
  
 Свойства зависимостей для данного элемента управления могут быть заданы посредством стиля элемента управления по умолчанию.  Если свойство имеет значение стилем по умолчанию, может измениться со значения по умолчанию, когда элемент управления отображается в приложении. Стиль по умолчанию определяется, какая тема рабочего стола используется, когда приложение выполняется.  Дополнительные сведения см. в разделе [темы WPF по умолчанию](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 В следующем примере показано, как создать <xref:System.Windows.Controls.ToolBar> внутри <xref:System.Windows.Controls.ToolBarTray>.  
  
 [!code-xaml[ToolBarExample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBarExample/CS/Pane1.xaml#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
    <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
    <altmember cref="T:System.Windows.Controls.ToolBarTray" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160053">Пример коллекции элементов управления WPF</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ToolBar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ToolBar();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Controls.ToolBar" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Band">
      <MemberSignature Language="C#" Value="public int Band { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Band" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.Band" />
      <MemberSignature Language="VB.NET" Value="Public Property Band As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Band { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Band : int with get, set" Usage="System.Windows.Controls.ToolBar.Band" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение показывающее, где должна быть расположена панель инструментов в <see cref="T:System.Windows.Controls.ToolBarTray" /></summary>
        <value>Строка в <see cref="T:System.Windows.Controls.ToolBarTray" />, в которой размещена панель инструментов. Значение по умолчанию — 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Положение <xref:System.Windows.Controls.ToolBar> в <xref:System.Windows.Controls.ToolBarTray> зависит от значения <xref:System.Windows.Controls.ToolBarTray.Orientation%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.ToolBar.Band%2A>, и <xref:System.Windows.Controls.ToolBar.BandIndex%2A> свойства. Когда <xref:System.Windows.Controls.ToolBarTray.Orientation%2A> присваивается <xref:System.Windows.Controls.Orientation.Horizontal>, полосе представляет строку в <xref:System.Windows.Controls.ToolBarTray>. Когда <xref:System.Windows.Controls.ToolBarTray.Orientation%2A> — <xref:System.Windows.Controls.Orientation.Vertical>, полосе представляет столбец <xref:System.Windows.Controls.ToolBarTray>. Следующая таблица описывает связь между <xref:System.Windows.Controls.ToolBarTray.Orientation%2A>, <xref:System.Windows.Controls.ToolBar.Band%2A>, и <xref:System.Windows.Controls.ToolBar.BandIndex%2A>.  
  
|Ориентация|Аппаратного контроллера управления|BandIndex|  
|-----------------|----------|---------------|  
|Горизонтально|Указывает на строку, в котором <xref:System.Windows.Controls.ToolBar> находится. Панели инструментов, которые имеют <xref:System.Windows.Controls.ToolBar.Band%2A> меньше значения являются выше с большим значением.|Указывает положение <xref:System.Windows.Controls.ToolBar> на <xref:System.Windows.Controls.ToolBar.Band%2A>. Панели инструментов, которые имеют <xref:System.Windows.Controls.ToolBar.BandIndex%2A> меньше значения являются налево от тех, с большим значением.|  
|Вертикально|Указывает столбец, в котором <xref:System.Windows.Controls.ToolBar> находится. Панели инструментов, которые имеют <xref:System.Windows.Controls.ToolBar.Band%2A> меньше значения являются налево от тех, с большим значением.|Указывает положение <xref:System.Windows.Controls.ToolBar> на <xref:System.Windows.Controls.ToolBar.Band%2A>. Панели инструментов, которые имеют <xref:System.Windows.Controls.ToolBar.BandIndex%2A> меньше значения являются выше с большим значением.|  
  
<a name="dependencyPropertyInfo_Band"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ToolBar.BandProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>|  
  
   
  
## Examples  
 В следующем примере показан как использовать это свойство для размещения <xref:System.Windows.Controls.ToolBar> элементы управления внутри <xref:System.Windows.Controls.ToolBarTray>.  
  
 [!code-xaml[ToolBarExample#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBarExample/CS/Pane1.xaml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="BandIndex">
      <MemberSignature Language="C#" Value="public int BandIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BandIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.BandIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property BandIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BandIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BandIndex : int with get, set" Usage="System.Windows.Controls.ToolBar.BandIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает номер индекса, показывающий расположение панели инструментов на полосе.</summary>
        <value>Расположение панели инструментов на полосе <see cref="T:System.Windows.Controls.ToolBarTray" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если это свойство не задано явно, его значение определяется порядок, в котором <xref:System.Windows.Controls.ToolBar> задается в <xref:System.Windows.Controls.ToolBarTray>. Например, если разместить два панелей инструментов в <xref:System.Windows.Controls.ToolBarTray> без параметра <xref:System.Windows.Controls.ToolBar.Band%2A> и <xref:System.Windows.Controls.ToolBar.BandIndex%2A> свойства, значение <xref:System.Windows.Controls.ToolBar.Band%2A> будет иметь значение 0 для обоих панелей инструментов. Значение <xref:System.Windows.Controls.ToolBar.BandIndex%2A> будет 0 для первой панели инструментов и 1 для второй панели инструментов.  
  
 Положение <xref:System.Windows.Controls.ToolBar> в <xref:System.Windows.Controls.ToolBarTray> зависит от значения <xref:System.Windows.Controls.ToolBarTray.Orientation%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.ToolBar.Band%2A>, и <xref:System.Windows.Controls.ToolBar.BandIndex%2A> свойства. Когда <xref:System.Windows.Controls.ToolBarTray.Orientation%2A> присваивается <xref:System.Windows.Controls.Orientation.Horizontal>, полосе представляет строку в <xref:System.Windows.Controls.ToolBarTray>. Когда <xref:System.Windows.Controls.ToolBarTray.Orientation%2A> — <xref:System.Windows.Controls.Orientation.Vertical>, полосе представляет столбец <xref:System.Windows.Controls.ToolBarTray>. Следующая таблица описывает связь между <xref:System.Windows.Controls.ToolBarTray.Orientation%2A>, <xref:System.Windows.Controls.ToolBar.Band%2A>, и <xref:System.Windows.Controls.ToolBar.BandIndex%2A>.  
  
|Ориентация|Аппаратного контроллера управления|BandIndex|  
|-----------------|----------|---------------|  
|Горизонтально|Указывает на строку, в котором <xref:System.Windows.Controls.ToolBar> находится. Панели инструментов, которые имеют <xref:System.Windows.Controls.ToolBar.Band%2A> меньше значения являются выше с большим значением.|Указывает положение <xref:System.Windows.Controls.ToolBar> на <xref:System.Windows.Controls.ToolBar.Band%2A>. Панели инструментов, которые имеют <xref:System.Windows.Controls.ToolBar.BandIndex%2A> меньше значения являются налево от тех, с большим значением.|  
|Вертикально|Указывает столбец, в котором <xref:System.Windows.Controls.ToolBar> находится. Панели инструментов, которые имеют <xref:System.Windows.Controls.ToolBar.Band%2A> меньше значения являются налево от тех, с большим значением.|Указывает положение <xref:System.Windows.Controls.ToolBar> на <xref:System.Windows.Controls.ToolBar.Band%2A>. Панели инструментов, которые имеют <xref:System.Windows.Controls.ToolBar.BandIndex%2A> меньше значения являются выше с большим значением.|  
  
<a name="dependencyPropertyInfo_BandIndex"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ToolBar.BandIndexProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>|  
  
   
  
## Examples  
 В следующем примере показан как использовать это свойство для размещения <xref:System.Windows.Controls.ToolBar> элементы управления внутри <xref:System.Windows.Controls.ToolBarTray>.  
  
 [!code-xaml[ToolBarExample#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBarExample/CS/Pane1.xaml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="BandIndexProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BandIndexProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BandIndexProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.BandIndexProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BandIndexProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BandIndexProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BandIndexProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.BandIndexProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.Controls.ToolBar.BandIndex" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.BandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.BandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.Controls.ToolBar.Band" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ButtonStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey ButtonStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey ButtonStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.ButtonStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ButtonStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ ButtonStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ButtonStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.ButtonStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Windows.Style" />, примененный к кнопкам в панели инструментов.</summary>
        <value>Ключ ресурса, который задает стиль по умолчанию для кнопок в панели инструментов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется, чтобы изменить стиль по умолчанию <xref:System.Windows.Controls.Button> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
<a name="xamlAttributeUsage_ButtonStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <*Объект* *свойство*=»`{` **ToolBar.ButtonStyleKey**`}"/>`  
  
   
  
## Examples  
 В следующем примере показано, как это свойство используется для применения <xref:System.Windows.Style> для <xref:System.Windows.Controls.Button> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
 [!code-xaml[ToolBar_snip#ToolBarButtonStyleKey](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBar_snip/CS/pane1.xaml#toolbarbuttonstylekey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckBoxStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey CheckBoxStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey CheckBoxStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.CheckBoxStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CheckBoxStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ CheckBoxStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CheckBoxStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.CheckBoxStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Windows.Style" />, примененный к флажкам на <see cref="T:System.Windows.Controls.ToolBar" />.</summary>
        <value>Ключ ресурса, который задает стиль по умолчанию для флажков на <see cref="T:System.Windows.Controls.ToolBar" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется, чтобы изменить стиль по умолчанию <xref:System.Windows.Controls.CheckBox> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
<a name="xamlAttributeUsage_CheckBoxStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <*Объект* *свойство*=»`{` **ToolBar.CheckBoxStyleKey**`}"/>`  
  
   
  
## Examples  
 В следующем примере это свойство используется для применения <xref:System.Windows.Style> для <xref:System.Windows.Controls.CheckBox> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
 [!code-xaml[ToolBar_snip#ToolBarCheckBoxStyleKey](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBar_snip/CS/pane1.xaml#toolbarcheckboxstylekey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ComboBoxStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey ComboBoxStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey ComboBoxStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.ComboBoxStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ComboBoxStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ ComboBoxStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComboBoxStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.ComboBoxStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Windows.Style" />, примененный к полям со списками на <see cref="T:System.Windows.Controls.ToolBar" />.</summary>
        <value>Ключ ресурса, который задает стиль по умолчанию для полей со списками в панели инструментов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется, чтобы изменить стиль по умолчанию <xref:System.Windows.Controls.ComboBox> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
<a name="xamlAttributeUsage_ComboBoxStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <*Объект* *свойство*=»`{` **ToolBar.comboboxstylekey внесения**`}"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsOverflowItem">
      <MemberSignature Language="C#" Value="public static bool GetIsOverflowItem (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsOverflowItem(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.GetIsOverflowItem(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsOverflowItem (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsOverflowItem(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetIsOverflowItem : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Controls.ToolBar.GetIsOverflowItem element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, с которого нужно считывать свойство.</param>
        <summary>Считывает значение свойства <see cref="P:System.Windows.Controls.ToolBar.IsOverflowItem" /> с указанного элемента.</summary>
        <returns>Значение свойства.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOverflowMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.OverflowMode GetOverflowMode (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Controls.OverflowMode GetOverflowMode(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.GetOverflowMode(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOverflowMode (element As DependencyObject) As OverflowMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::OverflowMode GetOverflowMode(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetOverflowMode : System.Windows.DependencyObject -&gt; System.Windows.Controls.OverflowMode" Usage="System.Windows.Controls.ToolBar.GetOverflowMode element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren(IncludeDescendants=true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.OverflowMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, с которого нужно считывать свойство.</param>
        <summary>Считывает значение свойства <see cref="P:System.Windows.Controls.ToolBar.OverflowMode" /> с указанного элемента.</summary>
        <returns>Значение свойства.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возможные значения, см. в разделе <xref:System.Windows.Controls.OverflowMode>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasOverflowItems">
      <MemberSignature Language="C#" Value="public bool HasOverflowItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasOverflowItems" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.HasOverflowItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasOverflowItems As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasOverflowItems { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasOverflowItems : bool" Usage="System.Windows.Controls.ToolBar.HasOverflowItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, имеет ли панель инструментов невидимые элементы.</summary>
        <value><see langword="true" />, если в панели инструментов есть невидимые элементы; иначе — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Controls.ToolBar> содержит больше элементов, чем есть места для отображения, оставшиеся элементы помещаются в свою область переполнения. Пользователь может щелкнуть стрелку на <xref:System.Windows.Controls.ToolBar> для доступа к элементам переполнения.  
  
<a name="dependencyPropertyInfo_HasOverflowItems"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ToolBar.HasOverflowItemsProperty>|  
|Значение свойства метаданных `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="HasOverflowItemsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HasOverflowItemsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HasOverflowItemsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.HasOverflowItemsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HasOverflowItemsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HasOverflowItemsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HasOverflowItemsProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.HasOverflowItemsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.Controls.ToolBar.HasOverflowItems" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOverflowItem">
      <MemberSignature Language="C#" Value="see GetIsOverflowItem, and SetIsOverflowItem" />
      <MemberSignature Language="ILAsm" Value="see GetIsOverflowItem, and SetIsOverflowItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.IsOverflowItem" />
      <MemberSignature Language="VB.NET" Value="see GetIsOverflowItem, and SetIsOverflowItem" />
      <MemberSignature Language="F#" Value="see GetIsOverflowItem, and SetIsOverflowItem" Usage="see GetIsOverflowItem, and SetIsOverflowItem" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает значение, которое определяет, является ли элемент <see cref="T:System.Windows.Controls.ToolBar" /> элементом переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство представляет присоединенное свойство только для чтения. Вложенные свойства только для чтения встречаются редко и не имеющие прямого [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] использования. Тем не менее можно использовать ссылку на вложенное свойство как триггер свойства в стиле, для применения значений различных стилей к элементу в панель инструментов, которая находится в панели переполнения.  
  
<a name="dependencyPropertyInfo_IsOverflowItem"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ToolBar.IsOverflowItemProperty>|  
|Значение свойства метаданных `true`|None|  
  
<a name="xamlTextUsage_IsOverflowItem"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 См. заметки.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="IsOverflowItemProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsOverflowItemProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsOverflowItemProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.IsOverflowItemProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsOverflowItemProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsOverflowItemProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsOverflowItemProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.IsOverflowItemProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Controls.ToolBar.IsOverflowItem" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOverflowOpen">
      <MemberSignature Language="C#" Value="public bool IsOverflowOpen { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOverflowOpen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.IsOverflowOpen" />
      <MemberSignature Language="VB.NET" Value="Public Property IsOverflowOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOverflowOpen { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsOverflowOpen : bool with get, set" Usage="System.Windows.Controls.ToolBar.IsOverflowOpen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, показывающее, является ли видимой в настоящее время область переполнения <see cref="T:System.Windows.Controls.ToolBar" />.</summary>
        <value><see langword="true" />, если область переполнения видима; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsOverflowOpen"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ToolBar.IsOverflowOpenProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="IsOverflowOpenProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsOverflowOpenProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsOverflowOpenProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.IsOverflowOpenProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsOverflowOpenProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsOverflowOpenProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsOverflowOpenProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.IsOverflowOpenProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.Controls.ToolBar.IsOverflowOpen" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="toolBar.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Ограничения размеров. <see cref="T:System.Windows.Controls.ToolBar" /> не может вернуть размер, превышающий ограничение.</param>
        <summary>Переопределяет размер <see cref="T:System.Windows.Controls.ToolBar" />.</summary>
        <returns>Размер <see cref="T:System.Windows.Controls.ToolBar" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MenuStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey MenuStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey MenuStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.MenuStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MenuStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ MenuStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.MenuStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Windows.Style" />, примененный к меню на <see cref="T:System.Windows.Controls.ToolBar" />.</summary>
        <value>Ключ ресурса, который задает стиль по умолчанию для меню в панели инструментов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется, чтобы изменить стиль по умолчанию <xref:System.Windows.Controls.Menu> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
<a name="xamlAttributeUsage_MenuStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <*Объект* *свойство*=»`{` **ToolBar.MenuStyleKey**`}"/>`  
  
   
  
## Examples  
 В следующем примере это свойство используется для применения <xref:System.Windows.Style> для <xref:System.Windows.Controls.Menu> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
 [!code-xaml[ToolBar_snip#ToolBarMenuStyleKey](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBar_snip/CS/pane1.xaml#toolbarmenustylekey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="toolBar.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Предоставляет подходящую реализацию <see cref="T:System.Windows.Automation.Peers.ToolBarAutomationPeer" /> для данного элемента управления как часть инфраструктуры [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</summary>
        <returns>Реализация <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />, зависящая от конкретного типа.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsChanged">
      <MemberSignature Language="C#" Value="protected override void OnItemsChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnItemsChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnItemsChanged (e As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnItemsChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnItemsChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="toolBar.OnItemsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Аргументы для события <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" />.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.Items" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="toolBar.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Аргументы для события <see cref="E:System.Windows.UIElement.KeyDown" />.</param>
        <summary>Обеспечивает обработку класса для маршрутизированного события <see cref="E:System.Windows.UIElement.KeyDown" />, происходящего, когда нажата клавиша на элементе в <see cref="T:System.Windows.Controls.ToolBar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда пользователь нажимает ГЛАВНАЯ, первый элемент в <xref:System.Windows.Controls.ToolBar> получает фокус клавиатуры. Когда пользователь нажимает последний элемент в КОНЦЕ <xref:System.Windows.Controls.ToolBar> получает фокус клавиатуры. В таких случаях эта реализация помечает <xref:System.Windows.UIElement.KeyDown> события как обработанного путем присвоения <xref:System.Windows.RoutedEventArgs.Handled%2A> свойство данных события для `true`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Controls.ToolBar.OnKeyDown(System.Windows.Input.KeyEventArgs)" />, всегда вызывать базовую реализацию вашей <see cref="M:System.Windows.Controls.ToolBar.OnKeyDown(System.Windows.Input.KeyEventArgs)" /> реализации. Сбой вызова базовой реализации предотвращает обработку событий с помощью обработчика класса, что может повлиять на поведение во время выполнения конечного класса базовых классов. В зависимости от требований можно вызвать базовую реализацию до или после специальной обработки.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected override void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="toolBar.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Аргументы для события <see cref="E:System.Windows.UIElement.LostMouseCapture" />.</param>
        <summary>Обеспечивает обработку классов для маршрутизированного события <see cref="E:System.Windows.UIElement.LostMouseCapture" />, происходящего, когда <see cref="T:System.Windows.Controls.ToolBar" /> теряет захват мышью.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация не изменяет состояние обработки ( <xref:System.Windows.RoutedEventArgs.Handled%2A> свойство) из <xref:System.Windows.UIElement.LostMouseCapture> данные события.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Controls.ToolBar.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />, всегда вызывать базовую реализацию вашей <see cref="M:System.Windows.Controls.ToolBar.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" /> реализации. Сбой вызова базовой реализации предотвращает обработку событий с помощью обработчика класса, что может повлиять на поведение во время выполнения конечного класса базовых классов. В зависимости от требований можно вызвать базовую реализацию до или после специальной обработки.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Orientation">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Orientation Orientation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.Orientation Orientation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.Orientation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Orientation As Orientation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Orientation Orientation { System::Windows::Controls::Orientation get(); };" />
      <MemberSignature Language="F#" Value="member this.Orientation : System.Windows.Controls.Orientation" Usage="System.Windows.Controls.ToolBar.Orientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Orientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ориентацию элемента управления <see cref="T:System.Windows.Controls.ToolBar" />.</summary>
        <value>Ориентация панели инструментов. Значение по умолчанию — <see cref="F:System.Windows.Controls.Orientation.Horizontal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство получает свое значение из родительского <xref:System.Windows.Controls.ToolBarTray>.  
  
<a name="dependencyPropertyInfo_Orientation"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ToolBar.OrientationProperty>|  
|Значение свойства метаданных `true`|None|  
  
   
  
## Examples  
 В следующем примере показано, как определить, является ли <xref:System.Windows.Controls.ToolBar> является вертикальным.  
  
 [!code-csharp[ToolBarOrient_snip#ToolBarOrientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBarOrient_snip/CSharp/Pane1.xaml.cs#toolbarorientation)]
 [!code-vb[ToolBarOrient_snip#ToolBarOrientation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ToolBarOrient_snip/visualbasic/pane1.xaml.vb#toolbarorientation)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="OrientationProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OrientationProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OrientationProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.OrientationProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OrientationProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OrientationProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OrientationProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.OrientationProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="T:System.Windows.Controls.Orientation" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OverflowMode">
      <MemberSignature Language="C#" Value="see GetOverflowMode, and SetOverflowMode" />
      <MemberSignature Language="ILAsm" Value="see GetOverflowMode, and SetOverflowMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.OverflowMode" />
      <MemberSignature Language="VB.NET" Value="see GetOverflowMode, and SetOverflowMode" />
      <MemberSignature Language="F#" Value="see GetOverflowMode, and SetOverflowMode" Usage="see GetOverflowMode, and SetOverflowMode" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает или задает значение, показывающее, когда элемент должен быть помещен в панель переполнения, а не в основную панель.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_OverflowMode"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ToolBar.OverflowModeProperty>|  
|Значение свойства метаданных `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarOverflowPanel" />
        <altmember cref="T:System.Windows.Controls.Primitives.ToolBarPanel" />
        <altmember cref="T:System.Windows.Controls.ToolBarTray" />
      </Docs>
    </Member>
    <Member MemberName="OverflowModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverflowModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverflowModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ToolBar.OverflowModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverflowModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverflowModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverflowModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ToolBar.OverflowModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Controls.ToolBar.OverflowMode" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected override void PrepareContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void PrepareContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub PrepareContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void PrepareContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="override this.PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="toolBar.PrepareContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">Объект, который будет отображать элемент.</param>
        <param name="item">Элемент для отображения.</param>
        <summary>Подготавливает заданный элемент для отображения указанного элемента.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioButtonStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey RadioButtonStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey RadioButtonStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.RadioButtonStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RadioButtonStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ RadioButtonStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RadioButtonStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.RadioButtonStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Windows.Style" />, примененный к переключателям в панели инструментов.</summary>
        <value>Ключ ресурса, который задает стиль по умолчанию для переключателей в панели инструментов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется, чтобы изменить стиль по умолчанию <xref:System.Windows.Controls.RadioButton> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
<a name="xamlAttributeUsage_RadioButtonStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <*Объект* *свойство*=»`{` **ToolBar.RadioButtonStyleKey**`}"/>`  
  
   
  
## Examples  
 В следующем примере это свойство используется для применения <xref:System.Windows.Style> для <xref:System.Windows.Controls.RadioButton> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
 [!code-xaml[ToolBar_snip#ToolBarRadioButtonStyleKey](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBar_snip/CS/pane1.xaml#toolbarradiobuttonstylekey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeparatorStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey SeparatorStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey SeparatorStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.SeparatorStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SeparatorStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ SeparatorStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SeparatorStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.SeparatorStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Windows.Style" />, примененный к разделителям на <see cref="T:System.Windows.Controls.ToolBar" />.</summary>
        <value>Ключ ресурса, который задает стиль по умолчанию для разделителей в панели инструментов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется, чтобы изменить стиль по умолчанию <xref:System.Windows.Controls.Separator> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
<a name="xamlAttributeUsage_SeparatorStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <*Объект* *свойство*=»`{` **ToolBar.SeparatorStyleKey**`}"/>`  
  
   
  
## Examples  
 В следующем примере это свойство используется для применения <xref:System.Windows.Style> для <xref:System.Windows.Controls.Separator> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
 [!code-xaml[ToolBar_snip#ToolBarSeparatorStyleKey](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBar_snip/CS/pane1.xaml#toolbarseparatorstylekey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetOverflowMode">
      <MemberSignature Language="C#" Value="public static void SetOverflowMode (System.Windows.DependencyObject element, System.Windows.Controls.OverflowMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetOverflowMode(class System.Windows.DependencyObject element, valuetype System.Windows.Controls.OverflowMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ToolBar.SetOverflowMode(System.Windows.DependencyObject,System.Windows.Controls.OverflowMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetOverflowMode (element As DependencyObject, mode As OverflowMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetOverflowMode(System::Windows::DependencyObject ^ element, System::Windows::Controls::OverflowMode mode);" />
      <MemberSignature Language="F#" Value="static member SetOverflowMode : System.Windows.DependencyObject * System.Windows.Controls.OverflowMode -&gt; unit" Usage="System.Windows.Controls.ToolBar.SetOverflowMode (element, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="mode" Type="System.Windows.Controls.OverflowMode" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, которому нужно записывать свойство.</param>
        <param name="mode">Задаваемое значение свойства.</param>
        <summary>Записывает значение свойства <see cref="P:System.Windows.Controls.ToolBar.OverflowMode" /> в указанный элемент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возможные значения, см. в разделе <xref:System.Windows.Controls.OverflowMode>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextBoxStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey TextBoxStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey TextBoxStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.TextBoxStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TextBoxStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ TextBoxStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TextBoxStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.TextBoxStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Windows.Style" />, примененный к текстовым ячейкам на <see cref="T:System.Windows.Controls.ToolBar" />.</summary>
        <value>Ключ ресурса, который задает стиль по умолчанию для текстовых полей в панели инструментов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется, чтобы изменить стиль по умолчанию <xref:System.Windows.Controls.TextBox> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
<a name="xamlAttributeUsage_TextBoxStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <*Объект* *свойство*=»`{` **ToolBar.TextBoxStyleKey**`}"/>`  
  
   
  
## Examples  
 В следующем примере это свойство используется для создания <xref:System.Windows.Style> для <xref:System.Windows.Controls.TextBox> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
 [!code-xaml[ToolBar_snip#ToolBarTextBoxStyleKey](~/samples/snippets/csharp/VS_Snippets_Wpf/ToolBar_snip/CS/pane1.xaml#toolbartextboxstylekey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleButtonStyleKey">
      <MemberSignature Language="C#" Value="public static System.Windows.ResourceKey ToggleButtonStyleKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.ResourceKey ToggleButtonStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ToolBar.ToggleButtonStyleKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleButtonStyleKey As ResourceKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::ResourceKey ^ ToggleButtonStyleKey { System::Windows::ResourceKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleButtonStyleKey : System.Windows.ResourceKey" Usage="System.Windows.Controls.ToolBar.ToggleButtonStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает свойство <see cref="T:System.Windows.Style" />, применяемое к элементам управления <see cref="T:System.Windows.Controls.Primitives.ToggleButton" /> на <see cref="T:System.Windows.Controls.ToolBar" />.</summary>
        <value>Ключ ресурса, представляющий стиль по умолчанию для переключателей на панели инструментов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется, чтобы изменить стиль по умолчанию <xref:System.Windows.Controls.Primitives.ToggleButton> элементов управления в <xref:System.Windows.Controls.ToolBar>.  
  
<a name="xamlAttributeUsage_ToggleButtonStyleKey"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 <*object* *property*="`{` **ToolBar.ToggleButtonStyleKey**`}"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>