<Type Name="MsmqBindingElementBase" FullName="System.ServiceModel.Configuration.MsmqBindingElementBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6801645420417b2fd7423bc5d1c123ba4ae743ba" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55307260" /></Metadata><TypeSignature Language="C#" Value="public abstract class MsmqBindingElementBase : System.ServiceModel.Configuration.StandardBindingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MsmqBindingElementBase extends System.ServiceModel.Configuration.StandardBindingElement" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Configuration.MsmqBindingElementBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MsmqBindingElementBase&#xA;Inherits StandardBindingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class MsmqBindingElementBase abstract : System::ServiceModel::Configuration::StandardBindingElement" />
  <TypeSignature Language="F#" Value="type MsmqBindingElementBase = class&#xA;    inherit StandardBindingElement" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Configuration.StandardBindingElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет базовый класс, члены которого являются общими для классов <see cref="T:System.ServiceModel.Configuration.NetMsmqBindingElement" /> и <see cref="T:System.ServiceModel.Configuration.MsmqIntegrationBindingElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс содержит параметры, необходимые для настройки привязки на основе очереди сообщений (MSMQ).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Configuration.MsmqBindingElementBase" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MsmqBindingElementBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.MsmqBindingElementBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MsmqBindingElementBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Configuration.MsmqBindingElementBase" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MsmqBindingElementBase (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.MsmqBindingElementBase.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MsmqBindingElementBase(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Configuration.MsmqBindingElementBase : string -&gt; System.ServiceModel.Configuration.MsmqBindingElementBase" Usage="new System.ServiceModel.Configuration.MsmqBindingElementBase name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя конфигурации привязки. Это значение должно быть уникальным, поскольку оно используется для идентификации конкретной привязки.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Configuration.MsmqBindingElementBase" /> с использованием указанного имени.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomDeadLetterQueue">
      <MemberSignature Language="C#" Value="public Uri CustomDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CustomDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property CustomDeadLetterQueue As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CustomDeadLetterQueue { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CustomDeadLetterQueue : Uri with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("customDeadLetterQueue", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает универсальный код ресурса <see cref="T:System.Uri" />, идентифицирующий пользовательскую очередь недоставленных сообщений, в которую отправляются просроченные сообщения и сообщения, которые не удалось доставить.</summary>
        <value>Экземпляр класса <see cref="T:System.Uri" />, содержащий универсальный код ресурса (URI) настраиваемой очереди недоставленных сообщений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект *очередь недоставленных сообщений* — это очередь, управляемая диспетчером очередей отправляющего приложения, в котором хранятся сообщения, которые не удалось доставить, или истек срок действия. Свойство `CustomDeadLetterQueue` позволяет указать настраиваемую очередь недоставленных сообщений вместо системной очереди недоставленных сообщений.  
  
 Универсальный код ресурса (URI), определяемый свойством <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue%2A>, должен использовать схему net.msmq.  
  
 Если свойству <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue%2A> присвоено значение <xref:System.ServiceModel.DeadLetterQueue.None> или <xref:System.ServiceModel.DeadLetterQueue.System>, свойству <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue%2A> необходимо присвоить значение `null`. Если значение свойства <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue%2A> отличается от значения `null`, свойству <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue%2A> необходимо присвоить значение <xref:System.ServiceModel.DeadLetterQueue.Custom>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeadLetterQueue">
      <MemberSignature Language="C#" Value="public System.ServiceModel.DeadLetterQueue DeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.DeadLetterQueue DeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property DeadLetterQueue As DeadLetterQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::DeadLetterQueue DeadLetterQueue { System::ServiceModel::DeadLetterQueue get(); void set(System::ServiceModel::DeadLetterQueue value); };" />
      <MemberSignature Language="F#" Value="member this.DeadLetterQueue : System.ServiceModel.DeadLetterQueue with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("deadLetterQueue", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.DeadLetterQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение параметра <see cref="T:System.ServiceModel.DeadLetterQueue" /> для данной привязки.</summary>
        <value>Значение <see cref="T:System.ServiceModel.DeadLetterQueue" />, задающее, какой тип очереди недоставленных сообщений следует использовать, и использовать ли вообще.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Очередь недоставленных сообщений* — это очередь, управляемая диспетчером очередей отправляющего приложения, в котором хранятся сообщения, которые не удалось доставить, или истек срок действия. Ниже перечислены возможные причины, по которым сообщение может не дойти до принимающего приложения.  
  
-   Транзакционное сообщение отправлено в нетранзакционную очередь.  
  
-   Нетранзакционное сообщение отправлено в транзакционную очередь.  
  
-   В очередь, принимающую только сообщения, которые прошли проверку подлинности, отправлено сообщение, не прошедшее проверку подлинности.  
  
-   В очередь, принимающую только зашифрованные сообщения, отправлено незашифрованное сообщение.  
  
-   Срок действия сообщения истек до того, как оно было доставлено получателю.  
  
-   При получении сообщения была превышена квота хранилища сообщений на конечном компьютере или квота хранилища очереди назначения, либо не хватило пространства памяти на конечном компьютере.  
  
-   Отправитель не имеет [права доступа](https://go.microsoft.com/fwlink/?LinkID=96167) необходимых для размещения сообщения в очередь назначения.  
  
-   Цифровая сигнатура сообщения недействительна.  
  
-   Диспетчеру очереди назначения не удалось расшифровать зашифрованное сообщение.  
  
-   Очередь назначения была очищена или удалена до извлечения сообщения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Durable">
      <MemberSignature Language="C#" Value="public bool Durable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Durable" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.Durable" />
      <MemberSignature Language="VB.NET" Value="Public Property Durable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Durable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Durable : bool with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.Durable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("durable", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, являются ли сообщения, отправляемые этой привязкой, устойчивыми или переменными.</summary>
        <value>Значение <see langword="true" />, если сообщения, обрабатываемые этой привязкой, являются устойчивыми; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этому свойству присвоено значение `true`, сообщения являются устойчивыми; в противном случае сообщения являются переменными. Устойчивые сообщения не теряются в случае сбоя диспетчера очередей. Значение по умолчанию для этого свойства — `true`. Если необходимо обеспечить для сообщений гарантию в точности однократной доставки (свойству <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A> присвоено значение `true`), этому свойству необходимо присвоить значение `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExactlyOnce">
      <MemberSignature Language="C#" Value="public bool ExactlyOnce { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExactlyOnce" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ExactlyOnce" />
      <MemberSignature Language="VB.NET" Value="Public Property ExactlyOnce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExactlyOnce { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExactlyOnce : bool with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.ExactlyOnce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("exactlyOnce", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, задана ли для сообщений, отправляемых этой привязкой, гарантия в точности однократной доставки.</summary>
        <value>Значение <see langword="true" />, если гарантирована однократная доставка сообщений, отправляемых этой привязкой; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A>, если значение `true`, указывает, что Message Queuing (MSMQ) гарантированно поместит отправленное сообщение в очередь полученных сообщений один и только один раз. В случае сбоя доставки сообщение отправляется в очередь недоставленных сообщений-в зависимости от `DeadLetterQueue` значение свойства. Если свойству <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A> присвоено значение `true`, используемая очередь должна быть очередью транзакционных сообщений.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeFrom">
      <MemberSignature Language="C#" Value="protected internal override void InitializeFrom (System.ServiceModel.Channels.Binding binding);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void InitializeFrom(class System.ServiceModel.Channels.Binding binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.MsmqBindingElementBase.InitializeFrom(System.ServiceModel.Channels.Binding)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void InitializeFrom(System::ServiceModel::Channels::Binding ^ binding);" />
      <MemberSignature Language="F#" Value="override this.InitializeFrom : System.ServiceModel.Channels.Binding -&gt; unit" Usage="msmqBindingElementBase.InitializeFrom binding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
      </Parameters>
      <Docs>
        <param name="binding">Привязка с параметрами, которые будут использоваться для инициализации данной привязки.</param>
        <summary>Инициализирует данную привязку содержимым указанной привязки.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxReceivedMessageSize">
      <MemberSignature Language="C#" Value="public long MaxReceivedMessageSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxReceivedMessageSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxReceivedMessageSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxReceivedMessageSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxReceivedMessageSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxReceivedMessageSize : int64 with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.MaxReceivedMessageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("maxReceivedMessageSize", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.LongValidator(MinValue=0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, в котором указывается максимально допустимый размер сообщения (в байтах).</summary>
        <value>Максимально допустимый размер сообщения, отправляемого или принимаемого данной привязкой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если размер входящего сообщения превышает значение <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxReceivedMessageSize%2A>, такое сообщение отбрасывается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxRetryCycles">
      <MemberSignature Language="C#" Value="public int MaxRetryCycles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxRetryCycles" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxRetryCycles As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxRetryCycles { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxRetryCycles : int with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("maxRetryCycles", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.IntegerValidator(MinValue=0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество циклов повторных попыток доставки сообщения принимающему приложению.</summary>
        <value>Максимально количество циклов повторных попыток, предпринимаемых перед тем, как поместить сообщение в очередь недоставленных сообщений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект *цикл повторной попытки* когда сообщение передается из очереди повторных попыток в очередь приложения для попытки доставки приложению. Сообщения помещаются в очередь повторных попыток после сбоя нескольких немедленных повторных попыток, как задано свойством <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveRetryCount%2A>. <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles%2A> задает число циклов повторных попыток и не включает первоначальную попытку отправки сообщения. Максимальное количество попыток отправки сообщения составляет (1 + MaxRetryCycles) * (ReceiveRetryCount + 1) раз. Например, если ReceiveRetryCount = 0, а MaxRetryCycles = 1, будет предпринято максимум две попытки доставить сообщение. Это свойство доступно в операционных системах Windows, начиная с [!INCLUDE[wv](~/includes/wv-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyConfiguration">
      <MemberSignature Language="C#" Value="protected override void OnApplyConfiguration (System.ServiceModel.Channels.Binding binding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApplyConfiguration(class System.ServiceModel.Channels.Binding binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.MsmqBindingElementBase.OnApplyConfiguration(System.ServiceModel.Channels.Binding)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApplyConfiguration(System::ServiceModel::Channels::Binding ^ binding);" />
      <MemberSignature Language="F#" Value="override this.OnApplyConfiguration : System.ServiceModel.Channels.Binding -&gt; unit" Usage="msmqBindingElementBase.OnApplyConfiguration binding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
      </Parameters>
      <Docs>
        <param name="binding">Привязка, содержащая параметры, которые необходимо применить.</param>
        <summary>Вызывается, когда содержимое данной привязки применяется к указанной привязке.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="protected override System.Configuration.ConfigurationPropertyCollection Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.ConfigurationPropertyCollection Properties" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.Properties" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property Properties As ConfigurationPropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Configuration::ConfigurationPropertyCollection ^ Properties { System::Configuration::ConfigurationPropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Configuration.ConfigurationPropertyCollection" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConfigurationPropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает экземпляр класса <see cref="T:System.Configuration.ConfigurationPropertyCollection" />, содержащий коллекцию объектов <see cref="T:System.Configuration.ConfigurationProperty" />, которые могут быть атрибутами или объектами <see cref="T:System.Configuration.ConfigurationElement" /> данного элемента конфигурации.</summary>
        <value>Экземпляр класса <see cref="T:System.Configuration.ConfigurationPropertyCollection" />, содержащий коллекцию объектов <see cref="T:System.Configuration.ConfigurationProperty" />, которые могут быть атрибутами или объектами <see cref="T:System.Configuration.ConfigurationElement" /> данного элемента конфигурации привязки.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveContextEnabled">
      <MemberSignature Language="C#" Value="public bool ReceiveContextEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReceiveContextEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveContextEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveContextEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReceiveContextEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveContextEnabled : bool with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveContextEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Configuration.ConfigurationProperty("receiveContextEnabled", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, включен ли контекст получения для обработки сообщений в очередях.</summary>
        <value>Значение <see langword="true" />, если включен контекст получения для обработки сообщений в очередях; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда эта функция включена, служба может «выбрать» сообщений в очереди, чтобы начать его обработку, и, если что-то пойдет не так, и возникает исключение, он остается в очереди. Службы могут также «блокировать сообщения, чтобы еще раз попытаться обработать последующий момент времени. Receivecontext имеет механизм для «завершения» сообщения после обработки, что он может быть удален из очереди. Сообщения больше не производится и считывание в очереди по сети, а отдельные сообщения не перебрасываются между различными экземплярами служб во время обработки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveErrorHandling">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ReceiveErrorHandling ReceiveErrorHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ReceiveErrorHandling ReceiveErrorHandling" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveErrorHandling As ReceiveErrorHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ReceiveErrorHandling ReceiveErrorHandling { System::ServiceModel::ReceiveErrorHandling get(); void set(System::ServiceModel::ReceiveErrorHandling value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveErrorHandling : System.ServiceModel.ReceiveErrorHandling with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("receiveErrorHandling", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ReceiveErrorHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение перечисления, указывающее, каким образом будут обрабатываться подозрительные сообщения и сообщения, которые не удалось доставить.</summary>
        <value>Значение <see cref="T:System.ServiceModel.ReceiveErrorHandling" />, указывающее, каким образом будут обрабатываться подозрительные сообщения и сообщения, которые не удалось доставить.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этому свойству присвоить значение <xref:System.ServiceModel.ReceiveErrorHandling.Fault>, это приведет к сбою прослушивателя и вызову исключения <xref:System.ServiceModel.ProtocolException> (являющегося оболочкой для класса <xref:System.ServiceModel.MsmqPoisonMessageException>) с трассировкой. Сообщение останется в очереди; его необходимо удалить вручную. Класс <xref:System.ServiceModel.MsmqPoisonMessageException> содержит свойство <xref:System.ServiceModel.MsmqPoisonMessageException.MessageLookupId%2A>, с помощью которого можно выявлять и вручную удалять такие сообщения из очереди подозрительных сообщений.  
  
 Если этому свойству присвоено значение <xref:System.ServiceModel.ReceiveErrorHandling.Drop>, сообщение, которое привело к вызову исключения, просто отбрасывается.  
  
 Если этому свойству присвоено значение <xref:System.ServiceModel.ReceiveErrorHandling.Reject>, клиенту отправляется уведомление о недоставке, а сообщение удаляется из очереди подозрительных сообщений. Этот параметр доступен только в очереди сообщений (MSMQ) 4.0.  
  
 Если этому свойству присвоено значение <xref:System.ServiceModel.ReceiveErrorHandling.Move>, сообщение перемещается во вложенную очередь для окончательного хранения подозрительных сообщений. Этот параметр доступен только в очереди сообщений (также известной как MSMQ) 4.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveRetryCount">
      <MemberSignature Language="C#" Value="public int ReceiveRetryCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveRetryCount" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveRetryCount" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveRetryCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveRetryCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveRetryCount : int with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveRetryCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("receiveRetryCount", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.IntegerValidator(MinValue=0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное число немедленных повторных попыток, которые должен выполнить диспетчер очереди, если не удается передать сообщение из очереди приложения самому приложению.</summary>
        <value>Максимальное число попыток отправки сообщения диспетчером очереди, после которого сообщение помещается в очередь повторного выполнения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если выполнено максимальное количество попыток доставки, а приложение не имеет доступа к сообщению, сообщение помещается в очередь повторного выполнения для повторной доставки через некоторое время. Время до повторного помещения сообщения в очередь отправки указывается в свойстве <xref:System.ServiceModel.Channels.MsmqBindingElementBase.RetryCycleDelay%2A>. Если число повторных попыток достигает значения <xref:System.ServiceModel.Channels.MsmqBindingElementBase.MaxRetryCycles%2A>, то сообщение отправляется в очередь подозрительных сообщений или отправителю отсылается уведомление о том, что сообщение не может быть доставлено.  
  
 Дополнительные сведения см. в разделах <xref:System.ServiceModel.Channels.MsmqBindingElementBase.MaxRetryCycles%2A> и <xref:System.ServiceModel.Channels.MsmqBindingElementBase.RetryCycleDelay%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RetryCycleDelay">
      <MemberSignature Language="C#" Value="public TimeSpan RetryCycleDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan RetryCycleDelay" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.RetryCycleDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryCycleDelay As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan RetryCycleDelay { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.RetryCycleDelay : TimeSpan with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.RetryCycleDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("retryCycleDelay", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Runtime.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, задающее время ожидания между циклами повторных попыток доставки сообщения, которое не удалось доставить.</summary>
        <value>Значение <see cref="T:System.TimeSpan" />, задающее промежуток времени ожидания до начала следующего цикла попыток доставки сообщения принимающему приложению. Значение по умолчанию — 30 (минут).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый цикл повторных попыток предпринимает попытки доставить сообщение принимающему приложению (задается свойством <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles%2A>). Если ни одна из попыток не увенчается успехом, сообщение будет помещено обратно в очередь повторного выполнения. Это свойство задает срок нахождения сообщения в очереди повторных попыток, по истечении которого сообщение будет передано в очередь приложения для следующего цикла повторных попыток. Это свойство доступно в операционных системах Windows, начиная с [!INCLUDE[wv](~/includes/wv-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeToLive">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToLive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToLive" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.TimeToLive" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToLive As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToLive { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToLive : TimeSpan with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.TimeToLive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("timeToLive", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Runtime.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, задающее срок действия сообщений. По истечении этого срока сообщение помещается в очередь недоставленных сообщений (если такая очередь существует).</summary>
        <value>Значение <see cref="T:System.TimeSpan" />, задающее срок действия сообщений. Значение по умолчанию — 24 часа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поставленные в очередь приложения работают по замыслу разработчиков асинхронно, то есть отправляющее и принимающее приложения могут быть запущены в разное время. Следовательно, возможна ситуация, при которой сообщение от отправляющего приложения может быть обработано принимающим приложением не сразу. Некоторые сообщения содержат сведения, действительные только в течение определенного промежутка времени. Если сообщение не будет доставлено в течение этого промежутка времени, содержащиеся в нем сведения потеряют свою актуальность, и поэтому такое сообщение следует удалить. Это свойство позволяет указать предельное время, в течение которого сообщение будет храниться перед доставкой в очередь приложения. Если это время истечет до помещения сообщения в очередь приложения, сообщение будет помещено в очередь недоставленных сообщений, если таковая существует (указывается в свойстве <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue%2A>); в противном случае, если очереди недоставленных сообщений не существует, сообщение удаляется.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseMsmqTracing">
      <MemberSignature Language="C#" Value="public bool UseMsmqTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseMsmqTracing" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.UseMsmqTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseMsmqTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseMsmqTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseMsmqTracing : bool with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.UseMsmqTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("useMsmqTracing", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, используется ли функция отслеживания сообщений, встроенная в очередь сообщений (MSMQ).</summary>
        <value>Значение <see langword="true" />, если используется встроенная трассировка сообщений очереди сообщений (MSMQ); в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойству <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.UseMsmqTracing%2A> задано значение `true`, поставленный в очередь канал использует встроенную функцию трассировки сообщений очереди сообщений. При включенной трассировке каждый раз, когда сообщение принимается и отправляется диспетчером очередей, в указанную очередь отчетов помещается сообщение с отчетом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseSourceJournal">
      <MemberSignature Language="C#" Value="public bool UseSourceJournal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSourceJournal" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.UseSourceJournal" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSourceJournal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSourceJournal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseSourceJournal : bool with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.UseSourceJournal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("useSourceJournal", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должны ли сохраняться в очереди журнала источника копии сообщений, обрабатываемых этой привязкой.</summary>
        <value>Значение <see langword="true" />, если сообщения, обрабатываемые данной привязкой, копируются в очередь журнала источника; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложения в очереди, которым необходимо вести учет сообщений, покинувших очередь исходящих сообщений на исходном компьютере, могут копировать сообщения в очередь журнала. После того как сообщение покидает очередь исходящих сообщений и появляется подтверждение, что сообщение было принято конечным компьютером, в очереди системного журнала отправляющего компьютера сохраняется копия этого сообщения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidityDuration">
      <MemberSignature Language="C#" Value="public TimeSpan ValidityDuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ValidityDuration" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ValidityDuration" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidityDuration As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ValidityDuration { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.ValidityDuration : TimeSpan with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.ValidityDuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Configuration.ConfigurationProperty("validityDuration", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Runtime.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее время ожидания соединения при работе с каналами, поставленными в очередь.</summary>
        <value>Время ожидания соединения при использовании с каналами в очереди.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Если в ходе транзакции для сообщения истекает срок <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ValidityDuration%2A>, то любая транзакция, используемая для его обработки, будет прервана вместе с экземпляром рабочего процесса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>