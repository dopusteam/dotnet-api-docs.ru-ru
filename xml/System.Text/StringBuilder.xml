<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9400910a9b479507f698dda5b833c16e8e1557de" /><Meta Name="ms.sourcegitcommit" Value="b99ec7065534584bfab2aebde9f144bedabb075a" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="58185328" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет изменяемую строку символов. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс представляет объект строкового типа, значение которого является изменяемая последовательность символов.  
  
 Содержание  
  
-   [Типы String и StringBuilder](#StringAndSB)  
  
-   [Как работает StringBuilder](#HowWorks)  
  
-   [Выделение памяти](#Memory)  
  
-   [Создание экземпляра объекта StringBuilder](#Instantiating)  
  
-   [Вызов методов StringBuilder](#Calling)  
  
-   [Выполнение операций StringBuilder](#Operations)  
  
    -   [Итерация StringBuilder символов](#Iterating)  
  
    -   [Добавление текста в объект StringBuilder](#Adding)  
  
    -   [Удаление текста из объекта StringBuilder](#Deleting)  
  
    -   [Изменение текста в объект StringBuilder](#Modifying)  
  
-   [Поиск текста в объект StringBuilder](#Searching)  
  
-   [Преобразование объекта StringBuilder в строку](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Типы String и StringBuilder  
 Несмотря на то что <xref:System.Text.StringBuilder> и <xref:System.String> обе они представляют последовательности символов, они реализуются по-разному. <xref:System.String> является неизменяемым типом. То есть каждой операции, который отображается для изменения <xref:System.String> объект фактически создает новую строку.  
  
 Например, вызов <xref:System.String.Concat%2A?displayProperty=nameWithType> метод в следующем примере C#, по-видимому, измените значение параметра строковую переменную с именем `value`. На самом деле <xref:System.String.Concat%2A> возвращает `value` объекта, имеющего другое значение и адрес из `value` объект, который был передан в метод. Обратите внимание, что пример должно быть скомпилировано с использованием `/unsafe` параметр компилятора.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Для подпрограмм, выполняющих обширной строками (например, приложения, измените строку несколько раз в цикле) несколько раз изменения строки можно точное к значительному снижению производительности. Альтернативой является использование <xref:System.Text.StringBuilder>, — это класс, изменяемую строку. Изменяемость означает, что после создания экземпляра класса, его можно изменить путем добавления, удаления, замены или Вставка символов. Объект <xref:System.Text.StringBuilder> объект поддерживает буфер, чтобы вместить расширения к строке. Новые данные добавляются в буфер, если доступно места; в противном случае выделяется новый, больший буфер, данные из исходного буфера копируются в новый буфер, и затем добавляются новые данные в новый буфер.  
  
> [!IMPORTANT]
>  Несмотря на то что <xref:System.Text.StringBuilder> класса, как правило, обеспечивает лучшую производительность, чем <xref:System.String> класс, вы не может заменить автоматически <xref:System.String> с <xref:System.Text.StringBuilder> каждый раз, когда требуется для работы со строками. Производительность зависит от размера строки, объем памяти, выделяемой для новой строки, системы, на котором выполняется приложение и тип операции. Вы должны быть готовы протестировать приложение, чтобы определить, является ли <xref:System.Text.StringBuilder> действительно предлагает значительного выигрыша в производительности.  
  
 Рассмотрите возможность использования <xref:System.String> класса в этих условиях:  
  
-   Когда число изменений, приложение будет строка мал. В этих случаях <xref:System.Text.StringBuilder> может незначительно предложения или не улучшение производительности по сравнению <xref:System.String>.  
  
-   При выполнении фиксированное число операции объединения, особенно со строковыми литералами. В этом случае компилятор может объединять операции объединения в одной операции.  
  
-   При наличии можно выполнять широкий поиск при построении строки. <xref:System.Text.StringBuilder> Отсутствует класс поиска методов, таких как `IndexOf` или `StartsWith`. Вам придется преобразовать <xref:System.Text.StringBuilder> объект <xref:System.String> для этих операций и это отключить выгода от использования <xref:System.Text.StringBuilder>. Дополнительные сведения см. в разделе [поиск текста в объект StringBuilder](#Searching) раздел.  
  
 Рассмотрите возможность использования <xref:System.Text.StringBuilder> класса в этих условиях:  
  
-   Когда это должно происходить чтобы ваше приложение произвело неизвестное количество изменений в строку во время разработки (например, при использовании цикла для объединения случайное число строк, содержащих ввод данных пользователем).  
  
-   Когда это должно происходить чтобы ваше приложение произвело значительное количество изменений в строку.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Как работает StringBuilder  
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> Свойство указывает количество символов <xref:System.Text.StringBuilder> содержит объект. При добавлении символов для <xref:System.Text.StringBuilder> объекта, его длина увеличивается, пока он равен размеру <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> свойство, которое определяет число символов, которые может содержать объект. Если количество добавленных символов вызывает длину <xref:System.Text.StringBuilder> объект превышение его текущей емкости, новую память выделяется, значение <xref:System.Text.StringBuilder.Capacity%2A> свойство удваивается, добавляются новые символы <xref:System.Text.StringBuilder> объекта и его <xref:System.Text.StringBuilder.Length%2A>настройки свойства. Дополнительная память для <xref:System.Text.StringBuilder> объект выделяется динамически, пока не достигнет значения, определяемого <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> свойство. При достижении максимальной емкости без дальнейшего памяти, выделяемой для <xref:System.Text.StringBuilder> объекта и попытка добавления символов или разверните его за пределы максимальной вместимости создает либо <xref:System.ArgumentOutOfRangeException> или <xref:System.OutOfMemoryException> исключение.  
  
 В следующем примере показано как <xref:System.Text.StringBuilder> объект выделяет новую память и его емкость динамически увеличивается расширяет строку, назначенный объекту. Код создает <xref:System.Text.StringBuilder> путем вызова его конструктора (без параметров) по умолчанию. Емкость по умолчанию данного объекта по 16 символов, которое приближается к максимальному более 2 миллиардов знаков. Добавление строки «Это предложение». приводит новое выделение памяти, так как длина строки (19 символов) превышает емкость по умолчанию <xref:System.Text.StringBuilder> объекта. Емкость объекта удваивается до 32 символов, добавляется новая строка и длину объекта теперь равно 19 символов. Затем код добавляет строку «This is Дополнительные предложения». значение <xref:System.Text.StringBuilder> объекта 11 раз. Каждый раз, когда операции добавления вызывает длину <xref:System.Text.StringBuilder> вдвое превышать его емкость вместимости существующего объекта и <xref:System.Text.StringBuilder.Append%2A> операция выполнена успешно.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Выделение памяти  
 Емкость по умолчанию <xref:System.Text.StringBuilder> объект — 16 символов, а его максимальная емкость по умолчанию — <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Эти значения по умолчанию используются в том случае, если вы вызываете <xref:System.Text.StringBuilder.%23ctor> и <xref:System.Text.StringBuilder.%23ctor%28System.String%29> конструкторы.  
  
 Можно явно определить исходная емкость <xref:System.Text.StringBuilder> объект одним из следующих способов:  
  
-   При вызовах <xref:System.Text.StringBuilder> конструкторы, которые включает в себя `capacity` при создании объекта.  
  
-   Назначив новое значение явным образом <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> свойство, чтобы развернуть существующий <xref:System.Text.StringBuilder> объекта. Обратите внимание, что свойство вызывает исключение, если новое значение емкости меньше, чем существующий емкости или больше, чем <xref:System.Text.StringBuilder> Максимальная емкость объекта.  
  
-   Путем вызова <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> метод с новым значением емкости. Новое значение емкости не должно быть больше, чем <xref:System.Text.StringBuilder> Максимальная емкость объекта. Тем не менее, в отличие от присвоения <xref:System.Text.StringBuilder.Capacity%2A> свойства <xref:System.Text.StringBuilder.EnsureCapacity%2A> не выдает исключение, если требуемый новое значение емкости меньше, чем емкость; таким образом, вызов метода не влияет.  
  
 Если назначено длину строки <xref:System.Text.StringBuilder> объект в вызове конструктора превышает емкость по умолчанию или указанной емкостью <xref:System.Text.StringBuilder.Capacity%2A> свойство имеет значение длины строки, указанной с помощью `value` параметра.  
  
 Можно явно определить максимальную емкость <xref:System.Text.StringBuilder> путем вызова метода <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> конструктор. Невозможно изменить максимальную емкость путем присвоения нового значения для <xref:System.Text.StringBuilder.MaxCapacity%2A> свойство, так как она доступна только для чтения.  
  
 Как в предыдущем разделе показано, всякий раз, когда емкость памяти недостаточно, дополнительно выделяется и емкость <xref:System.Text.StringBuilder> объекта удваивается до значения, определяемого <xref:System.Text.StringBuilder.MaxCapacity%2A> свойство.  
  
 Как правило емкость по умолчанию и максимальная емкость адекватны для большинства приложений. Можно принять эти значения при следующих условиях:  
  
-   Если конечный размер <xref:System.Text.StringBuilder> объект высокой вероятностью расширяться чрезвычайно большого, обычно сверх несколько мегабайт. В этом случае может быть некоторое повышение производительности от установки начального <xref:System.Text.StringBuilder.Capacity%2A> свойство значение большим, чтобы устранить необходимость использования более слишком много памяти.  
  
-   Если ваше приложение работает в системе с ограниченным объемом памяти. В этом случае может понадобиться рассмотреть параметр <xref:System.Text.StringBuilder.MaxCapacity%2A> значение меньше, чем <xref:System.Int32.MaxValue?displayProperty=nameWithType> Если приложение обрабатывает больших строк, которые могут вызвать его для выполнения в среде, ограниченных в памяти.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Создание экземпляра объекта StringBuilder  
 Вы создаете экземпляры <xref:System.Text.StringBuilder> объекта путем вызова одного из его шесть перегруженные конструкторы класса, которые перечислены в следующей таблице. Три из конструкторов для создания экземпляра <xref:System.Text.StringBuilder> объекта, значение которого является пустой строкой, но установить его <xref:System.Text.StringBuilder.Capacity%2A> и <xref:System.Text.StringBuilder.MaxCapacity%2A> значения по-разному. Остальные три конструктора определяют <xref:System.Text.StringBuilder> объект, имеющий значение подстроки и емкости. Два из трех конструкторов использовать по умолчанию максимальная емкость <xref:System.Int32.MaxValue?displayProperty=nameWithType>, а третий позволяет задать максимальную емкость.  
  
|Конструктор|Строковое значение|Емкость|Максимальная емкость|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Определяется `capacity` параметр|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Определяется `capacity` параметр|Определяется `maxCapacity` параметр|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Определяется `value` параметр|16 или `value`. <xref:System.String.Length%2A>, какое значение больше|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Определяется `value` параметр|Определяется `capacity` параметр или `value`. <xref:System.String.Length%2A>, какое значение больше.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Определяется в `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Определяется `capacity` параметр или `value`. <xref:System.String.Length%2A>, какое значение больше.|Определяется `maxCapacity` параметр|  
  
 В следующем примере используется три из этих перегрузок конструктора для создания экземпляра <xref:System.Text.StringBuilder> объектов.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Вызов методов StringBuilder  
 Большинство методов, измените строку в <xref:System.Text.StringBuilder> экземпляра возвращают ссылку на тот же экземпляр. Это позволяет вызывать <xref:System.Text.StringBuilder> методы двумя способами:  
  
-   Можно вызывать отдельные методы и игнорировать возвращаемое значение, как показано в следующем примере.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   Можно сделать ряд вызовов методов в одной инструкции. Это может быть удобно, если для одного оператора, который добавляет последовательных операций записи. Следующий пример объединяет три вызова метода из предыдущего примера в одну строку кода.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Выполнение операций StringBuilder  
 Можно использовать методы <xref:System.Text.StringBuilder> класса для выполнения итерации, добавление, удаление и изменение символов в <xref:System.Text.StringBuilder> объекта.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Итерация StringBuilder символов  
 Можно получить доступ к символы в <xref:System.Text.StringBuilder> объекта с помощью <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> свойство. В C# <xref:System.Text.StringBuilder.Chars%2A> является индексатором; в Visual Basic, это свойство по умолчанию <xref:System.Text.StringBuilder> класса. Это дает возможность задать или извлечь отдельные символы с использованием только индексов без явного указания ссылки <xref:System.Text.StringBuilder.Chars%2A> свойство. Символы в <xref:System.Text.StringBuilder> объект начинаются с индексом 0 (ноль) и индексировать по-прежнему <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 В следующем примере показано <xref:System.Text.StringBuilder.Chars%2A> свойство. Десять случайных чисел, чтобы к нему добавляется <xref:System.Text.StringBuilder> объекта, а затем выполняет итерацию каждого символа. Если категории символов Юникода <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, он сокращает число на 1 (или меняется на 9 номер, если его значение равно 0). В примере отображается содержимое <xref:System.Text.StringBuilder> оба объекта до и после изменения значений отдельных символов.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Добавление текста в объект StringBuilder  
 <xref:System.Text.StringBuilder> Класс включает следующие методы для расширения содержимого <xref:System.Text.StringBuilder> объекта:  
  
-   <xref:System.Text.StringBuilder.Append%2A> Метод добавляет строка, подстроку, массив символов, часть в массив символов, один символ повторяется несколько раз, либо строковое представление примитивных типов данных тип на <xref:System.Text.StringBuilder> объекта.  
  
-   <xref:System.Text.StringBuilder.AppendLine%2A> Метод добавляет знак завершения строки или строки вместе с признаком конца строки для <xref:System.Text.StringBuilder> объекта.  
  
-   <xref:System.Text.StringBuilder.AppendFormat%2A> Метод добавляет к <xref:System.Text.StringBuilder> объекта. Строковые представления объектов, включенных в результирующей строке может отражать соглашения о форматировании текущего языка и региональных параметров системы или указанного языка и региональных параметров.  
  
-   <xref:System.Text.StringBuilder.Insert%2A> Метод вставляет строка, подстроку, нескольких повторений строка, массив символов, часть массив символов, или строковое представление примитивных типов данных введите в указанной позиции в <xref:System.Text.StringBuilder> объекта. Отсчитываемый от нуля индекс, определяется положение.  
  
 В следующем примере используется <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, и <xref:System.Text.StringBuilder.Insert%2A> методы, чтобы развернуть текст <xref:System.Text.StringBuilder> объекта.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Удаление текста из объекта StringBuilder  
 <xref:System.Text.StringBuilder> Класс включает методы, которые можно уменьшить размер текущего <xref:System.Text.StringBuilder> экземпляра. <xref:System.Text.StringBuilder.Clear%2A> Метод удаляет все символы и задает <xref:System.Text.StringBuilder.Length%2A> свойства значение 0. <xref:System.Text.StringBuilder.Remove%2A> Метод удаляет указанное количество символов, начиная с определенного индекса позиции. Кроме того, можно удалить символы в конце <xref:System.Text.StringBuilder> объекта, задав его <xref:System.Text.StringBuilder.Length%2A> значение не меньше длины текущего экземпляра.  
  
 Следующий пример удаляет текст из <xref:System.Text.StringBuilder> объекта, отображается его итоговый емкости, максимальная емкость и значения свойств длиной, а затем вызывает <xref:System.Text.StringBuilder.Clear%2A> метод для удаления всех символов из <xref:System.Text.StringBuilder> объекта.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Изменение текста в объект StringBuilder  
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> Метод заменяет все вхождения символа или строки во всем <xref:System.Text.StringBuilder> объекта или в диапазоне определенный символ. В следующем примере используется <xref:System.Text.StringBuilder.Replace%2A> метод для замены всех точек восклицательный знак (!) вопросительные знаки (?) в <xref:System.Text.StringBuilder> объекта.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Поиск текста в объект StringBuilder  
 <xref:System.Text.StringBuilder> Класс включает методы, аналогичную <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, и <xref:System.String.StartsWith%2A?displayProperty=nameWithType> методы, предоставляемые <xref:System.String> класс, который можно выполнять поиск объектов, для конкретного символа или подстроки. Определение наличия или начальная позиция знака подстроки требуется выполнить <xref:System.String> значение с помощью поиска в строковый метод или метод регулярного выражения. Существует четыре способа для реализации такого поиска, как показано в следующей таблице.  
  
|Метод|Преимущества|Недостатки|  
|---------------|----------|----------|  
|Найдите строковые значения перед добавлением их к <xref:System.Text.StringBuilder> объекта.|Это удобно для определения того, существует ли подстрока.|Не может использоваться, если важно позицию индекса подстроки.|  
|Вызовите <xref:System.Text.StringBuilder.ToString%2A> и поиска, возвращенного <xref:System.String> объекта.|Прост в использовании при указании весь текст в <xref:System.Text.StringBuilder> объекта, а затем начните изменить его.|Неудобно в повторяющемся вызове <xref:System.Text.StringBuilder.ToString%2A> Если необходимо внести изменения, перед добавлением весь текст <xref:System.Text.StringBuilder> объекта.<br /><br /> Необходимо помнить, для работы с конца <xref:System.Text.StringBuilder> текста объекта, если вы вносите изменения.|  
|Используйте <xref:System.Text.StringBuilder.Chars%2A> свойство последовательно искомый диапазон символов.|Полезно, если вас интересует отдельные символы или небольшой подстроки.|Неудобно, если количество символов для поиска велико или логика поиска сложна.<br /><br />Приводит к очень низкой производительности для объектов, которые выросли очень больших через повторяющиеся вызовы.  |  
|Преобразовать <xref:System.Text.StringBuilder> объект <xref:System.String> объекта и внесения изменений на <xref:System.String> объекта.|Полезно, если количество изменений мал.|Инвертирует преимущества высокой производительности <xref:System.Text.StringBuilder> , если большое количество изменений.|  
  
 Давайте рассмотрим эти методы более подробно.  
  
-   Если цель поиска — для определения наличия определенной подстрокой (то есть, если вы не заинтересованы в положение подстроки), можно выполнить поиск строки перед их сохранением в <xref:System.Text.StringBuilder> объекта. Следующий пример предоставляет одна возможная реализация. Он определяет `StringBuilderFinder` класс, конструктор которого передается ссылка на <xref:System.Text.StringBuilder> объекта и в строке искомая подстрока. В этом случае в примере предпринимается попытка определить ли записанные температуры в шкале Цельсия или Фаренгейта и добавляет соответствующие вводного текста в начале <xref:System.Text.StringBuilder> объекта. Генератор случайных чисел используется для выбора массив, содержащий данные в градусах Цельсия или Фаренгейта.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Вызовите <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> метод для преобразования <xref:System.Text.StringBuilder> объект <xref:System.String> объекта. Выполните поиск строки с помощью методов, таких как <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> или <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, или можно использовать регулярные выражения и <xref:System.Text.RegularExpressions.Regex> класса для поиска шаблонов. Так как оба <xref:System.Text.StringBuilder> и <xref:System.String> объекты используют для хранения символов, значения индекса этих символов, подстрок, кодировкой UTF-16 и совпадения регулярного выражения одинаковы в обоих объектах. Это позволяет использовать <xref:System.Text.StringBuilder> методы для внесения изменений в той же позиции, по которому этот текст, обнаруженный в <xref:System.String> объекта.  
  
    > [!NOTE]
    >  Если будет применен такой подход, вы должны работать с конца <xref:System.Text.StringBuilder> объекта для его начала, чтобы не нужно повторно преобразовать <xref:System.Text.StringBuilder> объект в строку.  
  
     Этот подход показан в приведенном ниже примере. Он сохраняет четыре вхождения каждой буквы английского алфавита в <xref:System.Text.StringBuilder> объекта. Затем он преобразует текст, <xref:System.String> и использует регулярное выражение для идентификации начальное положение каждой последовательности четырех символов. Наконец добавляется символ подчеркивания перед каждой последовательности четырех символов, за исключением первой последовательности и преобразует первый знак последовательности в верхний регистр.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Используйте <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> свойства диапазон символов в последовательно <xref:System.Text.StringBuilder> объекта. Этот подход может оказаться практические Если количество символов для поиска имеет большой размер или логике поиска особенно сложен. Для последствия для производительности символ за символом доступа на основе индекса для очень больших, chunked <xref:System.Text.StringBuilder> объектов, см. в документации <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> свойство. 
  
     Следующий пример идентичен предыдущему примеру функциональных возможностей, но отличается в реализации. Она использует <xref:System.Text.StringBuilder.Chars%2A> свойство, чтобы определить, когда изменилось значение символа, вставляет символ подчеркивания в этой позиции и преобразует в верхний регистр первый символ в новой последовательности.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Store без изменений текста в <xref:System.Text.StringBuilder> , вызовите <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> метод для преобразования <xref:System.Text.StringBuilder> объект <xref:System.String> объекта и внесения изменений на <xref:System.String> объекта. Этот подход можно использовать при наличии нескольких изменений; в противном случае стоимость работы со строками неизменяемый может отменить преимущества производительности с помощью <xref:System.Text.StringBuilder> объекта.  
  
     В следующем примере же функциональность для двух предыдущих примеров, но отличается в реализации. Он создает <xref:System.Text.StringBuilder> объекта, преобразует ее в <xref:System.String> объекта, а затем использует регулярное выражение для выполнения всех оставшихся изменений в строке. <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Метод использует лямбда-выражение для выполнения замены каждого соответствия.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Преобразование объекта StringBuilder в строку  
 Необходимо преобразовать объект <xref:System.Text.StringBuilder> в <xref:System.String>, прежде чем передавать представленную объектом <xref:System.Text.StringBuilder> строку методу, который содержит параметр <xref:System.String>, или вывести ее в пользовательском интерфейсе. Выполнить это преобразование путем вызова <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> метод. Иллюстрация, см. в предыдущем примере, который вызывает <xref:System.Text.StringBuilder.ToString%2A> метод для преобразования <xref:System.Text.StringBuilder> объекта в строку, таким образом, его можно передать в метод регулярного выражения.  
  
   
  
## Examples  
 В следующем примере показано, как вызывать многие из методов, определенных <xref:System.Text.StringBuilder> класса.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строковое значение данного экземпляра присваивается <xref:System.String.Empty?displayProperty=nameWithType>, и параметр capacity имеет значение емкости по умолчанию зависит от реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор без параметров.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Предлагаемый начальный размер этого экземпляра.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />, используя указанную емкость.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Параметр определяет максимальное количество символов, которые могут храниться в памяти, назначенной текущим экземпляром. Его значение будет назначено <xref:System.Text.StringBuilder.Capacity%2A> свойство. Если количество символов для сохранения в текущем экземпляре превышает это `capacity` значение, <xref:System.Text.StringBuilder> объект выделяет дополнительную память для их хранения.  
  
 Строковое значение данного экземпляра присваивается <xref:System.String.Empty?displayProperty=nameWithType>. Если `capacity` равно нулю, используется емкость по умолчанию зависит от реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с указанной емкостью.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="capacity" /> меньше нуля.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка, используемая для инициализации значения экземпляра. Если <paramref name="value" /> равно <see langword="null" />, то новый <see cref="T:System.Text.StringBuilder" /> будет содержать пустую строку (то есть, он содержит <see cref="F:System.String.Empty" />).</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />, используя указанную строку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `value` равно `null`, то новый <xref:System.Text.StringBuilder> будет содержать пустую строку (то есть, он содержит <xref:System.String.Empty>).  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с указанной строкой.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Предлагаемый начальный размер <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">Наибольшее допустимое количество знаков в текущей строке.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />, который начинается с указанной емкости и может увеличиваться до указанного максимального значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Параметр определяет максимальное количество символов, которые могут храниться в памяти, назначенной текущим экземпляром. Его значение будет назначено <xref:System.Text.StringBuilder.Capacity%2A> свойство. Если количество символов для сохранения в текущем экземпляре превышает это `capacity` значение, <xref:System.Text.StringBuilder> объект выделяет дополнительную память для их хранения.  
  
 Если `capacity` равно нулю, используется емкость по умолчанию зависит от реализации.  
  
 `maxCapacity` Свойство определяет максимальное количество символов, содержащихся в текущем экземпляре. Его значение будет назначено <xref:System.Text.StringBuilder.MaxCapacity%2A> свойство. Если количество символов для сохранения в текущем экземпляре превышает это `maxCapacity` значение, <xref:System.Text.StringBuilder> объект не выделить дополнительную память, но вместо этого формируется исключение.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с указанной емкости и максимальная емкость.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" /> меньше единицы, <paramref name="capacity" /> меньше нуля, или <paramref name="capacity" /> больше <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка, используемая для инициализации значения экземпляра. Если <paramref name="value" /> равно <see langword="null" />, то новый <see cref="T:System.Text.StringBuilder" /> будет содержать пустую строку (то есть, он содержит <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">Предлагаемый начальный размер <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />, используя указанную строку и емкость.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Параметр определяет максимальное количество символов, которые могут храниться в памяти, назначенной текущим экземпляром. Его значение будет назначено <xref:System.Text.StringBuilder.Capacity%2A> свойство. Если количество символов для сохранения в текущем экземпляре превышает это `capacity` значение, <xref:System.Text.StringBuilder> объект выделяет дополнительную память для их хранения.  
  
 Если `capacity` равно нулю, используется емкость по умолчанию зависит от реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с начальной строки и указанной емкостью.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="capacity" /> меньше нуля.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка, содержащая подстроку, применяемую для инициализации значения этого экземпляра. Если <paramref name="value" /> равно <see langword="null" />, то новый <see cref="T:System.Text.StringBuilder" /> будет содержать пустую строку (то есть, он содержит <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">Позиция в пределах <paramref name="value" />, с которой начинается подстрока.</param>
        <param name="length">Число символов в подстроке.</param>
        <param name="capacity">Предлагаемый начальный размер <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" /> из указанной подстроки и емкости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Параметр определяет максимальное количество символов, которые могут храниться в памяти, назначенной текущим экземпляром. Его значение будет назначено <xref:System.Text.StringBuilder.Capacity%2A> свойство. Если количество символов для сохранения в текущем экземпляре превышает это `capacity` значение, <xref:System.Text.StringBuilder> объект выделяет дополнительную память для их хранения.  
  
 Если `capacity` равно нулю, используется емкость по умолчанию зависит от реализации.  
  
   
  
## Examples  
 Следующий пример демонстрирует вызов <xref:System.Text.StringBuilder.%23ctor%2A> конструктор с указанной строкой.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="capacity" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> плюс <paramref name="length" /> не является позицией в <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет строковое представление указанного объекта к данному экземпляру.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое логическое значение.</param>
        <summary>Добавляет строковое представление указанного логического значения к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Вызовы методов <xref:System.Boolean.ToString?displayProperty=nameWithType> метод, чтобы получить строковое представление `value`. При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 8-разрядного целого числа без знака к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> Вызовы методов <xref:System.Byte.ToString%28System.IFormatProvider%29> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Единица кода в кодировке UTF-16 для добавления.</param>
        <summary>Добавляет строковое представление указанного объекта <see cref="T:System.Char" /> в данный экземпляр.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Массив символов для добавления.</param>
        <summary>Добавляет строковое представление символа Юникода в указанном массиве к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет все символы в указанном массиве для текущего экземпляра в том же порядке, как они указаны в `value`. Если `value` является `null`, изменения не вносятся.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного десятичного числа к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Вызовы методов <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного числа с плавающей запятой с удвоенной точностью к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> Вызовы методов <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 16-разрядного целого числа со знаком к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> Вызовы методов <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 32-разрядного целого числа со знаком к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> Вызовы методов <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 64-разрядного целого числа со знаком к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> Вызовы методов <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемый объект.</param>
        <summary>Добавляет строковое представление указанного объекта к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере. Он определяет `Dog` класса, создает `Dog` объекта и делает три вызова <xref:System.Text.StringBuilder.Append%2A> метод, чтобы создать строку, содержащую имя и в своем классе dog.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> Вызовы методов <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, чтобы получить строковое представление `value`. Если `value` — `null`, изменения не вносятся в <xref:System.Text.StringBuilder> объекта.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlyMemory`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlyMemory(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 8-разрядного целого числа со знаком к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> Вызовы методов <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного числа с плавающей запятой с обычной точностью к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> Вызовы методов <xref:System.Single.ToString%2A?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемая строка.</param>
        <summary>Добавляет копию указанной строки к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Если `value` является `null`, изменения не вносятся.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 16-разрядного целого числа без знака к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Вызовы методов <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value`. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 32-разрядного целого числа без знака к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Вызовы <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 64-разрядного целого числа без знака к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Вызовы методов <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> метод, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемый символ.</param>
        <param name="repeatCount">Сколько раз следует добавить <paramref name="value" />.</param>
        <summary>Добавляет указанное число копий строкового представления символа Юникода к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="repeatCount" /> меньше нуля.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на массив символов.</param>
        <param name="valueCount">Количество символов в массиве.</param>
        <summary>Добавляет к данному экземпляру массив символов Юникода начиная с указанного адреса.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет `valueCount` символов, начиная с адреса `value` текущему экземпляру.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="valueCount" /> меньше нуля.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> является пустым указателем</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Массив символов.</param>
        <param name="startIndex">Начальная позиция в массиве <paramref name="value" />.</param>
        <param name="charCount">Количество добавляемых знаков.</param>
        <summary>Добавляет строковое представление указанного дочернего массива символов Юникода к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет заданный диапазон символов в `value` текущему экземпляру. Если `value` — `null` и `startIndex` и `count` оба ноль, не изменяются.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> имеет значение <see langword="null" />, а <paramref name="startIndex" /> и <paramref name="charCount" /> не равны нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charCount" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="startIndex" /> меньше нуля.  
  
-или- 
 Значение <paramref name="startIndex" /> + <paramref name="charCount" /> превышает длину <paramref name="value" />.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка, содержащая добавляемую подстроку.</param>
        <param name="startIndex">Начальная позиция подстроки в пределах <paramref name="value" />.</param>
        <param name="count">Число знаков в подстроке <paramref name="value" /> для добавления.</param>
        <summary>Добавляет копию указанной подстроки к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет заданный диапазон символов в `value` текущему экземпляру. Если `value` — `null` и `startIndex` и `count` оба ноль, не изменяются.  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> Метод изменяет существующий экземпляр этого класса; он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство на существующую ссылку и не нужно присвоить значение, возвращаемое для <xref:System.Text.StringBuilder> объекта, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> имеет значение <see langword="null" />, а <paramref name="startIndex" /> и <paramref name="count" /> не равны нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> меньше нуля.  
  
-или- 
 Значение <paramref name="startIndex" /> + <paramref name="count" /> превышает длину <paramref name="value" />.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением соответствующего аргумента объекта.</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением одного аргумента.</summary>
        <returns>Ссылка на данный экземпляр с добавленным <paramref name="format" />. Каждый элемент формата в параметре <paramref name="format" /> заменяется строковым представлением параметра <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования. Индекс элемента форматирования должен быть 0, в соответствии с `arg0`, один объект в списке параметров этого метода. Процесс форматирования каждый элемент формата заменяется строковым представлением `arg0`.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` Представляет объект для форматирования. Каждый элемент формата в `format` заменяется строковым представлением `arg0`. Если элемент формата включает `formatString` и `arg0` реализует <xref:System.IFormattable> интерфейс, затем `arg0.ToString(formatString, null)` определяет форматирование. В противном случае `arg0.ToString()` определяет форматирование.  
  
 Если строка, назначенная `format` является «Спасибо за пожертвование {0: ###} консервных банок нашей благотворительной организации.» и `arg0` должно быть целым числом со значением 10, возвращаемое значение будет «Спасибо за пожертвование 10 консервных банок нашей благотворительной организации».  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или не меньше 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="args">Массив объектов для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением соответствующего аргумента в массиве параметров.</summary>
        <returns>Ссылка на данный экземпляр с добавленным <paramref name="format" />. Каждый элемент формата в параметре <paramref name="format" /> заменяется строковым представлением соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процессе форматирования каждый элемент формата заменяется строковым представлением соответствующего объекта.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args` Представляет объекты, которые необходимо отформатировать. Каждый элемент формата в `format` заменяется строковым представлением соответствующего объекта в `args`. Если элемент формата включает `formatString` и соответствующего объекта в `args` реализует <xref:System.IFormattable> интерфейс, затем `args[index].ToString(formatString, provider)` определяет форматирование. В противном случае `args[index].ToString()` определяет форматирование.  
  
 Если строка, назначенная `format` является «Спасибо за пожертвование {0: ###} консервных банок нашей благотворительной организации.» и `arg0` должно быть целым числом со значением 10, возвращаемое значение будет «Спасибо за пожертвование 10 консервных банок нашей благотворительной организации».  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="format" /> или <paramref name="args" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше либо равен длине массива <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением одного аргумента с использованием указанного поставщика формата.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления. После операции добавления этот экземпляр содержит все данные, существовавшие до операции, к которым добавляется копия параметра <paramref name="format" />, где все спецификации форматирования заменяются представлением <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения `arg0` текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования. Индекс каждого элемента форматирования должен равняться нулю (0), так как этот метод содержит список аргументов с одним аргументом. Процесс форматирования каждый элемент формата заменяется строковым представлением `arg0`.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. В этом случае с момента <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> метод имеет один аргумент в списке аргументов, значение *индекс* всегда должен быть 0. Если это не так, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Параметр указывает <xref:System.IFormatProvider> реализация, которую может предоставить сведения о форматировании для объектов в `args`. Параметр `provider` может иметь любое из следующих значений.  
  
-   Объект <xref:System.Globalization.CultureInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` если он является числовым значением.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` Если это значение даты и времени.  
  
-   Пользовательский <xref:System.IFormatProvider> реализация, которая предоставляет сведения о форматировании `arg0`. Как правило, также реализует такой реализации <xref:System.ICustomFormatter> интерфейс.  
  
 Если `provider` параметр `null`, форматирования сведения извлекаются из текущего языка и региональных параметров.  
  
 `arg0` Представляет объект для форматирования. Каждый элемент формата в `format` заменяется строковым представлением `arg0`. Если элемент формата включает `formatString` и `arg0` реализует <xref:System.IFormattable> интерфейс, затем `arg0.ToString(formatString, provider)` определяет форматирование. В противном случае `arg0.ToString()` определяет форматирование.  
  
   
  
## Examples  
 Включает в себя следующие два вызова <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> метод. Используют соглашения о форматировании языка и региональных параметров Английский — Великобритания (en-GB). Первый Вставляет строковое представление <xref:System.Decimal> значение валюты в результирующую строку. Второй операции вставки <xref:System.DateTime> значение в двух местах, в результате строки, первый включая только для краткосрочного Дата строки, а вторая строка короткого времени.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше либо равен единице.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Практическое руководство. Определение и использование настраиваемых поставщиков числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">Строка составного формата.</param>
        <param name="args">Массив объектов для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением соответствующего аргумента в массиве параметров с помощью указанного поставщика формата.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления. После операции добавления этот экземпляр содержит все данные, существовавшие до операции, к которым добавляется копия параметра <paramref name="format" />, где все спецификации форматирования заменяются представлением строки соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процессе форматирования каждый элемент формата заменяется строковым представлением соответствующего объекта.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Параметр указывает <xref:System.IFormatProvider> реализация, которую может предоставить сведения о форматировании для объектов в `args`. Параметр `provider` может иметь любое из следующих значений.  
  
-   Объект <xref:System.Globalization.CultureInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения об особенностях язык и региональные параметры форматирования для числовых значений в `args`.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo> объект, предоставляющий сведения об особенностях язык и региональные параметры форматирования для значений даты и времени в `args`.  
  
-   Пользовательский <xref:System.IFormatProvider> реализация, которая предоставляет сведения о форматировании для одного или нескольких объектов в `args`. Как правило, также реализует такой реализации <xref:System.ICustomFormatter> интерфейс. Во втором примере в следующем разделе показан <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> вызов метода с пользовательским <xref:System.IFormatProvider> реализации.  
  
 Если `provider` параметр `null`, сведения о поставщике формата получается из текущего языка и региональных параметров.  
  
 `args` Представляет объекты, которые необходимо отформатировать. Каждый элемент формата в `format` заменяется строковым представлением соответствующего объекта в `args`. Если элемент формата включает `formatString` и соответствующего объекта в `args` реализует <xref:System.IFormattable> интерфейс, затем `args[index].ToString(formatString, provider)` определяет форматирование. В противном случае `args[index].ToString()` определяет форматирование.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 В следующем примере определяется пользовательский <xref:System.IFormatProvider> реализацию, именуемую `CustomerFormatter` , форматы чисел с дефисами клиента 10-значный после четвертая и седьмая цифр. Он передается <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> метод, чтобы создать строку, содержащую номер форматированный клиента и имя клиента.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше либо равен длине массива <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Практическое руководство. Определение и использование настраиваемых поставщиков числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением любого из двух аргументов.</summary>
        <returns>Ссылка на данный экземпляр с добавленным <paramref name="format" />. Каждый элемент формата в параметре <paramref name="format" /> заменяется строковым представлением соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют `arg0` и `arg1`, два объекта в списке параметров этого метода. Процессе форматирования каждый элемент формата заменяется строковым представлением соответствующего объекта.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` и `arg1` представляют объекты, которые необходимо отформатировать. Каждый элемент формата в `format` заменяется строковым представлением любого `arg0` или `arg1`. Если элемент формата включает `formatString` и соответствующий объект реализует <xref:System.IFormattable> интерфейс, затем `arg` *x* `.ToString(formatString, provider)` определяет форматирование, где *x* — Это индекс аргумента. В противном случае `arg` *x* `.ToString()` определяет форматирование.  
  
 Если строка, назначенная `format` является «Спасибо за пожертвование {0: ###} консервных банок нашей благотворительной организации.» и `arg0` должно быть целым числом со значением 10, возвращаемое значение будет «Спасибо за пожертвование 10 консервных банок нашей благотворительной организации».  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше либо равен двум.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением любого из двух аргументов с помощью указанного поставщика формата.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления. После операции добавления этот экземпляр содержит все данные, существовавшие до операции, к которым добавляется копия параметра <paramref name="format" />, где все спецификации форматирования заменяются представлением строки соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процессе форматирования каждый элемент формата заменяется строковым представлением соответствующего объекта.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Параметр указывает <xref:System.IFormatProvider> реализация, которую может предоставить сведения о форматировании `arg0` и `arg1`. Параметр `provider` может иметь любое из следующих значений.  
  
-   Объект <xref:System.Globalization.CultureInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` или `arg1` если они являются числовыми значениями.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` или `arg1` если они значений даты и времени.  
  
-   Пользовательский <xref:System.IFormatProvider> реализация, которая предоставляет сведения о форматировании `arg0` и `arg1`. Как правило, также реализует такой реализации <xref:System.ICustomFormatter> интерфейс.  
  
 Если `provider` параметр `null`, сведения о поставщике формата получается из текущего языка и региональных параметров.  
  
 `arg0` и `arg1` представляют объекты, которые необходимо отформатировать. Каждый элемент формата в `format` заменяется строковым представлением объект, имеющий соответствующий индекс. Если элемент формата включает `formatString` и соответствующий аргумент реализует <xref:System.IFormattable> интерфейс, а затем аргумента `ToString(formatString, provider)` метод определяет форматирование. В противном случае аргумент `ToString()` метод определяет форматирование.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> метод для отображения данных температуры и времени, хранящиеся в универсальной <xref:System.Collections.Generic.Dictionary%602> объекта. Обратите внимание на то, что строка формата имеет три элемента форматирования, несмотря на то, что существует только для объектов для форматирования. Это, так как первый объект в списке (значение даты и времени) используются элементы два формата: Первый формат элемента отображает время, а вторая отображает дату.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше либо равен двум.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Практическое руководство. Определение и использование настраиваемых поставщиков числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <param name="arg2">Третий объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением любого из трех аргументов.</summary>
        <returns>Ссылка на данный экземпляр с добавленным <paramref name="format" />. Каждый элемент формата в параметре <paramref name="format" /> заменяется строковым представлением соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют `arg0` через `arg2`, объекты в списке параметров этого метода. Процессе форматирования каждый элемент формата заменяется строковым представлением соответствующего объекта.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`, и `arg2` представляют объекты, которые необходимо отформатировать. Каждый элемент формата в `format` заменяется строковым представлением любого `arg0`, `arg1`, или `arg2`в зависимости от индекса элемента форматирования. Если элемент формата включает `formatString` и соответствующего объекта в `args` реализует <xref:System.IFormattable> интерфейс, затем `arg` *x* `.ToString(formatString, null)` определяет форматирование, где  *x* — это индекс аргумента. В противном случае `arg` *x* `.ToString()` определяет форматирование.  
  
 Если строка, назначенная `format` является «Спасибо за пожертвование {0: ###} консервных банок нашей благотворительной организации.» и `arg0` должно быть целым числом со значением 10, возвращаемое значение будет «Спасибо за пожертвование 10 консервных банок нашей благотворительной организации».  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendFormat%2A> метод.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля либо больше или равен 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <param name="arg2">Третий объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением любого из трех аргументов с помощью указанного поставщика формата.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления. После операции добавления этот экземпляр содержит все данные, существовавшие до операции, к которым добавляется копия параметра <paramref name="format" />, где все спецификации форматирования заменяются представлением строки соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составного форматирования](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework для преобразования значения объекта в текстовое представление и встроить это представление в текущем <xref:System.Text.StringBuilder> объекта.  
  
 `format` Параметр состоит из нуля или более текста перемежающихся ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процессе форматирования каждый элемент формата заменяется строковым представлением соответствующего объекта.  
  
 Синтаксис элемента формата выглядит следующим образом:  
  
 {*индекс*[,*длина*] [:*formatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*Индекс*|Отсчитываемый от нуля позиция в списке параметров объекта для форматирования. Если объект, определенный параметром *индекс* — `null`, элемент формата заменяется <xref:System.String.Empty?displayProperty=nameWithType>. При отсутствии параметра в *индекс* позиции, <xref:System.FormatException> возникает исключение.|  
|,*длина*|Минимальное число символов в строковое представление параметра. Если оно положительное, параметр по правому краю; Если оно отрицательное, оно по левому краю.|  
|:*formatString*|Строка стандартного или настраиваемого формата, поддерживаемый параметр.|  
  
> [!NOTE]
>  Стандартные и настраиваемые строки форматирования значений даты и времени, см. в разделе [Standard Date и Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательские строки даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Стандартные и настраиваемые строки форматирования числовых значений, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [пользовательские строки форматирования чисел](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые для перечислений, см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Параметр указывает <xref:System.IFormatProvider> реализация, которую может предоставить сведения о форматировании `arg0` и `arg1`. Параметр `provider` может иметь любое из следующих значений.  
  
-   Объект <xref:System.Globalization.CultureInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0` или `arg1` если они являются числовыми значениями.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo> объект, предоставляющий сведения о форматировании региональных `arg0`, `arg1`, или `arg2` если они значений даты и времени.  
  
-   Пользовательский <xref:System.IFormatProvider> реализация, которая предоставляет сведения о форматировании `arg0`, `arg1`, и `arg2`. Как правило, также реализует такой реализации <xref:System.ICustomFormatter> интерфейс.  
  
 Если `provider` параметр `null`, сведения о поставщике формата получается из текущего языка и региональных параметров.  
  
 `arg0`, `arg1`, и `arg2` представляют объекты, которые необходимо отформатировать. Каждый элемент формата в `format` заменяется строковым представлением объект, имеющий соответствующий индекс. Если элемент формата включает `formatString` и соответствующий аргумент реализует <xref:System.IFormattable> интерфейс, а затем аргумента `ToString(formatString, provider)` метод определяет форматирование. В противном случае аргумент `ToString()` метод определяет форматирование.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> метод, чтобы проиллюстрировать результат логического значения `And` операции с помощью целочисленных значений. Обратите внимание, строка формата содержит шесть элементов форматирования, что метод имеет только три элемента в списке аргументов, так как каждый элемент форматируется двумя разными способами.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или не меньше трех.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысила бы <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Практическое руководство. Определение и использование настраиваемых поставщиков числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет знак завершения строки по умолчанию или копию указанной строки и знак завершения строки по умолчанию в конце этого экземпляра.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Добавляет знак завершения строки по умолчанию в конец текущего объекта <see cref="T:System.Text.StringBuilder" />.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Знак завершения строки по умолчанию является текущее значение <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> свойства.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.AppendLine%2A> метод.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемая строка.</param>
        <summary>Добавляет копию указанной строки и знак завершения строки по умолчанию в конец текущего объекта <see cref="T:System.Text.StringBuilder" />.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Знак завершения строки по умолчанию является текущее значение <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> свойства.  
  
 При необходимости корректируется емкость данного экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <see cref="T:System.Text.StringBuilder" /> путем вызова метода <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> конструктор, длина и емкость <see cref="T:System.Text.StringBuilder" /> экземпляр может выйти за пределы значение его <see cref="P:System.Text.StringBuilder.MaxCapacity" /> свойство. Это может произойти, особенно при вызове <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> методы для добавления небольших строк.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное число знаков, которое может содержаться в памяти, назначенной текущим экземпляром.</summary>
        <value>Максимальное число символов, которое может содержаться в памяти, назначенной текущим экземпляром. Это значение может меняться в диапазоне от <see cref="P:System.Text.StringBuilder.Length" /> до <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> не влияет на строковое значение текущего экземпляра. <xref:System.Text.StringBuilder.Capacity%2A> может быть уменьшен, поскольку он не меньше, чем <xref:System.Text.StringBuilder.Length%2A>.  
  
 <xref:System.Text.StringBuilder> Динамически выделяет больше пространства, при необходимости и увеличивает <xref:System.Text.StringBuilder.Capacity%2A> соответствующим образом. Для повышения производительности <xref:System.Text.StringBuilder> может выделять больше памяти, чем требуется. Размер выделенной памяти зависит от реализации.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Capacity%2A> свойство.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное для операции задания, меньше текущей длины данного экземпляра.  
  
-или- 
Значение, заданное для операции задания, больше максимальной емкости.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция символа.</param>
        <summary>Возвращает или задает символ на указанной позиции в данном экземпляре.</summary>
        <value>Символ Юникода в позиции <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Параметр — это положение символа в <xref:System.Text.StringBuilder>. Первый символ в строке находится по индексу 0. Длина строки — количество символов, содержащихся в нем. Последний доступный знак <xref:System.Text.StringBuilder> экземпляр является индексом <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> по умолчанию свойство <xref:System.Text.StringBuilder> класса. В C# это индексатора. Это означает, что отдельные символы могут быть получены от <xref:System.Text.StringBuilder.Chars%2A> свойства, как показано в следующем примере, который подсчитывает число является буквой алфавита, пробелы и знаков препинания в строку.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Производительность и символьного индексирования

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">При задании символа <paramref name="index" /> находится за пределами данного экземпляра.</exception>
        <exception cref="T:System.IndexOutOfRangeException">При получении символа <paramref name="index" /> находится за пределами данного экземпляра.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все символы из текущего экземпляра <see cref="T:System.Text.StringBuilder" />.</summary>
        <returns>Объект, длина <see cref="P:System.Text.StringBuilder.Length" /> которого равна 0 (нулю).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Text.StringBuilder.Clear%2A> удобный метод, которое эквивалентно значению параметра <xref:System.Text.StringBuilder.Length%2A> свойства текущего экземпляра 0 (ноль).  
  
## Examples

В следующем примере создается <xref:System.Text.StringBuilder> объекта со строкой, а вызовы <xref:System.Text.StringBuilder.Clear%2A> метод, а затем добавляет новую строку.  
  
[!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
[!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.Char[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Начальная позиция в этом экземпляре, откуда будут скопированы символы. Индексация начинается с нуля.</param>
        <param name="destination">Массив, в который копируются символы.</param>
        <param name="destinationIndex">Начальная позиция в массиве <paramref name="destination" />, в которую копируются символы. Индексация начинается с нуля.</param>
        <param name="count">Число копируемых знаков.</param>
        <summary>Копирует символы из указанного сегмента этого экземпляра в указанный массив <see cref="T:System.Char" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.CopyTo%2A> Метод должен использоваться в редких случаях, когда необходимо эффективно копировать последующих разделах <xref:System.Text.StringBuilder> в массив. Массив должен иметь фиксированный размер, выделенные для повторного использования и глобального доступа.  
  
 Например, приложение может заполнить <xref:System.Text.StringBuilder> объекта с большим числом символов, а затем используйте <xref:System.Text.StringBuilder.CopyTo%2A> метод копирования небольших, последовательные части <xref:System.Text.StringBuilder> в массив, в котором обрабатываются элементы. Когда все данные в <xref:System.Text.StringBuilder> обработки объекта, размер <xref:System.Text.StringBuilder> объекта, равным нулю, и цикл повторяется.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.CopyTo%2A> метод.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> или <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="sourceIndex" /> больше длины этого экземпляра.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" /> больше длины этого экземпляра.  
  
-или- 
 Значение <paramref name="destinationIndex" /> + <paramref name="count" /> превышает длину <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Минимальная емкость для проверки.</param>
        <summary>Гарантирует, что емкость данного экземпляра <see cref="T:System.Text.StringBuilder" /> не меньше указанного значения.</summary>
        <returns>Новая емкость этого экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий объем будет меньше, чем `capacity` параметра, происходит перераспределение памяти для данного экземпляра для по крайней мере `capacity` знаков; в противном случае изменения памяти не происходит.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.EnsureCapacity%2A> метод.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="capacity" /> меньше нуля.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span">Диапазон символов для сравнения с текущим экземпляром.</param>
        <summary>Возвращает значение, указывающее, соответствуют ли символы в этом экземпляре символам в указанном диапазоне символов, доступном только для чтения.</summary>
        <returns><see langword="true" />, если символы в этом экземпляре и в <paramref name="span" /> совпадают; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`Equals` Метод выполняет порядковое сравнение для определения ли символов в текущем экземпляре и `span` равны.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Объект, сравниваемый с этим экземпляром, или значение <see langword="null" />.</param>
        <summary>Возвращает значение, показывающее, равен ли данный экземпляр заданному объекту.</summary>
        <returns><see langword="true" />, если данный экземпляр и <paramref name="sb" /> имеют одинаковую строку, <see cref="P:System.Text.StringBuilder.Capacity" /> и значения <see cref="P:System.Text.StringBuilder.MaxCapacity" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

**.NET framework и .NET Core 2.2 и предыдущие версии:** Текущий экземпляр и `sb` равны, если они имеют одинаковую строку, <xref:System.Text.StringBuilder.Capacity>, и <xref:System.Text.StringBuilder.MaxCapacity> значения. `Equals` Метод использует сравнение по порядковому номеру, чтобы определить, равны ли строки.

**.NET core 3.0 и более поздних версий:** Текущий экземпляр и `sb` равны, если строки назначены классы <xref:System.Text.StringBuilder> одинаковы.  Для определения равенства, `Equals` метод использует сравнение по порядковому номеру. <xref:System.Text.StringBuilder.Capacity> И <xref:System.Text.StringBuilder.MaxCapacity> значения свойств не используются для сравнения.

## Examples  
 В следующем коде используется <xref:System.Text.StringBuilder.Equals%2A> метод для проверки двух <xref:System.Text.StringBuilder> объекты равны. Метод вызывается повторно после небольших изменений к каждому объекту, а результаты выводятся на консоль.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChunks">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder.ChunkEnumerator GetChunks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringBuilder/ChunkEnumerator GetChunks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.GetChunks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChunks () As StringBuilder.ChunkEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder::ChunkEnumerator GetChunks();" />
      <MemberSignature Language="F#" Value="member this.GetChunks : unit -&gt; System.Text.StringBuilder.ChunkEnumerator" Usage="stringBuilder.GetChunks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder+ChunkEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вставляет строковое представление указанного объекта в данный экземпляр на указанную позицию символа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление логического значения в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость настроена, при необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного 8-разрядного целого числа без знака в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного символа Юникода в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Массив символов для вставки.</param>
        <summary>Вставляет строковое представление указанного массива символов Юникода в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
 Если `value` — `null`, <xref:System.Text.StringBuilder> не изменяется.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление десятичного числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление числа с плавающей запятой с удвоенной точностью в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного 16-разрядного знакового целого числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного 32-разрядного знакового целого числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление 64-разрядного знакового целого числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Объект для вставки или значение <see langword="null" />.</param>
        <summary>Вставляет строковое представление объекта в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
 Если `value` является `null`, значение данного экземпляра остается неизменным.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного 8-разрядного знакового целого числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость настроена, при необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление числа одинарной точности с плавающей запятой с обычной точностью в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Строка, которую требуется вставить.</param>
        <summary>Вставляет строку в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость настроена, при необходимости.  
  
 Этот экземпляр <xref:System.Text.StringBuilder> изменяется не в том случае, если `value` — `null`, или `value` не `null` , но его длина равна нулю.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше текущей длины этого экземпляра.  
  
-или- 
Текущая длина этого объекта <see cref="T:System.Text.StringBuilder" /> плюс длина <paramref name="value" /> превышает <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление 16-разрядного целого числа без знака в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление 32-разрядного целого числа без знака в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление 64-разрядного целого числа без знака в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версий, вызовы этого метода вызвал <see cref="T:System.ArgumentOutOfRangeException" /> Если вставка <paramref name="value" /> для перевода объекта общая длина превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], метод вызывает <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Строка, которую требуется вставить.</param>
        <param name="count">Сколько раз следует вставить <paramref name="value" />.</param>
        <summary>Вставляет одну или более копий указанной строки в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
 Это <xref:System.Text.StringBuilder> объекта не изменяется, если `value` — `null`, `value` не `null` , но его длина равна нулю, или `count` равно нулю.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше текущей длины этого экземпляра.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.OutOfMemoryException">Текущая длина этого объекта <see cref="T:System.Text.StringBuilder" /> плюс длина <paramref name="value" /> <paramref name="count" /> раз превышает <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Массив символов.</param>
        <param name="startIndex">Начальный индекс внутри <paramref name="value" />.</param>
        <param name="charCount">Число символов для вставки.</param>
        <summary>Вставляет строковое представление указанного подмассива символов Юникода в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости корректируется емкость данного экземпляра.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Insert%2A> метод.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> имеет значение <see langword="null" />, а <paramref name="startIndex" /> и <paramref name="charCount" /> не равны нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="index" />, <paramref name="startIndex" /> или <paramref name="charCount" /> меньше нуля.  
  
-или- 
 <paramref name="index" /> больше длины этого экземпляра.  
  
-или- 
 <paramref name="startIndex" /> плюс <paramref name="charCount" /> не является позицией в <paramref name="value" />.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает длину текущего объекта <see cref="T:System.Text.StringBuilder" />.</summary>
        <value>Длина этого экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Длина <xref:System.Text.StringBuilder> объект определяется его число <xref:System.Char> объектов.  
  
 Как и <xref:System.String.Length%2A?displayProperty=nameWithType> свойства <xref:System.Text.StringBuilder.Length%2A> свойство, указывающее длину текущего строкового объекта. В отличие от <xref:System.String.Length%2A?displayProperty=nameWithType> свойство, которое доступно только для чтения, <xref:System.Text.StringBuilder.Length%2A> свойства можно изменить длину строки, хранящейся в <xref:System.Text.StringBuilder> объекта.  
  
 Если указанная длина меньше, чем текущая длина текущего <xref:System.Text.StringBuilder> объект усекается до указанной длины. Если указанная длина больше, чем текущая длина, конец строковое значение текущего <xref:System.Text.StringBuilder> объект дополняется символом NULL Юникода (U + 0000).  
  
 Если указанная длина больше текущей емкости, <xref:System.Text.StringBuilder.Capacity%2A> увеличивается, так как это не меньше указанной длины.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Length%2A> свойство.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, заданное для операции задания, меньше нуля или больше <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальную емкость данного экземпляра.</summary>
        <value>Наибольшее количество символов, которое может содержать данный экземпляр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Максимальная емкость для этой реализации — <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Тем не менее это значение зависит от реализации и может отличаться в других реализациях. Можно явно задать максимальную емкость <xref:System.Text.StringBuilder> путем вызова метода <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> конструктор.  
  
В .NET Core, а также в .NET Framework 4.0 и более поздних версий, при создании экземпляра <xref:System.Text.StringBuilder> путем вызова метода <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> конструктор, длина и емкость <xref:System.Text.StringBuilder> экземпляр может выйти за пределы значение его <xref:System.Text.StringBuilder.MaxCapacity> свойство. Это может произойти, особенно при вызове <xref:System.Text.StringBuilder.Append(System.String)> и <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> методы для добавления небольших строк.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Отсчитываемая с нуля позиция в данном экземпляре, с которой начинается удаление.</param>
        <param name="length">Число знаков для удаления.</param>
        <summary>Удаляет указанный диапазон символов из данного экземпляра.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции удаления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий метод удаляет указанный диапазон символов из текущего экземпляра. Символы в (`startIndex` + `length`) перемещаются `startIndex`, и строковое значение текущего экземпляра сокращается на `length`. Емкость текущего экземпляра не изменится.  
  
> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A> Метод изменяет значение текущего <xref:System.Text.StringBuilder> экземпляра и возвращает этот экземпляр. Создание и не возвращают новый <xref:System.Text.StringBuilder> объекта.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Remove%2A> метод.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Если <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля или <paramref name="startIndex" /> + <paramref name="length" /> больше длины этого экземпляра.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Замещает все вхождения указанного символа или строки в данном экземпляре на другой указанный символ или строку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Замещаемый символ.</param>
        <param name="newChar">Символ, замещающий <paramref name="oldChar" />.</param>
        <summary>Замещает все вхождения указанного символа в данном экземпляре на другой указанный знак.</summary>
        <returns>Ссылка на данный экземпляр с помощью <paramref name="oldChar" /> заменяется на <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение по порядковому номеру с учетом регистра для идентификации вхождения `oldChar` в текущем экземпляре. Размер текущего <xref:System.Text.StringBuilder> экземпляра остается неизменным после замены.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Replace%2A> метод.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Замещаемая строка.</param>
        <param name="newValue">Строка, замещающая <paramref name="oldValue" />, или <see langword="null" />.</param>
        <summary>Замещает все вхождения указанной строки в данном экземпляре на другую указанную строку.</summary>
        <returns>Ссылка на данный экземпляр со всеми экземплярами <paramref name="oldValue" /> заменяется на <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение по порядковому номеру с учетом регистра для идентификации вхождения `oldValue` в текущем экземпляре. Если `newValue` — `null` или <xref:System.String.Empty?displayProperty=nameWithType>, все вхождения `oldValue` удаляются.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Replace%2A> метод.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="oldValue" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">Замещаемый символ.</param>
        <param name="newChar">Символ, замещающий <paramref name="oldChar" />.</param>
        <param name="startIndex">Позиция в данном экземпляре, с которой начинается подстрока.</param>
        <param name="count">Длина подстроки.</param>
        <summary>Замещает все вхождения указанного символа в подстроке данного экземпляра на другой указанный символ.</summary>
        <returns>Ссылка на данный экземпляр с <paramref name="oldChar" /> заменяется на <paramref name="newChar" /> в диапазоне от <paramref name="startIndex" /> до <paramref name="startIndex" /> + <paramref name="count" /> –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение по порядковому номеру с учетом регистра для идентификации вхождения `oldChar` в текущем экземпляре. Размер текущего <xref:System.Text.StringBuilder> объект остается неизменным после замены.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Replace%2A> метод.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" /> больше длины значения этого экземпляра.  
  
-или- 
 Значение параметра <paramref name="startIndex" /> или <paramref name="count" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">Замещаемая строка.</param>
        <param name="newValue">Строка, замещающая <paramref name="oldValue" />, или <see langword="null" />.</param>
        <param name="startIndex">Позиция в данном экземпляре, с которой начинается подстрока.</param>
        <param name="count">Длина подстроки.</param>
        <summary>Замещает все вхождения указанной строки в подстроке данного экземпляра на другую указанную строку.</summary>
        <returns>Ссылка на данный экземпляр со всеми экземплярами <paramref name="oldValue" /> заменяется на <paramref name="newValue" /> в диапазоне от <paramref name="startIndex" /> до <paramref name="startIndex" /> + <paramref name="count" /> – 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет сравнение по порядковому номеру с учетом регистра для идентификации вхождения `oldValue` в указанной подстроки. Если `newValue` — `null` или <xref:System.String.Empty?displayProperty=nameWithType>, все вхождения `oldValue` удаляются.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.StringBuilder.Replace%2A> метод.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="oldValue" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> плюс <paramref name="count" /> указывает на позицию символа за пределами данного экземпляра.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Объект, который требуется заполнить информацией о сериализации.</param>
        <param name="context">Место для хранения и извлечения сериализованных данных. Зарезервировано для будущего использования.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными даты, необходимыми для десериализации текущего объекта <see cref="T:System.Text.StringBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `context` Параметр зарезервирован для использования в будущем и не участвует в этой операции.  
  
 Дополнительные сведения см. в описании метода <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> — <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразовывает значение типа <see cref="T:System.Text.StringBuilder" /> в значение <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразует значение данного экземпляра в <see cref="T:System.String" />.</summary>
        <returns>Строка, чье значение совпадает с данным экземпляром.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо вызвать <xref:System.Text.StringBuilder.ToString%2A> метод для преобразования <xref:System.Text.StringBuilder> объект <xref:System.String> перед можно передать строку, представленную объектом <xref:System.Text.StringBuilder> в метод, имеющий <xref:System.String> параметра или для отображения его в пользовательском интерфейсе.  
  
   
  
## Examples  
 В следующем примере демонстрируется вызов метода <xref:System.Text.StringBuilder.ToString%2A>. Этот пример является частью большего примера для <xref:System.Text.StringBuilder> класса.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Начальная позиция подстроки в данном экземпляре.</param>
        <param name="length">Длина подстроки.</param>
        <summary>Преобразует значение подстроки этого экземпляра в <see cref="T:System.String" />.</summary>
        <returns>Строка, чье значение совпадает с указанной подстрокой данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо вызвать <xref:System.Text.StringBuilder.ToString%2A> метод для преобразования <xref:System.Text.StringBuilder> объект <xref:System.String> перед можно передать строку, представленную объектом <xref:System.Text.StringBuilder> в метод, имеющий <xref:System.String> параметра или для отображения его в пользовательском интерфейсе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.  
  
-или- 
Сума значений <paramref name="startIndex" /> и <paramref name="length" /> превышает длину текущего экземпляра.</exception>
      </Docs>
    </Member>
  </Members>
</Type>