<Type Name="ValueSerializer" FullName="System.Windows.Markup.ValueSerializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7d0bcead4cb9eb4ed8e1e1bf4db32bff7b856e73" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57936554" /></Metadata><TypeSignature Language="C#" Value="public abstract class ValueSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ValueSerializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.ValueSerializer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ValueSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class ValueSerializer abstract" />
  <TypeSignature Language="F#" Value="type ValueSerializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Абстрактный класс, который определяет поведение преобразования сериализации из представления объекта.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строка, возвращаемая преобразователем для сериализации должна быть потерь и преобразователь должен всегда возвращать одну и ту же строку для каждого значения.  Если преобразователь типов (производный от <xref:System.ComponentModel.TypeConverter>) не соответствует этим требованиям, в его `ConvertTo` реализации для строковых выходных данных, пользовательский <xref:System.Windows.Markup.ValueSerializer> должен быть объявлен. Либо <xref:System.Windows.Markup.ValueSerializer> должен удовлетворять требованиям, или значение null <xref:System.Windows.Markup.ValueSerializer> должен быть связан с типом. Объект <xref:System.Windows.Markup.ValueSerializer> связан с типом, применяя <xref:System.Windows.Markup.ValueSerializerAttribute> атрибута.  
  
 Значение null <xref:System.Windows.Markup.ValueSerializer> указывает, следует игнорировать преобразователь типов для преобразования convert-string из графа объектов.  
  
> [!IMPORTANT]
>  Реализация <xref:System.Windows.Markup.ValueSerializer> следует избегать вызова исключений. Все исключения могут прервать сериализацию.  
  
 <xref:System.Windows.Markup.IValueSerializerContext> для <xref:System.Windows.Markup.ValueSerializer> и его API является аналогом <xref:System.ComponentModel.ITypeDescriptorContext> для <xref:System.ComponentModel.TypeConverter>. На самом деле <xref:System.Windows.Markup.IValueSerializerContext> наследует <xref:System.ComponentModel.ITypeDescriptorContext>. Когда <xref:System.Windows.Markup.ValueSerializer> вызывается производном классе API, вызывающий объект (обычно процесс сериализации) передает контекст, который может предоставить определенные службы. Из-за Общие рекомендации, <xref:System.Windows.Markup.ValueSerializer> не должны выдавать исключения. Ошибка возврата определенной службы из контекста должен также не создает исключений.  
  
 В предыдущих версиях .NET Framework этот класс существовали в сборке WindowsBase относящихся к WPF. В [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Windows.Markup.ValueSerializer> находится в сборке System.Xaml. Для получения дополнительной информации см. [Types Migrated from WPF to System.Xaml](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlXmlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ValueSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текст этого конструктора пуст; <xref:System.Windows.Markup.ValueSerializer> класс не содержит любые значения, которые требуется инициализация.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertFromString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertFromString (value As String, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Строка, для которой требуется проверить возможность преобразования.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>При переопределении в производном классе определяет, может ли указанный класс <see cref="T:System.String" /> быть преобразован в экземпляр типа, который поддерживается реализацией класса <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>Значение <see langword="true" />, если значение можно преобразовать; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация всегда возвращает значение `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertToString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertToString (value As Object, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Объект, для которого необходимо проверить возможность преобразования.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Если переопределено в производном классе, определяет, можно ли преобразовать указанный объект в <see cref="T:System.String" />.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="value" /> можно преобразовать в <see cref="T:System.String" />; в противном случае — значение <see langword="false." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация всегда возвращает значение `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public virtual object ConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertFromString (value As String, context As IValueSerializerContext) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj&#xA;override this.ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj" Usage="valueSerializer.ConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Преобразуемая строка.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>При переопределении в производном классе преобразует <see cref="T:System.String" /> в экземпляр типа, который поддерживает реализация <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>Новый экземпляр типа, который поддерживает реализация <see cref="T:System.Windows.Markup.ValueSerializer" />, на основе предоставленного <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация всегда создает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> невозможно преобразовать.</exception>
        <block subset="none" type="overrides"><para>Избегайте создания исключений в реализациях. См. раздел <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public virtual string ConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertToString (value As Object, context As IValueSerializerContext) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string&#xA;override this.ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string" Usage="valueSerializer.ConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Объект, преобразуемый в строку.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Если переопределено в производном классе, преобразует указанный объект в <see cref="T:System.String" />.</summary>
        <returns>Представление строки указанного объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация всегда создает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> невозможно преобразовать.</exception>
        <block subset="none" type="overrides"><para>Избегайте создания исключений в реализациях. См. раздел <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetConvertFromException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertFromException (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertFromException(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertFromException(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertFromException (value As Object) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertFromException(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetConvertFromException : obj -&gt; Exception" Usage="valueSerializer.GetConvertFromException value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который не удалось преобразовать.</param>
        <summary>Возвращает исключение, возникающее, если преобразование не может быть выполнено.</summary>
        <returns>Объект <see cref="T:System.Exception" /> для исключения, которое необходимо создать, если невозможно выполнить преобразование <see langword="ConvertFrom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактический `throw` ключевое слово не вызывается этим методом, поэтому обычно `throw GetConvertFromException` (с предоставленными параметрами).  
  
 Конкретное исключение возвращается <xref:System.InvalidOperationException>, с помощью `value` переданное сообщение об исключении. Шаблон для использования такое же, как служебные программы исключение в <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConvertToException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertToException (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertToException(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertToException(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertToException (value As Object, destinationType As Type) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertToException(System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.GetConvertToException : obj * Type -&gt; Exception" Usage="valueSerializer.GetConvertToException (value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="destinationType" Type="System.Type" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который не удалось преобразовать.</param>
        <param name="destinationType">Тип, представляющий тип, в который осуществлялось преобразование.</param>
        <summary>Возвращает исключение, возникающее, если преобразование не может быть выполнено.</summary>
        <returns>Объект <see cref="T:System.Exception" /> для исключения, которое необходимо создать, если невозможно выполнить преобразование <see langword="ConvertTo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактический `throw` ключевое слово не вызывается этим методом, поэтому типичный сценарий использования `throw GetConvertToException` (с `value` указан параметр).  
  
 Конкретное исключение возвращается <xref:System.InvalidOperationException>, с помощью `value` переданное сообщение об исключении. Шаблон для использования такое же, как служебные программы исключение в <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSerializerFor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает <see cref="T:System.Windows.Markup.ValueSerializer" /> для объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="descriptor">Дескриптор свойства CLR сериализуемого свойства.</param>
        <summary>Получает класс <see cref="T:System.Windows.Markup.ValueSerializer" />, объявленный для свойства, путем передачи свойству дескриптора свойства среды CLR.</summary>
        <returns>Сериализатор, связанный с заданным свойством. Может возвращать значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Markup.ValueSerializer> для свойства или для типа, который используется в качестве значения для свойства, указывается путем применения <xref:System.Windows.Markup.ValueSerializerAttribute> атрибут в объявлении типа или свойства. <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> Метод — это служебный метод, который считывает информации о системе типов CLR и возвращает новый <xref:System.Windows.Markup.ValueSerializer> класс на основе атрибута Если обнаружен на свойство, или затем, если на тип свойства. `null` может быть возвращено, если сериализатор не существует. `null` может также возвращаться Если тип или свойство намеренно помечается с помощью со значением null <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Другой режим, <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> поддерживает Возвращает внутренний `TypeConverterValueSerializer` класс, являющийся <xref:System.Windows.Markup.ValueSerializer> реализации, который заключает в оболочку <xref:System.ComponentModel.TypeConverter> и преобразует `Convert` методы для `Convert*String` методы (например <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>вызывается с входом из <xref:System.String> введите и транслирует <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Это делается только в тех случаях, где выполняются все следующие условия:  
  
-   Объект <xref:System.ComponentModel.TypeConverterAttribute> находится на соответствующее свойство или тип соответствующего свойства.  
  
-   Указанный <xref:System.ComponentModel.TypeConverter> может быть успешно создан.  
  
-   <xref:System.ComponentModel.TypeConverter> Возвращает `true` для <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>, с именем ссылки на <xref:System.String> типа.  
  
-   <xref:System.ComponentModel.TypeConverter> Возвращает `true` для <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>, с именем ссылки на <xref:System.String> типа.  
  
-   <xref:System.ComponentModel.TypeConverter> Возвращает `true` для <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>, с именем ссылки на <xref:System.String> типа.  
  
> [!NOTE]
>  Ниже приведены особые случаи: <xref:System.DateTime> типы возвращают <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> типы возвращаемые внутренним, но функциональные сериализатор (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descriptor" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type">Тип, для которого требуется получить <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <summary>Получает <see cref="T:System.Windows.Markup.ValueSerializer" />, объявленный для заданного типа.</summary>
        <returns>Сериализатор, связанный с заданным типом. Может возвращать значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Markup.ValueSerializer> для типа указывается путем применения <xref:System.Windows.Markup.ValueSerializerAttribute> атрибут объявления типа. <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> Метод — это служебный метод, который считывает информации о системе типов CLR и возвращает новый <xref:System.Windows.Markup.ValueSerializer> класса, основанных на атрибуте, если найден в указанном `type`. `null` может быть возвращено, если сериализатор не существует. `null` может также возвращаться Если тип намеренно атрибут со значением null <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Другой режим, <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> поддерживает Возвращает внутренний `TypeConverterValueSerializer` класс, являющийся <xref:System.Windows.Markup.ValueSerializer> реализации, который заключает в оболочку <xref:System.ComponentModel.TypeConverter> и преобразует `Convert` методы для `Convert*String` методы (например <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>вызывается с входом из <xref:System.String> введите и транслирует <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Это делается только в тех случаях, где выполняются все следующие условия:  
  
-   Объект <xref:System.ComponentModel.TypeConverterAttribute> находится на `type`.  
  
-   Указанный <xref:System.ComponentModel.TypeConverter> может быть успешно создан.  
  
-   <xref:System.ComponentModel.TypeConverter> Возвращает `true` для <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>, с именем ссылки на <xref:System.String> типа.  
  
-   <xref:System.ComponentModel.TypeConverter> Возвращает `true` для <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>, с именем ссылки на <xref:System.String> типа.  
  
-   <xref:System.ComponentModel.TypeConverter> Возвращает `true` для <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>, с именем ссылки на <xref:System.String> типа.  
  
> [!NOTE]
>  Ниже приведены особые случаи: <xref:System.DateTime> типы возвращают <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> типы возвращаемые внутренним, но функциональные сериализатор (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (descriptor, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="descriptor">Дескриптор сериализуемого свойства.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Получает <see cref="T:System.Windows.Markup.ValueSerializer" />, объявленный для заданного свойства с использованием заданного контекста.</summary>
        <returns>Сериализатор, связанный с заданным свойством.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо того чтобы полагаться исключительно на атрибуты указаны в системе типов CLR, эта перегрузка использует `context` как услуга и вызывает реализацию службы <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> Реализации также обычно полагаются на `descriptor`, но может реализовывать специальное поведение для определенных контекстов.  
  
 Этот метод должен вызываться, когда вызывающий объект имеет доступный <xref:System.Windows.Markup.IValueSerializerContext> из службы.  Это обеспечит правильное <xref:System.Windows.Markup.ValueSerializer> возвращается для данного контекста.  
  
 Возвращает контекст `null` из его <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> для указанных `descriptor`, или если вы укажите контекст `null`, а затем идентичен вызову <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.ComponentModel.PropertyDescriptor%29> перегрузки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descriptor" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type">Тип, для которого требуется получить <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Получает <see cref="T:System.Windows.Markup.ValueSerializer" />, объявленный для заданного типа с использованием заданного контекста.</summary>
        <returns>Сериализатор, связанный с заданным типом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо того чтобы полагаться исключительно на атрибуты указаны в системе типов CLR, эта перегрузка использует `context` как услуга и вызывает реализацию службы <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> Реализации также обычно полагаются на `type`, но может реализовывать специальное поведение для определенных контекстов.  
  
 Этот метод должен вызываться, когда вызывающий объект имеет доступный <xref:System.Windows.Markup.IValueSerializerContext> из службы. Это обеспечит правильное <xref:System.Windows.Markup.ValueSerializer> возвращается для данного контекста.  
  
 Возвращает контекст `null` из его <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> для указанных `type`, или если вы укажите контекст `null`, а затем идентичен вызову <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.Type%29> перегрузки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.TypeReferences(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TypeReferences (value As Object, context As IValueSerializerContext) As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;&#xA;override this.TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;" Usage="valueSerializer.TypeReferences (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Сериализуемое значение.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Получает перечисление типов, на которые ссылается <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>Типы, преобразуемые данным сериализатором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все типы <xref:System.Windows.Markup.ValueSerializer> преобразует должны быть включены в возвращаемом перечислении.  Это позволяет убедиться, что десериализатор имеет достаточно сведений о типах, которые преобразует данный сериализатор сериализатору.  
  
 Переопределение этого метода является расширенным сценарием. Переопределение должно быть обязательным, если вы реализуете системы где CLR тип системы свойство владельца связей для контекст схемы XAML, не передают достаточно информации.  
  
## <a name="wpf-usage-notes"></a>Примечания об использовании WPF  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Системы свойств реализует внутреннее значение сериализатора, который переопределяет <xref:System.Windows.Markup.ValueSerializer.TypeReferences%2A> так, как свойство зависимости имеет смысл, что оно может добавлено владельцев. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] выражения также имеют специальной внутренней обработки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>