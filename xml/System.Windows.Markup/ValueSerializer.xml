<Type Name="ValueSerializer" FullName="System.Windows.Markup.ValueSerializer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dfe7052738061deaaa68c30a6aaa5efc25671310" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30659958" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ValueSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ValueSerializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.ValueSerializer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ValueSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class ValueSerializer abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Абстрактный класс, который определяет поведение преобразования для сериализации из представления объекта.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строка, возвращаемая преобразователем для сериализации должна быть потерь и преобразователь должен всегда возвращать одну и ту же строку для каждого значения.  Если преобразователь типов (производный от <xref:System.ComponentModel.TypeConverter>) не соответствует этим требованиям в его `ConvertTo` реализации для строковых выходных данных, пользовательский <xref:System.Windows.Markup.ValueSerializer> должен быть объявлен. Либо <xref:System.Windows.Markup.ValueSerializer> должна соответствовать требованиям, или значение null <xref:System.Windows.Markup.ValueSerializer> должен быть связан с типом. Объект <xref:System.Windows.Markup.ValueSerializer> связан с типом, применяя <xref:System.Windows.Markup.ValueSerializerAttribute> атрибута.  
  
 Значение null <xref:System.Windows.Markup.ValueSerializer> указывает, следует игнорировать преобразователь типов для преобразования convert-string из графа объектов.  
  
> [!IMPORTANT]
>  Реализация <xref:System.Windows.Markup.ValueSerializer> следует избегать вызова исключений. Все исключения могут прервать сериализацию.  
  
 <xref:System.Windows.Markup.IValueSerializerContext> для <xref:System.Windows.Markup.ValueSerializer> и его API-интерфейсы аналогичен <xref:System.ComponentModel.ITypeDescriptorContext> для <xref:System.ComponentModel.TypeConverter>. На самом деле <xref:System.Windows.Markup.IValueSerializerContext> наследует <xref:System.ComponentModel.ITypeDescriptorContext>. Когда <xref:System.Windows.Markup.ValueSerializer> вызывается API-интерфейса производного класса, вызывающий объект (обычно процесс сериализации) передает контекст, который может предоставить определенные службы. Из-за Общие рекомендации, <xref:System.Windows.Markup.ValueSerializer> не должны вызывать исключения. Ошибка возврата определенной службы из контекста должен также не вызывает исключений.  
  
 В предыдущих версиях платформы .NET Framework этот класс существовали в сборке WindowsBase конкретных WPF. В [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Windows.Markup.ValueSerializer> находится в сборке System.Xaml. Дополнительные сведения см. в разделе [типы, перенесенные из WPF в сборку System.Xaml](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlXmlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ValueSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текст этого конструктора является пустой; <xref:System.Windows.Markup.ValueSerializer> класс не содержит любые значения, которые требуется инициализация.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertFromString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertFromString (value As String, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Строка, для которой требуется проверить возможность преобразования.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>При переопределении в производном классе определяет, может ли указанный класс <see cref="T:System.String" /> быть преобразован в экземпляр типа, который поддерживается реализацией класса <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>
          Значение <see langword="true" />, если значение можно преобразовать; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация всегда возвращает значение `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertToString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertToString (value As Object, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Объект, для которого необходимо проверить возможность преобразования.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Если переопределено в производном классе, определяет, можно ли преобразовать указанный объект в <see cref="T:System.String" />.</summary>
        <returns>
          Значение <see langword="true" />, если <paramref name="value" /> можно преобразовать в <see cref="T:System.String" />; в противном случае — значение <see langword="false." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация всегда возвращает значение `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public virtual object ConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertFromString (value As String, context As IValueSerializerContext) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Преобразуемая строка.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>При переопределении в производном классе преобразует <see cref="T:System.String" /> в экземпляр типа, который поддерживает реализация <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>Новый экземпляр типа, который поддерживает реализация <see cref="T:System.Windows.Markup.ValueSerializer" />, на основе предоставленного <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация всегда создает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="value" /> невозможно преобразовать.</exception>
        <block subset="none" type="overrides">
          <para>Избегайте создания исключений в реализациях. См. раздел <see cref="T:System.Windows.Markup.ValueSerializer" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public virtual string ConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertToString (value As Object, context As IValueSerializerContext) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Объект, преобразуемый в строку.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Если переопределено в производном классе, преобразует указанный объект в <see cref="T:System.String" />.</summary>
        <returns>Представление строки указанного объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация всегда создает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="value" /> невозможно преобразовать.</exception>
        <block subset="none" type="overrides">
          <para>Избегайте создания исключений в реализациях. См. раздел <see cref="T:System.Windows.Markup.ValueSerializer" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetConvertFromException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertFromException (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertFromException(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertFromException(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertFromException (value As Object) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertFromException(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который не удалось преобразовать.</param>
        <summary>Возвращает исключение, возникающее в случае, если невозможно выполнить преобразование.</summary>
        <returns>Объект <see cref="T:System.Exception" /> для исключения, которое необходимо создать, если невозможно выполнить преобразование <see langword="ConvertFrom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактический `throw` ключевое слово не вызывается этим методом, поэтому обычно `throw GetConvertFromException` (с параметрами, предоставленными).  
  
 Возвращается определенное исключение <xref:System.InvalidOperationException>, с `value` переданное сообщение об исключении. Шаблон для использования аналогичен служебных программ исключение в <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConvertToException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertToException (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertToException(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertToException(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertToException (value As Object, destinationType As Type) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertToException(System::Object ^ value, Type ^ destinationType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="destinationType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который не удалось преобразовать.</param>
        <param name="destinationType">Тип, в который осуществлялось преобразование.</param>
        <summary>Возвращает исключение, возникающее в случае, если невозможно выполнить преобразование.</summary>
        <returns>Объект <see cref="T:System.Exception" /> для исключения, которое необходимо создать, если невозможно выполнить преобразование <see langword="ConvertTo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактический `throw` ключевое слово не вызывается этим методом, поэтому обычно `throw GetConvertToException` (с `value` указанный параметр).  
  
 Возвращается определенное исключение <xref:System.InvalidOperationException>, с `value` переданное сообщение об исключении. Шаблон для использования аналогичен служебных программ исключение в <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSerializerFor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает <see cref="T:System.Windows.Markup.ValueSerializer" /> для объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="descriptor">Дескриптор свойства CLR, которое нужно сериализовать.</param>
        <summary>Получает класс <see cref="T:System.Windows.Markup.ValueSerializer" />, объявленный для свойства, путем передачи свойству дескриптора свойства среды CLR.</summary>
        <returns>Сериализатор, связанный с указанным свойством. Может возвращать значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Markup.ValueSerializer> свойство или тип, который используется в качестве значения для свойства указывается путем применения <xref:System.Windows.Markup.ValueSerializerAttribute> атрибут в объявлении свойства или типа. <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> Метод является вспомогательный метод, который считывает информации о системе типов среды CLR и возвращает новый <xref:System.Windows.Markup.ValueSerializer> классов, основанных на атрибуте, если обнаружен на свойства, или если на тип свойства. `null` может быть возвращено, если такой сериализатор не существует. `null` может также возвращаться Если тип или свойство умышленно установлен атрибут со значением null <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Другой режим, <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> поддерживает Возвращает внутренний `TypeConverterValueSerializer` класса, который является <xref:System.Windows.Markup.ValueSerializer> реализацию, которая служит оболочкой для <xref:System.ComponentModel.TypeConverter> и преобразует `Convert` методы для `Convert*String` методы (например <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>вызывается с входом <xref:System.String> введите, а также преобразует для <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Это делается только в тех случаях, где выполняются все следующие условия:  
  
-   Объект <xref:System.ComponentModel.TypeConverterAttribute> находится на соответствующего свойства или типа, соответствующего свойства.  
  
-   Указанный <xref:System.ComponentModel.TypeConverter> может быть успешно создан.  
  
-   <xref:System.ComponentModel.TypeConverter> Возвращает `true` для <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>, с именем ссылки на <xref:System.String> типа.  
  
-   <xref:System.ComponentModel.TypeConverter> Возвращает `true` для <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>, с именем ссылки на <xref:System.String> типа.  
  
-   <xref:System.ComponentModel.TypeConverter> Возвращает `true` для <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>, с именем ссылки на <xref:System.String> типа.  
  
> [!NOTE]
>  Ниже приведены особые случаи: <xref:System.DateTime> типы возвращают <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> типов возвращается сериализатор внутренним, но режим работы (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="descriptor" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Тип, для которого требуется получить <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <summary>Получает <see cref="T:System.Windows.Markup.ValueSerializer" />, объявленный для заданного типа.</summary>
        <returns>Сериализатор, связанный с указанным типом. Может возвращать значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Markup.ValueSerializer> для указывает тип, применяя <xref:System.Windows.Markup.ValueSerializerAttribute> атрибута для объявления типа. <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> Метод является вспомогательный метод, который считывает информации о системе типов среды CLR и возвращает новый <xref:System.Windows.Markup.ValueSerializer> классов, основанных на атрибуте, если найден в указанном `type`. `null` может быть возвращено, если такой сериализатор не существует. `null` может также возвращаться Если тип намеренно атрибут со значением null <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Другой режим, <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> поддерживает Возвращает внутренний `TypeConverterValueSerializer` класса, который является <xref:System.Windows.Markup.ValueSerializer> реализацию, которая служит оболочкой для <xref:System.ComponentModel.TypeConverter> и преобразует `Convert` методы для `Convert*String` методы (например <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>вызывается с входом <xref:System.String> введите, а также преобразует для <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Это делается только в тех случаях, где выполняются все следующие условия:  
  
-   Объект <xref:System.ComponentModel.TypeConverterAttribute> находится на `type`.  
  
-   Указанный <xref:System.ComponentModel.TypeConverter> может быть успешно создан.  
  
-   <xref:System.ComponentModel.TypeConverter> Возвращает `true` для <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>, с именем ссылки на <xref:System.String> типа.  
  
-   <xref:System.ComponentModel.TypeConverter> Возвращает `true` для <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>, с именем ссылки на <xref:System.String> типа.  
  
-   <xref:System.ComponentModel.TypeConverter> Возвращает `true` для <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>, с именем ссылки на <xref:System.String> типа.  
  
> [!NOTE]
>  Ниже приведены особые случаи: <xref:System.DateTime> типы возвращают <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> типов возвращается сериализатор внутренним, но режим работы (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="descriptor">Дескриптор свойства, которое нужно сериализовать.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Получает <see cref="T:System.Windows.Markup.ValueSerializer" />, объявленный для заданного свойства с использованием заданного контекста.</summary>
        <returns>Сериализатор, связанный с указанным свойством.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо того чтобы полагаться исключительно на атрибуты зарегистрирована в системе типов среды CLR, эта перегрузка использует `context` как служба и вызывает реализацию службы <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> Реализации также обычно полагаются на `descriptor`, но могут быть реализованы особое поведение для определенных контекстах.  
  
 Этот метод должен вызываться при вызывающий оператор имеет доступный <xref:System.Windows.Markup.IValueSerializerContext> из службы.  Это обеспечит правильное <xref:System.Windows.Markup.ValueSerializer> возвращается для данного контекста.  
  
 Возвращает контекст `null` из его <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> к указанному `descriptor`, или если указать контекст `null`, то поведение совпадает с вызовом метода <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.ComponentModel.PropertyDescriptor%29> перегрузки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="descriptor" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="type">Тип, для которого требуется получить <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Получает <see cref="T:System.Windows.Markup.ValueSerializer" />, объявленный для заданного типа с использованием заданного контекста.</summary>
        <returns>Сериализатор, связанный с указанным типом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо того чтобы полагаться исключительно на атрибуты зарегистрирована в системе типов среды CLR, эта перегрузка использует `context` как служба и вызывает реализацию службы <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> Реализации также обычно полагаются на `type`, но могут быть реализованы особое поведение для определенных контекстах.  
  
 Этот метод должен вызываться при вызывающий оператор имеет доступный <xref:System.Windows.Markup.IValueSerializerContext> из службы. Это обеспечит правильное <xref:System.Windows.Markup.ValueSerializer> возвращается для данного контекста.  
  
 Возвращает контекст `null` из его <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> к указанному `type`, или если указать контекст `null`, то поведение совпадает с вызовом метода <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.Type%29> перегрузки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.TypeReferences(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TypeReferences (value As Object, context As IValueSerializerContext) As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Сериализуемое значение.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Получает перечисление типов, на которые ссылается <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>Типы, преобразуемые данным сериализатором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все типы <xref:System.Windows.Markup.ValueSerializer> преобразует должны быть включены в возвращаемый перечисления.  Это позволяет сериализатор, чтобы убедиться, что десериализатор будет иметь достаточно сведений о типах, которые преобразует данный сериализатор.  
  
 Переопределение этого метода является расширенным сценарием. Переопределение необходима только при реализации системы где CLR системы свойство ownertype связи типа для контекста схемы XAML не предоставляет достаточное количество сведений.  
  
## <a name="wpf-usage-notes"></a>Примечания об использовании WPF  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Системы свойств реализует внутреннее значение сериализатор, который переопределяет <xref:System.Windows.Markup.ValueSerializer.TypeReferences%2A> , так как свойство зависимости имеет смысл, что оно может добавлено владельцев. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] выражения также имеют специальные внутреннюю обработку.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>