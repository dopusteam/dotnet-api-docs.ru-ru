<Type Name="WorkflowInvoker" FullName="System.Activities.WorkflowInvoker">
  <Metadata><Meta Name="ms.openlocfilehash" Value="73cad7482ec89c2404cb253c90cebeaaff316196" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52590235" /></Metadata><TypeSignature Language="C#" Value="public sealed class WorkflowInvoker" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowInvoker extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Activities.WorkflowInvoker" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowInvoker" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInvoker sealed" />
  <TypeSignature Language="F#" Value="type WorkflowInvoker = class" />
  <AssemblyInfo>
    <AssemblyName>System.Activities</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет средства для вызова рабочего процесса аналогично вызову метода.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Модуль вызова <xref:System.Activities.WorkflowInvoker> содержит методы для вызова рабочих процессов в синхронном режиме (как методы экземпляра, так и статические методы), а также методы экземпляра для вызова рабочих процессов в асинхронном режиме.  
  
 <xref:System.Activities.WorkflowInvoker> не разрешает управлять экземплярами, в частности сохранять, выгружать и возобновлять закладки. Если необходимо управлять экземплярами, следует использовать <xref:System.Activities.WorkflowApplication>.  
  
 Чтобы выполнять рабочие процессы в синхронном режиме без управления экземплярами, вызовите метод <xref:System.Activities.WorkflowInvoker.Invoke%2A>. Чтобы выполнять рабочий процесс в асинхронном режиме без управления экземплярами, используйте пары методов <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A> и <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> или метод <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A>.  
  
   
  
## Examples  
 В следующем примере синхронно вызывается рабочий процесс, состоящий из одного действия <xref:System.Activities.Statements.WriteLine>, с помощью метода <xref:System.Activities.WorkflowInvoker>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#1](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowInvoker (System.Activities.Activity workflow);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflow As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowInvoker(System::Activities::Activity ^ workflow);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowInvoker : System.Activities.Activity -&gt; System.Activities.WorkflowInvoker" Usage="new System.Activities.WorkflowInvoker workflow" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflow">Определение рабочего процесса, который должен вызываться этим экземпляром класса <see cref="T:System.Activities.WorkflowInvoker" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Activities.WorkflowInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Модуль вызова <xref:System.Activities.WorkflowInvoker> содержит методы для вызова рабочих процессов в синхронном режиме (как методы экземпляра, так и статические методы), а также методы экземпляра для вызова рабочих процессов в асинхронном режиме.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из одного действия <xref:System.Activities.Statements.WriteLine>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#2](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [Обзор асинхронного программирования](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInvoker.BeginInvoke (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Метод, вызываемый после завершения рабочего процесса.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Вызывает рабочий процесс в асинхронном режиме с указанным <see cref="T:System.AsyncCallback" /> и предоставляемым пользователем состоянием.</summary>
        <returns>Ссылка на асинхронную операцию вызова.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить уведомление о завершении рабочего процесса и получить выходные параметры рабочего процесса, вызовите метод <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> из метода `callback`. Если вызвать метод <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> до завершения рабочего процесса, он будет заблокирован до завершения рабочего процесса. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Обзор асинхронного программирования](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. Они возвращаются путем вызова <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. После завершения вызова <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> в словаре выходных данных возвращается каждый выходной аргумент с указанием имени.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.Collections.Generic.IDictionary{System.String,System.Object},System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (inputs As IDictionary(Of String, Object), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Collections.Generic.IDictionary&lt;string, obj&gt; * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInvoker.BeginInvoke (inputs, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <param name="callback">Метод, вызываемый после завершения рабочего процесса.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Вызывает рабочий процесс в асинхронном режиме с указанным словарем <see cref="T:System.Collections.Generic.IDictionary`2" /> входных параметров, объектом <see cref="T:System.AsyncCallback" /> и предоставляемым пользователем состоянием.</summary>
        <returns>Ссылка на асинхронную операцию вызова.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить уведомление о завершении рабочего процесса и получить выходные параметры рабочего процесса, вызовите метод <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> из метода `callback`. Если вызвать метод <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> до завершения рабочего процесса, он будет заблокирован до завершения рабочего процесса.  Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Обзор асинхронного программирования](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. Они возвращаются путем вызова <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. После завершения вызова <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> в словаре выходных данных возвращается каждый выходной аргумент с указанием имени.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInvoker.BeginInvoke (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Период времени, в течение которого рабочий процесс должен быть завершен, прежде чем он будет прерван и возникнет исключение <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый после завершения рабочего процесса.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Вызывает рабочий процесс в асинхронном режиме с использованием указанного интервала времени ожидания, объекта <see cref="T:System.AsyncCallback" /> и предоставляемого пользователем состояния.</summary>
        <returns>Ссылка на асинхронную операцию вызова.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить уведомление о завершении рабочего процесса и получить выходные параметры рабочего процесса, вызовите метод <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> из метода `callback`. Если вызвать метод <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> до завершения рабочего процесса, он будет заблокирован до завершения рабочего процесса. Если рабочий процесс не завершается в течение указанного интервала времени ожидания, то он прерывается и при вызове метода <xref:System.TimeoutException> создается исключение <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Обзор асинхронного программирования](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. Они возвращаются путем вызова <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. После завершения вызова <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> в словаре выходных данных возвращается каждый выходной аргумент с указанием имени.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (inputs As IDictionary(Of String, Object), timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInvoker.BeginInvoke (inputs, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <param name="timeout">Период времени, в течение которого рабочий процесс должен быть завершен, прежде чем он будет прерван и возникнет исключение <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый после завершения рабочего процесса.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Вызывает рабочий процесс в асинхронном режиме с указанным словарем <see cref="T:System.Collections.Generic.IDictionary`2" /> входных параметров, интервалом времени ожидания, объектом <see cref="T:System.AsyncCallback" /> и предоставляемым пользователем состоянием.</summary>
        <returns>Ссылка на асинхронную операцию вызова.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить уведомление о завершении рабочего процесса и получить выходные параметры рабочего процесса, вызовите метод <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> из метода `callback`. Если вызвать метод <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> до завершения рабочего процесса, он будет заблокирован до завершения рабочего процесса. Если рабочий процесс не завершается в течение указанного интервала времени ожидания, то он прерывается и при вызове <xref:System.TimeoutException> создается исключение <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Обзор асинхронного программирования](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. Они возвращаются путем вызова <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. После завершения вызова <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> в словаре выходных данных возвращается каждый выходной аргумент с указанием имени.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync (object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync(object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.CancelAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync (userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync(System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : obj -&gt; unit" Usage="workflowInvoker.CancelAsync userState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="userState">Маркер для отменяемого рабочего процесса.</param>
        <summary>Выполняет отмену рабочего процесса, вызванного с указанным состоянием <paramref name="userState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отменять можно только рабочий процесс, вызванный одним из перегруженных вариантов метода <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A>, который принимает параметр `userState`.  
  
 Если Отмена выполняется успешно, <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> свойство <xref:System.Activities.InvokeCompletedEventArgs> передается <xref:System.Activities.WorkflowInvoker.InvokeCompleted> обработчика `true`; в противном случае он становится равным `false`.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. Когда вызывается рабочий процесс, сервер пытается отменить его.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#34](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; EndInvoke (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; EndInvoke(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.EndInvoke(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndInvoke (result As IAsyncResult) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ EndInvoke(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndInvoke : IAsyncResult -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.EndInvoke result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Интерфейс <see cref="T:System.IAsyncResult" />, ссылающийся на операцию <see cref="Overload:System.Activities.WorkflowInvoker.BeginInvoke" />, которая запустила рабочий процесс.</param>
        <summary>Возвращает результаты рабочего процесса, вызванного с помощью одного из перегруженных вариантов <see cref="Overload:System.Activities.WorkflowInvoker.BeginInvoke" />.</summary>
        <returns>Словарь значений <see cref="T:System.Activities.OutArgument" /> и <see cref="T:System.Activities.InOutArgument" /> корневого действия. Ключом этих значений является имя аргумента, представляющего выходные значения рабочего процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить уведомление о завершении рабочего процесса и получить его выходные параметры, вызовите метод <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> из метода `callback`, указанного в <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A>. Если вызвать метод <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> до завершения рабочего процесса, он будет заблокирован до завершения рабочего процесса.  
  
 Этот метод возвращает результат рабочего процесса, вызванного в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Обзор асинхронного программирования](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. Они возвращаются путем вызова <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. После завершения вызова <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> в словаре выходных данных возвращается каждый выходной аргумент с указанием имени.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowInvoker.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As WorkflowInstanceExtensionManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::Hosting::WorkflowInstanceExtensionManager ^ Extensions { System::Activities::Hosting::WorkflowInstanceExtensionManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extensions : System.Activities.Hosting.WorkflowInstanceExtensionManager" Usage="System.Activities.WorkflowInvoker.Extensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.Hosting.WorkflowInstanceExtensionManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию <see cref="T:System.Collections.ObjectModel.Collection`1" /> расширений, доступных для рабочих процессов, вызываемых экземпляром <see cref="T:System.Activities.WorkflowInvoker" />.</summary>
        <value>Коллекция <see cref="T:System.Collections.ObjectModel.Collection`1" /> расширений, доступных для рабочих процессов, вызываемых экземпляром <see cref="T:System.Activities.WorkflowInvoker" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется авторами узлов рабочих процессов для добавления расширений к экземпляру <xref:System.Activities.WorkflowInvoker>, чтобы они были доступны рабочим процессам, вызываемым эти экземпляром.  
  
   
  
## Examples  
 В следующем примере регистрируется настраиваемый участник <xref:System.Activities.Tracking.TrackingParticipant> с коллекцией <xref:System.Activities.WorkflowInvoker.Extensions%2A> экземпляра <xref:System.Activities.WorkflowInvoker>. Данный пример кода является частью [настраиваемое отслеживание](~/docs/framework/windows-workflow-foundation/samples/custom-tracking.md) образца.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#40](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#40)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывает рабочий процесс в синхронном режиме и возвращает словарь значений <see cref="T:System.Activities.OutArgument" /> и <see cref="T:System.Activities.InOutArgument" /> корневого действия, ключом которых является имя аргумента, представляющего выходные значения рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.Invoke%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke () As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke();" />
      <MemberSignature Language="F#" Value="member this.Invoke : unit -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.Invoke " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает рабочий процесс синхронным образом, используя определение рабочего процесса, переданное в конструктор <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" />.</summary>
        <returns>Словарь значений <see cref="T:System.Activities.OutArgument" /> и <see cref="T:System.Activities.InOutArgument" /> корневого действия. Ключом этих значений является имя аргумента, представляющего выходные значения рабочего процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.Invoke%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из одного действия `DiceRoll`. Действие `DiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. После завершения вызова `Invoke` в словаре выходных данных возвращается каждый выходной аргумент с указанием имени. Рабочий процесс вызывается дважды с использованием определения рабочего процесса, передаваемые в `WorkflowInvoker` конструктор.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#130](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#130)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#31](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#31)]  
  
 Если корневое действие рабочего процесса не имеет выходных аргументов или они не нужны обработчику, то их можно не учитывать. В следующем примере вызывается рабочий процесс, состоящий из одного действия <xref:System.Activities.Statements.WriteLine>, которое не имеет выходных аргументов.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#2](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Activities.WorkflowInvoker.Invoke workflow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflow">Определение вызываемого рабочего процесса.</param>
        <summary>Вызывает рабочий процесс в синхронном режиме с помощью указанного определения рабочего процесса.</summary>
        <returns>Словарь значений <see cref="T:System.Activities.OutArgument" /> и <see cref="T:System.Activities.InOutArgument" /> корневого действия. Ключом этих значений является имя аргумента, представляющего выходные значения рабочего процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.Invoke%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из одного действия `DiceRoll`. Действие `DiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. После завершения вызова `Invoke` в словаре выходных данных возвращается каждый выходной аргумент с указанием имени.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#130](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#130)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#30](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#30)]  
  
 Если корневое действие рабочего процесса не имеет выходных аргументов или они не нужны обработчику, то их можно не учитывать. В следующем примере вызывается рабочий процесс, состоящий из одного действия <xref:System.Activities.Statements.WriteLine>, которое не имеет выходных аргументов.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#1](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (inputs As IDictionary(Of String, Object)) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.Invoke inputs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <summary>Вызывает действие, переданное в конструктор <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" />, в синхронном режиме с указанным словарем <see cref="T:System.Collections.Generic.IDictionary`2" /> входных параметров.</summary>
        <returns>Словарь значений <see cref="T:System.Activities.OutArgument" /> и <see cref="T:System.Activities.InOutArgument" /> корневого действия. Ключом этих значений является имя аргумента, представляющего выходные значения рабочего процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.Invoke%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из одного действия `Divide`, которое имеет два входных аргумента и два выходных аргумента. При вызове рабочего процесса передается словарь `arguments`, содержащий значения каждого входного аргумента с указанием имени аргумента. После завершения вызова `Invoke` в словаре выходных данных `outputs` возвращается каждый выходной аргумент с указанием имени.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#120](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#120)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#22](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#22)]  
  
 Если рабочий процесс является производным от <xref:System.Activities.ActivityWithResult>, такие как `CodeActivity<TResult>` или `Activity<TResult>`, и имеются выходные аргументы, помимо правильно определенного <xref:System.Activities.Activity%601.Result%2A> выходной аргумент, перегрузка метода нестандартную `Invoke`, такому как это, необходимо использовать в Чтобы получить дополнительные аргументы. Для этого определение рабочего процесса, переданное в `WorkflowInvoker` конструктор должен иметь тип <xref:System.Activities.Activity>. В этом примере `Divide` действие является производным от `CodeActivity<int>`, но объявляется как <xref:System.Activities.Activity> таким образом, чтобы данная перегруженная версия `Invoke`, которая возвращает словарь аргументов вместо одиночного значения, используется.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#121](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#121)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#23](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : TimeSpan -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.Invoke timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период времени, в течение которого рабочий процесс должен быть завершен, прежде чем он будет прерван и возникнет исключение <see cref="T:System.TimeoutException" />.</param>
        <summary>Вызывает рабочий процесс в синхронном режиме с указанным интервалом времени ожидания.</summary>
        <returns>Словарь значений <see cref="T:System.Activities.OutArgument" /> и <see cref="T:System.Activities.InOutArgument" /> корневого действия. Ключом этих значений является имя аргумента, представляющего выходные значения рабочего процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Если рабочий процесс не завершается в течение указанного интервала времени ожидания, он прерывается и создается исключение <xref:System.TimeoutException>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, содержащий два действия <xref:System.Activities.Statements.WriteLine> и действие <xref:System.Activities.Statements.Delay>, для которого задан срок <xref:System.Activities.Statements.Delay.Duration%2A> в одну минуту. Этот рабочий процесс вызывается дважды: сначала с интервалом ожидания в две минуты, а затем с интервалом ожидания в 30 секунд. Первый рабочий процесс вызывается успешно, а второй не завершается, вызывается исключение <xref:System.TimeoutException>, и выводится следующее сообщение.  
  
```Output  
The operation did not complete within the allotted timeout of 00:00:30.   
The time allotted to this operation may have been a portion of a longer timeout.  
```  
  
 [!code-csharp[CFX_WorkflowInvokerExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#51)]  
  
 Например, с помощью `Invoke` с аргументами выходных данных, см. в разделе перегрузку <xref:System.Activities.WorkflowInvoker.Invoke%2A> с теми же параметрами, как эту перегрузку без ожидания.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity, inputs As IDictionary(Of String, Object)) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="workflow">Определение вызываемого рабочего процесса.</param>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <summary>Вызывает рабочий процесс в синхронном режиме с использованием определения рабочего процесса и словаря входных параметров <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <returns>Словарь значений <see cref="T:System.Activities.OutArgument" /> и <see cref="T:System.Activities.InOutArgument" /> корневого действия. Ключом этих значений является имя аргумента, представляющего выходные значения рабочего процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.Invoke%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из одного действия `Divide`, которое имеет два входных аргумента и два выходных аргумента. При вызове рабочего процесса передается словарь `arguments`, содержащий значения каждого входного аргумента с указанием имени аргумента. После завершения вызова `Invoke` в словаре выходных данных `outputs` возвращается каждый выходной аргумент с указанием имени.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#120](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#120)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#20](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#20)]  
  
 Если рабочий процесс является производным от <xref:System.Activities.ActivityWithResult>, такие как `CodeActivity<TResult>` или `Activity<TResult>`, и имеются выходные аргументы, помимо правильно определенного <xref:System.Activities.Activity%601.Result%2A> выходной аргумент, перегрузка метода нестандартную `Invoke`, такому как это, необходимо использовать в Чтобы получить дополнительные аргументы. Для этого определение рабочего процесса, переданное в `Invoke`, должно быть типа <xref:System.Activities.Activity>. В этом примере `Divide` действие является производным от `CodeActivity<int>`, но объявляется как <xref:System.Activities.Activity> таким образом, чтобы данная перегруженная версия `Invoke`, которая возвращает словарь аргументов вместо одиночного значения, используется.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#121](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#121)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#21](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity, timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity * TimeSpan -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="workflow">Определение вызываемого рабочего процесса.</param>
        <param name="timeout">Период времени, в течение которого рабочий процесс должен быть завершен, прежде чем он будет прерван и возникнет исключение <see cref="T:System.TimeoutException" />.</param>
        <summary>Вызывает рабочий процесс в синхронном режиме с использованием указанного определения рабочего процесса и интервала времени ожидания.</summary>
        <returns>Словарь значений <see cref="T:System.Activities.OutArgument" /> и <see cref="T:System.Activities.InOutArgument" /> корневого действия. Ключом этих значений является имя аргумента, представляющего выходные значения рабочего процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Если рабочий процесс не завершается в течение указанного интервала времени ожидания, он прерывается и создается исключение <xref:System.TimeoutException>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, содержащий два действия <xref:System.Activities.Statements.WriteLine> и действие <xref:System.Activities.Statements.Delay>, для которого задан срок <xref:System.Activities.Statements.Delay.Duration%2A> в одну минуту. Этот рабочий процесс вызывается дважды: сначала с интервалом ожидания в две минуты, а затем с интервалом ожидания в 30 секунд. Первый рабочий процесс завершается успешно, а второй не завершается, и вызывается исключение <xref:System.TimeoutException>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#50](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#50)]  
  
 Например, с помощью `Invoke` с аргументами выходных данных, см. в разделе перегрузку <xref:System.Activities.WorkflowInvoker.Invoke%2A> с теми же параметрами, как эту перегрузку без ожидания.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (inputs As IDictionary(Of String, Object), timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.Invoke (inputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <param name="timeout">Период времени, в течение которого рабочий процесс должен быть завершен, прежде чем он будет прерван и возникнет исключение <see cref="T:System.TimeoutException" />.</param>
        <summary>Вызывает действие, переданное в конструктор <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" />, в синхронном режиме с указанным словарем <see cref="T:System.Collections.Generic.IDictionary`2" /> входных параметров и указанным интервалом времени ожидания.</summary>
        <returns>Словарь значений <see cref="T:System.Activities.OutArgument" /> и <see cref="T:System.Activities.InOutArgument" /> корневого действия. Ключом этих значений является имя аргумента, представляющего выходные значения рабочего процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Если рабочий процесс не завершается в течение указанного интервала времени ожидания, он прерывается и создается исключение <xref:System.TimeoutException>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, содержащий два действия <xref:System.Activities.Statements.WriteLine> и действие <xref:System.Activities.Statements.Delay>, для которого задан срок <xref:System.Activities.Statements.Delay.Duration%2A> в одну минуту. Этот рабочий процесс вызывается дважды: сначала с интервалом ожидания в две минуты, а затем с интервалом ожидания в 30 секунд. Первый рабочий процесс вызывается успешно, а второй не завершается, вызывается исключение <xref:System.TimeoutException>, и выводится следующее сообщение.  
  
```Output  
The operation did not complete within the allotted timeout of 00:00:30.   
The time allotted to this operation may have been a portion of a longer timeout.  
```  
  
 [!code-csharp[CFX_WorkflowInvokerExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#51)]  
  
 Например, с помощью `Invoke` с входными и выходными параметрами см. в разделе перегрузку <xref:System.Activities.WorkflowInvoker.Invoke%2A> с теми же параметрами, как эту перегрузку без ожидания.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity, inputs As IDictionary(Of String, Object), timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="workflow">Определение вызываемого рабочего процесса.</param>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <param name="timeout">Период времени, в течение которого рабочий процесс должен быть завершен, прежде чем он будет прерван и возникнет исключение <see cref="T:System.TimeoutException" />.</param>
        <summary>Вызывает рабочий процесс в синхронном режиме с использованием определения рабочего процесса, словаря входных параметров <see cref="T:System.Collections.Generic.IDictionary`2" /> и интервала ожидания.</summary>
        <returns>Словарь значений <see cref="T:System.Activities.OutArgument" /> и <see cref="T:System.Activities.InOutArgument" /> корневого действия. Ключом этих значений является имя аргумента, представляющего выходные значения рабочего процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Если рабочий процесс не завершается в течение указанного интервала времени ожидания, он прерывается и создается исключение <xref:System.TimeoutException>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, содержащий два действия <xref:System.Activities.Statements.WriteLine> и действие <xref:System.Activities.Statements.Delay>, для которого задан срок <xref:System.Activities.Statements.Delay.Duration%2A> в одну минуту. Этот рабочий процесс вызывается дважды: сначала с интервалом ожидания в две минуты, а затем с интервалом ожидания в 30 секунд. Первый рабочий процесс завершается успешно, а второй не завершается, и вызывается исключение <xref:System.TimeoutException>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#50](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#50)]  
  
 Например, с помощью `Invoke` с входными и выходными параметрами см. в разделе перегрузку <xref:System.Activities.WorkflowInvoker.Invoke%2A> с теми же параметрами, как эту перегрузку без ожидания.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity&lt;'Result&gt; -&gt; 'Result" Usage="System.Activities.WorkflowInvoker.Invoke workflow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип рабочего процесса.</typeparam>
        <param name="workflow">Определение вызываемого рабочего процесса. Определение рабочего процесса должно быть производным от <see cref="T:System.Activities.ActivityWithResult" />.</param>
        <summary>Вызывает рабочий процесс синхронным образом, используя определение рабочего процесса, переданное в конструктор <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" />.</summary>
        <returns>Значение типа TResult с результатом выполнения действия.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.Invoke%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из одного `Add` действие, которое имеет два входных аргумента, и, поскольку он является производным от `CodeActivity<int>` он содержит один заранее определенный <xref:System.Activities.Activity%601.Result%2A> выходной аргумент. При вызове рабочего процесса передается словарь `arguments`, содержащий значения каждого входного аргумента с указанием имени аргумента. При вызове `Invoke` возвращает значение <xref:System.Activities.Activity%601.Result%2A> выходного аргумента. Данный пример кода, расположенного за пределами класса [использование класса WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) образца.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0},System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult), inputs As IDictionary(Of String, Object)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity&lt;'Result&gt; * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; 'Result" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип рабочего процесса.</typeparam>
        <param name="workflow">Определение вызываемого рабочего процесса.</param>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <summary>Вызывает рабочий процесс в синхронном режиме с использованием определения рабочего процесса и словаря входных параметров <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <returns>Значение типа TResult с результатом выполнения действия.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.Invoke%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из одного `Add` действие, которое имеет два входных аргумента, и, поскольку он является производным от `CodeActivity<int>` он содержит один заранее определенный <xref:System.Activities.Activity%601.Result%2A> выходной аргумент. При вызове рабочего процесса передается словарь `arguments`, содержащий значения каждого входного аргумента с указанием имени аргумента. При вызове `Invoke` возвращает значение <xref:System.Activities.Activity%601.Result%2A> выходного аргумента. Данный пример кода, расположенного за пределами класса [использование класса WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) образца.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0},System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult), inputs As IDictionary(Of String, Object), timeout As TimeSpan) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity&lt;'Result&gt; * System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan -&gt; 'Result" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип рабочего процесса.</typeparam>
        <param name="workflow">Определение вызываемого рабочего процесса.</param>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <param name="timeout">Период времени, в течение которого рабочий процесс должен быть завершен, прежде чем он будет прерван и возникнет исключение <see cref="T:System.TimeoutException" />.</param>
        <summary>Вызывает рабочий процесс в синхронном режиме с использованием определения рабочего процесса, словаря входных параметров <see cref="T:System.Collections.Generic.IDictionary`2" /> и интервала ожидания.</summary>
        <returns>Значение типа TResult с результатом выполнения действия.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Если рабочий процесс не завершается в течение указанного интервала времени ожидания, он прерывается и создается исключение <xref:System.TimeoutException>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из одного `Add` действие, которое имеет два входных аргумента, и, поскольку он является производным от `CodeActivity<int>` он содержит один заранее определенный <xref:System.Activities.Activity%601.Result%2A> выходной аргумент. При вызове рабочего процесса передается словарь `arguments`, содержащий значения каждого входного аргумента с указанием имени аргумента. При вызове `Invoke` возвращает значение <xref:System.Activities.Activity%601.Result%2A> выходного аргумента. Данный пример кода, расположенного за пределами класса [использование класса WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) образца.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, out System.Collections.Generic.IDictionary&lt;string,object&gt; additionalOutputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, [out] class System.Collections.Generic.IDictionary`2&lt;string, object&gt;&amp; additionalOutputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0},System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object}@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult), inputs As IDictionary(Of String, Object), ByRef additionalOutputs As IDictionary(Of String, Object), timeout As TimeSpan) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, [Runtime::InteropServices::Out] System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ % additionalOutputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity&lt;'Result&gt; * System.Collections.Generic.IDictionary&lt;string, obj&gt; *  * TimeSpan -&gt; 'Result" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs, additionalOutputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="additionalOutputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип рабочего процесса.</typeparam>
        <param name="workflow">Определение вызываемого рабочего процесса.</param>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <param name="additionalOutputs">Словарь дополнительных выходных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <param name="timeout">Период времени, в течение которого рабочий процесс должен быть завершен, прежде чем он будет прерван и возникнет исключение <see cref="T:System.TimeoutException" />.</param>
        <summary>Вызывает рабочий процесс в синхронном режиме с использованием указанного определения рабочего процесса, словаря <see cref="T:System.Collections.Generic.IDictionary`2" /> входных параметров, словаря <see cref="T:System.Collections.Generic.IDictionary`2" /> дополнительных выходных параметров и интервала времени ожидания.</summary>
        <returns>Значение типа TResult с результатом выполнения действия.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения рабочего процесса, включая время простоя. Все выполнение рабочего процесса гарантированно будет запущено в потоке вызова. Если рабочий процесс не завершается в течение указанного интервала времени ожидания, он прерывается и создается исключение <xref:System.TimeoutException>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из одного `Add` действие, которое имеет два входных аргумента, и, поскольку он является производным от `CodeActivity<int>` он содержит один заранее определенный <xref:System.Activities.Activity%601.Result%2A> выходной аргумент. При вызове рабочего процесса передается словарь `arguments`, содержащий значения каждого входного аргумента с указанием имени аргумента. При вызове `Invoke` возвращает значение <xref:System.Activities.Activity%601.Result%2A> выходного аргумента. Данный пример кода, расположенного за пределами класса [использование класса WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) образца.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования на основе событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить уведомление о завершении рабочего процесса, необходимо обработать событие <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования на основе событий. Дополнительные сведения см. в разделе [Обзор асинхронной модели на основе событий](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync();" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : unit -&gt; unit" Usage="workflowInvoker.InvokeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает рабочий процесс в асинхронном режиме.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить уведомление о завершении рабочего процесса, необходимо обработать событие <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования на основе событий. Дополнительные сведения см. в разделе [Обзор асинхронной модели на основе событий](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. После завершения рабочего процесса они возвращаются в обработчик <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; unit" Usage="workflowInvoker.InvokeAsync inputs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <summary>Вызывает рабочий процесс в асинхронном режиме с использованием указанного словаря <see cref="T:System.Collections.Generic.IDictionary`2" /> входных параметров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить уведомление о завершении рабочего процесса, необходимо обработать событие <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования на основе событий. Дополнительные сведения см. в разделе [Обзор асинхронной модели на основе событий](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. После завершения рабочего процесса они возвращаются в обработчик <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : obj -&gt; unit" Usage="workflowInvoker.InvokeAsync userState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="userState">Предоставляемый пользователем объект, который позволяет отличить данную асинхронную операцию вызова от других текущих асинхронных операций вызова.</param>
        <summary>Вызывает рабочий процесс в асинхронном режиме с использованием указанного уникального идентификатора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `userState` должен быть уникальным для всех выполняемых в настоящий момент операций <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> данного действия. Если параметр `userState` не уникален, возникает исключение <xref:System.ArgumentException>. Параметр `userState` используется для выявления рабочего процесса в состоянии <xref:System.Activities.WorkflowInvoker.InvokeCompleted> и отмены этого рабочего процесса с помощью метода <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>.  
  
 Чтобы получить уведомление о завершении рабочего процесса, необходимо обработать событие <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования на основе событий. Дополнительные сведения см. в разделе [Обзор асинхронной модели на основе событий](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. После завершения рабочего процесса они возвращаются в обработчик <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : TimeSpan -&gt; unit" Usage="workflowInvoker.InvokeAsync timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период времени, в течение которого рабочий процесс должен быть завершен, прежде чем он будет прерван и возникнет исключение <see cref="T:System.TimeoutException" />.</param>
        <summary>Вызывает рабочий процесс в асинхронном режиме с указанным интервалом времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить уведомление о завершении рабочего процесса, необходимо обработать событие <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Если рабочий процесс не завершается в течение указанного интервала времени ожидания, он прерывается и создается исключение <xref:System.TimeoutException>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования на основе событий. Дополнительные сведения см. в разделе [Обзор асинхронной модели на основе событий](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. После завершения рабочего процесса они возвращаются в обработчик <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object), userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : System.Collections.Generic.IDictionary&lt;string, obj&gt; * obj -&gt; unit" Usage="workflowInvoker.InvokeAsync (inputs, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <param name="userState">Предоставляемый пользователем объект, который позволяет отличить данную асинхронную операцию вызова от других текущих асинхронных операций вызова.</param>
        <summary>Вызывает рабочий процесс в асинхронном режиме с использованием указанного словаря <see cref="T:System.Collections.Generic.IDictionary`2" /> входных параметров и уникального идентификатора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `userState` должен быть уникальным для всех выполняемых в настоящий момент операций <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> данного действия. Если `userState` не уникален, возникает исключение <xref:System.ArgumentException>. Параметр `userState` используется для выявления рабочего процесса в состоянии <xref:System.Activities.WorkflowInvoker.InvokeCompleted> и отмены этого рабочего процесса с помощью метода <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>.  
  
 Чтобы получить уведомление о завершении рабочего процесса, необходимо обработать событие <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Чтобы задать интервал ожидания, в течение которого рабочий процесс должен завершиться, используйте одну из перегруженных версий метода <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A>, принимающую аргумент <xref:System.TimeSpan>.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования на основе событий. Дополнительные сведения см. в разделе [Обзор асинхронной модели на основе событий](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. После завершения рабочего процесса они возвращаются в обработчик <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object), timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan -&gt; unit" Usage="workflowInvoker.InvokeAsync (inputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <param name="timeout">Период времени, в течение которого рабочий процесс должен быть завершен, прежде чем он будет прерван и возникнет исключение <see cref="T:System.TimeoutException" />.</param>
        <summary>Вызывает рабочий процесс в асинхронном режиме с указанным словарем <see cref="T:System.Collections.Generic.IDictionary`2" /> входных параметров и указанным интервалом времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить уведомление о завершении рабочего процесса, необходимо обработать событие <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Если рабочий процесс не завершается в течение указанного интервала времени ожидания, он прерывается и создается исключение <xref:System.TimeoutException>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования на основе событий. Дополнительные сведения см. в разделе [Обзор асинхронной модели на основе событий](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. После завершения рабочего процесса они возвращаются в обработчик <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (TimeSpan timeout, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(valuetype System.TimeSpan timeout, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (timeout As TimeSpan, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(TimeSpan timeout, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : TimeSpan * obj -&gt; unit" Usage="workflowInvoker.InvokeAsync (timeout, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Период времени, в течение которого рабочий процесс должен быть завершен, прежде чем он будет прерван и возникнет исключение <see cref="T:System.TimeoutException" />.</param>
        <param name="userState">Предоставляемый пользователем объект, который позволяет отличить данную асинхронную операцию вызова от других текущих асинхронных операций вызова.</param>
        <summary>Вызывает рабочий процесс в асинхронном режиме с указанным интервалом времени ожидания и уникальным идентификатором.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `userState` должен быть уникальным для всех выполняемых в настоящий момент операций <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> данного действия. Если `userState` не уникален, возникает исключение <xref:System.ArgumentException>. Параметр `userState` используется для выявления рабочего процесса в состоянии <xref:System.Activities.WorkflowInvoker.InvokeCompleted> и отмены этого рабочего процесса с помощью метода <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>.  
  
 Чтобы получить уведомление о завершении рабочего процесса, необходимо обработать событие <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Если рабочий процесс не завершается в течение указанного интервала времени ожидания, он прерывается и создается исключение <xref:System.TimeoutException>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования на основе событий. Дополнительные сведения см. в разделе [Обзор асинхронной модели на основе событий](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. После завершения рабочего процесса они возвращаются в обработчик <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object), timeout As TimeSpan, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan * obj -&gt; unit" Usage="workflowInvoker.InvokeAsync (inputs, timeout, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">Словарь входных параметров рабочего процесса, различаемых по имени аргумента.</param>
        <param name="timeout">Период времени, в течение которого рабочий процесс должен быть завершен, прежде чем он будет прерван и возникнет исключение <see cref="T:System.TimeoutException" />.</param>
        <param name="userState">Предоставляемый пользователем объект, который позволяет отличить данную асинхронную операцию вызова от других текущих асинхронных операций вызова.</param>
        <summary>Вызывает рабочий процесс в асинхронном режиме с указанным словарем <see cref="T:System.Collections.Generic.IDictionary`2" /> входных параметров, указанным интервалом времени ожидания и уникальным идентификатором.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `userState` должен быть уникальным для всех выполняемых в настоящий момент операций <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> данного действия. Если `userState` не уникален, возникает исключение <xref:System.ArgumentException>. Параметр `userState` используется для выявления рабочего процесса в состоянии <xref:System.Activities.WorkflowInvoker.InvokeCompleted> и отмены этого рабочего процесса с помощью метода <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>.  
  
 Чтобы получить уведомление о завершении рабочего процесса, необходимо обработать событие <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Если рабочий процесс не завершается в течение указанного интервала времени ожидания, он прерывается и создается исключение <xref:System.TimeoutException>.  
  
> [!NOTE]
>  Исключение <xref:System.TimeoutException> создается только в случае, если время ожидания истекло и рабочий процесс перешел в состояние бездействия во время выполнения. Рабочий процесс, не завершающийся в течение отведенного времени ожидания, завершается успешно, если не переходит в состояние простоя.  
  
 Этот метод вызывает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования на основе событий. Дополнительные сведения см. в разделе [Обзор асинхронной модели на основе событий](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. После завершения рабочего процесса они возвращаются в обработчик <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt; InvokeCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Activities.InvokeCompletedEventArgs&gt; InvokeCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Activities.WorkflowInvoker.InvokeCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event InvokeCompleted As EventHandler(Of InvokeCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Activities::InvokeCompletedEventArgs ^&gt; ^ InvokeCompleted;" />
      <MemberSignature Language="F#" Value="member this.InvokeCompleted : EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt; " Usage="member this.InvokeCompleted : System.EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывается, когда рабочий процесс, вызванный одним из перегруженных вариантов <see cref="Overload:System.Activities.WorkflowInvoker.InvokeAsync" />, завершается или отменяется.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обработайте это для определения того, завершился ли успешно рабочий поток, вызванный одним из перегруженных вариантов <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A>, и для получения выходных аргументов завершившегося рабочего процесса.  
  
   
  
## Examples  
 В следующем примере вызывается рабочий процесс, состоящий из действия `LongRunningDiceRoll`. Действие `LongRunningDiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. После завершения рабочего процесса они возвращаются в обработчик <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>