<Type Name="WorkflowInstance" FullName="System.Workflow.Runtime.WorkflowInstance">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3f6722f462218341de377b996c28536f8dae9901" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52222299" /></Metadata><TypeSignature Language="C#" Value="public sealed class WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowInstance extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.WorkflowInstance" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInstance sealed" />
  <TypeSignature Language="F#" Value="type WorkflowInstance = class" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет экземпляр рабочего процесса.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 Класс <xref:System.Workflow.Runtime.WorkflowInstance> предоставляет методы и свойства, которые можно использовать для управления выполнением экземпляра рабочего процесса; по сути, это прокси для фактического экземпляра рабочего процесса, используемого механизмом среды выполнения рабочих процессов. Узел или служба могут предписать механизму среды выполнения рабочих процессов выполнить действия с экземпляром рабочего процесса, вызвав соответствующие методы, содержащиеся в классе <xref:System.Workflow.Runtime.WorkflowInstance>.  Если запрашиваемое действие недопустимо, например, если узел вызывает метод <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> для экземпляра рабочего процесса, который уже завершен, то механизм среды выполнения рабочих процессов вызовет соответствующее исключение.  
  
> [!NOTE]
>  Если экземпляр рабочего процесса перестает отвечать из-за того, что вызов ведущего приложения не возвращается, то единственным способом восстановления этого экземпляра будет перезапуск среды выполнения. Однако, если экземпляр был принудительно выгружен, прерван или приостановлен, то его выполнение можно продолжить, вызвав метод <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода показано создание и запуск экземпляра <xref:System.Workflow.Runtime.WorkflowInstance> в узле рабочего процесса. Код создает экземпляр <xref:System.Workflow.Runtime.WorkflowRuntime>, добавляет службы к среде выполнения, а затем рекомендуемым способом создает объект <xref:System.Workflow.Runtime.WorkflowInstance>. Код инициализирует экземпляр <xref:System.Workflow.Runtime.WorkflowInstance>, вызывая метод <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> и передавая ему созданный ранее тип. Экземпляр <xref:System.Workflow.Runtime.WorkflowInstance> запускается вызовом метода <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A>.  
  
 Данный пример кода является частью примера SDK «Canceling a Workflow» из файла Program.cs. Дополнительные сведения см. в разделе [Отмена рабочего процесса](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Отмена рабочего процесса</related>
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="workflowInstance.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Прерывает выполнение экземпляра рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Выполнение экземпляра рабочего процесса прерывается в синхронном режиме; то есть после прерывания выполнения экземпляра рабочего процесса метод возвращает управление. Механизм среды выполнения рабочих процессов объявляет экземпляр рабочего процесса недействительным в памяти и очищает свойство <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>. Если экземпляр рабочего процесса использовал службу сохраняемости, то все действия, выполненные с момента последнего сохранения, отбрасываются. После прерывания выполнения экземпляра рабочего процесса механизм среды выполнения рабочих процессов вызывает событие <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted>. Можно вызвать метод <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A>, чтобы заново загрузить экземпляр рабочего процесса и запустить его выполнение с последней точки сохранения.  
  
 Метод `Abort` отличается от метода <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> тем, что `Abort` просто удаляет из памяти экземпляр рабочего процесса, который впоследствии можно перезапустить с точки последнего сохранения, в то время как «Terminate» не только удаляет экземпляр рабочего процесса из памяти, но и уведомляет службу сохраняемости о том, что экземпляр удален. Для службы <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> это означает, что все данные о состоянии данного экземпляра рабочего процесса удаляются из базы данных при его завершении. Повторная загрузка экземпляра рабочего процесса с ранее сохраненной точки сохранения будет невозможна.  
  
   
  
## Examples  
 В следующем примере показан вызов метода Abort для экземпляра рабочего процесса типа Workflow1.  
  
 [!code-csharp[WF_Samples#13](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#13)]
 [!code-vb[WF_Samples#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Механизм среды выполнения рабочих процессов не работает.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyWorkflowChanges">
      <MemberSignature Language="C#" Value="public void ApplyWorkflowChanges (System.Workflow.ComponentModel.WorkflowChanges workflowChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyWorkflowChanges(class System.Workflow.ComponentModel.WorkflowChanges workflowChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ApplyWorkflowChanges(System.Workflow.ComponentModel.WorkflowChanges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyWorkflowChanges(System::Workflow::ComponentModel::WorkflowChanges ^ workflowChanges);" />
      <MemberSignature Language="F#" Value="member this.ApplyWorkflowChanges : System.Workflow.ComponentModel.WorkflowChanges -&gt; unit" Usage="workflowInstance.ApplyWorkflowChanges workflowChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowChanges" Type="System.Workflow.ComponentModel.WorkflowChanges" />
      </Parameters>
      <Docs>
        <param name="workflowChanges">Объект <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" />, задающий динамические обновления для экземпляра рабочего процесса.</param>
        <summary>Применяет к экземпляру рабочего процесса изменения, задаваемые объектом <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если экземпляр рабочего процесса еще не приостановлен, то механизм среды выполнения рабочих процессов временно приостанавливает выполнение экземпляра перед применением изменений.  
  
   
  
## Examples  
 В следующем примере показан вызов метода ApplyWorkflowChanges для объекта <xref:System.Workflow.Runtime.WorkflowInstance>.  Это пример из образца пакета SDK «Ordering State Machine» из файла Mainform.cs.  Дополнительные сведения см. в разделе [упорядочение пример конечного автомата](https://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c).  
  
 [!code-csharp[WF_Samples#89](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#89)]
 [!code-vb[WF_Samples#89](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Механизм среды выполнения рабочих процессов не работает.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItem">
      <MemberSignature Language="C#" Value="public void EnqueueItem (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItem(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItem(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItem (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItem(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItem : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItem (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">Имя <see cref="T:System.Workflow.Runtime.WorkflowQueue" />.</param>
        <param name="item">Объект для постановки в очередь.</param>
        <param name="pendingWork">Интерфейс <see cref="T:System.Workflow.Runtime.IPendingWork" />, позволяющий отправителю получать уведомления при доставке элемента <paramref name="item" />.</param>
        <param name="workItem">Объект, передаваемый в методы <see cref="T:System.Workflow.Runtime.IPendingWork" />.</param>
        <summary>Синхронно отправляет сообщение в указанную очередь рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отправляет элемент `item` в указанную очередь <xref:System.Workflow.Runtime.WorkflowQueue>. Если необходимо получать уведомления при доставке сообщений, то в службе можно реализовать интерфейс <xref:System.Workflow.Runtime.IPendingWork> и передавать элемент `workItem` и объект <xref:System.Workflow.Runtime.IPendingWork> в метод <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Если такое уведомление не требуется, то можно передать неопределенную ссылку (`Nothing` в Visual Basic) в качестве параметров `pendingWork` и `workItem`.  
  
 При использовании этого метода с рабочим процессом конечного автомата можно получить исключение с сообщением: «Очередь '{0}' не включена». Это происходит, когда при текущем состоянии конечного автомата не известно, как обработать определенное событие. Например, если какое-либо состояние, отличное от текущего, содержит действие <xref:System.Workflow.Activities.EventDrivenActivity>, содержащее действие <xref:System.Workflow.Activities.HandleExternalEventActivity>, которое представляется очередью "{0}".  
  
> [!NOTE]
>  Порядок сообщений, получаемых экземпляром рабочего процесса, не обязательно будет соответствовать порядку, в котором они были отправлены. Например, если получение сообщения в существующей очереди (очередь A) приводит к тому, что рабочий процесс создает другую очередь (очередь B), которая затем ожидает другое сообщение, отправленное после первого, то есть вероятность, что второе сообщение поступит первым и не будет получено, так как его очередь еще не создана. Чтобы предотвратить эту проблему, не следует отправлять второе сообщение, пока не проверено наличие его очереди (с помощью метода <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>.)  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование метода <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. При возникновении события <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> вызывается метод `OnWorkflowIdled`, определенный в этом примере. Он определяет, какой рабочий процесс бездействует, используя свойство <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A>, а затем возвращает коллекцию элементов, находящихся в очереди экземпляра рабочего потока, вызывая метод <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>. Код выполняет перебор элементов коллекции, чтобы определить, какое действие ожидает события, которое привело к бездействию рабочего процесса. После этого он отправляет исключение в очередь рабочего процесса, используя метод <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> с именем элемента очереди событий.  
  
 Данный пример кода является частью примера SDK «Canceling a Workflow» из файла Program.cs. Дополнительные сведения см. в разделе [Отмена рабочего процесса](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="queueName" /> является неопределенной ссылкой (<see langword="Nothing" /> в Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Механизм среды выполнения рабочих процессов не работает.  
  
- или - 
Очередь <see cref="T:System.Workflow.Runtime.WorkflowQueue" />, заданная именем <paramref name="queueName" />, не существует.  
  
- или - 
Очередь <see cref="T:System.Workflow.Runtime.WorkflowQueue" />, заданная именем <paramref name="queueName" />, не включена.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Отмена рабочего процесса</related>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItemOnIdle">
      <MemberSignature Language="C#" Value="public void EnqueueItemOnIdle (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItemOnIdle(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItemOnIdle (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItemOnIdle(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItemOnIdle : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItemOnIdle (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">Имя <see cref="T:System.Workflow.Runtime.WorkflowQueue" />.</param>
        <param name="item">Объект для постановки в очередь.</param>
        <param name="pendingWork">Интерфейс <see cref="T:System.Workflow.Runtime.IPendingWork" />, позволяющий отправителю получать уведомления при доставке элемента <paramref name="item" />.</param>
        <param name="workItem">Объект, передаваемый в методы <see cref="T:System.Workflow.Runtime.IPendingWork" />.</param>
        <summary>Отправляет сообщение в указанную очередь рабочего процесса, когда рабочий процесс находится в состоянии бездействия. Метод <see cref="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" /> ожидает перехода рабочего процесса в состояние бездействия и выполняет постановку в очередь после проверки на бездействие планировщика заданий рабочего процесса (то есть при отсутствии выполнения активных операций).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ожидает, когда экземпляр рабочего процесса перейдет в состояние бездействия, а затем отправляет элемент `item` в указанную очередь <xref:System.Workflow.Runtime.WorkflowQueue>. Если вызвать метод <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle%2A>, когда экземпляр рабочего процесса приостановлен, то механизм среды выполнения рабочих процессов вызовет исключение <xref:System.InvalidOperationException>. Если необходимо получать уведомления при доставке сообщений, то в службе можно реализовать интерфейс <xref:System.Workflow.Runtime.IPendingWork> и передавать элемент `workItem` и объект <xref:System.Workflow.Runtime.IPendingWork> в метод <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Если такое уведомление не требуется, то можно передать неопределенную ссылку (`Nothing` в Visual Basic) в качестве параметров `pendingWork` и `workItem`.  
  
 При использовании этого метода с рабочим процессом конечного автомата можно получить исключение с сообщением: «Очередь '{0}' не включена». Это происходит, когда текущее состояние конечного автомата не может обработать определенное событие. Например, если какое-либо состояние, отличное от текущего, содержит действие <xref:System.Workflow.Activities.EventDrivenActivity>, содержащее действие <xref:System.Workflow.Activities.HandleExternalEventActivity>, которое представляется очередью "{0}".  
  
   
  
## Examples  
 В следующем примере показана отправка данных экземпляру рабочего процесса с помощью метода `EnqueueItemOnIdle`. Сначала создается и запускается объект «WorkflowInstance»; затем создается объект, реализующий интерфейс <xref:System.Workflow.Runtime.IPendingWork>, и предоставляет ему контекст запроса. `EnqueueItemOnIdle` Затем вызывается, передавая имя очереди, в очередь и рабочего элемента, можно передать в методы объекта pendingWork в строковых значениях.  
  
 [!code-csharp[WF_Samples#12](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#12)]
 [!code-vb[WF_Samples#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="queueName" /> является неопределенной ссылкой (<see langword="Nothing" /> в Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Механизм среды выполнения рабочих процессов не работает.  
  
- или - 
Выполнение экземпляра рабочего процесса приостановлено.  
  
- или - 
Очередь <see cref="T:System.Workflow.Runtime.WorkflowQueue" />, заданная именем <paramref name="queueName" />, не существует.  
  
- или - 
Очередь <see cref="T:System.Workflow.Runtime.WorkflowQueue" />, заданная именем <paramref name="queueName" />, не включена.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="workflowInstance.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для сравнения.</param>
        <summary>Возвращает значение, указывающее, совпадает ли указанный объект с экземпляром <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</summary>
        <returns>Значение <see langword="true" />, если заданный объект совпадает с этим экземпляром <see cref="T:System.Workflow.Runtime.WorkflowInstance" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект должен быть экземпляром класса <xref:System.Workflow.Runtime.WorkflowInstance> и иметь свойство <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A>, совпадающее с данным экземпляром <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="workflowInstance.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код данного экземпляра рабочего процесса.</summary>
        <returns>Хэш-код для этого экземпляра <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Workflow.Runtime.WorkflowInstance.GetHashCode%2A> возвращает хэш-код, основанный на значении свойства <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowDefinition">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Activity GetWorkflowDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.ComponentModel.Activity GetWorkflowDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowDefinition () As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::ComponentModel::Activity ^ GetWorkflowDefinition();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowDefinition : unit -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowInstance.GetWorkflowDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает корневое действие экземпляра рабочего процесса.</summary>
        <returns>Объект <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Корневое действие можно использовать для переходов по иерархии действий рабочего процесса.  
  
 Этот метод не является потокобезопасным, поэтому узел должен синхронизировать свои вызовы с этим методом.  
  
   
  
## Examples  
 В следующем примере показано извлечение определения рабочего процесса из его экземпляра.  Это пример из образца пакета SDK «Ordering State Machine» из файла Mainform.cs.  Дополнительные сведения см. в разделе [упорядочение пример конечного автомата](https://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c).  
  
 [!code-csharp[WF_Samples#86](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#86)]
 [!code-vb[WF_Samples#86](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#86)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowNextTimerExpiration">
      <MemberSignature Language="C#" Value="public DateTime GetWorkflowNextTimerExpiration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetWorkflowNextTimerExpiration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowNextTimerExpiration () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetWorkflowNextTimerExpiration();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowNextTimerExpiration : unit -&gt; DateTime" Usage="workflowInstance.GetWorkflowNextTimerExpiration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает следующий момент времени, который запланирован для доставки сообщения таймера данному экземпляру <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</summary>
        <returns>Значение DateTime представляет следующий момент времени <see cref="P:System.Workflow.Runtime.TimerEventSubscription.ExpiresAt" />, когда данному экземпляру <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> будет доставлено сообщение таймера.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано использование метода <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration%2A> для проверки наличия других сообщений таймера рабочего процесса в очереди. Это пример из образца пакета SDK «WorkflowThreading» из файла Program.cs. Дополнительные сведения см. в разделе [Threading пример рабочего процесса](https://msdn.microsoft.com/library/5b650be7-09fa-47db-a2f6-523dc8ea5ee9).  
  
 [!code-csharp[WF_Samples#284](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#284)]
 [!code-vb[WF_Samples#284](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#284)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Workflow.Runtime.TimerEventSubscription" />
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowQueueData">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowQueueData () As ReadOnlyCollection(Of WorkflowQueueInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Workflow::Runtime::WorkflowQueueInfo ^&gt; ^ GetWorkflowQueueData();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowQueueData : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;" Usage="workflowInstance.GetWorkflowQueueData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию объектов <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" />, которая содержит ожидающие элементы и подписанные действия для очередей рабочего процесса, связанных с данным экземпляром рабочего процесса.</summary>
        <returns>Коллекция <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> объектов <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> возвращает коллекцию объектов <xref:System.Workflow.Runtime.WorkflowQueueInfo>, каждый из которых содержит сведения о состоянии одной из очередей рабочего процесса, связанных с данным экземпляром рабочего процесса. <xref:System.Workflow.Runtime.WorkflowQueueInfo.Items%2A?displayProperty=nameWithType> содержит ожидающие элементы для <xref:System.Workflow.Runtime.WorkflowQueue>, а <xref:System.Workflow.Runtime.WorkflowQueueInfo.SubscribedActivityNames%2A?displayProperty=nameWithType> содержит список действий, подписанных на доставку элементов для <xref:System.Workflow.Runtime.WorkflowQueue>.  
  
   
  
## Examples  
 В следующем примере кода показано использование метода <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> для получения данных о состоянии всех очередей рабочего процесса, связанных с объектом <xref:System.Workflow.Runtime.WorkflowInstance>. При возникновении события <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> вызывается метод `OnWorkflowIdled`, определенный в этом примере. Он определяет, какой рабочий процесс бездействует, используя свойство <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A>, а затем возвращает коллекцию элементов, находящихся в очереди экземпляра рабочего потока, вызывая метод <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>. Код выполняет перебор элементов коллекции, чтобы определить, какое действие ожидает события, которое привело к бездействию рабочего процесса. После этого он отправляет исключение в очередь рабочего процесса, используя метод <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> с именем элемента очереди событий.  
  
 Данный пример кода является частью примера SDK «Canceling a Workflow» из файла Program.cs. Дополнительные сведения см. в разделе [Отмена рабочего процесса](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Механизм среды выполнения рабочих процессов не работает.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Отмена рабочего процесса</related>
      </Docs>
    </Member>
    <Member MemberName="InstanceId">
      <MemberSignature Language="C#" Value="public Guid InstanceId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid InstanceId" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid InstanceId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceId : Guid" Usage="System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает уникальный идентификатор экземпляра рабочего процесса.</summary>
        <value>Тип <see cref="T:System.Guid" /> экземпляра рабочего процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для ссылки на экземпляр рабочего процесса можно использовать свойство <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано использование свойства <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> для получения сведений об объекте <xref:System.Workflow.Runtime.WorkflowInstance>. Первый фрагмент кода создает переменную <xref:System.Workflow.Runtime.WorkflowInstance> с именем `instanceId`.  
  
 [!code-csharp[WF_Samples#210](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#210)]
 [!code-vb[WF_Samples#210](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#210)]  
  
 Второй фрагмент использует свойство <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A>, как первый объект при вызове конструктора `OrderEventArgs`, когда вызывается метод `CallBackForApproval`.  
  
 Данный пример кода является частью образца пакета SDK Listen из файла OrderServiceImple.cs. Дополнительные сведения см. в разделе [прослушивания образец](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741698(v=vs.90)).  
  
 [!code-csharp[WF_Samples#211](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#211)]
 [!code-vb[WF_Samples#211](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#211)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741698(v=vs.90)">Пример. Прослушивание</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Load" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load();" />
      <MemberSignature Language="F#" Value="member this.Load : unit -&gt; unit" Usage="workflowInstance.Load " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Загружает ранее выгруженный экземпляр рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> является синхронным; если загрузка экземпляра рабочего процесса возможна, то после его загрузки в память и включения в план выполнения механизмом среды выполнения рабочих процессов метод <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> возвращает управление. Среда выполнения создает событие <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded> после того, как служба сохраняемости восстанавливает экземпляр рабочего процесса в памяти, но до того, как механизм среды выполнения рабочих процессов включит этот экземпляр в план выполнения.  
  
   
  
## Examples  
 В следующем примере показана загрузка ранее выгруженного объекта <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 [!code-csharp[WF_Samples#10](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#10)]
 [!code-vb[WF_Samples#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Механизм среды выполнения рабочих процессов не работает.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReloadTrackingProfiles">
      <MemberSignature Language="C#" Value="public void ReloadTrackingProfiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReloadTrackingProfiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ReloadTrackingProfiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReloadTrackingProfiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReloadTrackingProfiles();" />
      <MemberSignature Language="F#" Value="member this.ReloadTrackingProfiles : unit -&gt; unit" Usage="workflowInstance.ReloadTrackingProfiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Перезагрузите профили отслеживания для данного экземпляра рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Инфраструктура отслеживания среды выполнения перезагрузит все профили <xref:System.Workflow.Runtime.Tracking.TrackingProfile> для данного экземпляра рабочего процесса, связанные с ее каналами отслеживания. Если рабочий процесс не находится в приостановленном состоянии, то при повторной загрузке профилей отслеживания инфраструктура отслеживания среды выполнения временно приостанавливает его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Механизм среды выполнения рабочих процессов не работает.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="workflowInstance.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возобновляет выполнение ранее приостановленного экземпляра рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Узел может вызвать метод <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A> для возобновления выполнения экземпляра рабочего процесса, который был ранее приостановлен. Если экземпляр рабочего процесса не находится в приостановленном состоянии, то никакие действия не выполняются. Среда выполнения вызывает событие <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> непосредственно перед возобновлением выполнения экземпляра рабочего процесса.  
  
   
  
## Examples  
 В следующем примере показан вызов метода Resume для ранее приостановленного экземпляра рабочего процесса.  Данный пример является частью образца пакета SDK «Suspend and Terminate».  Дополнительные сведения см. в разделе [Suspend and Terminate образец](https://msdn.microsoft.com/library/f4dffa58-d01e-44fb-b5a1-3b283d2c4517).  
  
 [!code-csharp[WF_Samples#172](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#172)]
 [!code-vb[WF_Samples#172](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#172)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Механизм среды выполнения рабочих процессов не работает.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="workflowInstance.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает выполнение экземпляра рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> вызывает метод <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ExecuteActivity%2A> для корневого действия данного экземпляра рабочего процесса. Если в методе <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> возникает исключение, то он завершает выполнение экземпляра рабочего процесса, вызывая метод <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> со свойством <xref:System.Exception.Message%2A> исключения, переданным в качестве причины завершения.  
  
   
  
## Examples  
 В следующем примере кода показано использование метода <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> для запуска экземпляра <xref:System.Workflow.Runtime.WorkflowInstance> в узле рабочего процесса. Код создает экземпляр <xref:System.Workflow.Runtime.WorkflowRuntime>, добавляет службы к среде выполнения, а затем рекомендуемым способом создает объект <xref:System.Workflow.Runtime.WorkflowInstance>. Он создает объект типа <xref:System.Type> и приводит его к одному из объектов рабочего процесса, с которым связан узел. Затем код инициализирует экземпляр <xref:System.Workflow.Runtime.WorkflowInstance>, вызывая метод <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> и передавая ему созданный ранее тип. Экземпляр <xref:System.Workflow.Runtime.WorkflowInstance> запускается вызовом метода <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A>.  
  
 Данный пример кода является частью примера SDK «Canceling a Workflow» из файла Program.cs. Дополнительные сведения см. в разделе [Отмена рабочего процесса](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Механизм среды выполнения рабочих процессов не работает.  
  
- или - 
Экземпляр рабочего процесса уже запущен.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Отмена рабочего процесса</related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Suspend(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Suspend : string -&gt; unit" Usage="workflowInstance.Suspend error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">Описание причины приостановки выполнения экземпляра рабочего процесса.</param>
        <summary>Приостанавливает выполнение экземпляра рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр рабочего процесса приостановлен в синхронном режиме. Если экземпляр рабочего процесса уже приостановлен, то никакие действия не выполняются; в противном случае механизм среды выполнения рабочих процессов приостанавливает экземпляр рабочего процесса, вызывает событие <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended> и передает причину `reason` в аргументах <xref:System.Workflow.Runtime.WorkflowSuspendedEventArgs>.  
  
> [!NOTE]
>  Метод <xref:System.Workflow.Runtime.WorkflowInstance.Suspend%2A> не выгружает экземпляр рабочего процесса.  
  
   
  
## Examples  
 В следующем примере кода показан вызов метода Suspend для объекта <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 [!code-csharp[WF_Samples#9](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#9)]
 [!code-vb[WF_Samples#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Механизм среды выполнения рабочих процессов не работает.</exception>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Terminate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string -&gt; unit" Usage="workflowInstance.Terminate error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">Описание причины завершения выполнения экземпляра рабочего процесса.</param>
        <summary>Завершает выполнение экземпляра рабочего процесса в синхронном режиме.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Выполнение экземпляра рабочего процесса завершено в синхронном режиме. Узел вызывает метод <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> для завершения выполнения экземпляра рабочего процесса. Механизм среды выполнения рабочих процессов удаляет экземпляр рабочего процесса из памяти и уведомляет службу сохраняемости о том, что экземпляр удален. Для службы <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> это означает, что все данные о состоянии данного экземпляра рабочего процесса удаляются из базы данных при его завершении. Повторная загрузка экземпляра рабочего процесса с ранее сохраненной точки сохранения будет невозможна.  
  
 После удаления экземпляра рабочего процесса из памяти и уведомления службы сохраняемости о завершении, метод `Terminate` вызывает событие <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> и передает причину `reason` в свойство <xref:System.Exception.Message%2A> объекта <xref:System.Workflow.ComponentModel.WorkflowTerminatedException>, содержащегося в аргументах <xref:System.Workflow.Runtime.WorkflowTerminatedEventArgs>.  
  
 Метод `Terminate` отличается от метода <xref:System.Workflow.Runtime.WorkflowInstance.Abort%2A> тем, что «Terminate» не только удаляет экземпляр рабочего процесса из памяти, но и уведомляет службу сохраняемости о завершении, в то время как `Abort` просто удаляет из памяти экземпляр рабочего процесса, который впоследствии можно перезапустить с точки последнего сохранения.  
  
   
  
## Examples  
 В следующем примере кода показан вызов метода Terminate для объекта <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 [!code-csharp[WF_Samples#8](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#8)]
 [!code-vb[WF_Samples#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Механизм среды выполнения рабочих процессов не работает.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryUnload">
      <MemberSignature Language="C#" Value="public bool TryUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.TryUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function TryUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryUnload();" />
      <MemberSignature Language="F#" Value="member this.TryUnload : unit -&gt; bool" Usage="workflowInstance.TryUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выгружает экземпляр рабочего процесса из памяти в хранилище сохраняемости, если он приостановлен или бездействует.</summary>
        <returns>Значение <see langword="true" />, если экземпляр рабочего процесса выгружен; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если экземпляр рабочего процесса приостановлен или бездействует, то метод <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> использует службу сохраняемости для его удаления из памяти и сохранения в хранилище данных. Если служба сохраняемости, зарегистрированная объектом <xref:System.Workflow.Runtime.WorkflowRuntime>, отсутствует, то метод <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> вызывает исключение <xref:System.InvalidOperationException>. Если экземпляр рабочего процесса сохранен успешно, то среда выполнения вызывает <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> события; возвращает `true`. <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> Возвращает `false` Если экземпляр рабочего процесса уже был выгружен, был завершен, прерван или уже завершена.  
  
 Узел может использовать метод <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> для освобождения системных ресурсов бездействующего рабочего процесса.  
  
   
  
## Examples  
 В следующем примере показано использование метода «TryUnload» для выгрузки рабочего процесса при возникновении события <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled>. Данный пример является частью образца пакета SDK «Using Persistence Services» из файла Program.cs. Дополнительные сведения см. в разделе [с помощью пример службы постоянного хранения](https://msdn.microsoft.com/library/3176b7e7-ae49-4d5c-802b-85032d6ebde6).  
  
 [!code-csharp[WF_Samples#280](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#280)]
 [!code-vb[WF_Samples#280](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#280)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Отсутствует служба сохраняемости, зарегистрированная механизмом среды выполнения рабочих процессов.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="workflowInstance.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выгружает экземпляр рабочего процесса из памяти в хранилище сохраняемости. Этот вызов блокируется до завершения текущих запланированных заданий или до окончания области транзакции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> является синхронным, то есть после завершения выполняемых действий он возвращает управление. Если экземпляр рабочего процесса не бездействует, то среда выполнения будет ожидать возможности его прерывания. Экземпляр может быть прерван только после завершения текущей запланированной работы; обычно это происходит, когда выполняемое действие возвращает управление из своего метода <xref:System.Workflow.ComponentModel.Activity.Execute%2A>. Однако, если экземпляр выполняет действие <xref:System.Workflow.ComponentModel.TransactionScopeActivity>, то область транзакции должна завершить выполнение перед тем, как экземпляр сможет быть прерван. После этого метод «Unload» использует службу сохраняемости для удаления экземпляра рабочего процесса из памяти и сохраняет его в хранилище данных. Если служба сохраняемости, зарегистрированная объектом <xref:System.Workflow.Runtime.WorkflowRuntime>, отсутствует, то метод <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> вызывает исключение <xref:System.InvalidOperationException>. Если экземпляр рабочего процесса сохранен успешно, то среда выполнения вызывает событие <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded>.  
  
 Узел может использовать метод <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> для освобождения системных ресурсов бездействующего рабочего процесса.  
  
   
  
## Examples  
 В следующем примере показан вызов метода <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> для объекта <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 [!code-csharp[WF_Samples#11](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#11)]
 [!code-vb[WF_Samples#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Отсутствует служба сохраняемости, зарегистрированная механизмом среды выполнения рабочих процессов.</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkflowRuntime">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkflowRuntime As WorkflowRuntime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::Runtime::WorkflowRuntime ^ WorkflowRuntime { System::Workflow::Runtime::WorkflowRuntime ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkflowRuntime : System.Workflow.Runtime.WorkflowRuntime" Usage="System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowRuntime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> для данного экземпляра рабочего процесса.</summary>
        <value>Объект <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />, представляющий среду выполнения, в которой работает данный экземпляр рабочего процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано обращение к выполнению объекта <xref:System.Workflow.Runtime.WorkflowRuntime> объекта <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 [!code-csharp[WF_Samples#7](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#7)]
 [!code-vb[WF_Samples#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>