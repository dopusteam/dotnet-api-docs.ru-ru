<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileIO.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ee81e9f334899c8c9a4a0ad45ea8719d725893a8" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57953805" /></Metadata><TypeSignature Language="C#" Value="public class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Включает свойства и методы для работы с дисками, файлами и каталогами.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem` объекта.  
  
|Кому|См.|  
|-|-|  
|Чтение из текстового файла|[Практическое руководство. Чтение из текстовых файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Чтение из текстовых файлов|[Практическое руководство. Чтение из текстовых файлов с разделителями-запятыми](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Чтение из файла текста фиксированной ширины|[Практическое руководство. Чтение из текстовых файлов с полями фиксированного размера](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Чтение из текстового файла с несколькими форматами|[Практическое руководство. Чтение из текстовых файлов различных форматов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Чтение из двоичного файла|[Практическое руководство. Чтение из двоичных файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Чтение из текстового файла с помощью <xref:System.IO.StreamReader>|[Практическое руководство. Чтение текста из файлов с помощью StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Запись в текстовый файл|[Практическое руководство. Запись текста в файлы](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Добавьте в текстовый файл|[Практическое руководство. Дозапись в текстовый файл](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Запись в двоичный файл|[Практическое руководство. Запись в двоичные файлы](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Запись в текстовый файл в **MyDocuments** каталога|[Практическое руководство. Запись текста в файлы в каталоге "Мои документы"](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Запись в текстовый файл с `StreamWriter`|[Практическое руководство. Запись текста в файлы с помощью StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Копирование файлов по конкретному шаблону|[Практическое руководство. Копирование файлов по заданному шаблону в каталог](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Скопировать файл на том же каталоге|[Практическое руководство. Создание копии файла в том же каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другой каталог|[Практическое руководство. Создание копии файла в другом каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Создайте файл|[Практическое руководство. Создание файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Удаление файла|[Практическое руководство. Удаление файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Поиск файлов по конкретному шаблону|[Практическое руководство. Поиск файлов по конкретному шаблону](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Перемещение файла|[Практическое руководство. Перемещение файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Переименование файла|[Практическое руководство. Переименование файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Копирование каталога в другой каталог|[Практическое руководство. Копирование каталога в другой каталог](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Создание каталога|[Практическое руководство. Создание каталога](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Поиск подкаталогов по шаблону|[Практическое руководство. Поиск подкаталогов по шаблону](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Получение коллекции содержащихся в каталоге файлов|[Практическое руководство. Получение коллекции содержащихся в каталоге файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Чтение из **MyDocuments** каталога|[Практическое руководство. Извлечение содержимого каталога "Мои документы"](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Синтаксический анализ пути к файлу|[Практическое руководство. Анализ путей к файлам](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 В этом примере проверяется, чтобы определить, является ли папка `C:\backup\logs` существует и ее свойства.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
    <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Объекты (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystem ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [Объекты (Visual Basic)](~/docs/visual-basic/language-reference/objects/index.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public static string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CombinePath(string baseDirectory, string relativePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberSignature Language="F#" Value="static member CombinePath : string * string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CombinePath (baseDirectory, relativePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory"><see langword="String" />. Первый путь, который необходимо объединить.</param>
        <param name="relativePath"><see langword="String" />. Второй путь, который необходимо объединить.</param>
        <summary>Объединяет два пути и возвращает правильно отформатированный путь.</summary>
        <returns>Сочетание заданных путей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод удаляет лишние косые черты, чтобы создать путь в правильном формате.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.CombinePath` метод.  
  
|Кому|См.|  
|-|-|  
|Объединить путь и имя каталога|[Практическое руководство. Анализ путей к файлам в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 В этом примере объединяет путь и имя каталога для создания путь в правильном формате.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 В этом примере объединяются два пути для создания путь в правильном формате.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 Этот пример возвращает `C:\Dir1\Dir2\Dir4\Dir5\File.txt`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь <paramref name="baseDirectory" /> или <paramref name="relativePath" /> сформирован неправильно.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует содержимое каталога в другой каталог.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Каталог, который необходимо скопировать.</param>
        <param name="destinationDirectoryName">Местоположение, в которое необходимо скопировать содержимое каталога.</param>
        <summary>Копирует содержимое каталога в другой каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует содержимое исходного каталога в целевой каталог. Если целевой каталог не существует, он создается. Если каталог с тем же именем существует в целевом расположении, содержимое двух каталогов объединяется. Во время операции можно указать новое имя для каталога.  
  
 При копировании файлов в каталоге, могут быть исключения, вызванные определенного файла. При возникновении таких исключений, они объединяются в одно исключение, `Data` свойство содержит записи в виде <xref:System.Collections.IDictionary> путь к файлу или каталогу является ключом и содержится в конкретном исключении соответствующее значение. Используйте `For…Each` для перечисления по записям.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.CopyDirectory` метод.  
  
|Кому|См.|  
|-|-|  
|Копирование каталога|[Практическое руководство. Копирование каталога в другой каталог в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Следующий пример копирует содержимое каталога `TestDirectory1` в `TestDirectory2`, перезаписывая существующие файлы.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Замените `C:\TestDirectory1` и `C:\TestDirectory2` путь и имя каталога, который необходимо скопировать и расположение, к которому вы хотите скопировать его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> или <paramref name="sourceDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Исходный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Исходный и конечный пути совпадают.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя папки в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Конечный файл существует, но к нему нет доступа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Каталог, который необходимо скопировать.</param>
        <param name="destinationDirectoryName">Местоположение, в которое необходимо скопировать содержимое каталога.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Копирует содержимое каталога в другой каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует содержимое исходного каталога в целевой каталог. Если целевой каталог не существует, он создается. Если каталог с тем же именем существует в целевом расположении, содержимое двух каталогов объединяется. Во время операции можно указать новое имя для каталога.  
  
 При копировании файлов в каталоге, могут быть исключения, вызванные определенного файла. При возникновении таких исключений, они объединяются в одно исключение, `Data` свойство содержит записи в виде <xref:System.Collections.IDictionary> путь к файлу или каталогу является ключом и содержится в конкретном исключении соответствующее значение. Используйте `For…Each` для перечисления по записям.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.CopyDirectory` метод.  
  
|Кому|См.|  
|-|-|  
|Копирование каталога|[Практическое руководство. Копирование каталога в другой каталог в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Следующий пример копирует содержимое каталога `TestDirectory1` в `TestDirectory2`, перезаписывая существующие файлы.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Замените `C:\TestDirectory1` и `C:\TestDirectory2` путь и имя каталога, который необходимо скопировать и расположение, к которому вы хотите скопировать его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> или <paramref name="sourceDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Исходный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Исходный и конечный пути совпадают.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя папки в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Конечный файл существует, но к нему нет доступа.</exception>
        <exception cref="T:System.OperationCanceledException">Параметр <paramref name="ShowUI" /> имеет значение <see langword="UIOption.AllDialogs" />, а пользователь отменил операцию, или один или несколько файлов в каталоге не могут быть скопированы.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буфера обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Каталог, который необходимо скопировать.</param>
        <param name="destinationDirectoryName">Местоположение, в которое необходимо скопировать содержимое каталога.</param>
        <param name="overwrite">Значение <see langword="True" /> для перезаписи существующих файлов; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Копирует содержимое каталога в другой каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует содержимое исходного каталога в целевой каталог. Если целевой каталог не существует, он создается. Если каталог с тем же именем существует в целевом расположении, содержимое двух каталогов объединяется. Во время операции можно указать новое имя для каталога.  
  
 При копировании файлов в каталоге, могут быть исключения, вызванные определенного файла, например файлом, существующим во время слияния `overwrite` присваивается `False`. При возникновении таких исключений, они объединяются в одно исключение, `Data` свойство содержит записи в виде <xref:System.Collections.IDictionary> путь к файлу или каталогу является ключом и содержится в конкретном исключении соответствующее значение. Используйте `For…Each` для перечисления по записям.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.CopyDirectory` метод.  
  
|Кому|См.|  
|-|-|  
|Копирование каталога|[Практическое руководство. Копирование каталога в другой каталог в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Следующий пример копирует содержимое каталога `TestDirectory1` в `TestDirectory2`, перезаписывая существующие файлы.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Замените `C:\TestDirectory1` и `C:\TestDirectory2` путь и имя каталога, который необходимо скопировать и расположение, к которому вы хотите скопировать его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> или <paramref name="sourceDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Исходный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Исходный и конечный пути совпадают.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя папки в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Конечный файл существует, но к нему нет доступа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Каталог, который необходимо скопировать.</param>
        <param name="destinationDirectoryName">Местоположение, в которое необходимо скопировать содержимое каталога.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Определяет, что должно быть выполнено, если во время операции пользователь нажмет кнопку **Отмена**. Значение по умолчанию — <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Копирует содержимое каталога в другой каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует содержимое исходного каталога в целевой каталог. Если целевой каталог не существует, он создается. Если каталог с тем же именем существует в целевом расположении, содержимое двух каталогов объединяется. Во время операции можно указать новое имя для каталога.  
  
 При копировании файлов в каталоге, могут быть исключения, вызванные определенного файла. При возникновении таких исключений, они объединяются в одно исключение, `Data` свойство содержит записи в виде <xref:System.Collections.IDictionary> путь к файлу или каталогу является ключом и содержится в конкретном исключении соответствующее значение. Используйте `For…Each` для перечисления по записям.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.CopyDirectory` метод.  
  
|Кому|См.|  
|-|-|  
|Копирование каталога|[Практическое руководство. Копирование каталога в другой каталог в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Следующий пример копирует содержимое каталога `TestDirectory1` в `TestDirectory2`, перезаписывая существующие файлы.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Замените `C:\TestDirectory1` и `C:\TestDirectory2` путь и имя каталога, который необходимо скопировать и расположение, к которому вы хотите скопировать его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> или <paramref name="sourceDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Исходный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Исходный и конечный пути совпадают.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя папки в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Конечный файл существует, но к нему нет доступа.</exception>
        <exception cref="T:System.OperationCanceledException">Параметр <paramref name="ShowUI" /> имеет значение <see langword="UIOption.AllDialogs" />, а пользователь отменил операцию, или один или несколько файлов в каталоге не могут быть скопированы.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буфера обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует файл в новое местоположение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Файл, который необходимо скопировать.</param>
        <param name="destinationFileName">Местоположение, в которое необходимо скопировать файл.</param>
        <summary>Копирует файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` не сохраняет элементы управления доступом (записи управления доступом). Вновь созданный файл наследует элементы управления доступом по умолчанию из каталога, в котором он создан.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CopyFile` метод.  
  
|Кому|См.|  
|-|-|  
|Скопируйте файл в тот же каталог.|[Практическое руководство. Создание копии файла в том же каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другой каталог.|[Практическое руководство. Создание копии файла в другом каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 В этом примере копирует файл `Test.txt` в каталог `TestFiles2` без перезаписи существующих файлов.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 В этом примере копирует файл `Test.txt` в каталог `TestFiles2` и переименовывает его `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> или <paramref name="sourceFileName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл в целевом каталоге с тем же именем уже используется.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Файл, который необходимо скопировать.</param>
        <param name="destinationFileName">Местоположение, в которое необходимо скопировать файл.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Копирует файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` не сохраняет элементы управления доступом (записи управления доступом). Вновь созданный файл наследует элементы управления доступом по умолчанию из каталога, в котором он создан.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CopyFile` метод.  
  
|Кому|См.|  
|-|-|  
|Скопируйте файл в тот же каталог.|[Практическое руководство. Создание копии файла в том же каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другой каталог.|[Практическое руководство. Создание копии файла в другом каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 В этом примере копирует файл `Test.txt` в каталог `TestFiles2` без перезаписи существующих файлов.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 В этом примере копирует файл `Test.txt` в каталог `TestFiles2` и переименовывает его `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> или <paramref name="sourceFileName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Конечный файл существует, а параметр <paramref name="overwrite" /> имеет значение <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буфера обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Файл, который необходимо скопировать.</param>
        <param name="destinationFileName">Местоположение, в которое необходимо скопировать файл.</param>
        <param name="overwrite">Значение <see langword="True" />, если нужно перезаписывать существующие файлы; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Копирует файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` не сохраняет элементы управления доступом (записи управления доступом). Вновь созданный файл наследует элементы управления доступом по умолчанию из каталога, в котором он создан.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CopyFile` метод.  
  
|Кому|См.|  
|-|-|  
|Скопируйте файл в тот же каталог.|[Практическое руководство. Создание копии файла в том же каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другой каталог.|[Практическое руководство. Создание копии файла в другом каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 В этом примере копирует файл `Test.txt` в каталог `TestFiles2` без перезаписи существующих файлов.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 В этом примере копирует файл `Test.txt` в каталог `TestFiles2` и переименовывает его `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> или <paramref name="sourceFileName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Конечный файл существует, а параметр <paramref name="overwrite" /> имеет значение <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Файл, который необходимо скопировать.</param>
        <param name="destinationFileName">Местоположение, в которое необходимо скопировать файл.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Определяет, что должно быть выполнено, если во время операции пользователь нажмет кнопку **Отмена**. Значение по умолчанию — <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Копирует файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` не сохраняет элементы управления доступом (записи управления доступом). Вновь созданный файл наследует элементы управления доступом по умолчанию из каталога, в котором он создан.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CopyFile` метод.  
  
|Кому|См.|  
|-|-|  
|Скопируйте файл в тот же каталог.|[Практическое руководство. Создание копии файла в том же каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другой каталог.|[Практическое руководство. Создание копии файла в другом каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 В этом примере копирует файл `Test.txt` в каталог `TestFiles2` без перезаписи существующих файлов.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 В этом примере копирует файл `Test.txt` в каталог `TestFiles2` и переименовывает его `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> или <paramref name="sourceFileName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Конечный файл существует, а параметр <paramref name="overwrite" /> имеет значение <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="UICancelOption" /> имеет значение <see langword="ThrowException" />, а пользователь отменил операцию, или возникла ошибка ввода-вывода.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буфера обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CreateDirectory(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDirectory(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Имя и местоположение каталога.</param>
        <summary>Создает каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если каталог уже существует, исключение не возникает.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.CreateDirectory` метод.  
  
|Кому|См.|  
|-|-|  
|Создание каталога|[Практическое руководство. Создайте каталог в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 В этом примере создается каталог, `NewDirectory`в `C:\Documents and Settings\All Users\Documents`.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Неверное имя каталога. Например, оно содержит недопустимые символы или состоит только из пробелов.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Имя каталога имеет слишком большую длину.</exception>
        <exception cref="T:System.NotSupportedException">Имя каталога состоит только из двоеточия (:).</exception>
        <exception cref="T:System.IO.IOException">Родительский каталог создаваемого каталога доступен только для чтения.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет разрешения на создание каталога.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает текущий каталог.</summary>
        <value>Текущий каталог для файловых операций ввода-вывода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` является переменной среды уровня системы.  
  
   
  
## Examples  
 Этот пример возвращает текущий каталог и отображает его в окне сообщения.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 В этом примере задает текущий каталог `C:\TestDirectory`.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый путь.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет каталог.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.DeleteDirectoryOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, onDirectoryNotEmpty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, который необходимо удалить.</param>
        <param name="onDirectoryNotEmpty">Указывает, какие действия должны выполняться, когда удаляемый каталог содержит файлы или каталоги. Значение по умолчанию — <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Удаляет каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В примере выполняется удаление каталога `OldDirectory` только в том случае, если она пуста.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 В этом примере удаляет каталог `OldDirectory` и все ее содержимое.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 В этом примере удаляет каталог `OldDirectory` и все ее содержимое, у пользователя подтверждение удаления, но не отправляет содержимое файла в **корзины**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 В этом примере удаляет каталог `OldDirectory` и все его содержимое в **корзины**, но не показывает ход выполнения операции.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является пустой строкой, некорректен, содержит только пробелы или содержит недопустимые символы (включая знаки подстановки). Путь является путем к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует или является файлом.</exception>
        <exception cref="T:System.IO.IOException">Файл в каталоге или подкаталоге используется.</exception>
        <exception cref="T:System.NotSupportedException">Имя каталога содержит двоеточие (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет необходимых разрешений.</exception>
        <exception cref="T:System.OperationCanceledException">Пользователь отменяет операцию, или не удается удалить каталог.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, который необходимо удалить.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Указывает, нужно ли перемещать удаленный файл в **Корзину**. Значение по умолчанию — <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Удаляет каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `showUI` И `recycle` параметры не поддерживаются в приложениях, которые не являются интерактивными, такие как службы Windows для пользователя.  
  
   
  
## Examples  
 В примере выполняется удаление каталога `OldDirectory` только в том случае, если она пуста.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 В этом примере удаляет каталог `OldDirectory` и все ее содержимое.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 В этом примере удаляет каталог `OldDirectory` и все ее содержимое, у пользователя подтверждение удаления, но не отправляет содержимое файла в **корзины**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 В этом примере удаляет каталог `OldDirectory` и все его содержимое в **корзины**, но не показывает ход выполнения операции.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является пустой строкой, некорректен, содержит только пробелы или содержит недопустимые символы (включая знаки подстановки). Путь является путем к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует или является файлом.</exception>
        <exception cref="T:System.IO.IOException">Файл в каталоге или подкаталоге используется.</exception>
        <exception cref="T:System.NotSupportedException">Имя каталога содержит двоеточие (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет необходимых разрешений.</exception>
        <exception cref="T:System.OperationCanceledException">Пользователь отменяет операцию, или не удается удалить каталог.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буфера обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, который необходимо удалить.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Указывает, нужно ли перемещать удаленный файл в **Корзину**. Значение по умолчанию — <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Указывает, следует ли создавать исключение, если пользователь нажимает кнопку **Отмена**.</param>
        <summary>Удаляет каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `showUI`, `recycle`, И `onUserCancel` параметры не поддерживаются в приложениях, которые не являются интерактивными, такие как службы Windows для пользователя.  
  
   
  
## Examples  
 В примере выполняется удаление каталога `OldDirectory` только в том случае, если она пуста.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 В этом примере удаляет каталог `OldDirectory` и все ее содержимое.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 В этом примере удаляет каталог `OldDirectory` и все ее содержимое, у пользователя подтверждение удаления, но не отправляет содержимое файла в **корзины**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 В этом примере удаляет каталог `OldDirectory` и все его содержимое в **корзины**, но не показывает ход выполнения операции.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является пустой строкой, некорректен, содержит только пробелы или содержит недопустимые символы (включая знаки подстановки). Путь является путем к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует или является файлом.</exception>
        <exception cref="T:System.IO.IOException">Файл в каталоге или подкаталоге используется.</exception>
        <exception cref="T:System.NotSupportedException">Имя каталога содержит двоеточие (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет необходимых разрешений.</exception>
        <exception cref="T:System.OperationCanceledException">Пользователь отменяет операцию, или не удается удалить каталог.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буфера обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Путь к удаляемому файлу и его имя.</param>
        <summary>Удаляет файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.DeleteFile` метод.  
  
|Кому|См.|  
|-|-|  
|Чтобы удалить файл|[Практическое руководство. Удаление файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 В этом примере удаляется файл `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 В этом примере удаляется файл `Test.txt` и позволяет пользователю для подтверждения удаления файла.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 В этом примере удаляется файл `Test.txt` и отправляет ее в **корзины**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо оканчивается косой чертой там, где должен быть указан файл, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет разрешения на удаление файла, или файл доступен только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">Путь к удаляемому файлу и его имя.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Указывает, нужно ли перемещать удаленный файл в **Корзину**. Значение по умолчанию — <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Удаляет файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `showUI` И `recycle` параметры не поддерживаются в приложениях, которые не являются интерактивными, такие как службы Windows для пользователя.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.DeleteFile` метод.  
  
|Кому|См.|  
|-|-|  
|Чтобы удалить файл|[Практическое руководство. Удаление файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 В этом примере удаляется файл `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 В этом примере удаляется файл `Test.txt` и позволяет пользователю для подтверждения удаления файла.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 В этом примере удаляется файл `Test.txt` и отправляет ее в **корзины**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо оканчивается косой чертой там, где должен быть указан файл, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет разрешения на удаление файла, или файл доступен только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буфера обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">Путь к удаляемому файлу и его имя.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Указывает, нужно ли перемещать удаленный файл в **Корзину**. Значение по умолчанию — <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Указывает, выдается ли исключение, когда пользователь отменяет операцию. Значение по умолчанию — <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Удаляет файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `showUI`, `recycle`, И `onUserCancel` параметры не поддерживаются в приложениях, которые не являются интерактивными, такие как службы Windows для пользователя.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.DeleteFile` метод.  
  
|Кому|См.|  
|-|-|  
|Чтобы удалить файл|[Практическое руководство. Удаление файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 В этом примере удаляется файл `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 В этом примере удаляется файл `Test.txt` и позволяет пользователю для подтверждения удаления файла.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 В этом примере удаляется файл `Test.txt` и отправляет ее в **корзины**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо оканчивается косой чертой там, где должен быть указан файл, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет разрешения на удаление файла, или файл доступен только для чтения.</exception>
        <exception cref="T:System.OperationCanceledException">Пользователь отменил операцию, и для параметра <paramref name="onUserCancel" /> установлено значение <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буфера обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public static bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool DirectoryExists(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DirectoryExists(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member DirectoryExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Путь к каталогу.</param>
        <summary>Возвращает значение <see langword="True" />, если указанный каталог существует.</summary>
        <returns>Значение <see langword="True" />, если каталог существует; в противном случае — значение <see langword="False" />. Этот метод также возвращает <see langword="False" />, если параметр представляет имя и путь файла, а не каталог.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере определяется ли каталог `C:\backup\logs` существует и ее свойства.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Drives : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает доступную только для чтения коллекцию имен всех доступных дисков.</summary>
        <value>Доступная только для чтения коллекция всех доступных дисков в виде объектов <see cref="T:System.IO.DriveInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает все логические диски.  
  
   
  
## Examples  
 Этот пример отображает имена доступных дисков в окне сообщения.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None" />
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public static bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool FileExists(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FileExists(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member FileExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FileExists file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Путь к файлу и его имя.</param>
        <summary>Возвращает значение <see langword="True" />, если указанный файл существует.</summary>
        <returns>Возвращает значение <see langword="True" />, если файл существует; в противном случае возвращает значение <see langword="False" />. Этот метод также возвращает <see langword="False" />, если параметр представляет путь к каталогу, а файлу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если приложение не имеет достаточных полномочий на чтение заданного файла, `FileExists` возвращает метод `False`, независимо от наличия пути; метод выдает исключение.  
  
   
  
## Examples  
 В этом примере проверяется, чтобы увидеть ли файл `Check.txt` существует и предоставляет сведения в окне сообщения.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя файла заканчивается обратной косой чертой (\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает доступный только для чтения набор строк, представляющих собой имена файлов, которые содержат указанный текст.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, в котором необходимо выполнить поиск.</param>
        <param name="containsText">Текст, поиск которого необходимо выполнить.</param>
        <param name="ignoreCase">Значение <see langword="True" />, если при поиске следует учитывать регистр; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="True" />.</param>
        <param name="searchType">Указывает, нужно ли включать вложенные папки. Значение по умолчанию — <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Возвращает доступный только для чтения набор строк, представляющих собой имена файлов, которые содержат указанный текст.</summary>
        <returns>Доступная только для чтения коллекция имен файлов, содержащих указанный текст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файлы, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.FindInFiles` метод.  
  
|Кому|См.|  
|-|-|  
|Поиск в каталоге файлов, содержащих определенную строку|[Пошаговое руководство. Операции с файлами и каталогами в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 В этом примере ищет каталог `C:\TestDir` для всех файлов, содержащий строку `"sample string"` и отображает результаты в `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Чтобы работать, проект должен содержать `ListBox` с именем `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он представляет собой строку нулевой длины, либо содержит только пробелы, либо содержит недопустимые знаки, либо представляет собой путь к устройству (начинается с символов <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Заданный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Заданный каталог указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Указанный путь каталога содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType, fileWildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Каталог, в котором необходимо выполнить поиск.</param>
        <param name="containsText">Текст, поиск которого необходимо выполнить.</param>
        <param name="ignoreCase">Значение <see langword="True" />, если при поиске следует учитывать регистр; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="True" />.</param>
        <param name="searchType">Указывает, нужно ли включать вложенные папки. Значение по умолчанию — <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Шаблон, которому необходимо соответствовать.</param>
        <summary>Возвращает доступный только для чтения набор строк, представляющих собой имена файлов, которые содержат указанный текст.</summary>
        <returns>Доступная только для чтения коллекция имен файлов, содержащих указанный текст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файлы, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.FindInFiles` метод.  
  
|Кому|См.|  
|-|-|  
|Поиск в каталоге файлов, содержащих определенную строку|[Пошаговое руководство. Операции с файлами и каталогами в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 В этом примере ищет каталог `C:\TestDir` для всех файлов, содержащий строку `"sample string"` и отображает результаты в `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Чтобы работать, проект должен содержать `ListBox` с именем `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он представляет собой строку нулевой длины, либо содержит только пробелы, либо содержит недопустимые знаки, либо представляет собой путь к устройству (начинается с символов <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Заданный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Заданный каталог указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Указанный путь каталога содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает коллекцию строк, представляющих имена путей вложенных папок в каталоге.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Путь к каталогу и его имя.</param>
        <summary>Возвращает коллекцию строк, представляющих имена путей вложенных папок в каталоге.</summary>
        <returns>Доступная только для чтения коллекция путей к подкаталогам в указанном каталоге.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.GetDirectories` метод.  
  
|Кому|См.|  
|-|-|  
|Список подкаталогов по шаблону|[Практическое руководство. Поиск подкаталогов по шаблону в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Следующий пример возвращает все каталоги в структуре каталогов, которые содержат слово `Logs` в именах и добавляет их в `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 В этом примере требуется наличие `ListBox` с именем `ListBox1` в форме.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Заданный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Заданный каталог указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Путь к каталогу и его имя.</param>
        <param name="searchType">Указывает, нужно ли включать вложенные папки. Значение по умолчанию — <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Шаблон, которому должны соответствовать имена.</param>
        <summary>Возвращает коллекцию строк, представляющих имена путей вложенных папок в каталоге.</summary>
        <returns>Доступная только для чтения коллекция путей к подкаталогам в указанном каталоге.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для указания определенного шаблона можно использовать параметр `wildcards` . Если требуется включить в поиск содержимое подкаталогов, присвойте параметру `searchType` значение `SearchAllSubDirectories`.  
  
 Если каталоги, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.GetDirectories` метод.  
  
|Кому|См.|  
|-|-|  
|Список подкаталогов по шаблону|[Практическое руководство. Поиск подкаталогов по шаблону в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Следующий пример возвращает все каталоги в структуре каталогов, которые содержат слово `Logs` в именах и добавляет их в `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 В этом примере требуется наличие `ListBox` с именем `ListBox1` в форме.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько указанных подстановочных знаков являются <see langword="Nothing" />, пустой строкой или содержат только пробелы.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Заданный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Заданный каталог указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory"><see langword="String" />. Путь к каталогу.</param>
        <summary>Возвращает объект <see cref="T:System.IO.DirectoryInfo" /> для указанного пути.</summary>
        <returns>Объект <see cref="T:System.IO.DirectoryInfo" /> для указанного пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если каталог не существует, исключение не будет создано до момента первого свойства <xref:System.IO.DirectoryInfo> обращения к объекту.  
  
   
  
## Examples  
 В этом примере извлекаются <xref:System.IO.DirectoryInfo> для каталога `C:\Documents and Settings` и отображает каталога время создания, последнего времени доступа и последнего времени записи.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Путь каталога содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberSignature Language="F#" Value="static member GetDriveInfo : string -&gt; System.IO.DriveInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Диск, который необходимо проверить.</param>
        <summary>Возвращает объект <see cref="T:System.IO.DriveInfo" /> для указанного диска.</summary>
        <returns>Объект <see cref="T:System.IO.DriveInfo" /> для указанного диска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DriveInfo> Класс моделирует диск и предоставляет методы и свойства для запроса сведений о диске. Используйте <xref:System.IO.DriveInfo> для определения того, какие диски доступны и какие дисков они содержатся. Можно также запросить свойство для определения емкости и доступного свободного места на диске.  
  
   
  
## Examples  
 Этот пример демонстрирует получение <xref:System.IO.DriveInfo> объект для диска и использует его для отображения сведений о диске.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Сведения о дисках различных типов, см. в разделе <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="drive" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public static System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.FileInfo GetFileInfo(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member GetFileInfo : string -&gt; System.IO.FileInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Путь к файлу и его имя.</param>
        <summary>Возвращает объект <see cref="T:System.IO.FileInfo" /> для указанного файла.</summary>
        <returns>Объект <see cref="T:System.IO.FileInfo" /> для указанного файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Исключение не создано, если файл не существует; Вместо этого они будут создаваться при первом обращении к свойству объекта.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.GetFileInfo` метод.  
  
|Кому|См.|  
|-|-|  
|Определить имя и путь файла|[Практическое руководство. Анализ путей к файлам в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 В этом примере извлекаются <xref:System.IO.FileInfo?displayProperty=nameWithType> для файла `MyLogFile.log` и использует его для полное имя файла, время последнего доступа и длины.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимое имя пути Например, оно содержит недопустимые символы или состоит из пробела. В конце имени файла указана косая черта.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.NotSupportedException">Путь содержит двоеточие в середине строки.</exception>
        <exception cref="T:System.IO.PathTooLongException">Слишком длинный путь.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя нет необходимых разрешений.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет доступа к списку управления доступом (ACL) файла.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.FileInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает коллекцию строк только для чтения, представляющих имена путей к файлам в папке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, в котором необходимо выполнить поиск.</param>
        <summary>Возвращает коллекцию строк только для чтения, представляющих имена путей к файлам в папке.</summary>
        <returns>Доступная только для чтения коллекция имен файлов из указанного каталога.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файлы, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.GetFiles` метод.  
  
|Кому|См.|  
|-|-|  
|Получение коллекции содержащихся в каталоге файлов|[Практическое руководство. Получение коллекции содержащихся в каталоге файлов в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Поиск файлов по конкретному шаблону в каталог|[Практическое руководство. Поиск файлов по конкретному шаблону в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 В следующем примере возвращаются и добавляются в список `ListBox1` все файлы, находящиеся в каталоге.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 В этом примере требуется наличие `ListBox` с именем `ListBox1` в форме.  
  
 Этот пример возвращает все файлы в каталоге с расширением `.txt` и добавляет их в `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 В этом примере требуется наличие `ListBox` с именем `ListBox1` в форме.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог, где следует выполнить поиск, не существует.</exception>
        <exception cref="T:System.IO.IOException">Параметр <paramref name="directory" /> указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Каталог, в котором необходимо выполнить поиск.</param>
        <param name="searchType">Указывает, нужно ли включать вложенные папки. Значение по умолчанию — <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Шаблон, которому необходимо соответствовать.</param>
        <summary>Возвращает коллекцию строк только для чтения, представляющих имена путей к файлам в папке.</summary>
        <returns>Доступная только для чтения коллекция имен файлов из указанного каталога.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файлы, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.GetFiles` метод.  
  
|Кому|См.|  
|-|-|  
|Получение коллекции содержащихся в каталоге файлов|[Практическое руководство. Получение коллекции содержащихся в каталоге файлов в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Поиск файлов по конкретному шаблону в каталог|[Практическое руководство. Поиск файлов по конкретному шаблону в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 В следующем примере возвращаются и добавляются в список `ListBox1` все файлы, находящиеся в каталоге.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 В этом примере требуется наличие `ListBox` с именем `ListBox1` в форме.  
  
 Этот пример возвращает все файлы в каталоге с расширением `.txt` и добавляет их в `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 В этом примере требуется наличие `ListBox` с именем `ListBox1` в форме.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог, где следует выполнить поиск, не существует.</exception>
        <exception cref="T:System.IO.IOException">Параметр <paramref name="directory" /> указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetName : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Обязательный. Путь, синтаксический анализ которого нужно выполнить. <see langword="String" />.</param>
        <summary>Анализирует имя файла без указанного пути.</summary>
        <returns>Имя файла из указанного пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это операция строки; `FileSystem` не проверяется.  
  
 `GetName` Метод игнорирует косую черту в конце пути.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.GetFileName` метод.  
  
|Кому|См.|  
|-|-|  
|Синтаксический анализ пути к файлу|[Практическое руководство. Анализ путей к файлам в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Следующий пример выполняет синтаксический анализ пути к файлу и возвращает имя файла.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Замените путь `C:\Testdirectory\Testfile` с путем, который необходимо проанализировать.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public static string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetParentPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetParentPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParentPath : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь, который необходимо проверить.</param>
        <summary>Возвращает родительский путь предоставленного пути.</summary>
        <returns>Родительский путь для заданного пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это операция строки; в файловой системе не проверяется.  
  
   
  
## Examples  
 В этом примере извлекаются родительский путь для `C:\Backups\Tmp\Test`.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь не имеет родительского пути, так как это корневой путь.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает на диске временный пустой файл с уникальным именем и возвращает полный путь этого файла.</summary>
        <returns><see langword="String" />, содержащая полный путь к временному файлу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может использоваться для создания временного файла.  
  
   
  
## Examples  
 В этом примере создается временный файл и возвращает путь к нему.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Путь к каталогу, который необходимо переместить.</param>
        <param name="destinationDirectoryName">Путь к каталогу, в который необходимо переместить исходный каталог.</param>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если предпринята попытка переместить каталог в каталоге, который не существует, создается в целевой структуре.  
  
   
  
## Examples  
 В этом примере перемещает `Directory1` внутри `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 В этом примере перемещает `Directory1` внутри `Directory2`, перезапись каталога, если он уже существует.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> или <paramref name="destinationDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Источник является корневым каталогом, либо исходный путь совпадает с целевым.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Путь к каталогу, который необходимо переместить.</param>
        <param name="destinationDirectoryName">Путь к каталогу, в который необходимо переместить исходный каталог.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если предпринята попытка переместить каталог в каталоге, который не существует, создается в целевой структуре.  
  
   
  
## Examples  
 В этом примере перемещает `Directory1` внутри `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 В этом примере перемещает `Directory1` внутри `Directory2`, перезапись каталога, если он уже существует.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> или <paramref name="destinationDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Целевой каталог уже существует, а параметру <paramref name="overwrite" /> присвоено значение <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буфера обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Путь к каталогу, который необходимо переместить.</param>
        <param name="destinationDirectoryName">Путь к каталогу, в который необходимо переместить исходный каталог.</param>
        <param name="overwrite">Значение <see langword="True" />, если нужно перезаписывать существующие каталоги; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если предпринята попытка переместить каталог в каталоге, который не существует, создается в целевой структуре.  
  
   
  
## Examples  
 В этом примере перемещает `Directory1` внутри `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 В этом примере перемещает `Directory1` внутри `Directory2`, перезапись каталога, если он уже существует.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> или <paramref name="destinationDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Целевой каталог уже существует, а параметру <paramref name="overwrite" /> присвоено значение <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Путь к каталогу, который необходимо переместить.</param>
        <param name="destinationDirectoryName">Путь к каталогу, в который необходимо переместить исходный каталог.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Указывает, выдается ли исключение, когда пользователь отменяет операцию. Значение по умолчанию — <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если предпринята попытка переместить каталог в каталоге, который не существует, создается в целевой структуре.  
  
   
  
## Examples  
 В этом примере перемещает `Directory1` внутри `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 В этом примере перемещает `Directory1` внутри `Directory2`, перезапись каталога, если он уже существует.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> или <paramref name="destinationDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="onUserCancel" /> имеет значение <see langword="ThrowException" />, и подкаталог файла не может быть скопирован.</exception>
        <exception cref="T:System.OperationCanceledException">Параметр <paramref name="onUserCancel" /> имеет значение <see langword="ThrowException" />, а пользователь отменяет операцию, или операция не может быть завершена.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буфера обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перемещает файл в новое местоположение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Путь к перемещаемому файлу.</param>
        <param name="destinationFileName">Путь к каталогу, в который необходимо переместить файл.</param>
        <summary>Перемещает файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевая структура не существует, он создается.  
  
 `MoveFile` Метод сохраняет элементы управления доступом (записи управления доступом) только при перемещении файла в тот же том. Сюда входят наследуемые ACE, которые становятся прямыми ACE при перемещении (прямая элементы управления доступом имеет приоритет над наследуемые ACE). Если файл перемещается между томами, записи управления доступом не копируются.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.MoveFile` метод.  
  
|Кому|См.|  
|-|-|  
|Перемещение файла|[Практическое руководство. Перемещение файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2` и переименовывает его `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destinationFileName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Путь к перемещаемому файлу.</param>
        <param name="destinationFileName">Путь к каталогу, в который необходимо переместить файл.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Перемещает файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевая структура не существует, он создается.  
  
 `MoveFile` Метод сохраняет элементы управления доступом (записи управления доступом) только при перемещении файла в тот же том. Сюда входят наследуемые ACE, которые становятся прямыми ACE при перемещении (прямая элементы управления доступом имеет приоритет над наследуемые ACE). Если файл перемещается между томами, записи управления доступом не копируются.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.MoveFile` метод.  
  
|Кому|См.|  
|-|-|  
|Перемещение файла|[Практическое руководство. Перемещение файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2` и переименовывает его `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destinationFileName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буфера обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Путь к перемещаемому файлу.</param>
        <param name="destinationFileName">Путь к каталогу, в который необходимо переместить файл.</param>
        <param name="overwrite">Значение <see langword="True" /> для перезаписи существующих файлов; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Перемещает файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевая структура не существует, он создается.  
  
 `MoveFile` Метод сохраняет элементы управления доступом (записи управления доступом) только при перемещении файла в тот же том. Сюда входят наследуемые ACE, которые становятся прямыми ACE при перемещении (прямая элементы управления доступом имеет приоритет над наследуемые ACE). Если файл перемещается между томами, записи управления доступом не копируются.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.MoveFile` метод.  
  
|Кому|См.|  
|-|-|  
|Перемещение файла|[Практическое руководство. Перемещение файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2` и переименовывает его `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destinationFileName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Путь к перемещаемому файлу.</param>
        <param name="destinationFileName">Путь к каталогу, в который необходимо переместить файл.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Указывает, выдается ли исключение, когда пользователь отменяет операцию. Значение по умолчанию — <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Перемещает файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевая структура не существует, он создается.  
  
 `MoveFile` Метод сохраняет элементы управления доступом (записи управления доступом) только при перемещении файла в тот же том. Сюда входят наследуемые ACE, которые становятся прямыми ACE при перемещении (прямая элементы управления доступом имеет приоритет над наследуемые ACE). Если файл перемещается между томами, записи управления доступом не копируются.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.MoveFile` метод.  
  
|Кому|См.|  
|-|-|  
|Перемещение файла|[Практическое руководство. Перемещение файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2` и переименовывает его `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destinationFileName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="onUserCancel" /> имеет значение <see langword="ThrowException" />, а пользователь отменил операцию, или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буфера обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Метод <see langword="OpenTextFieldParser" /> позволяет создать объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, который предоставляет простой и эффективный способ синтаксического анализа структурированных текстовых файлов, например журналов. Объект <see langword="TextFieldParser" /> может использоваться для чтения и файлов с разделителями, и файлов с полями фиксированного размера.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Файл, который необходимо открыть с помощью <see langword="TextFieldParser" />.</param>
        <summary>Метод <see langword="OpenTextFieldParser" /> позволяет создать объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, который предоставляет простой и эффективный способ синтаксического анализа структурированных текстовых файлов, например журналов. Объект <see langword="TextFieldParser" /> может использоваться для чтения и файлов с разделителями, и файлов с полями фиксированного размера.</summary>
        <returns>Объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> для чтения указанного файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.OpenTextFieldParser` метод.  
  
|Кому|См.|  
|-|-|  
|Чтение из текстовых файлов|[Практическое руководство. Чтение из файлов с разделителями-запятыми в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Чтение из файла текста фиксированной ширины|[Практическое руководство. Чтение из файлов с полями фиксированного размера в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Чтение из текстового файла с несколькими форматами|[Практическое руководство. Чтение из текстовых файлов различных форматов в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 В этом примере открывается `TextFieldParser.reader` и использует его для чтения из `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Строка не может быть проанализирована с использованием указанного формата. Сообщение исключения содержит строку, вызвавшую исключение, а свойство <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> содержит текст, который содержится в этой строке.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Описывает набор разрешений безопасности, применяемых к коду. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * int[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, fieldWidths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Файл, который необходимо открыть с помощью <see langword="TextFieldParser" />.</param>
        <param name="fieldWidths">Значения ширины полей.</param>
        <summary>Метод <see langword="OpenTextFieldParser" /> позволяет создать объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, который предоставляет простой и эффективный способ синтаксического анализа структурированных текстовых файлов, например журналов. Объект <see langword="TextFieldParser" /> может использоваться для чтения и файлов с разделителями, и файлов с полями фиксированного размера.</summary>
        <returns>Объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> для чтения указанного файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.OpenTextFieldParser` метод.  
  
|Кому|См.|  
|-|-|  
|Чтение из текстовых файлов|[Практическое руководство. Чтение из файлов с разделителями-запятыми в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Чтение из файла текста фиксированной ширины|[Практическое руководство. Чтение из файлов с полями фиксированного размера в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Чтение из текстового файла с несколькими форматами|[Практическое руководство. Чтение из текстовых файлов различных форматов в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 В этом примере открывается `TextFieldParser.reader` и использует его для чтения из `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Строка не может быть проанализирована с использованием указанного формата. Сообщение исключения содержит строку, вызвавшую исключение, а свойство <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> содержит текст, который содержится в этой строке.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Описывает набор разрешений безопасности, применяемых к коду. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * string[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, delimiters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Файл, который необходимо открыть с помощью <see langword="TextFieldParser" />.</param>
        <param name="delimiters">Разделители для полей.</param>
        <summary>Метод <see langword="OpenTextFieldParser" /> позволяет создать объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, который предоставляет простой и эффективный способ синтаксического анализа структурированных текстовых файлов, например журналов. Объект <see langword="TextFieldParser" /> может использоваться для чтения и файлов с разделителями, и файлов с полями фиксированного размера.</summary>
        <returns>Объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> для чтения указанного файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.OpenTextFieldParser` метод.  
  
|Кому|См.|  
|-|-|  
|Чтение из текстовых файлов|[Практическое руководство. Чтение из файлов с разделителями-запятыми в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Чтение из файла текста фиксированной ширины|[Практическое руководство. Чтение из файлов с полями фиксированного размера в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Чтение из текстового файла с несколькими форматами|[Практическое руководство. Чтение из текстовых файлов различных форматов в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 В этом примере открывается `TextFieldParser.reader` и использует его для чтения из `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Строка не может быть проанализирована с использованием указанного формата. Сообщение исключения содержит строку, вызвавшую исключение, а свойство <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> содержит текст, который содержится в этой строке.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Описывает набор разрешений безопасности, применяемых к коду. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Файл, чтение которого необходимо выполнить.</param>
        <summary>Открывает объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</summary>
        <returns>Объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только текстовые файлы могут быть прочитаны с <xref:System.IO.StreamReader>.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.OpenTextFileReader` метод.  
  
|Кому|См.|  
|-|-|  
|Откройте файл с <xref:System.IO.StreamReader>|[Практическое руководство. Чтение текста из файлов с помощью StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 В этом примере открывается файл `Testfile.txt`, считывает строку из него и отображает строку в `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя файла оканчивается обратной косой чертой (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти указанный файл.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя нет необходимых разрешений на чтение из файла.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Файл, чтение которого необходимо выполнить.</param>
        <param name="encoding">Кодировка, используемая для содержимого файла. Кодировкой по умолчанию является ASCII.</param>
        <summary>Открывает объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</summary>
        <returns>Объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только текстовые файлы могут быть прочитаны с <xref:System.IO.StreamReader>.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.OpenTextFileReader` метод.  
  
|Кому|См.|  
|-|-|  
|Откройте файл с <xref:System.IO.StreamReader>|[Практическое руководство. Чтение текста из файлов с помощью StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 В этом примере открывается файл `Testfile.txt`, считывает строку из него и отображает строку в `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя файла оканчивается обратной косой чертой (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти указанный файл.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя нет необходимых разрешений на чтение из файла.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Файл, в который необходимо выполнить запись.</param>
        <param name="append"><see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Открывает объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</summary>
        <returns>Объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `OpenTextFileWriter` Метод открывает и инициализирует поток для файла и затем возвращает <xref:System.IO.StreamWriter> объект для этого потока. Можно записывать в поток столько раз и затем закройте его, когда вы закончите.  
  
> [!NOTE]
>  Необходимо вызвать <xref:System.IO.StreamWriter.Close%2A> метод <xref:System.IO.StreamWriter> объекта, чтобы убедиться в том, что все данные, правильно записываются в базовый поток.  
  
 Если вы создаете лишь нескольких строк в файл, возможно, проще в использовании <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> метод.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.OpenTextFileWriter` метод.  
  
|Кому|См.|  
|-|-|  
|Запись текста в файл с `StreamWriter`|[Практическое руководство. Запись текста в файлы с помощью StreamWriter в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 В этом примере открывается <xref:System.IO.StreamWriter> с `My.Computer.FileSystem.OpenTextFileWriter` метода и использует его для записи строки в текстовый файл с `WriteLine` метод `StreamWriter` класса.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.ArgumentException">Имя файла заканчивается косой чертой.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Файл, в который необходимо выполнить запись.</param>
        <param name="append"><see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла. Значение по умолчанию — <see langword="False" />.</param>
        <param name="encoding">Кодировка, которую необходимо использовать для записи в файл. Кодировкой по умолчанию является ASCII.</param>
        <summary>Открывает объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</summary>
        <returns>Объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `OpenTextFileWriter` Метод открывает и инициализирует поток для файла и затем возвращает <xref:System.IO.StreamWriter> объект для этого потока. Можно записывать в поток столько раз и затем закройте его, когда вы закончите.  
  
> [!NOTE]
>  Необходимо вызвать <xref:System.IO.StreamWriter.Close%2A> метод <xref:System.IO.StreamWriter> объекта, чтобы убедиться в том, что все данные, правильно записываются в базовый поток.  
  
 Если вы создаете лишь нескольких строк в файл, возможно, проще в использовании <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> метод.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.OpenTextFileWriter` метод.  
  
|Кому|См.|  
|-|-|  
|Запись текста в файл с `StreamWriter`|[Практическое руководство. Запись текста в файлы с помощью StreamWriter в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 В этом примере открывается <xref:System.IO.StreamWriter> с `My.Computer.FileSystem.OpenTextFileWriter` метода и использует его для записи строки в текстовый файл с `WriteLine` метод `StreamWriter` класса.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.ArgumentException">Имя файла заканчивается косой чертой.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int8[] ReadAllBytes(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllBytes : string -&gt; byte[]" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Файл, чтение которого необходимо выполнить.</param>
        <summary>Возвращает содержимое файла в виде массива байтов.</summary>
        <returns><see langword="Byte" /> массив с содержимым файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReadAllBytes` Метод `My.Computer.FileSystem` объекта позволяет считывать из двоичного файла. Содержимое файла возвращается в виде массива байтов.  
  
 По имени файла не всегда можно с уверенностью судить о его содержимом. Например, файл с именем Form1.vb может вовсе не быть исходным файлом Visual Basic. Следует проверять все входные данные перед использованием их в приложении.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.ReadAllBytes` метод.  
  
|Кому|См.|  
|-|-|  
|Чтение из двоичного файла|[Практическое руководство. Чтение из двоичного файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 Этот пример считывает из файла `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает содержимое текстового файла как <see langword="String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Имя файла и путь к файлу, чтение которого необходимо выполнить.</param>
        <summary>Возвращает содержимое текстового файла как <see langword="String" />.</summary>
        <returns><see langword="String" /> с содержимым файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `ReadAllText` объекта `My.Computer.FileSystem` позволяет считывать данные из текстового файла. Содержимое файла возвращается в виде строки.  
  
 Кодировка файла может быть указан, если содержимое файла используется кодировка ASCII или UTF-8. Если выполняется чтение из файла с символами национальных алфавитов, необходимо указать кодировку файла, используя другую перегрузку <xref:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText%2A> метод.  
  
 По имени файла не всегда можно с уверенностью судить о его содержимом. Например, файл с именем Form1.vb может вовсе не быть исходным файлом Visual Basic. Следует проверять все входные данные перед использованием их в приложении.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.ReadAllText` метод.  
  
|Кому|См.|  
|-|-|  
|Чтение из текстового файла|[Практическое руководство. Чтение из текстовых файлов в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Этот пример считывает содержимое `Test.txt` в строку и затем отображается в окне сообщения.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Этот пример считывает содержимое файла ASCII `Test.txt` в строку и затем отображается в окне сообщения.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string * System.Text.Encoding -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Имя файла и путь к файлу, чтение которого необходимо выполнить.</param>
        <param name="encoding">Кодировка, которую необходимо использовать при чтении файла. Значением по умолчанию является UTF-8.</param>
        <summary>Возвращает содержимое текстового файла как <see langword="String" />.</summary>
        <returns><see langword="String" /> с содержимым файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `ReadAllText` объекта `My.Computer.FileSystem` позволяет считывать данные из текстового файла. Содержимое файла возвращается в виде строки.  
  
 Кодировка файла может быть указан, если содержимое файла используется кодировка ASCII или UTF-8. Если выполняется чтение из файла с символами национальных алфавитов, необходимо указать кодировку файла.  
  
 По имени файла не всегда можно с уверенностью судить о его содержимом. Например, файл с именем Form1.vb может вовсе не быть исходным файлом Visual Basic. Следует проверять все входные данные перед использованием их в приложении.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.ReadAllText` метод.  
  
|Кому|См.|  
|-|-|  
|Чтение из текстового файла|[Практическое руководство. Чтение из текстовых файлов в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Этот пример считывает содержимое `Test.txt` в строку и затем отображается в окне сообщения.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Этот пример считывает содержимое файла ASCII `Test.txt` в строку и затем отображается в окне сообщения.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public static void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameDirectory(string directory, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory (directory, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Имя каталога, который необходимо переименовать, и путь к нему.</param>
        <param name="newName">Новое имя каталога.</param>
        <summary>Переименование каталога.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не может использоваться для перемещения каталога; Используйте `MoveDirectory` метод для перемещения и переименования каталога.  
  
   
  
## Examples  
 В этом примере переименовывается `Test` каталог `SecondTest`.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> — <see langword="Nothing" />.  
  
-или- 
 Параметр <paramref name="newName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Имеется существующий файл или каталог с именем, указанным в <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory" />
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public static void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameFile(string file, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameFile (file, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Файл, который необходимо переименовать.</param>
        <param name="newName">Новое имя файла.</param>
        <summary>Переименование файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод нельзя использовать для перемещения файла. Для перемещения и переименования файла используется метод <xref:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile%2A>.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.RenameFile` метод.  
  
|Кому|См.|  
|-|-|  
|Переименование файла|[Практическое руководство. Переименование файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 В этом примере переименовывает файл `Test.txt` для `SecondTest.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Изменение "`C:\Test.txt`" путь к файлу и имя файла, который требуется переименовать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newName" /> содержит сведения о пути или оканчивается обратной косой чертой (\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> — <see langword="Nothing" />.  
  
-или- 
 Параметр <paramref name="newName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Имеется существующий файл или каталог с именем, указанным в <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllBytes : string * byte[] * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes (file, data, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Имя файла, в который необходимо выполнить запись, и путь к нему.</param>
        <param name="data">Данные, которые необходимо записать в файл.</param>
        <param name="append"><see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Записывает данные в двоичный файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указанный путь, исключая имя файла является недопустимым, <xref:System.IO.DirectoryNotFoundException> будет создано исключение. Если путь является допустимым, но файл не существует, создается файл.  
  
> [!NOTE]
>  `WriteAllBytes` Метод открывает файл, записывает в него и затем закрывает его. Код, использующий `WriteAllBytes` метод проще, чем код, использующий <xref:System.IO.BinaryWriter> объекта. Тем не менее, при добавлении данных в файл с помощью цикла, <xref:System.IO.BinaryWriter> объект может предоставлять более высокую производительность, так как вам только нужно открыть и закрыть файл один раз.  
  
 В следующей таблице перечислены задачи с участием пример `My.Computer.FileSystem.WriteAllBytes` метод.  
  
|Кому|См.|  
|-|-|  
|Запись в двоичный файл|[Практическое руководство. Запись в двоичные файлы в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 Этот пример добавляет массив данных `CustomerData` к файлу `CollectedData`.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает текст в файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Файл, в который необходимо выполнить запись.</param>
        <param name="text">Текст, который необходимо записать в файл.</param>
        <param name="append"><see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла.</param>
        <summary>Записывает текст в файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка UTF-8 используется для записи в файл. Чтобы указать другую кодировку, используйте другой перегрузке <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> метод.  
  
 Если заданный файл не существует, он будет создан.  
  
 Если указанной кодировки не соответствует существующей кодировку файла, указанного создание кода учитывается.  
  
> [!NOTE]
>  `WriteAllText` Метод открывает файл, записывает в него и затем закрывает его. Код, использующий `WriteAllText` метод проще, чем код, использующий <xref:System.IO.StreamWriter> объекта. Тем не менее, при добавлении строк в файл с помощью цикла, <xref:System.IO.StreamWriter> объект может предоставлять более высокую производительность, так как вам только нужно открыть и закрыть файл один раз. Дополнительные сведения см. в описании метода <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.WriteAllText` метод.  
  
|Кому|См.|  
|-|-|  
|Запись текста в файл|[Практическое руководство. Запись текста в файлы в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Добавление текста в файл|[Практическое руководство. Дозапись в текстовый файл в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 В этом примере записывается строка `"This is new text to be added."` в файл `Test.txt`, перезаписав тексту, имеющемуся в файле.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 В этом примере записывается имена файлов в `Documents and Settings` папку `FileList.txt`, вставляется символ перевода строки между каждым для повышения удобочитаемости.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool * System.Text.Encoding -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Файл, в который необходимо выполнить запись.</param>
        <param name="text">Текст, который необходимо записать в файл.</param>
        <param name="append"><see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла.</param>
        <param name="encoding">Кодировка, которую необходимо использовать для записи в файл.</param>
        <summary>Записывает текст в файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если заданный файл не существует, он будет создан.  
  
 Если указанной кодировки не соответствует существующей кодировку файла, указанного создание кода учитывается.  
  
> [!NOTE]
>  `WriteAllText` Метод открывает файл, записывает в него и затем закрывает его. Код, использующий `WriteAllText` метод проще, чем код, использующий <xref:System.IO.StreamWriter> объекта. Тем не менее, при добавлении строк в файл с помощью цикла, <xref:System.IO.StreamWriter> объект может предоставлять более высокую производительность, так как вам только нужно открыть и закрыть файл один раз. Дополнительные сведения см. в описании метода <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.WriteAllText` метод.  
  
|Кому|См.|  
|-|-|  
|Запись текста в файл|[Практическое руководство. Запись текста в файлы в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Добавление текста в файл|[Практическое руководство. Дозапись в текстовый файл в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 В этом примере записывается строка `"This is new text to be added."` в файл `Test.txt`, перезаписав тексту, имеющемуся в файле.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 В этом примере записывается имена файлов в `Documents and Settings` папку `FileList.txt`, вставляется символ перевода строки между каждым для повышения удобочитаемости.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
  </Members>
</Type>