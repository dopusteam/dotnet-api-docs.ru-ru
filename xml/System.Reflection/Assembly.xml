<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9ff9e9059e4ce5150d6f6c7e167f04a8c9806c33" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52245192" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="cec47-101">Представляет сборку, которая является модулем с возможностью многократного использования, поддержкой версий и встроенным механизмом описания общеязыковой исполняющей среды.</span>
      <span class="sxs-lookup">
        <span data-stu-id="cec47-101">Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-102">Используйте <xref:System.Reflection.Assembly> класс для загрузки сборок, для просмотра метаданных и составные части сборки, для обнаружения типов, содержащихся в сборках и для создания экземпляров этих типов.</span><span class="sxs-lookup"><span data-stu-id="cec47-102">Use the <xref:System.Reflection.Assembly> class to load assemblies, to explore the metadata and constituent parts of assemblies, to discover the types contained in assemblies, and to create instances of those types.</span></span>  
  
 <span data-ttu-id="cec47-103">Чтобы получить массив <xref:System.Reflection.Assembly> объектов, представляющих сборки, в настоящее время загружены в домен приложения (например, домене приложения по умолчанию простого проекта), используйте <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-103">To get an array of <xref:System.Reflection.Assembly> objects representing the assemblies currently loaded into an application domain (for example, the default application domain of a simple project), use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="cec47-104">Для загрузки сборок динамически, <xref:System.Reflection.Assembly> класс предоставляет следующие статические методы (`Shared` методы в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="cec47-104">To load assemblies dynamically, the <xref:System.Reflection.Assembly> class provides the following static methods (`Shared` methods in Visual Basic).</span></span> <span data-ttu-id="cec47-105">Сборки загружаются в домен приложения, где выполняется операция загрузки.</span><span class="sxs-lookup"><span data-stu-id="cec47-105">Assemblies are loaded into the application domain where the load operation occurs.</span></span>  
  
-   <span data-ttu-id="cec47-106">Для загрузки сборок рекомендуется использовать <xref:System.AppDomain.Load%2A> метод, который идентифицирует сборку, который будет загружен по его отображаемому имени (например, «System.Windows.Forms, Version = 2.0.0.0, язык и региональные параметры = neutral, PublicKeyToken = b77a5c561934e089»).</span><span class="sxs-lookup"><span data-stu-id="cec47-106">The recommended way to load assemblies is to use the <xref:System.AppDomain.Load%2A> method, which identifies the assembly to be loaded by its display name (for example, "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089").</span></span> <span data-ttu-id="cec47-107">Поиск сборки следует правилам, описанные в [Обнаружение сборок в среде выполнения](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="cec47-107">The search for the assembly follows the rules described in [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).</span></span>  
  
-   <span data-ttu-id="cec47-108"><xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> И <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> методы позволяют загрузить сборку для отражения, но не для выполнения.</span><span class="sxs-lookup"><span data-stu-id="cec47-108">The <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods enable you to load an assembly for reflection, but not for execution.</span></span> <span data-ttu-id="cec47-109">Например сборки, предназначенный для 64-разрядной платформы можно просмотреть код, выполняемый на 32-разрядной платформе.</span><span class="sxs-lookup"><span data-stu-id="cec47-109">For example, an assembly that targets a 64-bit platform can be examined by code that is running on a 32-bit platform.</span></span>  
  
-   <span data-ttu-id="cec47-110"><xref:System.Reflection.Assembly.LoadFile%2A> И <xref:System.Reflection.Assembly.LoadFrom%2A> предоставляются методы для редких сценариев, в которых сборки должен быть идентифицирован по пути.</span><span class="sxs-lookup"><span data-stu-id="cec47-110">The <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A> methods are provided for rare scenarios in which an assembly must be identified by path.</span></span>  
  
 <span data-ttu-id="cec47-111">Чтобы получить <xref:System.Reflection.Assembly> объект для текущей выполняемой сборке, используйте <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-111">To get an <xref:System.Reflection.Assembly> object for the currently executing assembly, use the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method.</span></span>  
  
 <span data-ttu-id="cec47-112">Многие члены <xref:System.Reflection.Assembly> предоставляют сведения о сборке.</span><span class="sxs-lookup"><span data-stu-id="cec47-112">Many members of the <xref:System.Reflection.Assembly> class provide information about an assembly.</span></span> <span data-ttu-id="cec47-113">Пример:</span><span class="sxs-lookup"><span data-stu-id="cec47-113">For example:</span></span>  
  
-   <span data-ttu-id="cec47-114"><xref:System.Reflection.Assembly.GetName%2A> Возвращает метод <xref:System.Reflection.AssemblyName> объект, предоставляющий доступ к его частям отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-114">The <xref:System.Reflection.Assembly.GetName%2A> method returns an <xref:System.Reflection.AssemblyName> object that provides access to the parts of the assembly display name.</span></span>  
  
-   <span data-ttu-id="cec47-115"><xref:System.Reflection.Assembly.GetCustomAttributes%2A> Метод перечислены атрибуты, примененные к сборке.</span><span class="sxs-lookup"><span data-stu-id="cec47-115">The <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method lists the attributes applied to the assembly.</span></span>  
  
-   <span data-ttu-id="cec47-116"><xref:System.Reflection.Assembly.GetFiles%2A> Метод обеспечивает доступ к файлам в манифесте сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-116">The <xref:System.Reflection.Assembly.GetFiles%2A> method provides access to the files in the assembly manifest.</span></span>  
  
-   <span data-ttu-id="cec47-117"><xref:System.Reflection.Assembly.GetManifestResourceNames%2A> Метод предоставляет имена ресурсов в манифесте сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-117">The <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> method provides the names of the resources in the assembly manifest.</span></span>  
  
 <span data-ttu-id="cec47-118"><xref:System.Reflection.Assembly.GetTypes%2A> Метод перечисляет все типы в сборке.</span><span class="sxs-lookup"><span data-stu-id="cec47-118">The <xref:System.Reflection.Assembly.GetTypes%2A> method lists all the types in the assembly.</span></span> <span data-ttu-id="cec47-119"><xref:System.Reflection.Assembly.GetExportedTypes%2A> Метод перечислены типы, которые видны вызывающим объектам за пределами сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-119">The <xref:System.Reflection.Assembly.GetExportedTypes%2A> method lists the types that are visible to callers outside the assembly.</span></span> <span data-ttu-id="cec47-120"><xref:System.Reflection.Assembly.GetType%2A> Метод может использоваться для поиска для определенного типа в сборке.</span><span class="sxs-lookup"><span data-stu-id="cec47-120">The <xref:System.Reflection.Assembly.GetType%2A> method can be used to search for a particular type in the assembly.</span></span> <span data-ttu-id="cec47-121"><xref:System.Reflection.Assembly.CreateInstance%2A> Метод может использоваться для поиска и создания экземпляров типов в сборке.</span><span class="sxs-lookup"><span data-stu-id="cec47-121">The <xref:System.Reflection.Assembly.CreateInstance%2A> method can be used to search for and create instances of types in the assembly.</span></span>  
  
 <span data-ttu-id="cec47-122">Дополнительные сведения о сборках см. в разделе «Домены и сборки приложения» в [домены приложений](~/docs/framework/app-domains/application-domains.md) раздела.</span><span class="sxs-lookup"><span data-stu-id="cec47-122">For more information on assemblies, see the "Application Domains and Assemblies" section in the [Application Domains](~/docs/framework/app-domains/application-domains.md) topic.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-123">В следующем примере кода показано, как получение текущей выполняемой сборке, создание экземпляра типа, содержащегося в этой сборке и вызвать один из методов типа с поздним связыванием.</span><span class="sxs-lookup"><span data-stu-id="cec47-123">The following code example shows how to obtain the currently executing assembly, create an instance of a type contained in that assembly, and invoke one of the type's methods with late binding.</span></span> <span data-ttu-id="cec47-124">Для этой цели в примере кода определяется класс с именем `Example`, включающий метод `SampleMethod`.</span><span class="sxs-lookup"><span data-stu-id="cec47-124">For this purpose, the code example defines a class named `Example`, with a method named `SampleMethod`.</span></span> <span data-ttu-id="cec47-125">Конструктор класса принимает целое число, который используется для вычисления возвращаемое значение метода.</span><span class="sxs-lookup"><span data-stu-id="cec47-125">The constructor of the class accepts an integer, which is used to compute the return value of the method.</span></span>  
  
 <span data-ttu-id="cec47-126">В примере также показано использование <xref:System.Reflection.Assembly.GetName%2A> метод, чтобы получить <xref:System.Reflection.AssemblyName> объект, который может использоваться для синтаксического анализа полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-126">The code example also demonstrates the use of the <xref:System.Reflection.Assembly.GetName%2A> method to obtain an <xref:System.Reflection.AssemblyName> object that can be used to parse the full name of the assembly.</span></span> <span data-ttu-id="cec47-127">В примере отображается номер версии сборки, <xref:System.Reflection.Assembly.CodeBase%2A> свойство и <xref:System.Reflection.Assembly.EntryPoint%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="cec47-127">The example displays the version number of the assembly, the <xref:System.Reflection.Assembly.CodeBase%2A> property, and the <xref:System.Reflection.Assembly.EntryPoint%2A> property.</span></span>  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="cec47-128">для полного доверия для разработчиков производных классов.</span>
      <span class="sxs-lookup">
        <span data-stu-id="cec47-128">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="cec47-129">Этот класс не может наследоваться кодом с частичным доверием.</span>
      <span class="sxs-lookup">
        <span data-stu-id="cec47-129">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <threadsafe>
      <span data-ttu-id="cec47-130">Данный тип потокобезопасен.</span>
      <span class="sxs-lookup">
        <span data-stu-id="cec47-130">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md">
      <span data-ttu-id="cec47-131">Домены приложений</span>
      <span class="sxs-lookup">
        <span data-stu-id="cec47-131">Application Domains</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-132">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Assembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-132">Initializes a new instance of the <see cref="T:System.Reflection.Assembly" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-133">Этот конструктор вызывается производными классами во время создания <xref:System.Reflection.Assembly> объектов.</span><span class="sxs-lookup"><span data-stu-id="cec47-133">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Assembly> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-134">Получает первоначально заданное расположение сборки, например в объекте <see cref="T:System.Reflection.AssemblyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-134">Gets the location of the assembly as specified originally, for example, in an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-135">Первоначально заданное расположение сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-135">The location of the assembly as specified originally.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-136">Чтобы получить абсолютный путь к загруженного файла, содержащего манифест, используйте <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> свойство вместо этого.</span><span class="sxs-lookup"><span data-stu-id="cec47-136">To get the absolute path to the loaded manifest-containing file, use the <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="cec47-137">Если сборка была загружена как массив байтов, используя перегрузку <xref:System.Reflection.Assembly.Load%2A> метод, который принимает массив байтов, это свойство возвращает расположение объекта, вызывающего метод, а не расположение загруженной сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-137">If the assembly was loaded as a byte array, using an overload of the <xref:System.Reflection.Assembly.Load%2A> method that takes an array of bytes, this property returns the location of the caller of the method, not the location of the loaded assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-138">В следующем примере используется <xref:System.Reflection.Assembly.CodeBase%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="cec47-138">The following example uses the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-139">для доступа к пути.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-139">for access to the path.</span>
          </span>
          <span data-ttu-id="cec47-140">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-140">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-141">Находит тип в этой сборке и создает его экземпляр, используя абстрактный метод.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-141">Locates a type from this assembly and creates an instance of it using the system activator.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="cec47-142">
            <see cref="P:System.Type.FullName" /> искомого типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-142">The <see cref="P:System.Type.FullName" /> of the type to locate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-143">С помощью поиска с учетом регистра находит заданный тип в этой сборке и создает его экземпляр, используя абстрактный метод.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-143">Locates the specified type from this assembly and creates an instance of it using the system activator, using case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-144">Экземпляр указанного типа, созданный с использованием конструктора по умолчанию; или <see langword="null" />, если <paramref name="typeName" /> не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-144">An instance of the specified type created with the default constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
          <span data-ttu-id="cec47-145">Тип разрешается с использованием связывателя по умолчанию, не задавая языка и региональных параметров, а также атрибутов активации, при этом для объекта <see cref="T:System.Reflection.BindingFlags" /> задано значение <see langword="Public" /> или <see langword="Instance" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-145">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-146">Если среда CLR не удалось найти `typeName` в <xref:System.Reflection.Assembly> экземпляра, она возвращает `null` вместо выдачи исключения.</span><span class="sxs-lookup"><span data-stu-id="cec47-146">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="cec47-147">Это может произойти, когда:</span><span class="sxs-lookup"><span data-stu-id="cec47-147">This might happen because:</span></span>  
  
-   <span data-ttu-id="cec47-148">Вы не указали полное имя типа.</span><span class="sxs-lookup"><span data-stu-id="cec47-148">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="cec47-149">Вы указали полностью уточненное имя типа, но его вариант не совпадает по регистру типа <xref:System.Type.FullName%2A?displayProperty=nameWithType> свойство.</span><span class="sxs-lookup"><span data-stu-id="cec47-149">You've specified the fully qualified type name, but its case doesn’t match the case of the type's <xref:System.Type.FullName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="cec47-150">Сравнение без учета регистра `typeName` с полным именем типа, вызовите <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> перегрузки и укажите `true` для `ignoreCase` аргумент.</span><span class="sxs-lookup"><span data-stu-id="cec47-150">For a case-insensitive comparison of `typeName` with the type's full name, call the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specify `true` for the `ignoreCase` argument.</span></span>  
  
-   <span data-ttu-id="cec47-151">Тип не существует в текущем <xref:System.Reflection.Assembly> экземпляра.</span><span class="sxs-lookup"><span data-stu-id="cec47-151">The type doesn’t exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-152">В следующем примере определяется `Person` класс и вызывает метод <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> метод для создания его экземпляра.</span><span class="sxs-lookup"><span data-stu-id="cec47-152">The following example defines a `Person` class and calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-153">Значение <paramref name="typeName" /> является пустой строкой ("") или строкой, начинающейся с нуль-символа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-153">
              <paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span>
          </span>
          <span data-ttu-id="cec47-154">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-154">-or-</span>
          </span>
          <span data-ttu-id="cec47-155">Текущая сборка была загружена в контекст только для отражения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-155">The current assembly was loaded into the reflection-only context.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-156">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-156">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="cec47-157">Соответствующий конструктор не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-157">No matching constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-158">Для <paramref name="typeName" /> требуется зависимая сборка, которую не удалось найти.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-158">
              <paramref name="typeName" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-159">Для <paramref name="typeName" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-159">
              <paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-160">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-160">-or-</span>
          </span>
          <span data-ttu-id="cec47-161">Текущая сборка была загружена в контекст только для отражения, а для <paramref name="typeName" /> требуется зависимая сборка, которая не была предварительно загружена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-161">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-162">Для <paramref name="typeName" /> требуется зависимая сборка, однако файл не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-162">
              <paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-163">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-163">-or-</span>
          </span>
          <span data-ttu-id="cec47-164">Для <paramref name="typeName" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-164">
              <paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="cec47-165">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-165">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="cec47-166">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-166">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="cec47-167">
            <see cref="P:System.Type.FullName" /> искомого типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-167">The <see cref="P:System.Type.FullName" /> of the type to locate.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="cec47-168">Значение <see langword="true" />, чтобы игнорировать регистр имени типа, в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-168">
              <see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-169">При помощи необязательного поиска с учетом регистра находит заданный тип в этой сборке и создает его экземпляр, используя абстрактный метод.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-169">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-170">Экземпляр указанного типа, созданный с использованием конструктора по умолчанию; или <see langword="null" />, если <paramref name="typeName" /> не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-170">An instance of the specified type created with the default constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
          <span data-ttu-id="cec47-171">Тип разрешается с использованием связывателя по умолчанию, не задавая языка и региональных параметров, а также атрибутов активации, при этом для объекта <see cref="T:System.Reflection.BindingFlags" /> задано значение <see langword="Public" /> или <see langword="Instance" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-171">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-172">Если среда CLR не удалось найти `typeName` в <xref:System.Reflection.Assembly> экземпляра, она возвращает `null` вместо выдачи исключения.</span><span class="sxs-lookup"><span data-stu-id="cec47-172">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="cec47-173">Это может произойти, когда:</span><span class="sxs-lookup"><span data-stu-id="cec47-173">This might happen because:</span></span>  
  
-   <span data-ttu-id="cec47-174">Вы не указали полное имя типа.</span><span class="sxs-lookup"><span data-stu-id="cec47-174">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="cec47-175">Тип не существует в текущем <xref:System.Reflection.Assembly> экземпляра.</span><span class="sxs-lookup"><span data-stu-id="cec47-175">The type doesn’t exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-176">В следующем примере определяется `Person` класса.</span><span class="sxs-lookup"><span data-stu-id="cec47-176">The following example defines a `Person` class.</span></span> <span data-ttu-id="cec47-177">Затем он вызывает <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> метод для создания экземпляра, но поскольку регистр `typeName` аргумента не соответствует типу <xref:System.Type.FullName%2A> свойство, метод возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="cec47-177">It then calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it, but because the casing of the `typeName` argument doesn’t match that of the type's <xref:System.Type.FullName%2A> property, the method returns `null`.</span></span> <span data-ttu-id="cec47-178">Если в примере передается ту же строку, чтобы <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> перегрузки и указывает, что сравнение без учета регистра, `Person` класс найден и `Person` успешно создать экземпляр объекта.</span><span class="sxs-lookup"><span data-stu-id="cec47-178">When the example passes the same string to the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specifies that the comparison should be case-insensitive, the `Person` class is found, and a `Person` object is successfully instantiated.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-179">Значение <paramref name="typeName" /> является пустой строкой ("") или строкой, начинающейся с нуль-символа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-179">
              <paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span>
          </span>
          <span data-ttu-id="cec47-180">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-180">-or-</span>
          </span>
          <span data-ttu-id="cec47-181">Текущая сборка была загружена в контекст только для отражения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-181">The current assembly was loaded into the reflection-only context.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="cec47-182">Соответствующий конструктор не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-182">No matching constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-183">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-183">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-184">Для <paramref name="typeName" /> требуется зависимая сборка, которую не удается найти.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-184">
              <paramref name="typeName" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-185">Для <paramref name="typeName" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-185">
              <paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-186">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-186">-or-</span>
          </span>
          <span data-ttu-id="cec47-187">Текущая сборка была загружена в контекст только для отражения, а для <paramref name="typeName" /> требуется зависимая сборка, которая не была предварительно загружена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-187">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-188">Для <paramref name="typeName" /> требуется зависимая сборка, однако файл не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-188">
              <paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-189">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-189">-or-</span>
          </span>
          <span data-ttu-id="cec47-190">Для <paramref name="typeName" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-190">
              <paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="cec47-191">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-191">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="cec47-192">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-192">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="cec47-193">
            <see cref="P:System.Type.FullName" /> искомого типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-193">The <see cref="P:System.Type.FullName" /> of the type to locate.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="cec47-194">Значение <see langword="true" />, чтобы игнорировать регистр имени типа, в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-194">
              <see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="cec47-195">Битовая маска, влияющая на способ выполнения поиска.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-195">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="cec47-196">Значение является сочетанием одноразрядных флагов из <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-196">The value is a combination of bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="cec47-197">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see langword="MemberInfo" /> с помощью отражения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-197">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span>
          </span>
          <span data-ttu-id="cec47-198">Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-198">If <paramref name="binder" /> is <see langword="null" />, the default binder is used.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="cec47-199">Массив, содержащий аргументы, передаваемые конструктору.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-199">An array that contains the arguments to be passed to the constructor.</span>
          </span>
          <span data-ttu-id="cec47-200">Этот массив аргументов должен по числу, порядку и типу аргументов соответствовать параметрам вызываемого конструктора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-200">This array of arguments must match in number, order, and type the parameters of the constructor to be invoked.</span>
          </span>
          <span data-ttu-id="cec47-201">Если нужен конструктор по умолчанию, <paramref name="args" /> должен быть пустым массивом или <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-201">If the default constructor is desired, <paramref name="args" /> must be an empty array or <see langword="null" />.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="cec47-202">Экземпляр объекта <see langword="CultureInfo" />, используемого для управления приведением типов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-202">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="cec47-203">Если значение этого объекта — <see langword="null" />, для текущего потока используется <see langword="CultureInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-203">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="cec47-204">(Например, необходимо преобразовывать объект <see langword="String" />, представляющий 1000, в значение <see langword="Double" />, поскольку при разных языках и региональных параметрах 1000 представляется по-разному.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-204">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="cec47-205">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-205">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="cec47-206">Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  </span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-206">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="cec47-207">Этот параметр связан с объектами, активируемыми клиентом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-207">This parameter is related to client-activated objects.</span>
          </span>
          <span data-ttu-id="cec47-208">Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-208">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="cec47-209">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-209">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-210">Находит в сборке указанный тип и создает его экземпляр с использованием системного активатора при помощи необязательного поиска с учетом регистра и с заданными аргументами, культурой, а также атрибутами привязки и активации.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-210">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search and having the specified culture, arguments, and binding and activation attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-211">Экземпляр указанного типа или <see langword="null" />, если <paramref name="typeName" /> не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-211">An instance of the specified type, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
          <span data-ttu-id="cec47-212">Предоставленные аргументы используются для разрешения типа и привязки конструктора, который используется для создания экземпляра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-212">The supplied arguments are used to resolve the type, and to bind the constructor that is used to create the instance.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-213">Значение <paramref name="typeName" /> является пустой строкой ("") или строкой, начинающейся с нуль-символа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-213">
              <paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span>
          </span>
          <span data-ttu-id="cec47-214">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-214">-or-</span>
          </span>
          <span data-ttu-id="cec47-215">Текущая сборка была загружена в контекст только для отражения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-215">The current assembly was loaded into the reflection-only context.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-216">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-216">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="cec47-217">Соответствующий конструктор не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-217">No matching constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="cec47-218">Непустой массив атрибутов активации передан в тип, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-218">A non-empty activation attributes array is passed to a type that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-219">Для <paramref name="typeName" /> требуется зависимая сборка, которую не удалось найти.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-219">
              <paramref name="typeName" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-220">Для <paramref name="typeName" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-220">
              <paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-221">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-221">-or-</span>
          </span>
          <span data-ttu-id="cec47-222">Текущая сборка была загружена в контекст только для отражения, а для <paramref name="typeName" /> требуется зависимая сборка, которая не была предварительно загружена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-222">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-223">Для <paramref name="typeName" /> требуется зависимая сборка, однако файл не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-223">
              <paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-224">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-224">-or-</span>
          </span>
          <span data-ttu-id="cec47-225">Для <paramref name="typeName" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-225">
              <paramref name="typeName" /> requires a dependent assembly which that was compiled for a version of the runtime that is later than the currently loaded version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="cec47-226">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-226">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="cec47-227">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-227">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-228">для создания экземпляра делегата.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-228">to create an instance of a delegate.</span>
          </span>
          <span data-ttu-id="cec47-229">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-229">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="cec47-230">Отображаемое имя сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-230">The display name of an assembly.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="cec47-231">Полное имя типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-231">The full name of a type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-232">Создает имя типа, который определяется отображаемым именем его сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-232">Creates the name of a type qualified by the display name of its assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-233">Полное имя типа, дополненное отображаемым именем сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-233">The full name of the type qualified by the display name of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-234">Приведен формат возвращаемой строки.</span><span class="sxs-lookup"><span data-stu-id="cec47-234">The format of the returned string is:</span></span>  
  
 <span data-ttu-id="cec47-235">\<FullTypeName >, \<AssemblyDisplayName ></span><span class="sxs-lookup"><span data-stu-id="cec47-235">\<FullTypeName>, \<AssemblyDisplayName></span></span>  
  
 <span data-ttu-id="cec47-236">См. в разделе <xref:System.Reflection.AssemblyName> описание формата отображаемого имени сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-236">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
 <span data-ttu-id="cec47-237">В соответствии с изменениями в версиях среда CLR, используйте этот метод вместо создания полного имени самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="cec47-237">To accommodate changes in versions of the common language runtime, use this method rather than constructing the qualified name yourself.</span></span>  <span data-ttu-id="cec47-238">Сведения о полных имен сборок, см. в разделе <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cec47-238">For information about qualified assembly names, see <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-239">Получает коллекцию, содержащую пользовательские атрибуты этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-239">Gets a collection that contains this assembly's custom attributes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-240">Коллекция, содержащая пользовательские атрибуты этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-240">A collection that contains this assembly's custom attributes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-241">Получает коллекцию типов, определенных в этой сборке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-241">Gets a collection of the types defined in this assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-242">Коллекция типов, определенных в этой сборке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-242">A collection of the types defined in this assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-243"><xref:System.Reflection.Assembly.DefinedTypes%2A> Свойства можно сравнить с <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> метода, за исключением случаев, <xref:System.Reflection.Assembly.DefinedTypes%2A> свойство возвращает коллекцию <xref:System.Reflection.TypeInfo> объектов и <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> метод возвращает массив <xref:System.Type> объектов.</span><span class="sxs-lookup"><span data-stu-id="cec47-243">The <xref:System.Reflection.Assembly.DefinedTypes%2A> property is comparable to the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method, except that the <xref:System.Reflection.Assembly.DefinedTypes%2A> property returns a collection of <xref:System.Reflection.TypeInfo> objects, and the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method returns an array of <xref:System.Type> objects.</span></span>  
  
 <span data-ttu-id="cec47-244">Возвращаемый массив содержит вложенные типы.</span><span class="sxs-lookup"><span data-stu-id="cec47-244">The returned array includes nested types.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-245">Получает точку входа для этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-245">Gets the entry point of this assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-246">Объект, представляющий точку входа этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-246">An object that represents the entry point of this assembly.</span>
          </span>
          <span data-ttu-id="cec47-247">Если точка входа не найдена (например, сборка является DLL-библиотекой), возвращается значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-247">If no entry point is found (for example, the assembly is a DLL), <see langword="null" /> is returned.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="cec47-248">Объект, сравниваемый с данным экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-248">The object to compare with this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-249">Определяет равенство сборки и заданного объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-249">Determines whether this assembly and the specified object are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-250">Значение <see langword="true" />, если значение параметра <paramref name="o" /> равно данному экземпляру; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-250">
              <see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-251"><xref:System.Reflection.Assembly.Equals%2A> Метод выполняет проверку на равенство ссылок для определения ли текущий экземпляр и `o` равны.</span><span class="sxs-lookup"><span data-stu-id="cec47-251">The <xref:System.Reflection.Assembly.Equals%2A> method performs a test for reference equality to determine whether the current instance and `o` are equal.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-252">Получает универсальный код доступа (URI), предоставляющий базовый код, включая escape-символы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-252">Gets the URI, including escape characters, that represents the codebase.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-253">Универсальный код доступа (URI) с escape-символами.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-253">A URI with escape characters.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-254">для доступа к пути.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-254">for access to the path.</span>
          </span>
          <span data-ttu-id="cec47-255">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-255">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-256">Получает свидетельство для этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-256">Gets the evidence for this assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-257">Свидетельство для этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-257">The evidence for this assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-258">Свидетельство — это набор сведений, используемых для принятия решений политики безопасности, например, сведений о разрешениях, которые могут быть предоставлены коду.</span><span class="sxs-lookup"><span data-stu-id="cec47-258">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-259">на загрузку сборки со свидетельством.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-259">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="cec47-260">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-260">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-261">Получает коллекцию открытых типов, определенных в этой сборке и видимых за ее пределами.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-261">Gets a collection of the public types defined in this assembly that are visible outside the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-262">Коллекция открытых типов, определенных в этой сборке и видимых за ее пределами.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-262">A collection of the public types defined in this assembly that are visible outside the assembly.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-263">Получает отображаемое имя сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-263">Gets the display name of the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-264">Отображаемое имя сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-264">The display name of the assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-265">См. в разделе <xref:System.Reflection.AssemblyName> описание формата отображаемого имени сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-265">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-266">Написать собственный код для синтаксического анализа отображаемые имена не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="cec47-266">Writing your own code to parse display names is not recommended.</span></span> <span data-ttu-id="cec47-267">Вместо этого передайте имя, отображаемое <xref:System.Reflection.AssemblyName.%23ctor%2A> конструктор, который анализирует его и заполняет соответствующие поля нового <xref:System.Reflection.AssemblyName>.</span><span class="sxs-lookup"><span data-stu-id="cec47-267">Instead, pass the display name to the <xref:System.Reflection.AssemblyName.%23ctor%2A> constructor, which parses it and populates the appropriate fields of the new <xref:System.Reflection.AssemblyName>.</span></span>  
  
 <span data-ttu-id="cec47-268">В .NET Framework версии 2.0 архитектура процессора добавляется удостоверения сборки и может быть указан как часть строки имени сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-268">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="cec47-269">Тем не менее, он не включен в строку, возвращаемую <xref:System.Reflection.Assembly.FullName%2A> свойство, по соображениям совместимости.</span><span class="sxs-lookup"><span data-stu-id="cec47-269">However, it is not included in the string returned by the <xref:System.Reflection.Assembly.FullName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="cec47-270">См. раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cec47-270">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-271">В следующем примере извлекается отображаемое имя текущей выполняемой сборке и отображаемое имя сборки, содержащей <xref:System.Int32> тип (`int` в C# `Integer` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="cec47-271">The following example retrieves the display name of the currently executing assembly, and the display name of the assembly that contains the <xref:System.Int32> type (`int` in C#, `Integer` in Visual Basic).</span></span>  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="cec47-272">Указание полных имен типов</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-272">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="cec47-273">Объект, представляющий тип в сборке, которая будет возвращена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-273">An object representing a type in the assembly that will be returned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-274">Возвращает текущую загруженную сборку, в которой определен указанный тип.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-274">Gets the currently loaded assembly in which the specified type is defined.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-275">Сборка, в которой определен указанный тип.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-275">The assembly in which the specified type is defined.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-276">Вызов этого метода эквивалентен получение значения <xref:System.Type.Assembly?displayProperty=nameWithType> свойство.</span><span class="sxs-lookup"><span data-stu-id="cec47-276">Calling this method is equivalent to retrieving the value of the  <xref:System.Type.Assembly?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="cec47-277">Тем не менее <xref:System.Type.Assembly?displayProperty=nameWithType> свойства, как правило, обеспечивает более высокую производительность.</span><span class="sxs-lookup"><span data-stu-id="cec47-277">However, the <xref:System.Type.Assembly?displayProperty=nameWithType> property typically offers superior performance.</span></span>  
  
 <span data-ttu-id="cec47-278">Чтобы вызвать этот метод, необходимо иметь <xref:System.Type> объект, который означает, что сборка, в котором определен класс уже должна быть загружена.</span><span class="sxs-lookup"><span data-stu-id="cec47-278">In order to call this method, you must have a <xref:System.Type> object, which means that the assembly in which the class is defined must already be loaded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-279">В следующем примере извлекается сборки, содержащей <xref:System.Int32> введите и отображает его имя и местоположение файлов.</span><span class="sxs-lookup"><span data-stu-id="cec47-279">The following example retrieves the assembly that contains the <xref:System.Int32> type and displays its name and file location.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-280">Свойство <paramref name="type" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-280">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="cec47-281">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-281">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="cec47-282">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-282">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-283">Возвращает объект <see cref="T:System.Reflection.Assembly" /> метода, вызвавшего текущий выполняемый метод.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-283">Returns the <see cref="T:System.Reflection.Assembly" /> of the method that invoked the currently executing method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-284">Объект <see langword="Assembly" /> метода, вызвавшего выполняющийся в текущий момент метод.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-284">The <see langword="Assembly" /> object of the method that invoked the currently executing method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-285">Если на метод, который вызывает <xref:System.Reflection.Assembly.GetCallingAssembly%2A> метод является развернуты для подстановки компилятор just-in-time (JIT), или если вызывающий раскрываются внутри, сборка возвращаемые <xref:System.Reflection.Assembly.GetCallingAssembly%2A> неожиданно могут отличаться.</span><span class="sxs-lookup"><span data-stu-id="cec47-285">If the method that calls the <xref:System.Reflection.Assembly.GetCallingAssembly%2A> method is expanded inline by the just-in-time (JIT) compiler, or if its caller is expanded inline, the assembly that is returned by <xref:System.Reflection.Assembly.GetCallingAssembly%2A> may differ unexpectedly.</span></span> <span data-ttu-id="cec47-286">Например рассмотрим следующие методы и сборки:</span><span class="sxs-lookup"><span data-stu-id="cec47-286">For example, consider the following methods and assemblies:</span></span>  
  
-   <span data-ttu-id="cec47-287">Метод `M1` в сборке `A1` вызовы <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span><span class="sxs-lookup"><span data-stu-id="cec47-287">Method `M1` in assembly `A1` calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
-   <span data-ttu-id="cec47-288">Метод `M2` в сборке `A2` вызовы `M1`.</span><span class="sxs-lookup"><span data-stu-id="cec47-288">Method `M2` in assembly `A2` calls `M1`.</span></span>  
  
-   <span data-ttu-id="cec47-289">Метод `M3` в сборке `A3` вызовы `M2`.</span><span class="sxs-lookup"><span data-stu-id="cec47-289">Method `M3` in assembly `A3` calls `M2`.</span></span>  
  
 <span data-ttu-id="cec47-290">Когда `M1` не является встроенной, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> возвращает `A2`.</span><span class="sxs-lookup"><span data-stu-id="cec47-290">When `M1` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="cec47-291">Когда `M1` встроена, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> возвращает `A3`.</span><span class="sxs-lookup"><span data-stu-id="cec47-291">When `M1` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span> <span data-ttu-id="cec47-292">Аналогичным образом, когда `M2` не является встроенной, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> возвращает `A2`.</span><span class="sxs-lookup"><span data-stu-id="cec47-292">Similarly, when `M2` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="cec47-293">Когда `M2` встроена, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> возвращает `A3`.</span><span class="sxs-lookup"><span data-stu-id="cec47-293">When `M2` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span>  
  
 <span data-ttu-id="cec47-294">Этот эффект также происходит при `M1` выполняется вызов с префиксом tail из `M2`, или когда `M2` выполняется вызов с префиксом tail из `M3`.</span><span class="sxs-lookup"><span data-stu-id="cec47-294">This effect also occurs when `M1` executes as a tail call from `M2`, or when `M2` executes as a tail call from `M3`.</span></span> <span data-ttu-id="cec47-295">Отказаться от JIT-компилятора из встраивания метод, который вызывает <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, путем применения <xref:System.Runtime.CompilerServices.MethodImplAttribute> атрибут с <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> флаг, но аналогичный механизм для предотвращения вызовов с префиксом tail.</span><span class="sxs-lookup"><span data-stu-id="cec47-295">You can prevent the JIT compiler from inlining the method that calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, by applying the <xref:System.Runtime.CompilerServices.MethodImplAttribute> attribute with the <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> flag, but there is no similar mechanism for preventing tail calls.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-296">В следующем примере возвращается вызывающей сборки текущего метода.</span><span class="sxs-lookup"><span data-stu-id="cec47-296">The following example gets the calling assembly of the current method.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-297">Получает настраиваемые атрибуты для этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-297">Gets the custom attributes for this assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="cec47-298">Данный аргумент не учитывается для объектов типа <see cref="T:System.Reflection.Assembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-298">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-299">Получает все настраиваемые атрибуты для этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-299">Gets all the custom attributes for this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-300">Массив, содержащий настраиваемые атрибуты для этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-300">An array that contains the custom attributes for this assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-301">Этот метод реализует соответствующий <xref:System.Reflection.ICustomAttributeProvider> метод интерфейса.</span><span class="sxs-lookup"><span data-stu-id="cec47-301">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="cec47-302">Таким образом `inherit` параметр должен быть указан, несмотря на то, что он учитывается.</span><span class="sxs-lookup"><span data-stu-id="cec47-302">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="cec47-303">Псевдо-атрибут задает биты основных метаданных, которые должны быть установлены при наличии этого атрибута.</span><span class="sxs-lookup"><span data-stu-id="cec47-303">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="cec47-304">В отличие от пользовательского атрибута, который расширяет метаданные для типа и сохраняется вместе с типом, псевдо-атрибут изменяет метаданные для типа, а затем удаляются.</span><span class="sxs-lookup"><span data-stu-id="cec47-304">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="cec47-305">Некоторые из получившиеся биты, нельзя получить с помощью существующих API отражения.</span><span class="sxs-lookup"><span data-stu-id="cec47-305">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="cec47-306">В следующей таблице перечислены различные псевдо-атрибуты и методы доступа для битов, доступных при отражении.</span><span class="sxs-lookup"><span data-stu-id="cec47-306">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="cec47-307">Псевдо-атрибут</span><span class="sxs-lookup"><span data-stu-id="cec47-307">Pseudo-Attribute</span></span>|<span data-ttu-id="cec47-308">Биты метаданных</span><span class="sxs-lookup"><span data-stu-id="cec47-308">Metadata Bits</span></span>|<span data-ttu-id="cec47-309">Метод доступа к отражению</span><span class="sxs-lookup"><span data-stu-id="cec47-309">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="cec47-310">DllImportAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-310">DllImportAttribute</span></span>|<span data-ttu-id="cec47-311">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="cec47-311">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="cec47-312">Имя библиотеки DLL</span><span class="sxs-lookup"><span data-stu-id="cec47-312">DLL name</span></span>|<span data-ttu-id="cec47-313">Нет метода доступа для PInvokeMap для атрибутов обычного метода/глобального метода.</span><span class="sxs-lookup"><span data-stu-id="cec47-313">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="cec47-314">Нет метода доступа для имени библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="cec47-314">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="cec47-315">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-315">GuidAttribute</span></span>|<span data-ttu-id="cec47-316">Хранятся в виде фактических пользовательских атрибутов.</span><span class="sxs-lookup"><span data-stu-id="cec47-316">Stored as a real custom attribute.</span></span>|<span data-ttu-id="cec47-317">Доступен как реальный пользовательский атрибут.</span><span class="sxs-lookup"><span data-stu-id="cec47-317">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="cec47-318">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-318">ComImportAttribute</span></span>|<span data-ttu-id="cec47-319">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="cec47-319">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="cec47-320">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="cec47-320">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="cec47-321">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-321">SerializableAttribute</span></span>|<span data-ttu-id="cec47-322">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="cec47-322">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="cec47-323">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="cec47-323">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="cec47-324">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-324">NonSerializedAttribute</span></span>|<span data-ttu-id="cec47-325">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="cec47-325">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="cec47-326">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="cec47-326">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="cec47-327">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-327">MethodImplAttribute</span></span>|<span data-ttu-id="cec47-328">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="cec47-328">CorMethodImpl</span></span>|<span data-ttu-id="cec47-329">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="cec47-329">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="cec47-330">ConstructorInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="cec47-330">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="cec47-331">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-331">MarshalAsAttribute</span></span>|<span data-ttu-id="cec47-332">Различные элементы.</span><span class="sxs-lookup"><span data-stu-id="cec47-332">Various bits.</span></span>|<span data-ttu-id="cec47-333">Нет метода доступа.</span><span class="sxs-lookup"><span data-stu-id="cec47-333">No accessor.</span></span>|  
|<span data-ttu-id="cec47-334">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-334">PreserveSigAttribute</span></span>|<span data-ttu-id="cec47-335">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="cec47-335">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="cec47-336">MethodInfo.GetMethodImplementationFlags(). OLE</span><span class="sxs-lookup"><span data-stu-id="cec47-336">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="cec47-337">ConstructorInfo.GetMethodImplementationFlags(). OLE</span><span class="sxs-lookup"><span data-stu-id="cec47-337">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="cec47-338">InAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-338">InAttribute</span></span>|<span data-ttu-id="cec47-339">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="cec47-339">CorParamAttr.pdIn</span></span>|<span data-ttu-id="cec47-340">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="cec47-340">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="cec47-341">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-341">OutAttribute</span></span>|<span data-ttu-id="cec47-342">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="cec47-342">CorParamAttr.pdOut</span></span>|<span data-ttu-id="cec47-343">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="cec47-343">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="cec47-344">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-344">StructLayoutAttribute</span></span>|<span data-ttu-id="cec47-345">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="cec47-345">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="cec47-346">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="cec47-346">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="cec47-347">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="cec47-347">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="cec47-348">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="cec47-348">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="cec47-349">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="cec47-349">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="cec47-350">Упаковка классов.</span><span class="sxs-lookup"><span data-stu-id="cec47-350">Class packing.</span></span>|<span data-ttu-id="cec47-351">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="cec47-351">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="cec47-352">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="cec47-352">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="cec47-353">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="cec47-353">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="cec47-354">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="cec47-354">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="cec47-355">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="cec47-355">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="cec47-356">Нет метода доступа.</span><span class="sxs-lookup"><span data-stu-id="cec47-356">No accessor.</span></span>|  
|<span data-ttu-id="cec47-357">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-357">FieldOffsetAttribute</span></span>|<span data-ttu-id="cec47-358">Смещение поля.</span><span class="sxs-lookup"><span data-stu-id="cec47-358">Field offset.</span></span>|<span data-ttu-id="cec47-359">Нет метода доступа.</span><span class="sxs-lookup"><span data-stu-id="cec47-359">No accessor.</span></span>|  
|<span data-ttu-id="cec47-360">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-360">AssemblyLoadAttribute</span></span>|<span data-ttu-id="cec47-361">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="cec47-361">CorAssemblyFlags</span></span>|<span data-ttu-id="cec47-362">Нет доступа или перечислителя.</span><span class="sxs-lookup"><span data-stu-id="cec47-362">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="cec47-363">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-363">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="cec47-364">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-364">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="cec47-365">Тип, для которого должны быть возвращены настраиваемые атрибуты.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-365">The type for which the custom attributes are to be returned.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="cec47-366">Данный аргумент не учитывается для объектов типа <see cref="T:System.Reflection.Assembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-366">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-367">Получает настраиваемые атрибуты для этой сборки как заданные по типу.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-367">Gets the custom attributes for this assembly as specified by type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-368">Массив, содержащий настраиваемые атрибуты для этой сборки, заданные параметром <paramref name="attributeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-368">An array that contains the custom attributes for this assembly as specified by <paramref name="attributeType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-369">Этот метод реализует соответствующий <xref:System.Reflection.ICustomAttributeProvider> метод интерфейса.</span><span class="sxs-lookup"><span data-stu-id="cec47-369">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="cec47-370">Таким образом `inherit` параметр должен быть указан, несмотря на то, что он учитывается.</span><span class="sxs-lookup"><span data-stu-id="cec47-370">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="cec47-371">Псевдо-атрибут задает биты основных метаданных, которые должны быть установлены при наличии этого атрибута.</span><span class="sxs-lookup"><span data-stu-id="cec47-371">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="cec47-372">В отличие от пользовательского атрибута, который расширяет метаданные для типа и сохраняется вместе с типом, псевдо-атрибут изменяет метаданные для типа, а затем удаляются.</span><span class="sxs-lookup"><span data-stu-id="cec47-372">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="cec47-373">Некоторые из получившиеся биты, нельзя получить с помощью существующих API отражения.</span><span class="sxs-lookup"><span data-stu-id="cec47-373">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="cec47-374">В следующей таблице перечислены различные псевдо-атрибуты и методы доступа для битов, доступных при отражении.</span><span class="sxs-lookup"><span data-stu-id="cec47-374">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="cec47-375">Псевдо-атрибут</span><span class="sxs-lookup"><span data-stu-id="cec47-375">Pseudo-Attribute</span></span>|<span data-ttu-id="cec47-376">Биты метаданных</span><span class="sxs-lookup"><span data-stu-id="cec47-376">Metadata Bits</span></span>|<span data-ttu-id="cec47-377">Метод доступа к отражению</span><span class="sxs-lookup"><span data-stu-id="cec47-377">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="cec47-378">DllImportAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-378">DllImportAttribute</span></span>|<span data-ttu-id="cec47-379">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="cec47-379">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="cec47-380">Имя библиотеки DLL</span><span class="sxs-lookup"><span data-stu-id="cec47-380">DLL name</span></span>|<span data-ttu-id="cec47-381">Нет метода доступа для PInvokeMap для атрибутов обычного метода/глобального метода.</span><span class="sxs-lookup"><span data-stu-id="cec47-381">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="cec47-382">Нет метода доступа для имени библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="cec47-382">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="cec47-383">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-383">GuidAttribute</span></span>|<span data-ttu-id="cec47-384">Хранятся в виде фактических пользовательских атрибутов.</span><span class="sxs-lookup"><span data-stu-id="cec47-384">Stored as a real custom attribute.</span></span>|<span data-ttu-id="cec47-385">Доступен как реальный пользовательский атрибут.</span><span class="sxs-lookup"><span data-stu-id="cec47-385">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="cec47-386">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-386">ComImportAttribute</span></span>|<span data-ttu-id="cec47-387">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="cec47-387">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="cec47-388">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="cec47-388">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="cec47-389">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-389">SerializableAttribute</span></span>|<span data-ttu-id="cec47-390">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="cec47-390">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="cec47-391">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="cec47-391">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="cec47-392">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-392">NonSerializedAttribute</span></span>|<span data-ttu-id="cec47-393">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="cec47-393">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="cec47-394">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="cec47-394">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="cec47-395">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-395">MethodImplAttribute</span></span>|<span data-ttu-id="cec47-396">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="cec47-396">CorMethodImpl</span></span>|<span data-ttu-id="cec47-397">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="cec47-397">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="cec47-398">ConstructorInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="cec47-398">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="cec47-399">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-399">MarshalAsAttribute</span></span>|<span data-ttu-id="cec47-400">Различные элементы.</span><span class="sxs-lookup"><span data-stu-id="cec47-400">Various bits.</span></span>|<span data-ttu-id="cec47-401">Нет метода доступа.</span><span class="sxs-lookup"><span data-stu-id="cec47-401">No accessor.</span></span>|  
|<span data-ttu-id="cec47-402">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-402">PreserveSigAttribute</span></span>|<span data-ttu-id="cec47-403">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="cec47-403">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="cec47-404">MethodInfo.GetMethodImplementationFlags(). OLE</span><span class="sxs-lookup"><span data-stu-id="cec47-404">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="cec47-405">ConstructorInfo.GetMethodImplementationFlags(). OLE</span><span class="sxs-lookup"><span data-stu-id="cec47-405">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="cec47-406">InAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-406">InAttribute</span></span>|<span data-ttu-id="cec47-407">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="cec47-407">CorParamAttr.pdIn</span></span>|<span data-ttu-id="cec47-408">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="cec47-408">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="cec47-409">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-409">OutAttribute</span></span>|<span data-ttu-id="cec47-410">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="cec47-410">CorParamAttr.pdOut</span></span>|<span data-ttu-id="cec47-411">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="cec47-411">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="cec47-412">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-412">StructLayoutAttribute</span></span>|<span data-ttu-id="cec47-413">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="cec47-413">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="cec47-414">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="cec47-414">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="cec47-415">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="cec47-415">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="cec47-416">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="cec47-416">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="cec47-417">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="cec47-417">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="cec47-418">Упаковка классов.</span><span class="sxs-lookup"><span data-stu-id="cec47-418">Class packing.</span></span>|<span data-ttu-id="cec47-419">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="cec47-419">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="cec47-420">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="cec47-420">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="cec47-421">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="cec47-421">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="cec47-422">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="cec47-422">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="cec47-423">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="cec47-423">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="cec47-424">Нет метода доступа.</span><span class="sxs-lookup"><span data-stu-id="cec47-424">No accessor.</span></span>|  
|<span data-ttu-id="cec47-425">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-425">FieldOffsetAttribute</span></span>|<span data-ttu-id="cec47-426">Смещение поля.</span><span class="sxs-lookup"><span data-stu-id="cec47-426">Field offset.</span></span>|<span data-ttu-id="cec47-427">Нет метода доступа.</span><span class="sxs-lookup"><span data-stu-id="cec47-427">No accessor.</span></span>|  
|<span data-ttu-id="cec47-428">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="cec47-428">AssemblyLoadAttribute</span></span>|<span data-ttu-id="cec47-429">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="cec47-429">CorAssemblyFlags</span></span>|<span data-ttu-id="cec47-430">Нет доступа или перечислителя.</span><span class="sxs-lookup"><span data-stu-id="cec47-430">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-431">Свойство <paramref name="attributeType" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-431">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-432">
            <paramref name="attributeType" /> не является типом среды выполнения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-432">
              <paramref name="attributeType" /> is not a runtime type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="cec47-433">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-433">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="cec47-434">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-434">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-435">Возвращает сведения об атрибутах, примененных к текущему объекту <see cref="T:System.Reflection.Assembly" />; сведения представляют собой объекты <see cref="T:System.Reflection.CustomAttributeData" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-435">Returns information about the attributes that have been applied to the current <see cref="T:System.Reflection.Assembly" />, expressed as <see cref="T:System.Reflection.CustomAttributeData" /> objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-436">Универсальный список объектов <see cref="T:System.Reflection.CustomAttributeData" />, представляющих данные об атрибутах, которые были применены к текущей сборке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-436">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-437">Этот метод позволяет просмотреть пользовательские атрибуты кода в контексте только для отражения в случаях, когда сами настраиваемые атрибуты определены в коде, который загружается в контекст только для отражения.</span><span class="sxs-lookup"><span data-stu-id="cec47-437">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="cec47-438">Методы, такие как <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> и <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> не может использоваться в таких случаях, так как они создают экземпляры атрибутов.</span><span class="sxs-lookup"><span data-stu-id="cec47-438">Methods like <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="cec47-439">Не удается выполнить код в контексте только для отражения.</span><span class="sxs-lookup"><span data-stu-id="cec47-439">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="cec47-440">Дополнительные сведения и пример кода, см. в разделе <xref:System.Reflection.CustomAttributeData> класса.</span><span class="sxs-lookup"><span data-stu-id="cec47-440">For more information and for example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-441">Получает процесс, исполняемый в домене приложения по умолчанию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-441">Gets the process executable in the default application domain.</span>
          </span>
          <span data-ttu-id="cec47-442">В других доменах приложений это первый исполняемый процесс, который был выполнен методом <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-442">In other application domains, this is the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-443">Сборка, представляющая собой исполняемый файл процесса в домене приложения по умолчанию или первый исполняемый файл, выполненный методом <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-443">The assembly that is the process executable in the default application domain, or the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span>
          </span>
          <span data-ttu-id="cec47-444">Может возвратить значение <see langword="null" /> при вызове из неуправляемого кода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-444">Can return <see langword="null" /> when called from unmanaged code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-445"><xref:System.Reflection.Assembly.GetEntryAssembly%2A> Метод может возвращать `null` когда управляемая сборка была загружена из неуправляемого приложения.</span><span class="sxs-lookup"><span data-stu-id="cec47-445">The <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method can return `null` when a managed assembly has been loaded from an unmanaged application.</span></span> <span data-ttu-id="cec47-446">Например, если неуправляемое приложение создает экземпляр COM-компонента на языке C#, вызов <xref:System.Reflection.Assembly.GetEntryAssembly%2A> метода из компонента на C# возвращает значение null, так как точка входа для процесса неуправляемого кода, а не является управляемой сборкой.</span><span class="sxs-lookup"><span data-stu-id="cec47-446">For example, if an unmanaged application creates an instance of a COM component written in C#, a call to the <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method from the C# component returns null, because the entry point for the process was unmanaged code rather than a managed assembly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-447">Получает сборку, которая содержит выполняемый в текущий момент код.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-447">Gets the assembly that contains the code that is currently executing.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-448">Сборка, содержащая выполняемый в текущий момент код.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-448">The assembly that contains the code that is currently executing.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-449">Для повышения производительности этот метод следует вызывать только в том случае, если вы не знаете во время разработки сборку в данный момент.</span><span class="sxs-lookup"><span data-stu-id="cec47-449">For performance reasons, you should call this method only when you do not know at design time what assembly is currently executing.</span></span> <span data-ttu-id="cec47-450">Рекомендуемый способ получения <xref:System.Reflection.Assembly> , представляющий текущая сборка является использование <xref:System.Type.Assembly%2A?displayProperty=nameWithType> свойство типа, найденные в сборке, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="cec47-450">The recommended way to retrieve an <xref:System.Reflection.Assembly> object that represents the current assembly is to use the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property of a type found in the assembly, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 <span data-ttu-id="cec47-451">Чтобы получить сборку, содержащую метод, который вызывается текущим исполняемым кодом, используйте <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span><span class="sxs-lookup"><span data-stu-id="cec47-451">To get the assembly that contains the method that called the currently executing code, use <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-452">В следующем примере используется <xref:System.Type.Assembly%2A?displayProperty=nameWithType> свойство для получения текущей выполняемой сборке на основе типа, содержащегося в этой сборке.</span><span class="sxs-lookup"><span data-stu-id="cec47-452">The following example uses the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property to get the currently executing assembly based on a type contained in that assembly.</span></span> <span data-ttu-id="cec47-453">Он также вызовет <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> метод, чтобы показать, что он возвращает <xref:System.Reflection.Assembly> объект, который представляет ту же сборку.</span><span class="sxs-lookup"><span data-stu-id="cec47-453">It also calls the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method to show that it returns an <xref:System.Reflection.Assembly> object that represents the same assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-454">Получает открытые типы, определенные в этой сборке и видимые за ее пределами.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-454">Gets the public types defined in this assembly that are visible outside the assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-455">Массив, представляющий типы, определенные в сборке и видимые за ее пределами.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-455">An array that represents the types defined in this assembly that are visible outside the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-456">Только типы, видимый за пределами сборки, открытые типы и открытые типы, вложенные в другие открытые типы.</span><span class="sxs-lookup"><span data-stu-id="cec47-456">The only types visible outside an assembly are public types and public types nested within other public types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-457">В следующем образце кода определяет несколько классов с помощью различных уровней доступа и вызовы <xref:System.Reflection.Assembly.GetExportedTypes%2A> для отображения те, которые видим за пределами сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-457">The following code sample defines a number of classes with various access levels, and calls <xref:System.Reflection.Assembly.GetExportedTypes%2A> to display the ones that are visible from outside the assembly.</span></span>  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="cec47-458">Сборка является динамической.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-458">The assembly is a dynamic assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-459">Не удается загрузить зависимую сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-459">Unable to load a dependent assembly.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="cec47-460">Имя указанного файла.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-460">The name of the specified file.</span>
          </span>
          <span data-ttu-id="cec47-461">Не должно содержать путь к файлу.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-461">Do not include the path to the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-462">Возвращает объект <see cref="T:System.IO.FileStream" /> для указанного файла из таблицы файлов манифеста данной сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-462">Gets a <see cref="T:System.IO.FileStream" /> for the specified file in the file table of the manifest of this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-463">Поток, содержащий указанный файл или <see langword="null" />, если файл не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-463">A stream that contains the specified file, or <see langword="null" /> if the file is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-464">Этот метод работает на обоих файлов открытого и закрытого ресурса.</span><span class="sxs-lookup"><span data-stu-id="cec47-464">This method works on both public and private resource files.</span></span>  
  
 <span data-ttu-id="cec47-465">`name` Не должно содержать путь к файлу.</span><span class="sxs-lookup"><span data-stu-id="cec47-465">The `name` should not include the path to the file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-466">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-466">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-467">Параметр <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-467">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-468">Параметр <paramref name="name" /> представляет собой пустую строку ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-468">The <paramref name="name" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-469">Не удалось найти <paramref name="name" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-469">
              <paramref name="name" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-470">
            <paramref name="name" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-470">
              <paramref name="name" /> is not a valid assembly.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-471">для доступа к пути и для чтения указанного файла.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-471">for access to the path and for reading the specified file.</span>
          </span>
          <span data-ttu-id="cec47-472">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-472">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-473">Получает файлы в таблице файлов манифеста сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-473">Gets the files in the file table of an assembly manifest.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-474">Получает файлы в таблице файлов манифеста сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-474">Gets the files in the file table of an assembly manifest.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-475">Массив потоков, содержащий файлы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-475">An array of streams that contain the files.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-476">Этот метод работает с файлами ресурсов общедоступных и частных.</span><span class="sxs-lookup"><span data-stu-id="cec47-476">This method works on public and private resource files.</span></span>  
  
 <span data-ttu-id="cec47-477">Эта перегрузка эквивалентно вызову <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> перегрузки и указав `false`.</span><span class="sxs-lookup"><span data-stu-id="cec47-477">This overload is equivalent to calling the <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> overload and specifying `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-478">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-478">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-479">Файл не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-479">A file was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-480">Файл не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-480">A file was not a valid assembly.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <span data-ttu-id="cec47-481">Значение <see langword="true" />, если необходимо включать модули ресурсов; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-481">
              <see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-482">Получает файлы из таблицы манифеста сборки с указанием включать или не включать модули ресурсов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-482">Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-483">Массив потоков, содержащий файлы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-483">An array of streams that contain the files.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-484">Этот метод работает с файлами ресурсов общедоступных и частных.</span><span class="sxs-lookup"><span data-stu-id="cec47-484">This method works on public and private resource files.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-485">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-485">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-486">Файл не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-486">A file was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-487">Файл не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-487">A file was not a valid assembly.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-488">Возвращает хэш-код данного экземпляра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-488">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-489">Хэш-код в виде 32-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-489">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-490">Получает все загруженные модули, являющиеся частью этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-490">Gets all the loaded modules that are part of this assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-491">Получает все загруженные модули, являющиеся частью этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-491">Gets all the loaded modules that are part of this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-492">Массив модулей.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-492">An array of modules.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <span data-ttu-id="cec47-493">Значение <see langword="true" />, если необходимо включать модули ресурсов; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-493">
              <see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-494">Получает все загруженные модули, входящие в эту сборку, с заданием возможности включения модулей ресурсов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-494">Gets all the loaded modules that are part of this assembly, specifying whether to include resource modules.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-495">Массив модулей.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-495">An array of modules.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">
          <span data-ttu-id="cec47-496">Имя ресурса, зависящее от регистра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-496">The case-sensitive name of the resource.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-497">Возвращает сведения о сохранении заданного ресурса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-497">Returns information about how the given resource has been persisted.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-498">Объект со сведениями о топологии ресурса или <see langword="null" />, если ресурс не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-498">An object that is populated with information about the resource's topology, or <see langword="null" /> if the resource is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-499">Сведения о ресурсах, возвращается только в том случае, если ресурс является видимым для вызывающего объекта, или вызывающий оператор имеет <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="cec47-499">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-500">Свойство <paramref name="resourceName" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-500">
              <paramref name="resourceName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-501">Параметр <paramref name="resourceName" /> представляет собой пустую строку ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-501">The <paramref name="resourceName" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="cec47-502">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-502">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="cec47-503">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-503">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-504">Возвращает имена всех ресурсов в этой сборке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-504">Returns the names of all the resources in this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-505">Массив, который содержит имена всех ресурсов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-505">An array that contains the names of all the resources.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-506">Имена всех ресурсов, можно использовать в массиве, возвращенное этим методом, следующим образом:</span><span class="sxs-lookup"><span data-stu-id="cec47-506">You can use each resource name in the array returned by this method as follows:</span></span>  
  
-   <span data-ttu-id="cec47-507">Можно передать имя ресурса, чтобы <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> метод для получения дополнительных сведений о ресурсе.</span><span class="sxs-lookup"><span data-stu-id="cec47-507">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> method to get additional information about the resource.</span></span>  
  
-   <span data-ttu-id="cec47-508">Если имя обозначает двоичный RESOURCES-файл, можно удалить его расширение RESOURCES-файла и передать его в <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> конструктора для создания диспетчера ресурсов.</span><span class="sxs-lookup"><span data-stu-id="cec47-508">If the name identifies a binary .resources file, you can remove its .resources file extension and pass it to the <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> constructor to instantiate the resource manager.</span></span>  
  
-   <span data-ttu-id="cec47-509">Можно передать имя ресурса, чтобы <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> метод для извлечения <xref:System.IO.Stream> объект, который затем можно передать <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> конструктор.</span><span class="sxs-lookup"><span data-stu-id="cec47-509">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
-   <span data-ttu-id="cec47-510">Можно передать имя ресурса, чтобы <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> метод для извлечения <xref:System.IO.Stream> объект, который затем можно передать <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> конструктор.</span><span class="sxs-lookup"><span data-stu-id="cec47-510">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
 <span data-ttu-id="cec47-511">Сведения о ресурсах, возвращается только в том случае, если ресурс является видимым для вызывающего объекта, или вызывающий оператор имеет <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="cec47-511">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="cec47-512">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-512">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="cec47-513">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-513">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-514">Загружает указанный ресурс манифеста из сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-514">Loads the specified manifest resource from this assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="cec47-515">Имя запрашиваемого ресурса манифеста, зависящее от регистра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-515">The case-sensitive name of the manifest resource being requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-516">Загружает указанный ресурс манифеста из сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-516">Loads the specified manifest resource from this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-517">Ресурс манифеста; или значение <see langword="null" />, если при компиляции не были заданы ресурсы или ресурс не является видимым для вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-517">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-518">Ресурс манифеста является ресурсом (например, файл изображения), который внедряется в сборку во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="cec47-518">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="cec47-519">Дополнительные сведения о ресурсах манифеста см. в разделе [основы ресурсов Microsoft .NET Framework](https://go.microsoft.com/fwlink/?LinkId=204554) в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="cec47-519">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](https://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="cec47-520">Сведения о ресурсах, возвращается только в том случае, если ресурс является видимым для вызывающего объекта, или вызывающий оператор имеет <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="cec47-520">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-521">Этот метод возвращает `null` при доступе к закрытому ресурсу в другой сборке, и вызывающий объект не имеет <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> флаг.</span><span class="sxs-lookup"><span data-stu-id="cec47-521">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="cec47-522">Если файл ресурсов в манифесте сборки <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> возвращает <xref:System.IO.Stream> объекта, даже если не удается найти файл ресурсов на диске во время.</span><span class="sxs-lookup"><span data-stu-id="cec47-522">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="cec47-523">Если файл ресурсов не найден, передав итоговый <xref:System.IO.Stream> объект <xref:System.Resources.ResourceReader> вызывает конструктор <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-523">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-524">Параметр <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-524">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-525">Параметр <paramref name="name" /> представляет собой пустую строку ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-525">The <paramref name="name" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="cec47-526">Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.IO.IOException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="cec47-526">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="cec47-527">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-527">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-528">Не удалось найти <paramref name="name" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-528">
              <paramref name="name" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-529">
            <paramref name="name" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-529">
              <paramref name="name" /> is not a valid assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="cec47-530">Длина ресурса больше <see cref="F:System.Int64.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-530">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="cec47-531">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-531">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="cec47-532">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-532">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">
          <span data-ttu-id="cec47-533">Манифест сборки</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-533">Assembly Manifest</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="cec47-534">Тип, пространством имен которого ограничена область действия имени ресурса манифеста.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-534">The type whose namespace is used to scope the manifest resource name.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="cec47-535">Имя запрашиваемого ресурса манифеста, зависящее от регистра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-535">The case-sensitive name of the manifest resource being requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-536">Загружает из сборки указанный ресурс манифеста с учетом ограничения области действия пространства имен по типу.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-536">Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-537">Ресурс манифеста; или значение <see langword="null" />, если при компиляции не были заданы ресурсы или ресурс не является видимым для вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-537">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-538">Например, если полное имя, указанное для `type` является «MyNameSpace.MyClasses» и `name` является «Net», этот метод перегрузки ищет ресурс с именем «MyNameSpace.Net».</span><span class="sxs-lookup"><span data-stu-id="cec47-538">For example, if the full name specified for `type` is "MyNameSpace.MyClasses" and `name` is "Net", this method overload searches for a resource named "MyNameSpace.Net".</span></span>  
  
 <span data-ttu-id="cec47-539">Ресурс манифеста является ресурсом (например, файл изображения), который внедряется в сборку во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="cec47-539">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="cec47-540">Дополнительные сведения о ресурсах манифеста см. в разделе [основы ресурсов Microsoft .NET Framework](https://go.microsoft.com/fwlink/?LinkId=204554) в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="cec47-540">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](https://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="cec47-541">Сведения о ресурсах, возвращается только в том случае, если ресурс является видимым для вызывающего объекта, или вызывающий оператор имеет <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="cec47-541">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-542">Этот метод возвращает `null` при доступе к закрытому ресурсу в другой сборке, и вызывающий объект не имеет <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> флаг.</span><span class="sxs-lookup"><span data-stu-id="cec47-542">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="cec47-543">Если файл ресурсов в манифесте сборки <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> возвращает <xref:System.IO.Stream> объекта, даже если не удается найти файл ресурсов на диске во время.</span><span class="sxs-lookup"><span data-stu-id="cec47-543">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="cec47-544">Если файл ресурсов не найден, передав итоговый <xref:System.IO.Stream> объект <xref:System.Resources.ResourceReader> вызывает конструктор <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-544">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-545">Параметр <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-545">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-546">Параметр <paramref name="name" /> представляет собой пустую строку ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-546">The <paramref name="name" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-547">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-547">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-548">Не удалось найти <paramref name="name" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-548">
              <paramref name="name" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-549">
            <paramref name="name" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-549">
              <paramref name="name" /> is not a valid assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="cec47-550">Длина ресурса больше <see cref="F:System.Int64.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-550">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="cec47-551">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-551">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="cec47-552">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-552">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">
          <span data-ttu-id="cec47-553">Манифест сборки</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-553">Assembly Manifest</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="cec47-554">Имя запрашиваемого модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-554">The name of the module being requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-555">Получает указанный модуль этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-555">Gets the specified module in this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-556">Запрашиваемый модуль или значение <see langword="null" />, если модуль не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-556">The module being requested, or <see langword="null" /> if the module is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-557">Этот метод работает с именами файлов.</span><span class="sxs-lookup"><span data-stu-id="cec47-557">This method works on file names.</span></span>  
  
 <span data-ttu-id="cec47-558">Классы в `Reflection.Emit` пространства имен порождают имя области для динамического модуля.</span><span class="sxs-lookup"><span data-stu-id="cec47-558">Classes in the `Reflection.Emit` namespace emit the scope name for a dynamic module.</span></span> <span data-ttu-id="cec47-559">Имя области можно определить с помощью <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> свойство.</span><span class="sxs-lookup"><span data-stu-id="cec47-559">The scope name can be determined by the <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="cec47-560">Тип модуля, чтобы передать `Assembly.GetModule`.</span><span class="sxs-lookup"><span data-stu-id="cec47-560">Pass the kind of module you want to `Assembly.GetModule`.</span></span> <span data-ttu-id="cec47-561">Например, если требуется модуля, содержащего манифест сборки, передать имя области модуля `GetModule`.</span><span class="sxs-lookup"><span data-stu-id="cec47-561">For example, if you want the module that contains the assembly manifest, pass the scope name of the module to `GetModule`.</span></span> <span data-ttu-id="cec47-562">В противном случае передайте имя файла модуля.</span><span class="sxs-lookup"><span data-stu-id="cec47-562">Otherwise, pass the file name of the module.</span></span> <span data-ttu-id="cec47-563">Сборки, загруженные в один из `Load` методы, которые имеют параметр byte [] содержат только один модуль, и модуль манифеста.</span><span class="sxs-lookup"><span data-stu-id="cec47-563">Assemblies loaded by one of the `Load` methods that have a byte[] parameter have only one module, and that is the manifest module.</span></span> <span data-ttu-id="cec47-564">Всегда следует выполнять поиск этих модулей, используя имя области.</span><span class="sxs-lookup"><span data-stu-id="cec47-564">Always seek these modules using the scope name.</span></span>  
  
 <span data-ttu-id="cec47-565">Тип может быть извлечен из конкретного модуля с помощью <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cec47-565">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cec47-566">Вызов `Module.GetType` модуля, содержащего манифест, не приведет к поиску для всей сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-566">Calling `Module.GetType` on the module containing the manifest will not initiate a search of the entire assembly.</span></span> <span data-ttu-id="cec47-567">Чтобы получить тип из сборки, независимо от того, какой модуль он находится, необходимо вызвать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cec47-567">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-568">Параметр <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-568">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-569">Параметр <paramref name="name" /> представляет собой пустую строку ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-569">The <paramref name="name" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-570">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-570">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-571">Не удалось найти <paramref name="name" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-571">
              <paramref name="name" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-572">
            <paramref name="name" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-572">
              <paramref name="name" /> is not a valid assembly.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-573">Получает все модули, являющиеся частью этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-573">Gets all the modules that are part of this assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-574">Получает все модули, являющиеся частью этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-574">Gets all the modules that are part of this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-575">Массив модулей.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-575">An array of modules.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-576">Этот метод работает с файлами ресурсов общедоступных и частных.</span><span class="sxs-lookup"><span data-stu-id="cec47-576">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-577">Модули должны включаться с расширениями имен файлов.</span><span class="sxs-lookup"><span data-stu-id="cec47-577">Modules must be emitted with file name extensions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-578">Следующий пример отображает имя модуля в возвращаемый массив, содержащий манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-578">The following example displays the name of the module in the returned array that contains the assembly manifest.</span></span>  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-579">В загружаемом модуле не указано расширение имени файла.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-579">The module to be loaded does not specify a file name extension.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <span data-ttu-id="cec47-580">Значение <see langword="true" />, если необходимо включать модули ресурсов; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-580">
              <see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-581">Получает все загруженные модули, входящие в эту сборку, с указанием возможности включения модулей ресурсов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-581">Gets all the modules that are part of this assembly, specifying whether to include resource modules.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-582">Массив модулей.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-582">An array of modules.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-583">Этот метод работает с файлами ресурсов общедоступных и частных.</span><span class="sxs-lookup"><span data-stu-id="cec47-583">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-584">Модули должны включаться с расширениями имен файлов.</span><span class="sxs-lookup"><span data-stu-id="cec47-584">Modules must be emitted with file name extensions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-585">Получает имя <see cref="T:System.Reflection.AssemblyName" /> для этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-585">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-586">Получает имя <see cref="T:System.Reflection.AssemblyName" /> для этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-586">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-587">Объект, содержащий полностью проанализированное отображаемое имя для этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-587">An object that contains the fully parsed display name for this assembly.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-588">для доступа к пути сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-588">for access to the path of the assembly.</span>
          </span>
          <span data-ttu-id="cec47-589">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-589">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">
          <span data-ttu-id="cec47-590">Значение <see langword="true" />, чтобы значение свойства <see cref="P:System.Reflection.Assembly.CodeBase" /> указывало на расположение сборки после создания ее теневой копии; значение <see langword="false" />, если значение свойства <see cref="P:System.Reflection.Assembly.CodeBase" /> должно указывать на первоначальное расположение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-590">
              <see langword="true" /> to set the <see cref="P:System.Reflection.Assembly.CodeBase" /> to the location of the assembly after it was shadow copied; <see langword="false" /> to set <see cref="P:System.Reflection.Assembly.CodeBase" /> to the original location.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-591">Возвращает значение <see cref="T:System.Reflection.AssemblyName" /> для этой сборки, база кода устанавливается в соответствии с параметром <paramref name="copiedName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-591">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly, setting the codebase as specified by <paramref name="copiedName" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-592">Объект, содержащий полностью проанализированное отображаемое имя для этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-592">An object that contains the fully parsed display name for this assembly.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-593">для доступа к пути сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-593">for access to the path of the assembly.</span>
          </span>
          <span data-ttu-id="cec47-594">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-594">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="cec47-595">Объект, для которого будут заполнены сведения о сериализации.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-595">The object to be populated with serialization information.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="cec47-596">Контекст назначения сериализации.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-596">The destination context of the serialization.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-597">Получает сведения сериализации со всеми данными, необходимыми для повторного создания экземпляра этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-597">Gets serialization information with all of the data needed to reinstantiate this assembly.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-598">Свойство <paramref name="info" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-598">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="cec47-599">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-599">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="cec47-600">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-600">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-601">Возвращает объекты <see cref="T:System.Reflection.AssemblyName" /> для всех сборок, на которые ссылается данная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-601">Gets the <see cref="T:System.Reflection.AssemblyName" /> objects for all the assemblies referenced by this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-602">Массив, содержащий полностью проанализированные отображаемые имена всех сборок, на которые ссылается данная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-602">An array that contains the fully parsed display names of all the assemblies referenced by this assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="cec47-603">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> свойство <xref:System.Reflection.AssemblyName> объект, который возвращается этим методом является <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> при хэш-алгоритм по связанной сборке, или в том случае, если хэш-алгоритм сборки, на которую указывает ссылка, не является определяется <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> перечисления.</span><span class="sxs-lookup"><span data-stu-id="cec47-603">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property of an <xref:System.Reflection.AssemblyName> object that is returned by this method is <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="cec47-604">В предыдущих версиях .NET Framework <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> свойство, возвращенное <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> в этой ситуации.</span><span class="sxs-lookup"><span data-stu-id="cec47-604">In previous versions of the .NET Framework, the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property returned <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> in this situation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-605">В следующем примере кода показан вызов <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-605">The following code example demonstrates calling the <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> method.</span></span> <span data-ttu-id="cec47-606">Данный пример кода является частью большего примера для <xref:System.Reflection.Assembly> класса.</span><span class="sxs-lookup"><span data-stu-id="cec47-606">This code example is part of a larger example provided for the <xref:System.Reflection.Assembly> class.</span></span>  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-607">Получает вспомогательную сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-607">Gets the satellite assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">
          <span data-ttu-id="cec47-608">Заданные язык и региональные параметры.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-608">The specified culture.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-609">Получает сопутствующую сборку для указанной культуры.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-609">Gets the satellite assembly for the specified culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-610">Указанная вспомогательная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-610">The specified satellite assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-611">Вспомогательные сборки содержат локализованные ресурсы, в отличие от основного приложения сборки, содержащие не локализуемый исполняемый код и ресурсы для одного языка и региональных параметров, которые служат по умолчанию или нейтрального языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="cec47-611">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="cec47-612">Вызовите этот метод, чтобы использовать текущую версию сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-612">Call this method to use your current assembly version.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-613">Свойство <paramref name="culture" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-613">
              <paramref name="culture" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-614">Не удается найти сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-614">The assembly cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-615">Вспомогательная сборка с соответствующим именем файла была найдена, но параметр <see langword="CultureInfo" /> не соответствует указанному.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-615">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> did not match the one specified.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-616">Вспомогательная сборка не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-616">The satellite assembly is not a valid assembly.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">
          <span data-ttu-id="cec47-617">Заданные язык и региональные параметры.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-617">The specified culture.</span>
          </span>
        </param>
        <param name="version">
          <span data-ttu-id="cec47-618">Версия вспомогательной сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-618">The version of the satellite assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-619">Получает указанную версию вспомогательной сборки для указанной культуры.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-619">Gets the specified version of the satellite assembly for the specified culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-620">Указанная вспомогательная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-620">The specified satellite assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-621">Вспомогательные сборки содержат локализованные ресурсы, в отличие от основного приложения сборки, содержащие не локализуемый исполняемый код и ресурсы для одного языка и региональных параметров, которые служат по умолчанию или нейтрального языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="cec47-621">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="cec47-622">Вызовите <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> перегрузки, чтобы использовать текущую версию сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-622">Call the <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> overload to use your current assembly version.</span></span>  
  
 <span data-ttu-id="cec47-623">Если `version` является `null`, используется текущая версия сборки используется в том случае, если подписываются как ресурс, так и основные сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-623">If `version` is `null`, the current assembly version is used if both the resource and main assemblies are signed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-624">Свойство <paramref name="culture" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-624">
              <paramref name="culture" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-625">Вспомогательная сборка с соответствующим именем файла была найдена, но <see langword="CultureInfo" /> или версия не соответствуют указанным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-625">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> or the version did not match the one specified.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-626">Не удается найти сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-626">The assembly cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-627">Вспомогательная сборка не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-627">The satellite assembly is not a valid assembly.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-628">Получает объект <see cref="T:System.Type" />, представляющий указанный тип.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-628">Gets the <see cref="T:System.Type" /> object that represents the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="cec47-629">Полное имя типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-629">The full name of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-630">Возвращает объект <see cref="T:System.Type" /> с указанным именем в экземпляре сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-630">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-631">Объект, представляющий указанный класс, или <see langword="null" />, если класс не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-631">An object that represents the specified class, or <see langword="null" /> if the class is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-632">Этот метод осуществляет только текущего экземпляра сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-632">This method only searches the current assembly instance.</span></span> <span data-ttu-id="cec47-633">`name` Параметр включает в себя пространство имен, но не сборку.</span><span class="sxs-lookup"><span data-stu-id="cec47-633">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="cec47-634">Чтобы выполнить поиск других сборок для типа, используйте <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> перегрузку метода, которая может включать отображаемое имя сборки как часть имени типа.</span><span class="sxs-lookup"><span data-stu-id="cec47-634">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-635">Если тип был перемещен в другую сборку, он по-прежнему возвращается этим методом.</span><span class="sxs-lookup"><span data-stu-id="cec47-635">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="cec47-636">Сведения о перенаправлении типов см. в разделе [Переадресация типа в системе Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="cec47-636">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-637">В следующем примере определяется абстрактный `MeansOfTransportation` в класс `Transportation` пространства имен.</span><span class="sxs-lookup"><span data-stu-id="cec47-637">The following example defines an abstract `MeansOfTransportation` class in the `Transportation` namespace.</span></span> <span data-ttu-id="cec47-638">Он вызывает <xref:System.Reflection.Assembly.GetType%28System.String%29> метод для извлечения его <xref:System.Type> объекта, вызывает <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> метод для получения массива <xref:System.Reflection.PropertyInfo> объекты, представляющие свойства типа и затем отображает информацию на типа абстрактного свойства.</span><span class="sxs-lookup"><span data-stu-id="cec47-638">It calls the <xref:System.Reflection.Assembly.GetType%28System.String%29> method to retrieve its <xref:System.Type> object, calls the <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> method to get an array of <xref:System.Reflection.PropertyInfo> objects that represent the type's properties, and then displays information on the type's abstract properties.</span></span> <span data-ttu-id="cec47-639">Обратите внимание, что вызов <xref:System.Reflection.Assembly.GetType%28System.String%29> метод использует полное имя типа (то есть, его пространство имен вместе с именем типа).</span><span class="sxs-lookup"><span data-stu-id="cec47-639">Note that the call to the <xref:System.Reflection.Assembly.GetType%28System.String%29> method uses the type's fully qualified name (that is, its namespace along with its type name).</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-640">
            <paramref name="name" /> недопустим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-640">
              <paramref name="name" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-641">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-641">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-642">Для <paramref name="name" /> требуется зависимая сборка, которую не удается найти.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-642">
              <paramref name="name" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="cec47-643">Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.IO.IOException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="cec47-643">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="cec47-644">Для 
          <paramref name="name" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-644">
              <paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-645">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-645">-or-</span>
          </span>
          <span data-ttu-id="cec47-646">Текущая сборка была загружена в контекст только для отражения, а для <paramref name="name" /> требуется зависимая сборка, которая не была предварительно загружена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-646">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-647">Для <paramref name="name" /> требуется зависимая сборка, однако файл не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-647">
              <paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-648">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-648">-or-</span>
          </span>
          <span data-ttu-id="cec47-649">Для <paramref name="name" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-649">
              <paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="cec47-650">Полное имя типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-650">The full name of the type.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="cec47-651">Значение <see langword="true" /> для создания исключения, если тип не найден, в обратном случае — значение <see langword="false" />, в результате чего будет возвращено значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-651">
              <see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-652">Возвращает объект <see cref="T:System.Type" /> с заданным именем в экземпляре сборки и может вызывать исключение, если тип не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-652">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance and optionally throws an exception if the type is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-653">Объект, представляющий указанный класс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-653">An object that represents the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-654">Этот метод осуществляет только текущего экземпляра сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-654">This method only searches the current assembly instance.</span></span> <span data-ttu-id="cec47-655">`name` Параметр включает в себя пространство имен, но не сборку.</span><span class="sxs-lookup"><span data-stu-id="cec47-655">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="cec47-656">Чтобы выполнить поиск других сборок для типа, используйте <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> перегрузку метода, которая может включать отображаемое имя сборки как часть имени типа.</span><span class="sxs-lookup"><span data-stu-id="cec47-656">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-657">Если тип был перемещен в другую сборку, он по-прежнему возвращается этим методом.</span><span class="sxs-lookup"><span data-stu-id="cec47-657">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="cec47-658">Сведения о перенаправлении типов см. в разделе [Переадресация типа в системе Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="cec47-658">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="cec47-659">`throwOnError` Параметр влияет только на что произойдет, если тип не найден.</span><span class="sxs-lookup"><span data-stu-id="cec47-659">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="cec47-660">Он не влияет на другие исключения, которые могут быть вызваны.</span><span class="sxs-lookup"><span data-stu-id="cec47-660">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="cec47-661">В частности, если найден тип, но не может быть загружен <xref:System.TypeLoadException> может быть создано даже в том случае, если `throwOnError` является `false`.</span><span class="sxs-lookup"><span data-stu-id="cec47-661">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-662">
            <paramref name="name" /> недопустим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-662">
              <paramref name="name" /> is invalid.</span>
          </span>
          <span data-ttu-id="cec47-663">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-663">-or-</span>
          </span>
          <span data-ttu-id="cec47-664">Длина <paramref name="name" /> превышает 1024 символа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-664">The length of <paramref name="name" /> exceeds 1024 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-665">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-665">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="cec47-666">
            <paramref name="throwOnError" /> является <see langword="true" />, не удается найти тип.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-666">
              <paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-667">Для <paramref name="name" /> требуется зависимая сборка, которую не удается найти.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-667">
              <paramref name="name" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-668">Для <paramref name="name" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-668">
              <paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-669">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-669">-or-</span>
          </span>
          <span data-ttu-id="cec47-670">Текущая сборка была загружена в контекст только для отражения, а для <paramref name="name" /> требуется зависимая сборка, которая не была предварительно загружена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-670">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-671">Для <paramref name="name" /> требуется зависимая сборка, однако файл не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-671">
              <paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-672">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-672">-or-</span>
          </span>
          <span data-ttu-id="cec47-673">Для <paramref name="name" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-673">
              <paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="cec47-674">Полное имя типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-674">The full name of the type.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="cec47-675">Значение <see langword="true" /> для создания исключения, если тип не найден, в обратном случае — значение <see langword="false" />, в результате чего будет возвращено значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-675">
              <see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="cec47-676">Значение <see langword="true" />, чтобы игнорировать регистр имени типа, в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-676">
              <see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-677">Возвращает объект <see cref="T:System.Type" /> с заданным именем в экземпляре сборки, с возможностями игнорировать регистр и вызвать исключение, если тип не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-677">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance, with the options of ignoring the case, and of throwing an exception if the type is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-678">Объект, представляющий указанный класс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-678">An object that represents the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-679">Этот метод осуществляет только текущего экземпляра сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-679">This method only searches the current assembly instance.</span></span> <span data-ttu-id="cec47-680">`name` Параметр включает в себя пространство имен, но не сборку.</span><span class="sxs-lookup"><span data-stu-id="cec47-680">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="cec47-681">Чтобы выполнить поиск других сборок для типа, используйте <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> перегрузку метода, которая может включать отображаемое имя сборки как часть имени типа.</span><span class="sxs-lookup"><span data-stu-id="cec47-681">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-682">Если тип был перемещен в другую сборку, он по-прежнему возвращается этим методом.</span><span class="sxs-lookup"><span data-stu-id="cec47-682">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="cec47-683">Сведения о перенаправлении типов см. в разделе [Переадресация типа в системе Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="cec47-683">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="cec47-684">`throwOnError` Параметр влияет только на что произойдет, если тип не найден.</span><span class="sxs-lookup"><span data-stu-id="cec47-684">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="cec47-685">Он не влияет на другие исключения, которые могут быть вызваны.</span><span class="sxs-lookup"><span data-stu-id="cec47-685">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="cec47-686">В частности, если найден тип, но не может быть загружен <xref:System.TypeLoadException> может быть создано даже в том случае, если `throwOnError` является `false`.</span><span class="sxs-lookup"><span data-stu-id="cec47-686">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-687">
            <paramref name="name" /> недопустим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-687">
              <paramref name="name" /> is invalid.</span>
          </span>
          <span data-ttu-id="cec47-688">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-688">-or-</span>
          </span>
          <span data-ttu-id="cec47-689">Длина <paramref name="name" /> превышает 1024 символа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-689">The length of <paramref name="name" /> exceeds 1024 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-690">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-690">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="cec47-691">
            <paramref name="throwOnError" /> является <see langword="true" />, не удается найти тип.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-691">
              <paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-692">Для <paramref name="name" /> требуется зависимая сборка, которую не удается найти.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-692">
              <paramref name="name" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-693">Для <paramref name="name" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-693">
              <paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-694">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-694">-or-</span>
          </span>
          <span data-ttu-id="cec47-695">Текущая сборка была загружена в контекст только для отражения, а для <paramref name="name" /> требуется зависимая сборка, которая не была предварительно загружена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-695">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-696">Для <paramref name="name" /> требуется зависимая сборка, однако файл не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-696">
              <paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-697">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-697">-or-</span>
          </span>
          <span data-ttu-id="cec47-698">Для <paramref name="name" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-698">
              <paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-699">Получает типы, определенные в этой сборке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-699">Gets the types defined in this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-700">Массив, содержащий все типы, определенные в этой сборке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-700">An array that contains all the types that are defined in this assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-701">Возвращаемый массив содержит вложенные типы.</span><span class="sxs-lookup"><span data-stu-id="cec47-701">The returned array includes nested types.</span></span>  
  
 <span data-ttu-id="cec47-702">Если <xref:System.Reflection.Assembly.GetTypes%2A> метод вызывается для сборки и тип, в том, что сборка зависит от типа в сборке, которая не была загружена (например, если он является производным от типа в сборке второй), <xref:System.Reflection.ReflectionTypeLoadException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="cec47-702">If the <xref:System.Reflection.Assembly.GetTypes%2A> method is called on an assembly and a type in that assembly is dependent on a type in an assembly that has not been loaded (for example, if it derives from a type in the second assembly), a <xref:System.Reflection.ReflectionTypeLoadException> is thrown.</span></span> <span data-ttu-id="cec47-703">Например, это может произойти, если первая сборка была загружена с <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> или <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> методов, а вторая сборка не загружена.</span><span class="sxs-lookup"><span data-stu-id="cec47-703">For example, this can happen if the first assembly was loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> or <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods, and the second assembly was not loaded.</span></span> <span data-ttu-id="cec47-704">Это также может произойти с сборки, загруженные с помощью <xref:System.Reflection.Assembly.Load%2A> и <xref:System.Reflection.Assembly.LoadFile%2A> методов, если вторую сборку не удается найти, когда <xref:System.Reflection.Assembly.GetTypes%2A> вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-704">It can also happen with assemblies loaded using the <xref:System.Reflection.Assembly.Load%2A> and <xref:System.Reflection.Assembly.LoadFile%2A> methods if the second assembly cannot be located when the <xref:System.Reflection.Assembly.GetTypes%2A> method is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-705">Если тип был перемещен в другую сборку, он не включен в возвращаемый массив.</span><span class="sxs-lookup"><span data-stu-id="cec47-705">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="cec47-706">Сведения о перенаправлении типов см. в разделе [Переадресация типа в системе Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="cec47-706">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="cec47-707">Чтобы получить коллекцию <xref:System.Reflection.TypeInfo> объектов вместо массива <xref:System.Type> объекты, используют <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> свойство.</span><span class="sxs-lookup"><span data-stu-id="cec47-707">To retrieve a collection of <xref:System.Reflection.TypeInfo> objects instead of an array of <xref:System.Type> objects, use the <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-708">Следующий пример отображает параметры одного метода для типа в заданной сборке.</span><span class="sxs-lookup"><span data-stu-id="cec47-708">The following example displays parameters of one method on a type in the specified assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">
          <span data-ttu-id="cec47-709">Сборка содержит один или несколько типов, которые не удается загрузить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-709">The assembly contains one or more types that cannot be loaded.</span>
          </span>
          <span data-ttu-id="cec47-710">Массив, возвращаемый свойством <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> этого исключения, содержит объект <see cref="T:System.Type" /> для каждого типа, который был загружен, и объект <see langword="null" /> для каждого типа, который не удалось загрузить, тогда как свойство <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> содержит исключение для каждого типа, который не удалось загрузить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-710">The array returned by the <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> property of this exception contains a <see cref="T:System.Type" /> object for each type that was loaded and <see langword="null" /> for each type that could not be loaded, while the <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> property contains an exception for each type that could not be loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-711">Получает значение, указывающее, была ли сборка загружена из глобального кэша сборок.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-711">Gets a value indicating whether the assembly was loaded from the global assembly cache.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-712">Значение <see langword="true" />, если сборка была загружена из глобального кэша сборок, в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-712">
              <see langword="true" /> if the assembly was loaded from the global assembly cache; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-713">Получает контекст хост-сайта, с которым была загружена сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-713">Gets the host context with which the assembly was loaded.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-714">Значение <see cref="T:System.Int64" />, которое указывает контекст узла, с которым была загружена сборка, при его наличии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-714">An <see cref="T:System.Int64" /> value that indicates the host context with which the assembly was loaded, if any.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-715">Получает строку, представляющую версию общеязыковой среды выполнения (CLR), сохраненной в файле, содержащем манифест.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-715">Gets a string representing the version of the common language runtime (CLR) saved in the file containing the manifest.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-716">Имя папки версии среды CLR.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-716">The CLR version folder name.</span>
          </span>
          <span data-ttu-id="cec47-717">Указанный путь не является полным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-717">This is not a full path.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-718">Например значение для платформы .NET Framework версии 1.1 будет v1.1.4322.</span><span class="sxs-lookup"><span data-stu-id="cec47-718">For example, the value for the .NET Framework version 1.1 would be v1.1.4322.</span></span> <span data-ttu-id="cec47-719">Двоичные файлы для этой версии будет находиться в пути % windir%\Microsoft.NET\Framework\v1.1.4322.</span><span class="sxs-lookup"><span data-stu-id="cec47-719">The binary files for that version would be located in the path %windir%\Microsoft.NET\Framework\v1.1.4322.</span></span>  
  
 <span data-ttu-id="cec47-720">По умолчанию <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> задана версия среды CLR, используемый для построения сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-720">By default, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> is set to the version of the CLR used to build the assembly.</span></span> <span data-ttu-id="cec47-721">Тем не менее он может было присвоено другое значение во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="cec47-721">However, it might have been set to another value at compile time.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="cec47-722">Тип атрибута, который нужно проверить для данной сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-722">The type of the attribute to be checked for this assembly.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="cec47-723">Данный аргумент не учитывается для объектов этого типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-723">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-724">Указывает, применен ли конкретный атрибут к сборке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-724">Indicates whether or not a specified attribute has been applied to the assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-725">Значение <see langword="true" />, если атрибут был применен к сборке; в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-725">
              <see langword="true" /> if the attribute has been applied to the assembly; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="cec47-726">В следующем примере кода применяется <xref:System.Reflection.AssemblyTitleAttribute> атрибут сборки, и затем использует <xref:System.Reflection.Assembly.IsDefined%2A> для указания того, была ли применена.</span><span class="sxs-lookup"><span data-stu-id="cec47-726">The following code example applies the <xref:System.Reflection.AssemblyTitleAttribute> attribute to an assembly and then uses <xref:System.Reflection.Assembly.IsDefined%2A> to indicate whether it was applied.</span></span> <span data-ttu-id="cec47-727">Она также проверяет, который не был применен атрибут.</span><span class="sxs-lookup"><span data-stu-id="cec47-727">It also tests an attribute that was not applied.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-728">Свойство <paramref name="attributeType" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-728">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-729">
            <paramref name="attributeType" /> использует недопустимый тип.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-729">
              <paramref name="attributeType" /> uses an invalid type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-730">Получает значение, определяющее, была ли текущая сборка создана динамически в текущем процессе с помощью отражения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-730">Gets a value that indicates whether the current assembly was generated dynamically in the current process by using reflection emit.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-731">Значение <see langword="true" />, если текущая сборка была создана динамически в текущем процессе; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-731">
              <see langword="true" /> if the current assembly was generated dynamically in the current process; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-732">Динамические сборки, представляются производного класса <xref:System.Reflection.Emit.AssemblyBuilder>.</span><span class="sxs-lookup"><span data-stu-id="cec47-732">Dynamic assemblies are represented by the derived class <xref:System.Reflection.Emit.AssemblyBuilder>.</span></span>  
  
 <span data-ttu-id="cec47-733">При сохранении динамическую сборку на диск, сохраненную сборку не является динамическим.</span><span class="sxs-lookup"><span data-stu-id="cec47-733">When a dynamic assembly is saved to disk, the saved assembly is not dynamic.</span></span> <span data-ttu-id="cec47-734">Если сохраненный сборка загружается в другой домен приложения или процесса, <xref:System.Reflection.Assembly.IsDynamic%2A> возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="cec47-734">If the saved assembly is loaded into another application domain or process, the <xref:System.Reflection.Assembly.IsDynamic%2A> property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-735">Получает значение, указывающее, загружена ли текущая сборка с полным доверием.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-735">Gets a value that indicates whether the current assembly is loaded with full trust.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-736">Значение <see langword="true" />, если текущая сборка загружена с полным доверием; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-736">
              <see langword="true" /> if the current assembly is loaded with full trust; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-737">Загружает сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-737">Loads an assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="cec47-738">Массив байтов, который является образом в формате COFF, содержащим созданную сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-738">A byte array that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-739">Загружает сборку с образом в формате COFF, содержащим порожденную сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-739">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly.</span>
          </span>
          <span data-ttu-id="cec47-740">Сборка загружается в домен приложения вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-740">The assembly is loaded into the application domain of the caller.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-741">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-741">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-742">Уровень доверия сборки, которая загружена с помощью этого метода является таким же, как уровень доверия вызывающей сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-742">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="cec47-743">Чтобы загрузить сборку из массива байтов с уровнем доверия домена приложения, используйте <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="cec47-743">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="cec47-744">Дополнительные сведения об использовании доказательств с перегрузками <xref:System.Reflection.Assembly.Load%2A> метод, использующий байтовых массивов, см. в разделе <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="cec47-744">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="cec47-745">Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-745">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="cec47-746">Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла.</span><span class="sxs-lookup"><span data-stu-id="cec47-746">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="cec47-747">Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.</span><span class="sxs-lookup"><span data-stu-id="cec47-747">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="cec47-748">Обратите внимание, что эта перегрузка метода всегда создает новый <xref:System.Reflection.Assembly> объекта с собственным сопоставлением.</span><span class="sxs-lookup"><span data-stu-id="cec47-748">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-749">Свойство <paramref name="rawAssembly" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-749">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-750">
            <paramref name="rawAssembly" /> не является допустимым именем сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-750">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-751">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-751">-or-</span>
          </span>
          <span data-ttu-id="cec47-752">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-752">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">
          <span data-ttu-id="cec47-753">Объект, описывающий загружаемую сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-753">The object that describes the assembly to be loaded.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-754">Загружает сборку с заданным именем <see cref="T:System.Reflection.AssemblyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-754">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-755">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-755">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-756"><xref:System.IO.FileLoadException> возникает, если `assemblyRef` указывает полное имя сборки и первой сборки, которая соответствует простое имя имеет другой версии, языка и региональных параметров или маркер открытого ключа.</span><span class="sxs-lookup"><span data-stu-id="cec47-756"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="cec47-757">Загрузчик не производит поиск других сборок, которые соответствуют простым именем.</span><span class="sxs-lookup"><span data-stu-id="cec47-757">The loader does not continue probing for other assemblies that match the simple name.</span></span> <span data-ttu-id="cec47-758">Начиная с .NET Framework 4, так как выполнение кода в удаленных сборок отключен по умолчанию <xref:System.IO.FileLoadException> возникает также в том случае, если `assemblyRef` указывает удаленную сборку.</span><span class="sxs-lookup"><span data-stu-id="cec47-758">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="cec47-759">Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.</span><span class="sxs-lookup"><span data-stu-id="cec47-759">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>     
  
> [!NOTE]
>  <span data-ttu-id="cec47-760">Не используйте <xref:System.Reflection.AssemblyName> только с <xref:System.Reflection.AssemblyName.CodeBase%2A> набор свойств.</span><span class="sxs-lookup"><span data-stu-id="cec47-760">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="cec47-761"><xref:System.Reflection.AssemblyName.CodeBase%2A> Свойство не поддерживает какие-либо элементы удостоверения сборки (например, имя или версию), поэтому загрузка не происходит в соответствии с правилами load, удостоверения, как и следовало ожидать из <xref:System.Reflection.Assembly.Load%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-761">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="cec47-762">Вместо этого сборка загружается с помощью загрузить из правил.</span><span class="sxs-lookup"><span data-stu-id="cec47-762">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="cec47-763">Сведения о недостатках использования контекст загрузки с см. в разделе <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> перегрузку метода или [советы и рекомендации для загрузки сборок](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span><span class="sxs-lookup"><span data-stu-id="cec47-763">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="cec47-764">От свидетельства зависит, предоставляются ли сборке определенные разрешения.</span><span class="sxs-lookup"><span data-stu-id="cec47-764">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="cec47-765">Далее приведены правила для сборки и слияние свидетельством безопасности.</span><span class="sxs-lookup"><span data-stu-id="cec47-765">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="cec47-766">При использовании <xref:System.Reflection.Assembly.Load%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-766">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="cec47-767">При использовании <xref:System.Reflection.Assembly.Load%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются.</span><span class="sxs-lookup"><span data-stu-id="cec47-767">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="cec47-768">Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.Load%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-768">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="cec47-769">При использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр для загрузки общего объекта файла формате COFF образа, свидетельство наследуется от вызывающей сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-769">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="cec47-770">Это относится к .NET Framework версии 1.1 пакета обновления 1 (SP1) и последующих выпусков.</span><span class="sxs-lookup"><span data-stu-id="cec47-770">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="cec47-771">В .NET Framework версии 1.0 и в версии 1.1 без SP1, при использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр, чтобы загрузить образ COFF свидетельство объединяется.</span><span class="sxs-lookup"><span data-stu-id="cec47-771">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="cec47-772">`Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.</span><span class="sxs-lookup"><span data-stu-id="cec47-772">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="cec47-773">При использовании <xref:System.Reflection.Assembly.Load%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство.</span><span class="sxs-lookup"><span data-stu-id="cec47-773">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="cec47-774">Свидетельство вызывающей сборки и свидетельство образа в формате COFF учитывается.</span><span class="sxs-lookup"><span data-stu-id="cec47-774">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="cec47-775">Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-775">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="cec47-776">Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла.</span><span class="sxs-lookup"><span data-stu-id="cec47-776">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="cec47-777">Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.</span><span class="sxs-lookup"><span data-stu-id="cec47-777">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-778">Если оба <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> свойство и <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> имеет значение, первая попытка загрузить сборку использует отображаемое имя (включая версии, языка и региональных параметров и т. д., возвращенная <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> свойство).</span><span class="sxs-lookup"><span data-stu-id="cec47-778">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="cec47-779">Если файл не найден, <xref:System.Reflection.AssemblyName.CodeBase%2A> используется для поиска сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-779">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="cec47-780">Если сборка найдена с помощью <xref:System.Reflection.AssemblyName.CodeBase%2A>, противопоставляется отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-780">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="cec47-781">Если сопоставление завершается ошибкой, <xref:System.IO.FileLoadException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="cec47-781">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-782">В следующем примере создается <xref:System.Reflection.AssemblyName> и использует его для загрузки `sysglobal.dll` сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-782">The following example instantiates an <xref:System.Reflection.AssemblyName> object and uses it to load the `sysglobal.dll` assembly.</span></span> <span data-ttu-id="cec47-783">Затем выводится полное имя сборки, открытые типы.</span><span class="sxs-lookup"><span data-stu-id="cec47-783">The example then displays the full name of the assembly's public types.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-784">Свойство <paramref name="assemblyRef" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-784">
              <paramref name="assemblyRef" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-785">
            <paramref name="assemblyRef" /> не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-785">
              <paramref name="assemblyRef" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="cec47-786">Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.IO.IOException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="cec47-786">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="cec47-787">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-787">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-788">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-788">-or-</span>
          </span>
          <span data-ttu-id="cec47-789">
            <paramref name="assemblyRef" /> указывает на удаленную сборку, но возможность выполнения кода в удаленных сборках отключена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-789">
              <paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="cec47-790">См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-790">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-791">
            <paramref name="assemblyRef" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-791">
              <paramref name="assemblyRef" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-792">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-792">-or-</span>
          </span>
          <span data-ttu-id="cec47-793">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyRef" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-793">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-794">для доступа на чтение из файла или каталога, а также для доступа к сведениям, включенным в путь.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-794">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="cec47-795">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-795">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="cec47-796">для чтения URI, который не начинается с «file://».</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-796">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-797">на загрузку сборки со свидетельством.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-797">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="cec47-798">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-798">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">
          <span data-ttu-id="cec47-799">Обнаружение сборок в среде выполнения</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-799">How the Runtime Locates Assemblies</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">
          <span data-ttu-id="cec47-800">Длинная форма имени сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-800">The long form of the assembly name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-801">Загружает сборку, заданную длинной формой ее имени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-801">Loads an assembly given the long form of its name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-802">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-802">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-803">Длинная форма имени сборки состоит из его простое имя (например, «система» для сборки System.dll) вместе с его версия, язык и региональные параметры, токен открытого ключа и при необходимости архитектурой процессора.</span><span class="sxs-lookup"><span data-stu-id="cec47-803">The long form of an assembly name consists of its simple name (such as "System" for the System.dll assembly) along with its version, culture, public key token, and optionally its processor architecture.</span></span> <span data-ttu-id="cec47-804">Он соответствует сборки <xref:System.Reflection.Assembly.FullName%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="cec47-804">It corresponds to the assembly's <xref:System.Reflection.Assembly.FullName%2A> property.</span></span> <span data-ttu-id="cec47-805">Следующий пример иллюстрирует использование длинное имя для загрузки сборки System.dll для .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="cec47-805">The following example illustrates the use of a long name to load the System.dll assembly for the .NET Framework 4.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <span data-ttu-id="cec47-806"><xref:System.IO.FileLoadException> возникает, если `assemblyString` указывает полное имя сборки и первой сборки, которая соответствует простое имя имеет другой версии, языка и региональных параметров или маркер открытого ключа.</span><span class="sxs-lookup"><span data-stu-id="cec47-806"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="cec47-807">Загрузчик не производит поиск других сборок, которые соответствуют простым именем.</span><span class="sxs-lookup"><span data-stu-id="cec47-807">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="cec47-808">От свидетельства зависит, предоставляются ли сборке определенные разрешения.</span><span class="sxs-lookup"><span data-stu-id="cec47-808">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="cec47-809">Далее приведены правила для сборки и слияние свидетельством безопасности.</span><span class="sxs-lookup"><span data-stu-id="cec47-809">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="cec47-810">При использовании <xref:System.Reflection.Assembly.Load%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-810">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="cec47-811">При использовании <xref:System.Reflection.Assembly.Load%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются.</span><span class="sxs-lookup"><span data-stu-id="cec47-811">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="cec47-812">Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.Load%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-812">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="cec47-813">При использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр для загрузки общего объекта файла формате COFF образа, свидетельство наследуется от вызывающей сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-813">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="cec47-814">Это относится к .NET Framework версии 1.1 пакета обновления 1 (SP1) и последующих выпусков.</span><span class="sxs-lookup"><span data-stu-id="cec47-814">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="cec47-815">В .NET Framework версии 1.0 и в версии 1.1 без SP1, при использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр, чтобы загрузить образ COFF свидетельство объединяется.</span><span class="sxs-lookup"><span data-stu-id="cec47-815">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="cec47-816">`Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.</span><span class="sxs-lookup"><span data-stu-id="cec47-816">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="cec47-817">При использовании <xref:System.Reflection.Assembly.Load%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство.</span><span class="sxs-lookup"><span data-stu-id="cec47-817">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="cec47-818">Свидетельство вызывающей сборки и свидетельство образа в формате COFF учитывается.</span><span class="sxs-lookup"><span data-stu-id="cec47-818">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="cec47-819">Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-819">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="cec47-820">Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла.</span><span class="sxs-lookup"><span data-stu-id="cec47-820">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="cec47-821">Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.</span><span class="sxs-lookup"><span data-stu-id="cec47-821">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="cec47-822">В .NET Framework версии 2.0 архитектура процессора добавляется удостоверения сборки и может быть указан как часть строки имени сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-822">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="cec47-823">Например «ProcessorArchitecture = msil».</span><span class="sxs-lookup"><span data-stu-id="cec47-823">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="cec47-824">Тем не менее, чтобы указать имя сборки рекомендуется создать <xref:System.Reflection.AssemblyName> и передать его в соответствующую перегрузку <xref:System.Reflection.Assembly.Load%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-824">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="cec47-825">См. раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cec47-825">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-826">В следующем примере загружает сборку с заданным его полное имя и перечисляются все типы, содержащиеся в указанной сборке.</span><span class="sxs-lookup"><span data-stu-id="cec47-826">The following example loads an assembly given its fully qualified name, and lists all the types contained in the specified assembly.</span></span> <span data-ttu-id="cec47-827">Для этого примера кода для запуска необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-827">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="cec47-828">Сведения о том, как получить полное имя сборки, см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="cec47-828">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-829">Свойство <paramref name="assemblyString" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-829">
              <paramref name="assemblyString" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-830">
            <paramref name="assemblyString" /> представляет собой строку нулевой длины.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-830">
              <paramref name="assemblyString" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-831">
            <paramref name="assemblyString" /> не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-831">
              <paramref name="assemblyString" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-832">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-832">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-833">
            <paramref name="assemblyString" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-833">
              <paramref name="assemblyString" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-834">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-834">-or-</span>
          </span>
          <span data-ttu-id="cec47-835">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyString" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-835">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-836">на загрузку сборки со свидетельством.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-836">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="cec47-837">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-837">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">
          <span data-ttu-id="cec47-838">Обнаружение сборок в среде выполнения</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-838">How the Runtime Locates Assemblies</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="cec47-839">Массив байтов, который является образом в формате COFF, содержащим созданную сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-839">A byte array that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <param name="rawSymbolStore">
          <span data-ttu-id="cec47-840">Массив байтов, содержащий необработанные байты, которые представляют символы для сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-840">A byte array that contains the raw bytes representing the symbols for the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-841">Загружает сборку с образом в формате COFF, содержащим выпущенную сборку и (дополнительно) символы для сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-841">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols for the assembly.</span>
          </span>
          <span data-ttu-id="cec47-842">Сборка загружается в домен приложения вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-842">The assembly is loaded into the application domain of the caller.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-843">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-843">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-844">Уровень доверия сборки, которая загружена с помощью этого метода является таким же, как уровень доверия вызывающей сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-844">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="cec47-845">Чтобы загрузить сборку из массива байтов с уровнем доверия домена приложения, используйте <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="cec47-845">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="cec47-846">Дополнительные сведения об использовании доказательств с перегрузками <xref:System.Reflection.Assembly.Load%2A> метод, использующий байтовых массивов, см. в разделе <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="cec47-846">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="cec47-847">Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-847">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="cec47-848">Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла.</span><span class="sxs-lookup"><span data-stu-id="cec47-848">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="cec47-849">Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.</span><span class="sxs-lookup"><span data-stu-id="cec47-849">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="cec47-850">Обратите внимание, что эта перегрузка метода всегда создает новый <xref:System.Reflection.Assembly> объекта с собственным сопоставлением.</span><span class="sxs-lookup"><span data-stu-id="cec47-850">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-851">Свойство <paramref name="rawAssembly" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-851">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-852">
            <paramref name="rawAssembly" /> не является допустимым именем сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-852">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-853">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-853">-or-</span>
          </span>
          <span data-ttu-id="cec47-854">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-854">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">
          <span data-ttu-id="cec47-855">Объект, описывающий загружаемую сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-855">The object that describes the assembly to be loaded.</span>
          </span>
        </param>
        <param name="assemblySecurity">
          <span data-ttu-id="cec47-856">Свидетельство для загрузки сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-856">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-857">Загружает сборку с заданным именем <see cref="T:System.Reflection.AssemblyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-857">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span>
          </span>
          <span data-ttu-id="cec47-858">Сборка загружена в домен вызывающего объекта с использованием переданного свидетельства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-858">The assembly is loaded into the domain of the caller using the supplied evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-859">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-859">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-860"><xref:System.IO.FileLoadException> возникает, если `assemblyRef` указывает полное имя сборки и первой сборки, которая соответствует простое имя имеет другой версии, языка и региональных параметров или маркер открытого ключа.</span><span class="sxs-lookup"><span data-stu-id="cec47-860"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="cec47-861">Загрузчик не производит поиск других сборок, которые соответствуют простым именем.</span><span class="sxs-lookup"><span data-stu-id="cec47-861">The loader does not continue probing for other assemblies that match the simple name.</span></span>  <span data-ttu-id="cec47-862">Начиная с .NET Framework 4, так как выполнение кода в удаленных сборок отключен по умолчанию <xref:System.IO.FileLoadException> возникает также в том случае, если `assemblyRef` указывает удаленную сборку.</span><span class="sxs-lookup"><span data-stu-id="cec47-862">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="cec47-863">Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.</span><span class="sxs-lookup"><span data-stu-id="cec47-863">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>   
  
> [!NOTE]
>  <span data-ttu-id="cec47-864">Не используйте <xref:System.Reflection.AssemblyName> только с <xref:System.Reflection.AssemblyName.CodeBase%2A> набор свойств.</span><span class="sxs-lookup"><span data-stu-id="cec47-864">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="cec47-865"><xref:System.Reflection.AssemblyName.CodeBase%2A> Свойство не поддерживает какие-либо элементы удостоверения сборки (например, имя или версию), поэтому загрузка не происходит в соответствии с правилами load, удостоверения, как и следовало ожидать из <xref:System.Reflection.Assembly.Load%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-865">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="cec47-866">Вместо этого сборка загружается с помощью загрузить из правил.</span><span class="sxs-lookup"><span data-stu-id="cec47-866">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="cec47-867">Сведения о недостатках использования контекст загрузки с см. в разделе <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> перегрузку метода или [советы и рекомендации для загрузки сборок](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span><span class="sxs-lookup"><span data-stu-id="cec47-867">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="cec47-868">От свидетельства зависит, предоставляются ли сборке определенные разрешения.</span><span class="sxs-lookup"><span data-stu-id="cec47-868">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="cec47-869">Далее приведены правила для сборки и слияние свидетельством безопасности.</span><span class="sxs-lookup"><span data-stu-id="cec47-869">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="cec47-870">При использовании <xref:System.Reflection.Assembly.Load%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-870">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="cec47-871">При использовании <xref:System.Reflection.Assembly.Load%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются.</span><span class="sxs-lookup"><span data-stu-id="cec47-871">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="cec47-872">Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.Load%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-872">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="cec47-873">При использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр для загрузки общего объекта файла формате COFF образа, свидетельство наследуется от вызывающей сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-873">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="cec47-874">Это относится к .NET Framework версии 1.1 пакета обновления 1 (SP1) и последующих выпусков.</span><span class="sxs-lookup"><span data-stu-id="cec47-874">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="cec47-875">В .NET Framework версии 1.0 и в версии 1.1 без SP1, при использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр, чтобы загрузить образ COFF свидетельство объединяется.</span><span class="sxs-lookup"><span data-stu-id="cec47-875">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="cec47-876">`Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.</span><span class="sxs-lookup"><span data-stu-id="cec47-876">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="cec47-877">При использовании <xref:System.Reflection.Assembly.Load%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство.</span><span class="sxs-lookup"><span data-stu-id="cec47-877">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="cec47-878">Свидетельство вызывающей сборки и свидетельство образа в формате COFF учитывается.</span><span class="sxs-lookup"><span data-stu-id="cec47-878">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="cec47-879">Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-879">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="cec47-880">Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла.</span><span class="sxs-lookup"><span data-stu-id="cec47-880">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="cec47-881">Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.</span><span class="sxs-lookup"><span data-stu-id="cec47-881">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-882">Если оба <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> свойство и <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> имеет значение, первая попытка загрузить сборку использует отображаемое имя (включая версии, языка и региональных параметров и т. д., возвращенная <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> свойство).</span><span class="sxs-lookup"><span data-stu-id="cec47-882">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="cec47-883">Если файл не найден, <xref:System.Reflection.AssemblyName.CodeBase%2A> используется для поиска сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-883">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="cec47-884">Если сборка найдена с помощью <xref:System.Reflection.AssemblyName.CodeBase%2A>, противопоставляется отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-884">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="cec47-885">Если сопоставление завершается ошибкой, <xref:System.IO.FileLoadException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="cec47-885">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 <span data-ttu-id="cec47-886">При вызове метода <xref:System.Reflection.Assembly.Load%2A> более чем один раз для одной сборки, но с разными свидетельствами, среда CLR не вызывает метод <xref:System.IO.FileLoadException> из-за невозможности проверки на равенство и целостность различных спецификаций свидетельства определить.</span><span class="sxs-lookup"><span data-stu-id="cec47-886">If you call the <xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="cec47-887">Свидетельство сначала выполняется успешно, это свидетельство, который используется.</span><span class="sxs-lookup"><span data-stu-id="cec47-887">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-888">Свойство <paramref name="assemblyRef" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-888">
              <paramref name="assemblyRef" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-889">
            <paramref name="assemblyRef" /> не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-889">
              <paramref name="assemblyRef" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-890">
            <paramref name="assemblyRef" /> не является допустимым именем сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-890">
              <paramref name="assemblyRef" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-891">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-891">-or-</span>
          </span>
          <span data-ttu-id="cec47-892">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyRef" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-892">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-893">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-893">An assembly or module was loaded twice with two different evidences.</span>
          </span>
          <span data-ttu-id="cec47-894">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-894">-or-</span>
          </span>
          <span data-ttu-id="cec47-895">
            <paramref name="assemblyRef" /> указывает на удаленную сборку, но возможность выполнения кода в удаленных сборках отключена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-895">
              <paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="cec47-896">См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-896">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-897">для доступа на чтение из файла или каталога, а также для доступа к сведениям, включенным в путь.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-897">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="cec47-898">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-898">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="cec47-899">для чтения URI, который не начинается с «file://».</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-899">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-900">на загрузку сборки со свидетельством.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-900">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="cec47-901">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-901">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">
          <span data-ttu-id="cec47-902">Обнаружение сборок в среде выполнения</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-902">How the Runtime Locates Assemblies</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">
          <span data-ttu-id="cec47-903">Отображаемое имя сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-903">The display name of the assembly.</span>
          </span>
        </param>
        <param name="assemblySecurity">
          <span data-ttu-id="cec47-904">Свидетельство для загрузки сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-904">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-905">Загружает сборку с заданным отображаемым именем. Сборка загружается в домен вызывающего объекта с использованием переданного основания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-905">Loads an assembly given its display name, loading the assembly into the domain of the caller using the supplied evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-906">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-906">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-907"><xref:System.IO.FileLoadException> возникает, если `assemblyString` указывает полное имя сборки и первой сборки, которая соответствует простое имя имеет другой версии, языка и региональных параметров или маркер открытого ключа.</span><span class="sxs-lookup"><span data-stu-id="cec47-907"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="cec47-908">Загрузчик не производит поиск других сборок, которые соответствуют простым именем.</span><span class="sxs-lookup"><span data-stu-id="cec47-908">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="cec47-909">От свидетельства зависит, предоставляются ли сборке определенные разрешения.</span><span class="sxs-lookup"><span data-stu-id="cec47-909">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="cec47-910">Далее приведены правила для сборки и слияние свидетельством безопасности.</span><span class="sxs-lookup"><span data-stu-id="cec47-910">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="cec47-911">При использовании <xref:System.Reflection.Assembly.Load%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-911">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="cec47-912">При использовании <xref:System.Reflection.Assembly.Load%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются.</span><span class="sxs-lookup"><span data-stu-id="cec47-912">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="cec47-913">Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.Load%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-913">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="cec47-914">При использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр для загрузки общего объекта файла формате COFF образа, свидетельство наследуется от вызывающей сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-914">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="cec47-915">Это относится к .NET Framework версии 1.1 пакета обновления 1 (SP1) и последующих выпусков.</span><span class="sxs-lookup"><span data-stu-id="cec47-915">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="cec47-916">В .NET Framework версии 1.0 и в версии 1.1 без SP1, при использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр, чтобы загрузить образ COFF свидетельство объединяется.</span><span class="sxs-lookup"><span data-stu-id="cec47-916">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="cec47-917">`Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.</span><span class="sxs-lookup"><span data-stu-id="cec47-917">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="cec47-918">При использовании <xref:System.Reflection.Assembly.Load%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство.</span><span class="sxs-lookup"><span data-stu-id="cec47-918">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="cec47-919">Свидетельство вызывающей сборки и свидетельство образа в формате COFF учитывается.</span><span class="sxs-lookup"><span data-stu-id="cec47-919">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="cec47-920">Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-920">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="cec47-921">Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла.</span><span class="sxs-lookup"><span data-stu-id="cec47-921">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="cec47-922">Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.</span><span class="sxs-lookup"><span data-stu-id="cec47-922">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="cec47-923">Если этот метод вызывается несколько раз к той же сборке, но с разными свидетельствами, среда CLR не создает исключение <xref:System.IO.FileLoadException> , так как невозможно определить равенство и целостность различных спецификаций свидетельства.</span><span class="sxs-lookup"><span data-stu-id="cec47-923">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="cec47-924">Свидетельство сначала выполняется успешно, это свидетельство, который используется.</span><span class="sxs-lookup"><span data-stu-id="cec47-924">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="cec47-925">В .NET Framework версии 2.0 архитектура процессора добавляется удостоверения сборки и может быть указан как часть строки имени сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-925">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="cec47-926">Например «ProcessorArchitecture = msil».</span><span class="sxs-lookup"><span data-stu-id="cec47-926">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="cec47-927">Тем не менее, чтобы указать имя сборки рекомендуется создать <xref:System.Reflection.AssemblyName> и передать его в соответствующую перегрузку <xref:System.Reflection.Assembly.Load%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-927">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="cec47-928">См. раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cec47-928">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-929">Свойство <paramref name="assemblyString" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-929">
              <paramref name="assemblyString" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-930">
            <paramref name="assemblyString" /> не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-930">
              <paramref name="assemblyString" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-931">
            <paramref name="assemblyString" /> не является допустимым именем сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-931">
              <paramref name="assemblyString" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-932">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-932">-or-</span>
          </span>
          <span data-ttu-id="cec47-933">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyString" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-933">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-934">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-934">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-935">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-935">-or-</span>
          </span>
          <span data-ttu-id="cec47-936">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-936">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-937">на загрузку сборки со свидетельством.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-937">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="cec47-938">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-938">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">
          <span data-ttu-id="cec47-939">Обнаружение сборок в среде выполнения</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-939">How the Runtime Locates Assemblies</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="cec47-940">Массив байтов, который является образом в формате COFF, содержащим созданную сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-940">A byte array that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <param name="rawSymbolStore">
          <span data-ttu-id="cec47-941">Массив байтов, содержащий необработанные байты, которые представляют символы для сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-941">A byte array that contains the raw bytes representing the symbols for the assembly.</span>
          </span>
        </param>
        <param name="securityEvidence">
          <span data-ttu-id="cec47-942">Свидетельство для загрузки сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-942">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-943">Загружает сборку с образом в формате COFF, содержащим выпущенную сборку и (необязательно) символы и свидетельство для сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-943">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and evidence for the assembly.</span>
          </span>
          <span data-ttu-id="cec47-944">Сборка загружается в домен приложения вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-944">The assembly is loaded into the application domain of the caller.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-945">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-945">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-946">Сборка загружена в домен вызывающего объекта с использованием переданного свидетельства.</span><span class="sxs-lookup"><span data-stu-id="cec47-946">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span> <span data-ttu-id="cec47-947">Также загружаются необработанные байты, представляющие собой символы для сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-947">The raw bytes representing the symbols for the assembly are also loaded.</span></span>  
  
 <span data-ttu-id="cec47-948">От свидетельства зависит, предоставляются ли сборке определенные разрешения.</span><span class="sxs-lookup"><span data-stu-id="cec47-948">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="cec47-949">Далее приведены правила для сборки и слияние свидетельством безопасности.</span><span class="sxs-lookup"><span data-stu-id="cec47-949">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="cec47-950">При использовании <xref:System.Reflection.Assembly.Load%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-950">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="cec47-951">При использовании <xref:System.Reflection.Assembly.Load%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются.</span><span class="sxs-lookup"><span data-stu-id="cec47-951">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="cec47-952">Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.Load%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-952">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="cec47-953">При использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр, чтобы загрузить образ COFF свидетельство наследуется от вызывающей сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-953">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="cec47-954">Это относится к .NET Framework версии 1.1 пакета обновления 1 (SP1) и последующих выпусков.</span><span class="sxs-lookup"><span data-stu-id="cec47-954">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="cec47-955">В .NET Framework версии 1.0 и в версии 1.1 без SP1, при использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр, чтобы загрузить образ COFF свидетельство объединяется.</span><span class="sxs-lookup"><span data-stu-id="cec47-955">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="cec47-956">`Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.</span><span class="sxs-lookup"><span data-stu-id="cec47-956">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="cec47-957">При использовании <xref:System.Reflection.Assembly.Load%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство.</span><span class="sxs-lookup"><span data-stu-id="cec47-957">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="cec47-958">Свидетельство вызывающей сборки и свидетельство образа в формате COFF, игнорируются.</span><span class="sxs-lookup"><span data-stu-id="cec47-958">Evidence of the calling assembly and evidence of the COFF image are ignored.</span></span>  
  
 <span data-ttu-id="cec47-959">Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-959">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="cec47-960">Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла.</span><span class="sxs-lookup"><span data-stu-id="cec47-960">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="cec47-961">Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.</span><span class="sxs-lookup"><span data-stu-id="cec47-961">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="cec47-962">При вызове метода [\], байтов\<xref:System.Reflection.Assembly.Load%2A > более чем один раз для одной сборки, но с разными свидетельствами, среда CLR не вызывает метод <xref:System.IO.FileLoadException> поскольку не удается определить равенство и целостность различных спецификаций свидетельства.</span><span class="sxs-lookup"><span data-stu-id="cec47-962">If you call the [\], Byte\<xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="cec47-963">Свидетельство сначала выполняется успешно, это свидетельство, который используется.</span><span class="sxs-lookup"><span data-stu-id="cec47-963">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="cec47-964">Обратите внимание, что эта перегрузка метода всегда создает новый <xref:System.Reflection.Assembly> объекта с собственным сопоставлением.</span><span class="sxs-lookup"><span data-stu-id="cec47-964">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-965">Свойство <paramref name="rawAssembly" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-965">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-966">
            <paramref name="rawAssembly" /> не является допустимым именем сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-966">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-967">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-967">-or-</span>
          </span>
          <span data-ttu-id="cec47-968">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-968">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-969">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-969">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="cec47-970">
            <paramref name="securityEvidence" /> не является <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-970">
              <paramref name="securityEvidence" /> is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="cec47-971">По умолчанию устаревшая политика CAS не включена в [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; если она не включена, параметр <paramref name="securityEvidence" /> должен иметь значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-971">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-972">возможность передать свидетельство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-972">for the ability to supply evidence.</span>
          </span>
          <span data-ttu-id="cec47-973">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-973">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
          <span data-ttu-id="cec47-974">Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-974">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="cec47-975">Массив байтов, который является образом в формате COFF, содержащим созданную сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-975">A byte array that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <param name="rawSymbolStore">
          <span data-ttu-id="cec47-976">Массив байтов, содержащий необработанные байты, которые представляют символы для сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-976">A byte array that contains the raw bytes representing the symbols for the assembly.</span>
          </span>
        </param>
        <param name="securityContextSource">
          <span data-ttu-id="cec47-977">Источник контекста безопасности.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-977">The source of the security context.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-978">Загружает сборку с образом в формате COFF, содержащим выпущенную сборку и необязательно содержащим символы и задающим источник для контекста безопасности.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-978">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and specifying the source for the security context.</span>
          </span>
          <span data-ttu-id="cec47-979">Сборка загружается в домен приложения вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-979">The assembly is loaded into the application domain of the caller.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-980">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-980">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-981">Сборка загружается в домен приложения вызывающего объекта, используя указанный источник для контекста безопасности.</span><span class="sxs-lookup"><span data-stu-id="cec47-981">The assembly is loaded into the application domain of the caller using the specified source for the security context.</span></span> <span data-ttu-id="cec47-982">Если `rawSymbolStore` был указан, также загружаются необработанные байты, которые представляют символы для сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-982">If `rawSymbolStore` was specified, the raw bytes that represent the symbols for the assembly are also loaded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-983">Свойство <paramref name="rawAssembly" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-983">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-984">
            <paramref name="rawAssembly" /> не является допустимым именем сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-984">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-985">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-985">-or-</span>
          </span>
          <span data-ttu-id="cec47-986">Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-986">
              <paramref name="rawAssembly" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="cec47-987">Значение <paramref name="securityContextSource" /> не является одним из значений перечисления.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-987">The value of <paramref name="securityContextSource" /> is not one of the enumeration values.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-988">Загружает содержимое файла сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-988">Loads the contents of an assembly file.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="cec47-989">Полный путь к загружаемому файлу.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-989">The fully qualified path of the file to load.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-990">Загружает содержимое файла сборки, находящегося по указанному пути.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-990">Loads the contents of an assembly file on the specified path.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-991">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-991">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-992">Используйте <xref:System.Reflection.Assembly.LoadFile%2A> метод для загрузки и анализа сборок, которые имеют одинаковое удостоверение, но расположены в разных путей.</span><span class="sxs-lookup"><span data-stu-id="cec47-992">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="cec47-993"><xref:System.Reflection.Assembly.LoadFile%2A> не загружает файлы в контекст загрузки с, а не разрешать зависимости, используя в качестве пути загрузки, <xref:System.Reflection.Assembly.LoadFrom%2A> делает метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-993"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the load-from  context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="cec47-994"><xref:System.Reflection.Assembly.LoadFile%2A> полезно в этом сценарии ограниченной поскольку <xref:System.Reflection.Assembly.LoadFrom%2A> не может использоваться для загрузки сборок, имеющих одинаковые идентификаторы, но разные пути; он будет загружаться только первые такой сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-994"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="cec47-995">Начиная с .NET Framework 4, если `path` указывает на сборку в удаленных расположениях, загрузка сборки отключено по умолчанию и `LoadFile` вызывает метод <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-995">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="cec47-996">Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.</span><span class="sxs-lookup"><span data-stu-id="cec47-996">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-997">Аргумент <paramref name="path" /> не является абсолютным путем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-997">The <paramref name="path" /> argument is not an absolute path.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-998">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-998">The <paramref name="path" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-999">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-999">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-1000">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1000">-or-</span>
          </span>
          <span data-ttu-id="cec47-1001">Возможность выполнения кода в удаленных сборках отключена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1001">The ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="cec47-1002">См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1002">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-1003">Параметр <paramref name="path" /> представляет собой пустую строку ("") или не существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1003">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1004">
            <paramref name="path" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1004">
              <paramref name="path" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-1005">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1005">-or-</span>
          </span>
          <span data-ttu-id="cec47-1006">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="path" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1006">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-1007">для доступа на чтение из файла или каталога, а также для доступа к сведениям, включенным в путь.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1007">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="cec47-1008">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1008">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-1009">на загрузку сборки со свидетельством.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1009">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="cec47-1010">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1010">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="cec47-1011">Полный путь к файлу сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1011">The fully qualified path of the assembly file.</span>
          </span>
        </param>
        <param name="securityEvidence">
          <span data-ttu-id="cec47-1012">Свидетельство для загрузки сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1012">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1013">Загружает сборку с заданным путем в домен вызывающего объекта с использованием переданного свидетельства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1013">Loads an assembly given its path, loading the assembly into the domain of the caller using the supplied evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1014">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1014">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1015">Используйте <xref:System.Reflection.Assembly.LoadFile%2A> метод для загрузки и анализа сборок, которые имеют одинаковое удостоверение, но расположены в разных путей.</span><span class="sxs-lookup"><span data-stu-id="cec47-1015">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="cec47-1016"><xref:System.Reflection.Assembly.LoadFile%2A> не загружает файлы в <xref:System.Reflection.Assembly.LoadFrom%2A> контекста и не разрешает зависимости, используя в качестве пути загрузки <xref:System.Reflection.Assembly.LoadFrom%2A> делает метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-1016"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the <xref:System.Reflection.Assembly.LoadFrom%2A> context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="cec47-1017"><xref:System.Reflection.Assembly.LoadFile%2A> полезно в этом сценарии ограниченной поскольку <xref:System.Reflection.Assembly.LoadFrom%2A> не может использоваться для загрузки сборок, имеющих одинаковые идентификаторы, но разные пути; он будет загружаться только первые такой сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1017"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="cec47-1018">Начиная с .NET Framework 4, если `path` указывает на сборку в удаленных расположениях, загрузка сборки отключено по умолчанию и `LoadFile` вызывает метод <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1018">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="cec47-1019">Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.</span><span class="sxs-lookup"><span data-stu-id="cec47-1019">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-1020">Аргумент <paramref name="path" /> не является абсолютным путем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1020">The <paramref name="path" /> argument is not an absolute path.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1021">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1021">The <paramref name="path" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-1022">Параметр <paramref name="path" /> представляет собой пустую строку ("") или не существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1022">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-1023">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1023">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-1024">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1024">-or-</span>
          </span>
          <span data-ttu-id="cec47-1025">Возможность выполнения кода в удаленных сборках отключена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1025">The ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="cec47-1026">См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1026">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1027">
            <paramref name="path" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1027">
              <paramref name="path" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-1028">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1028">-or-</span>
          </span>
          <span data-ttu-id="cec47-1029">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="path" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1029">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="cec47-1030">
            <paramref name="securityEvidence" /> не является <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1030">
              <paramref name="securityEvidence" /> is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="cec47-1031">По умолчанию устаревшая политика CAS не включена в [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; если она не включена, параметр <paramref name="securityEvidence" /> должен иметь значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1031">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-1032">для доступа на чтение из файла или каталога, а также для доступа к сведениям, включенным в путь.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1032">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="cec47-1033">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1033">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-1034">на загрузку сборки со свидетельством.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1034">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="cec47-1035">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1035">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1036">Загружает сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1036">Loads an assembly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

<span data-ttu-id="cec47-1037">Начиная с .NET Framework 4, по умолчанию, а вызов отключена возможность выполнения кода в сборки, загруженные из удаленных расположений `LoadFrom` вызывает метод <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1037">Starting with .NET Framework 4, the ability to execute code in assemblies loaded from remote locations is disabled by default, and the call to the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="cec47-1038">Для загрузки сборки и выполнения его кода, необходимо:</span><span class="sxs-lookup"><span data-stu-id="cec47-1038">To load the assembly and execute its code, you must either:</span></span>

- <span data-ttu-id="cec47-1039">Явным образом создайте "песочницу" для сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1039">Explicitly create a sandbox for the assembly.</span></span> <span data-ttu-id="cec47-1040">(См. в разделе [как: запуска частично доверенного кода в изолированной среде](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)</span><span class="sxs-lookup"><span data-stu-id="cec47-1040">(See [How to: Run Partially Trusted Code in a Sandbox](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)</span></span>

- <span data-ttu-id="cec47-1041">Выполнять код сборки в режиме полного доверия, присвоив `enabled` атрибут [ `<loadFromRemoteSources>` элемента конфигурации](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) для `true`.</span><span class="sxs-lookup"><span data-stu-id="cec47-1041">Run the assembly's code in full trust by setting the `enabled` attribute of the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) to `true`.</span></span> <span data-ttu-id="cec47-1042">Дополнительные сведения см. в разделе [ `<loadFromRemoteSources>` элемента конфигурации](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) статьи.</span><span class="sxs-lookup"><span data-stu-id="cec47-1042">For more information, see the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) article.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="cec47-1043">Имя файла, содержащего манифест сборки, либо путь к нему.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1043">The name or path of the file that contains the manifest of the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1044">Загружает сборку с заданным именем или путем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1044">Loads an assembly given its file name or path.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1045">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1045">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1046">`assemblyFile` Параметр должен ссылаться на URI без escape-символы.</span><span class="sxs-lookup"><span data-stu-id="cec47-1046">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="cec47-1047">Этот метод предоставляет escape-символы для всех недопустимых символов в URI.</span><span class="sxs-lookup"><span data-stu-id="cec47-1047">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-1048">Протокол передачи файлов (FTP) не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="cec47-1048">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="cec47-1049">Если указан URI для `assemblyFile` является адресом FTP, сборка не загружается.</span><span class="sxs-lookup"><span data-stu-id="cec47-1049">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="cec47-1050">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="cec47-1050">No exception is thrown.</span></span>  
  
 <span data-ttu-id="cec47-1051">`assemblyFile` может быть абсолютным или относительным для текущего каталога, и сборка загружается в домен вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="cec47-1051">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="cec47-1052">Сборки могут загружаться в одном из трех контекстов или могут быть загружены без контекста:</span><span class="sxs-lookup"><span data-stu-id="cec47-1052">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="cec47-1053">Контекст загрузки содержит сборки, обнаруженные в результате поиска: в глобальном кэше СБОРОК, в хранилище сборки хранить Если размещается среда выполнения или в <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A> домена приложения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1053">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="cec47-1054">В большинстве перегруженных версий метода <xref:System.Reflection.Assembly.Load%2A> сборки загружаются именно в этот контекст.</span><span class="sxs-lookup"><span data-stu-id="cec47-1054">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="cec47-1055">Контекст загрузки с содержит сборки, для которых пользователь указал путь не включен в каталоги поиска проверки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1055">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="cec47-1056">К примерам методов, которые выполняют загрузку по указанному пути, относятся методы <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.AppDomain.ExecuteAssembly%2A>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1056"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span> 

    <span data-ttu-id="cec47-1057">Начиная с .NET Framework 4, если URI `assemblyFile` указывает удаленного расположения, загрузка сборки отключен по умолчанию и `LoadFrom` вызывает метод <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1057">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="cec47-1058">Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.</span><span class="sxs-lookup"><span data-stu-id="cec47-1058">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="cec47-1059">Контекст только для отражения содержит сборки, загруженные с <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> и <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> методов; код в этих контекстах, не может быть выполнена.</span><span class="sxs-lookup"><span data-stu-id="cec47-1059">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="cec47-1060">Если пользователь создается или найти сборку, это не в любом контексте.</span><span class="sxs-lookup"><span data-stu-id="cec47-1060">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="cec47-1061">Это относится к сборкам, загруженным с помощью перегрузки <xref:System.Reflection.Assembly.Load%2A> метод, который указывается массив байтов, содержащий сборку, а чтобы временные динамические сборки, созданные с помощью отражения для создания и не сохраняются на диске.</span><span class="sxs-lookup"><span data-stu-id="cec47-1061">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="cec47-1062">Контекст загрузки с сборку необходимо загрузить из пути, не включается в область поиска и еще позволяет зависимости по этому пути, чтобы найти и загрузить, так как сведения о пути хранятся в контексте.</span><span class="sxs-lookup"><span data-stu-id="cec47-1062">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="cec47-1063"><xref:System.Reflection.Assembly.LoadFrom%2A> Метод имеет следующие недостатки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1063">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="cec47-1064">Вместо этого рекомендуется использовать <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1064">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="cec47-1065">Если сборка с тем же идентификатором уже загружена, метод <xref:System.Reflection.Assembly.LoadFrom%2A> возвращает загруженную сборку даже в том случае, если был задан другой путь.</span><span class="sxs-lookup"><span data-stu-id="cec47-1065">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="cec47-1066">Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>и последующие попытки загрузить ту же сборку по отображаемому имени сборки в контекст загрузки, попытка загрузки завершится неудачей.</span><span class="sxs-lookup"><span data-stu-id="cec47-1066">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="cec47-1067">Это может произойти при десериализации сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1067">This can occur when an assembly is de-serialized.</span></span>  
  
-   <span data-ttu-id="cec47-1068">Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>, и путь поиска сборок включает сборку с тем же идентификатором, но другое расположение, <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, или другие непредсказуемые последствия.</span><span class="sxs-lookup"><span data-stu-id="cec47-1068">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="cec47-1069">Метод <xref:System.Reflection.Assembly.LoadFrom%2A> требует наличия флагов <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> или <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> либо наличия объекта <xref:System.Net.WebPermission> для заданного пути.</span><span class="sxs-lookup"><span data-stu-id="cec47-1069"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="cec47-1070">Если образ в машинном коде для `assemblyFile`, он не используется.</span><span class="sxs-lookup"><span data-stu-id="cec47-1070">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="cec47-1071">Сборка не может быть загружена как нейтральная к домену.</span><span class="sxs-lookup"><span data-stu-id="cec47-1071">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="cec47-1072">В .NET Framework версий 1.0 и 1.1 политика не применяется.</span><span class="sxs-lookup"><span data-stu-id="cec47-1072">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-1073">В следующем примере загружается сборка, заданная его имя файла или путь.</span><span class="sxs-lookup"><span data-stu-id="cec47-1073">The following example loads an assembly given its file name or path.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1074">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1074">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-1075">Файл <paramref name="assemblyFile" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1075">
              <paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-1076">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1076">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-1077">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1077">-or-</span>
          </span>
          <span data-ttu-id="cec47-1078">Возможность выполнения кода в удаленных сборках отключена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1078">The ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="cec47-1079">См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1079">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1080">
            <paramref name="assemblyFile" /> не является допустимой сборкой. Например, это 32-разрядная сборка в 64-разрядном процессе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1080">
              <paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span>
          </span>
          <span data-ttu-id="cec47-1081">Дополнительные сведения см. в разделе исключений.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1081">See the exception topic for more information.</span>
          </span>
          <span data-ttu-id="cec47-1082">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1082">-or-</span>
          </span>
          <span data-ttu-id="cec47-1083">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1083">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="cec47-1084">База кода, которая не начинается с "file://", была указана без требуемого <see cref="T:System.Net.WebPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1084">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-1085">Параметр <paramref name="assemblyFile" /> представляет собой пустую строку ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1085">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="cec47-1086">Длина имени сборки превышает максимальную длину, определенную в системе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1086">The assembly name exceeds the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-1087">для чтения URI, который начинается с «file://».</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1087">for reading a URI that begins with "file://".</span>
          </span>
          <span data-ttu-id="cec47-1088">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1088">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="cec47-1089">для чтения URI, который не начинается с «file://».</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1089">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="cec47-1090">Имя файла, содержащего манифест сборки, либо путь к нему.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1090">The name or path of the file that contains the manifest of the assembly.</span>
          </span>
        </param>
        <param name="securityEvidence">
          <span data-ttu-id="cec47-1091">Свидетельство для загрузки сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1091">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1092">Загружает сборку, заданную именем файла или путем к этому файлу и предоставленным свидетельством безопасности.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1092">Loads an assembly given its file name or path and supplying security evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1093">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1093">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1094">`assemblyFile` Параметр должен ссылаться на URI без escape-символы.</span><span class="sxs-lookup"><span data-stu-id="cec47-1094">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="cec47-1095">Этот метод предоставляет escape-символы для всех недопустимых символов в URI.</span><span class="sxs-lookup"><span data-stu-id="cec47-1095">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-1096">Протокол передачи файлов (FTP) не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="cec47-1096">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="cec47-1097">Если указан URI для `assemblyFile` является адресом FTP, сборка не загружается.</span><span class="sxs-lookup"><span data-stu-id="cec47-1097">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="cec47-1098">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="cec47-1098">No exception is thrown.</span></span>  
  
 <span data-ttu-id="cec47-1099">`assemblyFile` может быть абсолютным или относительным для текущего каталога, и сборка загружается в домен вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="cec47-1099">`assemblyFile` may be absolute or  relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="cec47-1100">Сборки могут загружаться в одном из трех контекстов или могут быть загружены без контекста:</span><span class="sxs-lookup"><span data-stu-id="cec47-1100">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="cec47-1101">Контекст загрузки содержит сборки, обнаруженные в результате поиска: в глобальном кэше СБОРОК, в хранилище сборки хранить Если размещается среда выполнения или в <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A> домена приложения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1101">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="cec47-1102">В большинстве перегруженных версий метода <xref:System.Reflection.Assembly.Load%2A> сборки загружаются именно в этот контекст.</span><span class="sxs-lookup"><span data-stu-id="cec47-1102">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="cec47-1103">Контекст загрузки с содержит сборки, для которых пользователь указал путь не включен в каталоги поиска проверки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1103">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="cec47-1104">К примерам методов, которые выполняют загрузку по указанному пути, относятся методы <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.AppDomain.ExecuteAssembly%2A>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1104"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>

    <span data-ttu-id="cec47-1105">Начиная с .NET Framework 4, если URI `assemblyFile` указывает удаленного расположения, загрузка сборки отключен по умолчанию и `LoadFrom` вызывает метод <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1105">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="cec47-1106">Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.</span><span class="sxs-lookup"><span data-stu-id="cec47-1106">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="cec47-1107">Контекст только для отражения содержит сборки, загруженные с <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> и <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> методов; код в этих контекстах, не может быть выполнена.</span><span class="sxs-lookup"><span data-stu-id="cec47-1107">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="cec47-1108">Если пользователь создается или найти сборку, это не в любом контексте.</span><span class="sxs-lookup"><span data-stu-id="cec47-1108">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="cec47-1109">Это относится к сборкам, загруженным с помощью перегрузки <xref:System.Reflection.Assembly.Load%2A> метод, который указывается массив байтов, содержащий сборку, а чтобы временные динамические сборки, созданные с помощью отражения для создания и не сохраняются на диске.</span><span class="sxs-lookup"><span data-stu-id="cec47-1109">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="cec47-1110">Контекст загрузки с сборку необходимо загрузить из пути, не включается в область поиска и еще позволяет зависимости по этому пути, чтобы найти и загрузить, так как сведения о пути хранятся в контексте.</span><span class="sxs-lookup"><span data-stu-id="cec47-1110">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="cec47-1111"><xref:System.Reflection.Assembly.LoadFrom%2A> Метод имеет следующие недостатки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1111">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="cec47-1112">Вместо этого рекомендуется использовать <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1112">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="cec47-1113">Если сборка с тем же идентификатором уже загружена, метод <xref:System.Reflection.Assembly.LoadFrom%2A> возвращает загруженную сборку даже в том случае, если был задан другой путь.</span><span class="sxs-lookup"><span data-stu-id="cec47-1113">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="cec47-1114">Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>и последующие попытки загрузить ту же сборку по отображаемому имени сборки в контекст загрузки, попытка загрузки завершится неудачей.</span><span class="sxs-lookup"><span data-stu-id="cec47-1114">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="cec47-1115">Это может произойти при десериализации сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1115">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="cec47-1116">Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>, и путь поиска сборок включает сборку с тем же идентификатором, но другое расположение, <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, или другие непредсказуемые последствия.</span><span class="sxs-lookup"><span data-stu-id="cec47-1116">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="cec47-1117">Метод <xref:System.Reflection.Assembly.LoadFrom%2A> требует наличия флагов <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> или <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> либо наличия объекта <xref:System.Net.WebPermission> для заданного пути.</span><span class="sxs-lookup"><span data-stu-id="cec47-1117"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="cec47-1118">Если образ в машинном коде для `assemblyFile`, он не используется.</span><span class="sxs-lookup"><span data-stu-id="cec47-1118">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="cec47-1119">Сборка не может быть загружена как нейтральная к домену.</span><span class="sxs-lookup"><span data-stu-id="cec47-1119">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="cec47-1120">В .NET Framework версий 1.0 и 1.1 политика не применяется.</span><span class="sxs-lookup"><span data-stu-id="cec47-1120">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="cec47-1121">От свидетельства зависит, предоставляются ли сборке определенные разрешения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1121">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="cec47-1122">Далее приведены правила для сборки и слияние свидетельством безопасности.</span><span class="sxs-lookup"><span data-stu-id="cec47-1122">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="cec47-1123">При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-1123">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="cec47-1124">При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются.</span><span class="sxs-lookup"><span data-stu-id="cec47-1124">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="cec47-1125">Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.LoadFrom%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-1125">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="cec47-1126">Если этот метод вызывается несколько раз к той же сборке, но с разными свидетельствами, среда CLR не создает исключение <xref:System.IO.FileLoadException> , так как невозможно определить равенство и целостность различных спецификаций свидетельства.</span><span class="sxs-lookup"><span data-stu-id="cec47-1126">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="cec47-1127">Свидетельство сначала выполняется успешно, это свидетельство, который используется.</span><span class="sxs-lookup"><span data-stu-id="cec47-1127">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="cec47-1128">При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод с `Byte[]` параметр для загрузки общего объекта файла формате COFF образа, свидетельство объединяется.</span><span class="sxs-lookup"><span data-stu-id="cec47-1128">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="cec47-1129">`Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.</span><span class="sxs-lookup"><span data-stu-id="cec47-1129">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="cec47-1130">При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство.</span><span class="sxs-lookup"><span data-stu-id="cec47-1130">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="cec47-1131">Свидетельство вызывающей сборки и свидетельство образа в формате COFF учитывается.</span><span class="sxs-lookup"><span data-stu-id="cec47-1131">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1132">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1132">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-1133">Файл <paramref name="assemblyFile" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1133">
              <paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-1134">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1134">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-1135">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1135">-or-</span>
          </span>
          <span data-ttu-id="cec47-1136">Параметр <paramref name="securityEvidence" /> не является неоднозначным и определяется как недопустимый.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1136">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span>
          </span>
          <span data-ttu-id="cec47-1137">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1137">-or-</span>
          </span>
          <span data-ttu-id="cec47-1138">Возможность выполнения кода в удаленных сборках отключена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1138">The ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="cec47-1139">См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1139">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1140">
            <paramref name="assemblyFile" /> не является допустимой сборкой. Например, это 32-разрядная сборка в 64-разрядном процессе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1140">
              <paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span>
          </span>
          <span data-ttu-id="cec47-1141">Дополнительные сведения см. в разделе исключений.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1141">See the exception topic for more information.</span>
          </span>
          <span data-ttu-id="cec47-1142">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1142">-or-</span>
          </span>
          <span data-ttu-id="cec47-1143">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1143">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="cec47-1144">База кода, которая не начинается с "file://", была указана без требуемого <see cref="T:System.Net.WebPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1144">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-1145">Параметр <paramref name="assemblyFile" /> представляет собой пустую строку ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1145">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="cec47-1146">Длина имени сборки превышает максимальную длину, определенную в системе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1146">The assembly name exceeds the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-1147">на загрузку сборки со свидетельством.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1147">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="cec47-1148">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1148">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-1149">для чтения URI, который начинается с «file://».</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1149">for reading a URI that begins with "file://".</span>
          </span>
          <span data-ttu-id="cec47-1150">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1150">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="cec47-1151">для чтения URI, который не начинается с «file://».</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1151">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="cec47-1152">Имя файла, содержащего манифест сборки, либо путь к нему.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1152">The name or path of the file that contains the manifest of the assembly.</span>
          </span>
        </param>
        <param name="hashValue">
          <span data-ttu-id="cec47-1153">Значение вычисленного хэш-кода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1153">The value of the computed hash code.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="cec47-1154">Алгоритм хэширования, используемый для хэширования файлов и генерации строгого имени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1154">The hash algorithm used for hashing files and for generating the strong name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1155">Загружает сборку с заданным именем файла сборки или путем, хэш-значением и хэш-алгоритмом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1155">Loads an assembly given its file name or path, hash value, and hash algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1156">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1156">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1157">`assemblyFile` Параметр должен ссылаться на URI без escape-символы.</span><span class="sxs-lookup"><span data-stu-id="cec47-1157">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="cec47-1158">Этот метод предоставляет escape-символы для всех недопустимых символов в URI.</span><span class="sxs-lookup"><span data-stu-id="cec47-1158">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-1159">Протокол передачи файлов (FTP) не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="cec47-1159">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="cec47-1160">Если указан URI для `assemblyFile` является адресом FTP, сборка не загружается.</span><span class="sxs-lookup"><span data-stu-id="cec47-1160">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="cec47-1161">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="cec47-1161">No exception is thrown.</span></span>  
  
 <span data-ttu-id="cec47-1162">`assemblyFile` может быть абсолютным или относительным для текущего каталога, и сборка загружается в домен вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="cec47-1162">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="cec47-1163">Сборки могут загружаться в одном из трех контекстов или могут быть загружены без контекста:</span><span class="sxs-lookup"><span data-stu-id="cec47-1163">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="cec47-1164">Контекст загрузки содержит сборки, обнаруженные в результате поиска: в глобальном кэше сборок, в хранилище сборки хранить Если размещается среда выполнения или в <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A> домена приложения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1164">The load context contains assemblies found by probing: in the global assembly cache, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="cec47-1165">В большинстве перегруженных версий метода <xref:System.Reflection.Assembly.Load%2A> сборки загружаются именно в этот контекст.</span><span class="sxs-lookup"><span data-stu-id="cec47-1165">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="cec47-1166">Контекст загрузки с содержит сборки, для которых пользователь указал путь, который не входит в область поиска.</span><span class="sxs-lookup"><span data-stu-id="cec47-1166">The load-from context contains assemblies for which the user provided a path that is not included in probing.</span></span> <span data-ttu-id="cec47-1167">К примерам методов, которые выполняют загрузку по указанному пути, относятся методы <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.AppDomain.ExecuteAssembly%2A>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1167"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="cec47-1168">Начиная с .NET Framework 4, если URI `assemblyFile` указывает удаленного расположения, загрузка сборки отключен по умолчанию и `LoadFrom` вызывает метод <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1168">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="cec47-1169">Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.</span><span class="sxs-lookup"><span data-stu-id="cec47-1169">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="cec47-1170">Контекст только для отражения содержит сборки, загруженные с <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> и <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> методов; код в этих контекстах, не может быть выполнена.</span><span class="sxs-lookup"><span data-stu-id="cec47-1170">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="cec47-1171">Если пользователь создается или найти сборку, это не в любом контексте.</span><span class="sxs-lookup"><span data-stu-id="cec47-1171">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="cec47-1172">Это относится к сборкам, загруженным с помощью перегрузки <xref:System.Reflection.Assembly.Load%2A> метод, который указывается массив байтов, содержащий сборку, а чтобы временные динамические сборки, созданные с помощью отражения для создания и не сохраняются на диске.</span><span class="sxs-lookup"><span data-stu-id="cec47-1172">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="cec47-1173">Контекст загрузки с позволяет сборки для загрузки, путь которой не включается в область поиска, а еще разрешает зависимости по этому пути, чтобы найти и загрузить, так как сведения о пути хранятся в контексте.</span><span class="sxs-lookup"><span data-stu-id="cec47-1173">The load-from context allows an assembly to be loaded from a path that is not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="cec47-1174"><xref:System.Reflection.Assembly.LoadFrom%2A> Метод имеет следующие недостатки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1174">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="cec47-1175">Вместо этого рекомендуется использовать <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1175">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="cec47-1176">Если сборка с тем же идентификатором уже загружена, метод <xref:System.Reflection.Assembly.LoadFrom%2A> возвращает загруженную сборку даже в том случае, если был задан другой путь.</span><span class="sxs-lookup"><span data-stu-id="cec47-1176">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="cec47-1177">Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>и последующие попытки загрузить ту же сборку по отображаемому имени сборки в контекст загрузки, попытка загрузки завершится неудачей.</span><span class="sxs-lookup"><span data-stu-id="cec47-1177">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="cec47-1178">Это может произойти при десериализации сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1178">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="cec47-1179">Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>, и путь поиска сборок включает сборку с тем же идентификатором, но другое расположение, <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, или другие непредсказуемые последствия.</span><span class="sxs-lookup"><span data-stu-id="cec47-1179">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="cec47-1180">Метод <xref:System.Reflection.Assembly.LoadFrom%2A> требует наличия флагов <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> или <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> либо наличия объекта <xref:System.Net.WebPermission> для заданного пути.</span><span class="sxs-lookup"><span data-stu-id="cec47-1180"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="cec47-1181">Если образ в машинном коде для `assemblyFile`, он не используется.</span><span class="sxs-lookup"><span data-stu-id="cec47-1181">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="cec47-1182">Сборка не может быть загружена как доменно-нейтральная.</span><span class="sxs-lookup"><span data-stu-id="cec47-1182">The assembly cannot be loaded as domain-neutral.</span></span>  
  
 <span data-ttu-id="cec47-1183">Сборка загружается со свидетельством, предоставленным загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-1183">The assembly is loaded with the evidence that the loader supplies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1184">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1184">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-1185">Параметр <paramref name="assemblyFile" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1185">
              <paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-1186">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1186">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-1187">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1187">-or-</span>
          </span>
          <span data-ttu-id="cec47-1188">Возможность выполнения кода в удаленных сборках отключена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1188">The ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="cec47-1189">См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1189">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1190">
            <paramref name="assemblyFile" /> не является допустимой сборкой. Например, это 32-разрядная сборка в 64-разрядном процессе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1190">
              <paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span>
          </span>
          <span data-ttu-id="cec47-1191">Дополнительные сведения см. в разделе исключений.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1191">See the exception topic for more information.</span>
          </span>
          <span data-ttu-id="cec47-1192">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1192">-or-</span>
          </span>
          <span data-ttu-id="cec47-1193">Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1193">
              <paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="cec47-1194">База кода, которая не начинается с "file://", была указана без требуемого разрешения <see cref="T:System.Net.WebPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1194">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-1195">Параметр <paramref name="assemblyFile" /> представляет собой пустую строку ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1195">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="cec47-1196">Длина имени сборки превышает максимальную длину, определенную в системе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1196">The assembly name exceeds the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-1197">на загрузку сборки со свидетельством.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1197">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="cec47-1198">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1198">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-1199">для чтения URI, который начинается с «file://».</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1199">for reading a URI that begins with "file://".</span>
          </span>
          <span data-ttu-id="cec47-1200">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1200">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="cec47-1201">для чтения URI, который не начинается с «file://».</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1201">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="cec47-1202">Имя файла, содержащего манифест сборки, либо путь к нему.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1202">The name or path of the file that contains the manifest of the assembly.</span>
          </span>
        </param>
        <param name="securityEvidence">
          <span data-ttu-id="cec47-1203">Свидетельство для загрузки сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1203">Evidence for loading the assembly.</span>
          </span>
        </param>
        <param name="hashValue">
          <span data-ttu-id="cec47-1204">Значение вычисленного хэш-кода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1204">The value of the computed hash code.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="cec47-1205">Алгоритм хэширования, используемый для хэширования файлов и генерации строгого имени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1205">The hash algorithm used for hashing files and for generating the strong name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1206">Загружает сборку с заданным именем файла сборки или путем, свидетельством безопасности, хэш-значением и хэш-алгоритмом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1206">Loads an assembly given its file name or path, security evidence, hash value, and hash algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1207">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1207">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1208">`assemblyFile` Параметр должен ссылаться на URI без escape-символы.</span><span class="sxs-lookup"><span data-stu-id="cec47-1208">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="cec47-1209">Этот метод предоставляет escape-символы для всех недопустимых символов в URI.</span><span class="sxs-lookup"><span data-stu-id="cec47-1209">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-1210">Протокол передачи файлов (FTP) не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="cec47-1210">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="cec47-1211">Если указан URI для `assemblyFile` является адресом FTP, сборка не загружается.</span><span class="sxs-lookup"><span data-stu-id="cec47-1211">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="cec47-1212">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="cec47-1212">No exception is thrown.</span></span>  
  
 <span data-ttu-id="cec47-1213">`assemblyFile` может быть абсолютным или относительным для текущего каталога, и сборка загружается в домен вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="cec47-1213">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="cec47-1214">Сборки могут загружаться в одном из трех контекстов или могут быть загружены без контекста:</span><span class="sxs-lookup"><span data-stu-id="cec47-1214">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="cec47-1215">Контекст загрузки содержит сборки, обнаруженные в результате поиска: в глобальном кэше СБОРОК, в хранилище сборки хранить Если размещается среда выполнения или в <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A> домена приложения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1215">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="cec47-1216">В большинстве перегруженных версий метода <xref:System.Reflection.Assembly.Load%2A> сборки загружаются именно в этот контекст.</span><span class="sxs-lookup"><span data-stu-id="cec47-1216">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="cec47-1217">Контекст загрузки с содержит сборки, для которых пользователь указал путь не включен в каталоги поиска проверки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1217">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="cec47-1218">К примерам методов, которые выполняют загрузку по указанному пути, относятся методы <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.AppDomain.ExecuteAssembly%2A>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1218"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="cec47-1219">Начиная с .NET Framework 4, если URI `assemblyFile` указывает удаленного расположения, загрузка сборки отключен по умолчанию и `LoadFrom` вызывает метод <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1219">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="cec47-1220">Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.</span><span class="sxs-lookup"><span data-stu-id="cec47-1220">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="cec47-1221">Контекст только для отражения содержит сборки, загруженные с <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> и <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> методов; код в этих контекстах, не может быть выполнена.</span><span class="sxs-lookup"><span data-stu-id="cec47-1221">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="cec47-1222">Если пользователь создается или найти сборку, это не в любом контексте.</span><span class="sxs-lookup"><span data-stu-id="cec47-1222">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="cec47-1223">Это относится к сборкам, загруженным с помощью перегрузки <xref:System.Reflection.Assembly.Load%2A> метод, который указывается массив байтов, содержащий сборку, а чтобы временные динамические сборки, созданные с помощью отражения для создания и не сохраняются на диске.</span><span class="sxs-lookup"><span data-stu-id="cec47-1223">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="cec47-1224">Контекст загрузки с сборку необходимо загрузить из пути, не включается в область поиска и еще позволяет зависимости по этому пути, чтобы найти и загрузить, так как сведения о пути хранятся в контексте.</span><span class="sxs-lookup"><span data-stu-id="cec47-1224">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="cec47-1225"><xref:System.Reflection.Assembly.LoadFrom%2A> Метод имеет следующие недостатки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1225">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="cec47-1226">Вместо этого рекомендуется использовать <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1226">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="cec47-1227">Если сборка с тем же идентификатором уже загружена, метод <xref:System.Reflection.Assembly.LoadFrom%2A> возвращает загруженную сборку даже в том случае, если был задан другой путь.</span><span class="sxs-lookup"><span data-stu-id="cec47-1227">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="cec47-1228">Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>и последующие попытки загрузить ту же сборку по отображаемому имени сборки в контекст загрузки, попытка загрузки завершится неудачей.</span><span class="sxs-lookup"><span data-stu-id="cec47-1228">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="cec47-1229">Это может произойти при десериализации сборки.</span><span class="sxs-lookup"><span data-stu-id="cec47-1229">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="cec47-1230">Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>, и путь поиска сборок включает сборку с тем же идентификатором, но другое расположение, <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, или другие непредсказуемые последствия.</span><span class="sxs-lookup"><span data-stu-id="cec47-1230">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="cec47-1231">Метод <xref:System.Reflection.Assembly.LoadFrom%2A> требует наличия флагов <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> или <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> либо наличия объекта <xref:System.Net.WebPermission> для заданного пути.</span><span class="sxs-lookup"><span data-stu-id="cec47-1231"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="cec47-1232">Если образ в машинном коде для `assemblyFile`, он не используется.</span><span class="sxs-lookup"><span data-stu-id="cec47-1232">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="cec47-1233">Сборка не может быть загружена как нейтральная к домену.</span><span class="sxs-lookup"><span data-stu-id="cec47-1233">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="cec47-1234">В .NET Framework версий 1.0 и 1.1 политика не применяется.</span><span class="sxs-lookup"><span data-stu-id="cec47-1234">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="cec47-1235">От свидетельства зависит, предоставляются ли сборке определенные разрешения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1235">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="cec47-1236">Далее приведены правила для сборки и слияние свидетельством безопасности.</span><span class="sxs-lookup"><span data-stu-id="cec47-1236">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="cec47-1237">При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-1237">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="cec47-1238">При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются.</span><span class="sxs-lookup"><span data-stu-id="cec47-1238">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="cec47-1239">Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.LoadFrom%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="cec47-1239">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="cec47-1240">Если этот метод вызывается несколько раз к той же сборке, но с разными свидетельствами, среда CLR не создает исключение <xref:System.IO.FileLoadException> , так как невозможно определить равенство и целостность различных спецификаций свидетельства.</span><span class="sxs-lookup"><span data-stu-id="cec47-1240">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="cec47-1241">Свидетельство сначала выполняется успешно, это свидетельство, который используется.</span><span class="sxs-lookup"><span data-stu-id="cec47-1241">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="cec47-1242">При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод с `Byte[]` параметр для загрузки общего объекта файла формате COFF образа, свидетельство объединяется.</span><span class="sxs-lookup"><span data-stu-id="cec47-1242">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="cec47-1243">`Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.</span><span class="sxs-lookup"><span data-stu-id="cec47-1243">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="cec47-1244">При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство.</span><span class="sxs-lookup"><span data-stu-id="cec47-1244">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="cec47-1245">Свидетельство вызывающей сборки и свидетельство образа в формате COFF учитывается.</span><span class="sxs-lookup"><span data-stu-id="cec47-1245">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1246">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1246">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-1247">Файл <paramref name="assemblyFile" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1247">
              <paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-1248">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1248">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="cec47-1249">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1249">-or-</span>
          </span>
          <span data-ttu-id="cec47-1250">Параметр <paramref name="securityEvidence" /> не является неоднозначным и определяется как недопустимый.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1250">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span>
          </span>
          <span data-ttu-id="cec47-1251">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1251">-or-</span>
          </span>
          <span data-ttu-id="cec47-1252">Возможность выполнения кода в удаленных сборках отключена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1252">The ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="cec47-1253">См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1253">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1254">
            <paramref name="assemblyFile" /> не является допустимой сборкой. Например, это 32-разрядная сборка в 64-разрядном процессе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1254">
              <paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span>
          </span>
          <span data-ttu-id="cec47-1255">Дополнительные сведения см. в разделе исключений.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1255">See the exception topic for more information.</span>
          </span>
          <span data-ttu-id="cec47-1256">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1256">-or-</span>
          </span>
          <span data-ttu-id="cec47-1257">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1257">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="cec47-1258">База кода, которая не начинается с "file://", была указана без требуемого <see cref="T:System.Net.WebPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1258">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-1259">Параметр <paramref name="assemblyFile" /> представляет собой пустую строку ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1259">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="cec47-1260">Длина имени сборки превышает максимальную длину, определенную в системе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1260">The assembly name exceeds the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-1261">на загрузку сборки со свидетельством.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1261">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="cec47-1262">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1262">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-1263">для чтения URI, который начинается с «file://».</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1263">for reading a URI that begins with "file://".</span>
          </span>
          <span data-ttu-id="cec47-1264">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1264">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="cec47-1265">для чтения URI, который не начинается с «file://».</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1265">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1266">Загружает внутренний модуль этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1266">Loads the module internal to this assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">
          <span data-ttu-id="cec47-1267">Имя модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1267">The name of the module.</span>
          </span>
          <span data-ttu-id="cec47-1268">Эта строка должна соответствовать имени файла в манифесте этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1268">This string must correspond to a file name in this assembly's manifest.</span>
          </span>
        </param>
        <param name="rawModule">
          <span data-ttu-id="cec47-1269">Массив байтов, который является COFF-образом, содержащим передаваемый модуль или ресурс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1269">A byte array that is a COFF-based image containing an emitted module, or a resource.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1270">Загружает модуль, внутренний для этой сборки, с образом в формате COFF, содержащим включенный модуль или файл ресурсов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1270">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1271">Загруженный модуль.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1271">The loaded module.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1272">Параметр <paramref name="moduleName" /> или <paramref name="rawModule" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1272">
              <paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-1273">
            <paramref name="moduleName" /> не соответствует записи файла в манифесте этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1273">
              <paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1274">
            <paramref name="rawModule" /> не является допустимым модулем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1274">
              <paramref name="rawModule" /> is not a valid module.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-1275">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1275">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-1276">Чтобы получить свидетельство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1276">to provide evidence.</span>
          </span>
          <span data-ttu-id="cec47-1277">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1277">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">
          <span data-ttu-id="cec47-1278">Имя модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1278">The name of the module.</span>
          </span>
          <span data-ttu-id="cec47-1279">Эта строка должна соответствовать имени файла в манифесте этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1279">This string must correspond to a file name in this assembly's manifest.</span>
          </span>
        </param>
        <param name="rawModule">
          <span data-ttu-id="cec47-1280">Массив байтов, который является COFF-образом, содержащим передаваемый модуль или ресурс.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1280">A byte array that is a COFF-based image containing an emitted module, or a resource.</span>
          </span>
        </param>
        <param name="rawSymbolStore">
          <span data-ttu-id="cec47-1281">Массив байтов, содержащий необработанные байты, представляющие собой символы для модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1281">A byte array containing the raw bytes representing the symbols for the module.</span>
          </span>
          <span data-ttu-id="cec47-1282">Для файла ресурсов должно быть задано значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1282">Must be <see langword="null" /> if this is a resource file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1283">Загружает модуль, внутренний для этой сборки, с образом в формате COFF, содержащим включенный модуль или файл ресурсов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1283">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span>
          </span>
          <span data-ttu-id="cec47-1284">Также загружаются необработанные байты, представляющие собой символы для модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1284">The raw bytes representing the symbols for the module are also loaded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1285">Загруженный модуль.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1285">The loaded module.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1286">Параметр <paramref name="moduleName" /> или <paramref name="rawModule" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1286">
              <paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-1287">
            <paramref name="moduleName" /> не соответствует записи файла в манифесте этой сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1287">
              <paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1288">
            <paramref name="rawModule" /> не является допустимым модулем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1288">
              <paramref name="rawModule" /> is not a valid module.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-1289">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1289">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-1290">Чтобы получить свидетельство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1290">to provide evidence.</span>
          </span>
          <span data-ttu-id="cec47-1291">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1291">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1292">Загружает сборку из каталога приложения или из глобального кэша сборок с использованием частичного имени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1292">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="cec47-1293">Перегрузки <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> метод устарели и были сохранены для обеспечения обратной совместимости.</span><span class="sxs-lookup"><span data-stu-id="cec47-1293">The overloads of the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method are obsolete and have been retained for backward compatibility.</span></span> <span data-ttu-id="cec47-1294">Альтернативой устаревшим функциям служит метод <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1294">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">
          <span data-ttu-id="cec47-1295">Отображаемое имя сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1295">The display name of the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1296">Загружает сборку из каталога приложения или из глобального кэша сборок с использованием частичного имени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1296">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1297">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1297">The loaded assembly.</span>
          </span>
          <span data-ttu-id="cec47-1298">Если значение <paramref name="partialName" /> не найдено, этот метод возвращает значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1298">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="cec47-1299"><xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> Метод устарел и был сохранен для обратной совместимости.</span><span class="sxs-lookup"><span data-stu-id="cec47-1299">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="cec47-1300">Альтернативой устаревшим функциям служит метод <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1300">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="cec47-1301">Приложения, загружающие сборки с помощью этого метода будет зависеть от обновления этих сборок.</span><span class="sxs-lookup"><span data-stu-id="cec47-1301">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="cec47-1302">Таким образом не используйте этот метод; Измените приложение для использования <xref:System.Reflection.Assembly.Load%28System.String%29> перегрузку метода или <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="cec47-1302">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%28System.String%29> method overload or the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 <span data-ttu-id="cec47-1303">Этот метод сначала вызывает <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1303">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="cec47-1304">Если сборка не найдена, этот метод возвращает сборки из глобального кэша сборок с аналогичным простым именем и номером последней версии.</span><span class="sxs-lookup"><span data-stu-id="cec47-1304">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1305">Параметр <paramref name="partialName" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1305">The <paramref name="partialName" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1306">
            <paramref name="assemblyFile" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1306">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-1307">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1307">-or-</span>
          </span>
          <span data-ttu-id="cec47-1308">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="partialName" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1308">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">
          <span data-ttu-id="cec47-1309">Отображаемое имя сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1309">The display name of the assembly.</span>
          </span>
        </param>
        <param name="securityEvidence">
          <span data-ttu-id="cec47-1310">Свидетельство для загрузки сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1310">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1311">Загружает сборку из каталога приложения или из глобального кэша сборок с использованием частичного имени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1311">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span>
          </span>
          <span data-ttu-id="cec47-1312">Сборка загружена в домен вызывающего объекта с использованием переданного свидетельства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1312">The assembly is loaded into the domain of the caller using the supplied evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1313">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1313">The loaded assembly.</span>
          </span>
          <span data-ttu-id="cec47-1314">Если значение <paramref name="partialName" /> не найдено, этот метод возвращает значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1314">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="cec47-1315"><xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> Метод устарел и был сохранен для обратной совместимости.</span><span class="sxs-lookup"><span data-stu-id="cec47-1315">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="cec47-1316">Альтернативой устаревшим функциям служит метод <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1316">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="cec47-1317">Свидетельство — это набор сведений, используемых для принятия решений политики безопасности, например, сведений о разрешениях, которые могут быть предоставлены коду.</span><span class="sxs-lookup"><span data-stu-id="cec47-1317">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 <span data-ttu-id="cec47-1318">Приложения, загружающие сборки с помощью этого метода будет зависеть от обновления этих сборок.</span><span class="sxs-lookup"><span data-stu-id="cec47-1318">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="cec47-1319">Таким образом не используйте этот метод; Измените приложение для использования <xref:System.Reflection.Assembly.Load%2A> метод или <xref:System.Reflection.Assembly.LoadFrom%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-1319">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%2A> method or the <xref:System.Reflection.Assembly.LoadFrom%2A> method.</span></span>  
  
 <span data-ttu-id="cec47-1320">Этот метод сначала вызывает <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1320">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="cec47-1321">Если сборка не найдена, этот метод возвращает сборки из глобального кэша сборок с аналогичным простым именем и номером последней версии.</span><span class="sxs-lookup"><span data-stu-id="cec47-1321">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-1322">Сборка или модуль был загружен дважды с двумя разными наборами свидетельств.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1322">An assembly or module was loaded twice with two different sets of evidence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1323">Параметр <paramref name="partialName" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1323">The <paramref name="partialName" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1324">
            <paramref name="assemblyFile" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1324">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-1325">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1325">-or-</span>
          </span>
          <span data-ttu-id="cec47-1326">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="partialName" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1326">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="cec47-1327">для вызова неуправляемого кода и на загрузку сборки со свидетельством.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1327">for calling unmanaged code and to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="cec47-1328">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1328">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1329">Получает полный путь либо UNC для расположения загруженного файла, содержащего манифест.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1329">Gets the full path or UNC location of the loaded file that contains the manifest.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-1330">Местоположение загруженного файла, содержащего манифест.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1330">The location of the loaded file that contains the manifest.</span>
          </span>
          <span data-ttu-id="cec47-1331">Если для загруженного файла был создан снимок состояния, местонахождение является местонахождением файла после теневого копирования.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1331">If the loaded file was shadow-copied, the location is that of the file after being shadow-copied.</span>
          </span>
          <span data-ttu-id="cec47-1332">Если сборка загружается из массива байтов, например, при использовании метода перегрузки <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" />, возвращаемое значение является пустой строкой ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1332">If the assembly is loaded from a byte array, such as when using the <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> method overload, the value returned is an empty string ("").</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1333">Чтобы получить расположение, прежде чем файл был теневого копирования, используйте <xref:System.Reflection.Assembly.CodeBase%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="cec47-1333">To get the location before the file has been shadow-copied, use the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cec47-1334">Следующий пример отображает расположение загруженного файла, содержащего манифест.</span><span class="sxs-lookup"><span data-stu-id="cec47-1334">The following example displays the location of the loaded file that contains the manifest.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="cec47-1335">Текущая сборка является динамической сборкой, представленной объектом <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1335">The current assembly is a dynamic assembly, represented by an <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> object.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-1336">для доступа к пути.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1336">for access to the path.</span>
          </span>
          <span data-ttu-id="cec47-1337">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1337">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">
          <span data-ttu-id="cec47-1338">Теневое копирование сборок</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1338">Shadow Copying Assemblies</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1339">Возвращает модуль, содержащий манифест текущей сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1339">Gets the module that contains the manifest for the current assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-1340">Модуль, содержащий манифест текущей сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1340">The module that contains the manifest for the assembly.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1341">Возникает, если загрузчик классов общеязыковой среды выполнения не может обработать ссылку на внутренний модуль сборки, используя обычные средства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1341">Occurs when the common language runtime class loader cannot resolve a reference to an internal module of an assembly through normal means.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1342">Это событие позволяет обратного вызова, чтобы найти и загрузить сам модуль и вернуть его.</span><span class="sxs-lookup"><span data-stu-id="cec47-1342">This event gives the callback a chance to find and load the module itself and return it.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="cec47-1343">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1343">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="cec47-1344">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1344">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1345">Получает коллекцию, содержащую модули в этой сборке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1345">Gets a collection that contains the modules in this assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-1346">Коллекция, содержащая модули в этой сборке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1346">A collection that contains the modules in this assembly.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="cec47-1347">Сборка, сравниваемая со значением <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1347">The assembly to compare to <paramref name="right" />.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="cec47-1348">Сборка, сравниваемая со значением <paramref name="left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1348">The assembly to compare to <paramref name="left" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1349">Определение равенства двух объектов <see cref="T:System.Reflection.Assembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1349">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1350">
            <see langword="true" />, если значения параметров <paramref name="left" /> и <paramref name="right" /> равны; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1350">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="cec47-1351">Сборка, сравниваемая со значением <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1351">The assembly to compare to <paramref name="right" />.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="cec47-1352">Сборка, сравниваемая со значением <paramref name="left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1352">The assembly to compare to <paramref name="left" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1353">Определяет неравенство двух объектов <see cref="T:System.Reflection.Assembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1353">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1354">
            <see langword="true" />, если значения <paramref name="left" /> и <paramref name="right" /> не равны; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1354">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1355">Получает набор разрешений текущей сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1355">Gets the grant set of the current assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-1356">Набор разрешений текущей сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1356">The grant set of the current assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1357"><xref:System.Security.PermissionSet> объекты могут содержать конфиденциальные сведения, например пути.</span><span class="sxs-lookup"><span data-stu-id="cec47-1357"><xref:System.Security.PermissionSet> objects can contain sensitive information such as paths.</span></span> <span data-ttu-id="cec47-1358">Таким образом для доступа к этим объектам требуется полное доверие.</span><span class="sxs-lookup"><span data-stu-id="cec47-1358">Therefore, full trust is required to access these objects.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="cec47-1359">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1359">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="cec47-1360">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1360">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1361">Возвращает значение <see cref="T:System.Boolean" />, которое указывает, была ли эта сборка загружена в контекст, предназначенный только для отражения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1361">Gets a <see cref="T:System.Boolean" /> value indicating whether this assembly was loaded into the reflection-only context.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-1362">Значение <see langword="true" />, если сборка была загружена в контекст, предназначенный только для отражения вместо контекста выполнения; в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1362">
              <see langword="true" /> if the assembly was loaded into the reflection-only context, rather than the execution context; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1363">Если сборка была загружена в контекст только для отражения, с помощью <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> метода, нельзя выполнять код в сборке.</span><span class="sxs-lookup"><span data-stu-id="cec47-1363">If an assembly has been loaded into the reflection-only context, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, you cannot execute code in the assembly.</span></span> <span data-ttu-id="cec47-1364">Для выполнения кода, сборка должна быть загружена в контекст выполнения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1364">To execute code, the assembly must be loaded into the execution context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1365">Загружает сборку в контекст, предназначенный только для отражения, где она может быть проанализирована, но не может быть выполнена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1365">Loads an assembly into the reflection-only context, where it can be examined but not executed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="cec47-1366">Массив байтов, который является образом в формате COFF, содержащим созданную сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1366">A byte array that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1367">Загружает сборку из образа в формате COFF, содержащего порожденную сборку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1367">Loads the assembly from a common object file format (COFF)-based image containing an emitted assembly.</span>
          </span>
          <span data-ttu-id="cec47-1368">Сборка загружается в контекст, предназначенный только для отражения, который относится к домену приложения вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1368">The assembly is loaded into the reflection-only context of the caller's application domain.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1369">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1369">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1370">Нельзя выполнять код из сборки, загруженной в контекст только для отражения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1370">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="cec47-1371">Для выполнения кода, сборка должна быть загружена в контекст выполнения, с помощью <xref:System.Reflection.Assembly.Load%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-1371">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="cec47-1372">Контекст только для отражения ничем не отличается от других контекстах.</span><span class="sxs-lookup"><span data-stu-id="cec47-1372">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="cec47-1373">Сборки, загруженные в контекст, могут быть выгружены путем выгрузки домена приложения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1373">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1374">Свойство <paramref name="rawAssembly" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1374">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1375">
            <paramref name="rawAssembly" /> не является допустимым именем сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1375">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-1376">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1376">-or-</span>
          </span>
          <span data-ttu-id="cec47-1377">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1377">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-1378">Не удается загрузить <paramref name="rawAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1378">
              <paramref name="rawAssembly" /> cannot be loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">
          <span data-ttu-id="cec47-1379">Отображаемое имя сборки, возвращаемое свойством <see cref="P:System.Reflection.AssemblyName.FullName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1379">The display name of the assembly, as returned by the <see cref="P:System.Reflection.AssemblyName.FullName" /> property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1380">Загружает сборку с заданным отображаемым именем в контекст, предназначенный только для отражения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1380">Loads an assembly into the reflection-only context, given its display name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1381">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1381">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1382">Зависимости не загружаются автоматически в контекст только для отражения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1382">Dependencies are not automatically loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="cec47-1383">Нельзя выполнять код из сборки, загруженной в контекст только для отражения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1383">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="cec47-1384">Для выполнения кода, сборка должна быть загружена в контекст выполнения, с помощью <xref:System.Reflection.Assembly.Load%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-1384">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="cec47-1385">От свидетельства зависит, предоставляются ли сборке определенные разрешения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1385">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="cec47-1386">Далее приведены правила для сборки и слияние свидетельством безопасности.</span><span class="sxs-lookup"><span data-stu-id="cec47-1386">The rules for assembly and security evidence merging are as follows:</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cec47-1387">Отражение на исполняемые файлы, скомпилированные в C++ может вызывать <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="cec47-1387">Reflecting on executable files compiled in C++ might throw a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="cec47-1388">Скорее всего, это вызвано компилятор C++ чередует адреса переадресации и раздел .reloc исполняемого файла.</span><span class="sxs-lookup"><span data-stu-id="cec47-1388">This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file.</span></span> <span data-ttu-id="cec47-1389">Чтобы сохранить адрес .reloc, укажите `/fixed:no` при компоновке.</span><span class="sxs-lookup"><span data-stu-id="cec47-1389">To preserve the .reloc address, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="cec47-1390">Контекст только для отражения ничем не отличается от других контекстах.</span><span class="sxs-lookup"><span data-stu-id="cec47-1390">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="cec47-1391">Сборки, загруженные в контекст, могут быть выгружены путем выгрузки домена приложения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1391">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1392">Свойство <paramref name="assemblyString" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1392">
              <paramref name="assemblyString" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-1393">Параметр <paramref name="assemblyString" /> является пустой строкой ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1393">
              <paramref name="assemblyString" /> is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-1394">
            <paramref name="assemblyString" /> не найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1394">
              <paramref name="assemblyString" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-1395">
            <paramref name="assemblyString" /> найдена, но не может быть загружена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1395">
              <paramref name="assemblyString" /> is found, but cannot be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1396">
            <paramref name="assemblyString" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1396">
              <paramref name="assemblyString" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-1397">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1397">-or-</span>
          </span>
          <span data-ttu-id="cec47-1398">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyString" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1398">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="cec47-1399">Путь к файлу, содержащему манифест сборки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1399">The path of the file that contains the manifest of the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1400">Загружает сборку с заданным путем в контекст, предназначенный только для отражения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1400">Loads an assembly into the reflection-only context, given its path.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1401">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1401">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1402">Зависимости не загружаются автоматически в контекст только для отражения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1402">Dependencies are not automatically loaded into the reflection-only context.</span></span> <span data-ttu-id="cec47-1403">Чтобы автоматически загрузить зависимости, обрабатывать <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> событий и загрузка зависимостей в обработчике событий.</span><span class="sxs-lookup"><span data-stu-id="cec47-1403">To automatically load dependencies, handle the <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> event and load the dependency in the event handler.</span></span>  
  
 <span data-ttu-id="cec47-1404">Нельзя выполнять код из сборки, который был загружен в контекст только для отражения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1404">You cannot execute code from an assembly that has been loaded into the reflection-only context.</span></span> <span data-ttu-id="cec47-1405">Для выполнения кода, загрузить сборку с <xref:System.Reflection.Assembly.LoadFile%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="cec47-1405">To execute the code, load the assembly with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="cec47-1406">`assemblyFile` Параметр должен ссылаться на URI без escape-символы.</span><span class="sxs-lookup"><span data-stu-id="cec47-1406">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="cec47-1407">Этот метод предоставляет escape-символы для всех недопустимых символов в URI.</span><span class="sxs-lookup"><span data-stu-id="cec47-1407">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
 <span data-ttu-id="cec47-1408">Путь, указанный для `assemblyFile` задается относительно текущего каталога.</span><span class="sxs-lookup"><span data-stu-id="cec47-1408">The path specified for `assemblyFile` is relative to the current directory.</span></span> <span data-ttu-id="cec47-1409">Сборка загружается в домен вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="cec47-1409">The assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="cec47-1410">Контекст только для отражения ничем не отличается от других контекстах.</span><span class="sxs-lookup"><span data-stu-id="cec47-1410">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="cec47-1411">Сборки, загруженные в контекст, могут быть выгружены путем выгрузки домена приложения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1411">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1412">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1412">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-1413">Файл <paramref name="assemblyFile" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1413">
              <paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-1414">Файл <paramref name="assemblyFile" /> найден, но его не удается загрузить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1414">
              <paramref name="assemblyFile" /> is found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1415">Файл <paramref name="assemblyFile" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1415">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-1416">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1416">-or-</span>
          </span>
          <span data-ttu-id="cec47-1417">В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1417">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="cec47-1418">База кода, которая не начинается с "file://", была указана без требуемого разрешения <see cref="T:System.Net.WebPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1418">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="cec47-1419">Длина имени сборки превышает максимальную длину, определенную в системе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1419">The assembly name exceeds the system-defined maximum length.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-1420">Параметр <paramref name="assemblyFile" /> является пустой строкой ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1420">
              <paramref name="assemblyFile" /> is an empty string ("").</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="cec47-1421">для чтения URI, который начинается с «file://».</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1421">for reading a URI that begins with "file://".</span>
          </span>
          <span data-ttu-id="cec47-1422">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1422">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="cec47-1423">для чтения URI, который не начинается с «file://».</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1423">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1424">Получает значение, указывающее набор правил безопасности, которые применяются средой CLR к данной сборке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1424">Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="cec47-1425">Набор правил безопасности, которые применяются средой CLR к данной сборке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1425">The security rule set that the CLR enforces for this assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1426">По умолчанию, сборки, компиляции с параметром [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] имеют прозрачность, несмотря на то, что вы можете явно сделать их вместо этого.</span><span class="sxs-lookup"><span data-stu-id="cec47-1426">By default, assemblies that you compile with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] have  transparency, although you can explicitly make them  instead.</span></span> <span data-ttu-id="cec47-1427">Сборки, которые были скомпилированы с более ранними версиями платформы .NET Framework имеют прозрачность уровня 1.</span><span class="sxs-lookup"><span data-stu-id="cec47-1427">Assemblies that were compiled with earlier versions of the .NET Framework have level 1 transparency.</span></span>  
  
 <span data-ttu-id="cec47-1428">См. раздел [Изменения системы безопасности](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="cec47-1428">See [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md">
          <span data-ttu-id="cec47-1429">Прозрачный для системы безопасности код</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1429">Security-Transparent Code</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">
          <span data-ttu-id="cec47-1430">Изменения системы безопасности в .NET Framework 4</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1430">Security Changes in the .NET Framework 4</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1431">Возвращает тип текущего экземпляра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1431">Returns the type of the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1432">Объект, представляющий тип <see cref="T:System.Reflection.Assembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1432">An object that represents the <see cref="T:System.Reflection.Assembly" /> type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cec47-1433">Возвращает полное имя сборки, также называемое отображаемым именем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1433">Returns the full name of the assembly, also known as the display name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1434">Полное имя сборки или имя класса, если полное имя сборки не может быть определено.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1434">The full name of the assembly, or the class name if the full name of the assembly cannot be determined.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="cec47-1435">Имя файла, содержащего манифест сборки, либо путь к нему.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1435">The name or path of the file that contains the manifest of the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cec47-1436">Загружает сборку в контекст, из которого производится загрузка, обходя некоторые проверки безопасности.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1436">Loads an assembly into the load-from context, bypassing some security checks.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cec47-1437">Загруженная сборка.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1437">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cec47-1438">Этот метод позволяет загрузить локальную сборку, которую операционная система пометила как загруженную из Интернета (например, временный файл, загруженный из Интернета или интрасети).</span><span class="sxs-lookup"><span data-stu-id="cec47-1438">Use this method to load a local assembly that the operating system has flagged as having been loaded from the Web (for example, a temporary file that was downloaded from the Internet or intranet).</span></span> <span data-ttu-id="cec47-1439">Прежде чем [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], такие сборки автоматически загружались в изолированном домене приложения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1439">Before the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], such assemblies were automatically loaded into a sandboxed application domain.</span></span> <span data-ttu-id="cec47-1440">Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], они загружаются с полным доверием.</span><span class="sxs-lookup"><span data-stu-id="cec47-1440">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], they are loaded with full trust.</span></span>  
  
 <span data-ttu-id="cec47-1441">В качестве альтернативы с помощью данного метода, можно применить [ &lt;NetFx40_LegacySecurityPolicy&gt; элемент](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) в файле конфигурации приложения.</span><span class="sxs-lookup"><span data-stu-id="cec47-1441">As an alternative to using this method, you can apply the [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) in your application configuration file.</span></span> <span data-ttu-id="cec47-1442">В результате среда CLR для возврата к политике безопасности [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span><span class="sxs-lookup"><span data-stu-id="cec47-1442">This causes the common language runtime to revert to the security policy of the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="cec47-1443">При использовании любого из этих решений, необходимо быть уверенным, что он безопасен для загрузки `assemblyFile` с полным доверием.</span><span class="sxs-lookup"><span data-stu-id="cec47-1443">If you use either of these solutions, you must be certain that it is safe to load `assemblyFile` with full trust.</span></span>  
  
 <span data-ttu-id="cec47-1444">Обсуждение контекстов загрузки, включая контекст загрузки с см. в разделе <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="cec47-1444">For a discussion of load contexts, including the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="cec47-1445">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1445">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="cec47-1446">Файл <paramref name="assemblyFile" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1446">
              <paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="cec47-1447">Не удалось загрузить файл, который был найден.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1447">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="cec47-1448">
            <paramref name="assemblyFile" /> не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1448">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="cec47-1449">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1449">-or-</span>
          </span>
          <span data-ttu-id="cec47-1450">Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1450">
              <paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="cec47-1451">База кода, которая не начинается с "file://", была указана без требуемого разрешения <see cref="T:System.Net.WebPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1451">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="cec47-1452">Параметр <paramref name="assemblyFile" /> представляет собой пустую строку ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1452">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="cec47-1453">Длина имени сборки превышает максимальную длину, определенную в системе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1453">The assembly name exceeds the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="cec47-1454">Требует полного доверия для непосредственного вызывающего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1454">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="cec47-1455">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cec47-1455">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>