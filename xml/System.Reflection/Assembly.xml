<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d0a2048d69fcf906a89f73e106fcf01598bf1745" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58681996" /></Metadata><TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет сборку, которая является модулем с возможностью многократного использования, поддержкой версий и встроенным механизмом описания общеязыковой исполняющей среды.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Reflection.Assembly> класс для загрузки сборок, для просмотра метаданных и составные части сборки, для обнаружения типов, содержащихся в сборках и для создания экземпляров этих типов.  
  
 Чтобы получить массив <xref:System.Reflection.Assembly> объектов, представляющих сборки, в настоящее время загружены в домен приложения (например, домене приложения по умолчанию простого проекта), используйте <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> метод.  
  
 Для загрузки сборок динамически, <xref:System.Reflection.Assembly> класс предоставляет следующие статические методы (`Shared` методы в Visual Basic). Сборки загружаются в домен приложения, где выполняется операция загрузки.  
  
-   Для загрузки сборок рекомендуется использовать <xref:System.AppDomain.Load%2A> метод, который идентифицирует сборку, который будет загружен по его отображаемому имени (например, «System.Windows.Forms, Version = 2.0.0.0, язык и региональные параметры = neutral, PublicKeyToken = b77a5c561934e089»). Поиск сборки следует правилам, описанные в [Обнаружение сборок в среде выполнения](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).  
  
-   <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> И <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> методы позволяют загрузить сборку для отражения, но не для выполнения. Например сборки, предназначенный для 64-разрядной платформы можно просмотреть код, выполняемый на 32-разрядной платформе.  
  
-   <xref:System.Reflection.Assembly.LoadFile%2A> И <xref:System.Reflection.Assembly.LoadFrom%2A> предоставляются методы для редких сценариев, в которых сборки должен быть идентифицирован по пути.  
  
 Чтобы получить <xref:System.Reflection.Assembly> объект для текущей выполняемой сборке, используйте <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> метод.  
  
 Многие члены <xref:System.Reflection.Assembly> предоставляют сведения о сборке. Например:  
  
-   <xref:System.Reflection.Assembly.GetName%2A> Возвращает метод <xref:System.Reflection.AssemblyName> объект, предоставляющий доступ к его частям отображаемое имя сборки.  
  
-   <xref:System.Reflection.Assembly.GetCustomAttributes%2A> Метод перечислены атрибуты, примененные к сборке.  
  
-   <xref:System.Reflection.Assembly.GetFiles%2A> Метод обеспечивает доступ к файлам в манифесте сборки.  
  
-   <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> Метод предоставляет имена ресурсов в манифесте сборки.  
  
 <xref:System.Reflection.Assembly.GetTypes%2A> Метод перечисляет все типы в сборке. <xref:System.Reflection.Assembly.GetExportedTypes%2A> Метод перечислены типы, которые видны вызывающим объектам за пределами сборки. <xref:System.Reflection.Assembly.GetType%2A> Метод может использоваться для поиска для определенного типа в сборке. <xref:System.Reflection.Assembly.CreateInstance%2A> Метод может использоваться для поиска и создания экземпляров типов в сборке.  
  
 Дополнительные сведения о сборках см. в разделе «Домены и сборки приложения» в [домены приложений](~/docs/framework/app-domains/application-domains.md) раздела.  
  
   
  
## Examples  
 В следующем примере кода показано, как получение текущей выполняемой сборке, создание экземпляра типа, содержащегося в этой сборке и вызвать один из методов типа с поздним связыванием. Для этой цели в примере кода определяется класс с именем `Example`, включающий метод `SampleMethod`. Конструктор класса принимает целое число, который используется для вычисления возвращаемое значение метода.  
  
 В примере также показано использование <xref:System.Reflection.Assembly.GetName%2A> метод, чтобы получить <xref:System.Reflection.AssemblyName> объект, который может использоваться для синтаксического анализа полное имя сборки. В примере отображается номер версии сборки, <xref:System.Reflection.Assembly.CodeBase%2A> свойство и <xref:System.Reflection.Assembly.EntryPoint%2A> свойство.  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот класс не может наследоваться кодом с частичным доверием.</permission>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md">Домены приложений</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Assembly" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор вызывается производными классами во время создания <xref:System.Reflection.Assembly> объектов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает первоначально заданное расположение сборки, например в объекте <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <value>Первоначально заданное расположение сборки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить абсолютный путь к загруженного файла, содержащего манифест, используйте <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> свойство вместо этого.  
  
 Если сборка была загружена как массив байтов, используя перегрузку <xref:System.Reflection.Assembly.Load%2A> метод, который принимает массив байтов, это свойство возвращает расположение объекта, вызывающего метод, а не расположение загруженной сборки.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Reflection.Assembly.CodeBase%2A> свойство.  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Находит тип в этой сборке и создает его экземпляр, используя абстрактный метод.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><see cref="P:System.Type.FullName" /> искомого типа.</param>
        <summary>С помощью поиска с учетом регистра находит заданный тип в этой сборке и создает его экземпляр, используя абстрактный метод.</summary>
        <returns>Экземпляр указанного типа, созданный с использованием конструктора по умолчанию; или <see langword="null" />, если <paramref name="typeName" /> не найден. Тип разрешается с использованием связывателя по умолчанию, не задавая языка и региональных параметров, а также атрибутов активации, при этом для объекта <see cref="T:System.Reflection.BindingFlags" /> задано значение <see langword="Public" /> или <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если среда CLR не удалось найти `typeName` в <xref:System.Reflection.Assembly> экземпляра, она возвращает `null` вместо выдачи исключения. Это может произойти, когда:  
  
-   Вы не указали полное имя типа.  
  
-   Вы указали полностью уточненное имя типа, но его вариант не совпадает по регистру типа <xref:System.Type.FullName%2A?displayProperty=nameWithType> свойство. Сравнение без учета регистра `typeName` с полным именем типа, вызовите <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> перегрузки и укажите `true` для `ignoreCase` аргумент.  
  
-   Тип не существует в текущем <xref:System.Reflection.Assembly> экземпляра.  
  
   
  
## Examples  
 В следующем примере определяется `Person` класс и вызывает метод <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> метод для создания его экземпляра.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение <paramref name="typeName" /> является пустой строкой ("") или строкой, начинающейся с нуль-символа.  
  
-или- 
Текущая сборка была загружена в контекст только для отражения.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Для <paramref name="typeName" /> требуется зависимая сборка, которую не удается найти.</exception>
        <exception cref="T:System.IO.FileLoadException">Для <paramref name="typeName" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.  
  
-или- 
Текущая сборка была загружена в контекст только для отражения, а для <paramref name="typeName" /> требуется зависимая сборка, которая не была предварительно загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Для <paramref name="typeName" /> требуется зависимая сборка, однако файл не является допустимой сборкой.  
  
-или- 
 Для <paramref name="typeName" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><see cref="P:System.Type.FullName" /> искомого типа.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы игнорировать регистр имени типа, в обратном случае — значение <see langword="false" />.</param>
        <summary>При помощи необязательного поиска с учетом регистра находит заданный тип в этой сборке и создает его экземпляр, используя абстрактный метод.</summary>
        <returns>Экземпляр указанного типа, созданный с использованием конструктора по умолчанию; или <see langword="null" />, если <paramref name="typeName" /> не найден. Тип разрешается с использованием связывателя по умолчанию, не задавая языка и региональных параметров, а также атрибутов активации, при этом для объекта <see cref="T:System.Reflection.BindingFlags" /> задано значение <see langword="Public" /> или <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если среда CLR не удалось найти `typeName` в <xref:System.Reflection.Assembly> экземпляра, она возвращает `null` вместо выдачи исключения. Это может произойти, когда:  
  
-   Вы не указали полное имя типа.  
  
-   Тип не существует в текущем <xref:System.Reflection.Assembly> экземпляра.  
  
   
  
## Examples  
 В следующем примере определяется `Person` класса. Затем он вызывает <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> метод для создания экземпляра, но поскольку регистр `typeName` аргумента не соответствует типу <xref:System.Type.FullName%2A> свойство, метод возвращает `null`. Если в примере передается ту же строку, чтобы <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> перегрузки и указывает, что сравнение без учета регистра, `Person` класс найден и `Person` успешно создать экземпляр объекта.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение <paramref name="typeName" /> является пустой строкой ("") или строкой, начинающейся с нуль-символа.  
  
-или- 
Текущая сборка была загружена в контекст только для отражения.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Для <paramref name="typeName" /> требуется зависимая сборка, которую не удается найти.</exception>
        <exception cref="T:System.IO.FileLoadException">Для <paramref name="typeName" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.  
  
-или- 
Текущая сборка была загружена в контекст только для отражения, а для <paramref name="typeName" /> требуется зависимая сборка, которая не была предварительно загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Для <paramref name="typeName" /> требуется зависимая сборка, однако файл не является допустимой сборкой.  
  
-или- 
 Для <paramref name="typeName" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><see cref="P:System.Type.FullName" /> искомого типа.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы игнорировать регистр имени типа, в обратном случае — значение <see langword="false" />.</param>
        <param name="bindingAttr">Битовая маска, влияющая на способ выполнения поиска. Значение является сочетанием одноразрядных флагов из <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see langword="MemberInfo" /> с помощью отражения. Если значение параметра <paramref name="binder" /> равно <see langword="null" />, используется связыватель по умолчанию.</param>
        <param name="args">Массив, содержащий аргументы, передаваемые конструктору. Этот массив аргументов должен по числу, порядку и типу аргументов соответствовать параметрам вызываемого конструктора. Если нужен конструктор по умолчанию, <paramref name="args" /> должен быть пустым массивом или <see langword="null" />.</param>
        <param name="culture">Экземпляр объекта <see langword="CultureInfo" />, используемого для управления приведением типов. Если значение этого объекта — <see langword="null" />, для текущего потока используется <see langword="CultureInfo" />. (Например, необходимо преобразовывать объект <see langword="String" />, представляющий 1000, в значение <see langword="Double" />, поскольку при разных языках и региональных параметрах 1000 представляется по-разному.)</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.    Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <summary>Находит в сборке указанный тип и создает его экземпляр с использованием системного активатора при помощи необязательного поиска с учетом регистра и с заданными аргументами, культурой, а также атрибутами привязки и активации.</summary>
        <returns>Экземпляр указанного типа или <see langword="null" />, если <paramref name="typeName" /> не найден. Предоставленные аргументы используются для разрешения типа и привязки конструктора, который используется для создания экземпляра.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Значение <paramref name="typeName" /> является пустой строкой ("") или строкой, начинающейся с нуль-символа.  
  
-или- 
Текущая сборка была загружена в контекст только для отражения.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.NotSupportedException">Непустой массив атрибутов активации передан в тип, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Для <paramref name="typeName" /> требуется зависимая сборка, которую не удалось найти.</exception>
        <exception cref="T:System.IO.FileLoadException">Для <paramref name="typeName" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.  
  
-или- 
Текущая сборка была загружена в контекст только для отражения, а для <paramref name="typeName" /> требуется зависимая сборка, которая не была предварительно загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Для <paramref name="typeName" /> требуется зависимая сборка, однако файл не является допустимой сборкой.  
  
-или- 
 Для <paramref name="typeName" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для создания экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки.</param>
        <param name="typeName">Полное имя типа.</param>
        <summary>Создает имя типа, который определяется отображаемым именем его сборки.</summary>
        <returns>Полное имя типа, дополненное отображаемым именем сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приведен формат возвращаемой строки.  
  
 \<FullTypeName >, \<AssemblyDisplayName >  
  
 См. в разделе <xref:System.Reflection.AssemblyName> описание формата отображаемого имени сборки.  
  
 В соответствии с изменениями в версиях среда CLR, используйте этот метод вместо создания полного имени самостоятельно.  Сведения о полных имен сборок, см. в разделе <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию, содержащую пользовательские атрибуты этой сборки.</summary>
        <value>Коллекция, содержащая пользовательские атрибуты этой сборки.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию типов, определенных в этой сборке.</summary>
        <value>Коллекция типов, определенных в этой сборке.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.DefinedTypes%2A> Свойства можно сравнить с <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> метода, за исключением случаев, <xref:System.Reflection.Assembly.DefinedTypes%2A> свойство возвращает коллекцию <xref:System.Reflection.TypeInfo> объектов и <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> метод возвращает массив <xref:System.Type> объектов.  
  
 Возвращаемый массив содержит вложенные типы.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает точку входа для этой сборки.</summary>
        <value>Объект, представляющий точку входа этой сборки. Если точка входа не найдена (например, сборка является DLL-библиотекой), возвращается значение <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o">Объект, сравниваемый с данным экземпляром.</param>
        <summary>Определяет равенство сборки и заданного объекта.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="o" /> равно данному экземпляру; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.Equals%2A> Метод выполняет проверку на равенство ссылок для определения ли текущий экземпляр и `o` равны.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает универсальный код доступа (URI), предоставляющий базовый код, включая escape-символы.</summary>
        <value>Универсальный код доступа (URI) с escape-символами.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает свидетельство для этой сборки.</summary>
        <value>Свидетельство для этой сборки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свидетельство — это набор сведений, используемых для принятия решений политики безопасности, например, сведений о разрешениях, которые могут быть предоставлены коду.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на загрузку сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию открытых типов, определенных в этой сборке и видимых за ее пределами.</summary>
        <value>Коллекция открытых типов, определенных в этой сборке и видимых за ее пределами.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает отображаемое имя сборки.</summary>
        <value>Отображаемое имя сборки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 См. в разделе <xref:System.Reflection.AssemblyName> описание формата отображаемого имени сборки.  
  
> [!NOTE]
>  Написать собственный код для синтаксического анализа отображаемые имена не рекомендуется. Вместо этого передайте имя, отображаемое <xref:System.Reflection.AssemblyName.%23ctor%2A> конструктор, который анализирует его и заполняет соответствующие поля нового <xref:System.Reflection.AssemblyName>.  
  
 В .NET Framework версии 2.0 архитектура процессора добавляется удостоверения сборки и может быть указан как часть строки имени сборки. Тем не менее, он не включен в строку, возвращаемую <xref:System.Reflection.Assembly.FullName%2A> свойство, по соображениям совместимости. См. раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере извлекается отображаемое имя текущей выполняемой сборке и отображаемое имя сборки, содержащей <xref:System.Int32> тип (`int` в C# `Integer` в Visual Basic).  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Указание полных имен типов</related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Объект, представляющий тип в сборке, которая будет возвращена.</param>
        <summary>Возвращает текущую загруженную сборку, в которой определен указанный тип.</summary>
        <returns>Сборка, в которой определен указанный тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода эквивалентен получение значения <xref:System.Type.Assembly?displayProperty=nameWithType> свойство. Тем не менее <xref:System.Type.Assembly?displayProperty=nameWithType> свойства, как правило, обеспечивает более высокую производительность.  
  
 Чтобы вызвать этот метод, необходимо иметь <xref:System.Type> объект, который означает, что сборка, в котором определен класс уже должна быть загружена.  
  
   
  
## Examples  
 В следующем примере извлекается сборки, содержащей <xref:System.Int32> введите и отображает его имя и местоположение файлов.  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Reflection.Assembly" /> метода, вызвавшего текущий выполняемый метод.</summary>
        <returns>Объект <see langword="Assembly" /> метода, вызвавшего выполняющийся в текущий момент метод.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если на метод, который вызывает <xref:System.Reflection.Assembly.GetCallingAssembly%2A> метод является развернуты для подстановки компилятор just-in-time (JIT), или если вызывающий раскрываются внутри, сборка возвращаемые <xref:System.Reflection.Assembly.GetCallingAssembly%2A> неожиданно могут отличаться. Например рассмотрим следующие методы и сборки:  
  
-   Метод `M1` в сборке `A1` вызовы <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
-   Метод `M2` в сборке `A2` вызовы `M1`.  
  
-   Метод `M3` в сборке `A3` вызовы `M2`.  
  
 Когда `M1` не является встроенной, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> возвращает `A2`. Когда `M1` встроена, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> возвращает `A3`. Аналогичным образом, когда `M2` не является встроенной, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> возвращает `A2`. Когда `M2` встроена, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> возвращает `A3`.  
  
 Этот эффект также происходит при `M1` выполняется вызов с префиксом tail из `M2`, или когда `M2` выполняется вызов с префиксом tail из `M3`. Отказаться от JIT-компилятора из встраивания метод, который вызывает <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, путем применения <xref:System.Runtime.CompilerServices.MethodImplAttribute> атрибут с <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> флаг, но аналогичный механизм для предотвращения вызовов с префиксом tail.  
  
   
  
## Examples  
 В следующем примере возвращается вызывающей сборки текущего метода.  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает настраиваемые атрибуты для этой сборки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inherit">Данный аргумент не учитывается для объектов типа <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Получает все настраиваемые атрибуты для этой сборки.</summary>
        <returns>Массив, содержащий настраиваемые атрибуты для этой сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует соответствующий <xref:System.Reflection.ICustomAttributeProvider> метод интерфейса. Таким образом `inherit` параметр должен быть указан, несмотря на то, что он учитывается.  
  
 Псевдо-атрибут задает биты основных метаданных, которые должны быть установлены при наличии этого атрибута. В отличие от пользовательского атрибута, который расширяет метаданные для типа и сохраняется вместе с типом, псевдо-атрибут изменяет метаданные для типа, а затем удаляются. Некоторые из получившиеся биты, нельзя получить с помощью существующих API отражения.  
  
 В следующей таблице перечислены различные псевдо-атрибуты и методы доступа для битов, доступных при отражении.  
  
|Псевдо-атрибут|Биты метаданных|Метод доступа к отражению|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> Имя библиотеки DLL|Нет метода доступа для PInvokeMap для атрибутов обычного метода/глобального метода.<br /><br /> Нет метода доступа для имени библиотеки DLL.|  
|GuidAttribute|Хранятся в виде фактических пользовательских атрибутов.|Доступен как реальный пользовательский атрибут.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Различные элементы.|Нет метода доступа.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags(). OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags(). OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Упаковка классов.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Нет метода доступа.|  
|FieldOffsetAttribute|Смещение поля.|Нет метода доступа.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Нет доступа или перечислителя.|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType">Тип, для которого должны быть возвращены настраиваемые атрибуты.</param>
        <param name="inherit">Данный аргумент не учитывается для объектов типа <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Получает настраиваемые атрибуты для этой сборки как заданные по типу.</summary>
        <returns>Массив, содержащий настраиваемые атрибуты для этой сборки, заданные параметром <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует соответствующий <xref:System.Reflection.ICustomAttributeProvider> метод интерфейса. Таким образом `inherit` параметр должен быть указан, несмотря на то, что он учитывается.  
  
 Псевдо-атрибут задает биты основных метаданных, которые должны быть установлены при наличии этого атрибута. В отличие от пользовательского атрибута, который расширяет метаданные для типа и сохраняется вместе с типом, псевдо-атрибут изменяет метаданные для типа, а затем удаляются. Некоторые из получившиеся биты, нельзя получить с помощью существующих API отражения.  
  
 В следующей таблице перечислены различные псевдо-атрибуты и методы доступа для битов, доступных при отражении.  
  
|Псевдо-атрибут|Биты метаданных|Метод доступа к отражению|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> Имя библиотеки DLL|Нет метода доступа для PInvokeMap для атрибутов обычного метода/глобального метода.<br /><br /> Нет метода доступа для имени библиотеки DLL.|  
|GuidAttribute|Хранятся в виде фактических пользовательских атрибутов.|Доступен как реальный пользовательский атрибут.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Различные элементы.|Нет метода доступа.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags(). OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags(). OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Упаковка классов.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Нет метода доступа.|  
|FieldOffsetAttribute|Смещение поля.|Нет метода доступа.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Нет доступа или перечислителя.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" /> не является типом среды выполнения.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает сведения об атрибутах, примененных к текущему объекту <see cref="T:System.Reflection.Assembly" />; сведения представляют собой объекты <see cref="T:System.Reflection.CustomAttributeData" />.</summary>
        <returns>Универсальный список объектов <see cref="T:System.Reflection.CustomAttributeData" />, представляющих данные об атрибутах, которые были применены к текущей сборке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет просмотреть пользовательские атрибуты кода в контексте только для отражения в случаях, когда сами настраиваемые атрибуты определены в коде, который загружается в контекст только для отражения. Методы, такие как <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> и <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> не может использоваться в таких случаях, так как они создают экземпляры атрибутов. Не удается выполнить код в контексте только для отражения. Дополнительные сведения и пример кода, см. в разделе <xref:System.Reflection.CustomAttributeData> класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает процесс, исполняемый в домене приложения по умолчанию. В других доменах приложений это первый исполняемый процесс, который был выполнен методом <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</summary>
        <returns>Сборка, представляющая собой исполняемый файл процесса в домене приложения по умолчанию или первый исполняемый файл, выполненный методом <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />. Может возвратить значение <see langword="null" /> при вызове из неуправляемого кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> Метод может возвращать `null` когда управляемая сборка была загружена из неуправляемого приложения. Например, если неуправляемое приложение создает экземпляр COM-компонента на языке C#, вызов <xref:System.Reflection.Assembly.GetEntryAssembly%2A> метода из компонента на C# возвращает значение null, так как точка входа для процесса неуправляемого кода, а не является управляемой сборкой.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает сборку, которая содержит выполняемый в текущий момент код.</summary>
        <returns>Сборка, содержащая выполняемый в текущий момент код.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для повышения производительности этот метод следует вызывать только в том случае, если вы не знаете во время разработки сборку в данный момент. Рекомендуемый способ получения <xref:System.Reflection.Assembly> , представляющий текущая сборка является использование <xref:System.Type.Assembly%2A?displayProperty=nameWithType> свойство типа, найденные в сборке, как показано в следующем примере.  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 Чтобы получить сборку, содержащую метод, который вызывается текущим исполняемым кодом, используйте <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Type.Assembly%2A?displayProperty=nameWithType> свойство для получения текущей выполняемой сборке на основе типа, содержащегося в этой сборке. Он также вызовет <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> метод, чтобы показать, что он возвращает <xref:System.Reflection.Assembly> объект, который представляет ту же сборку.  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает открытые типы, определенные в этой сборке и видимые за ее пределами.</summary>
        <returns>Массив, представляющий типы, определенные в сборке и видимые за ее пределами.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только типы, видимый за пределами сборки, открытые типы и открытые типы, вложенные в другие открытые типы.  
  
   
  
## Examples  
 В следующем образце кода определяет несколько классов с помощью различных уровней доступа и вызовы <xref:System.Reflection.Assembly.GetExportedTypes%2A> для отображения те, которые видим за пределами сборки.  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Сборка является динамической.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается загрузить зависимую сборку.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Имя указанного файла. Не должно содержать путь к файлу.</param>
        <summary>Возвращает объект <see cref="T:System.IO.FileStream" /> для указанного файла из таблицы файлов манифеста данной сборки.</summary>
        <returns>Поток, содержащий указанный файл или <see langword="null" />, если файл не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод работает на обоих файлов открытого и закрытого ресурса.  
  
 `name` Не должно содержать путь к файлу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> представляет собой пустую строку ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="name" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> не является допустимой сборкой.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к пути и для чтения указанного файла. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает файлы в таблице файлов манифеста сборки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает файлы в таблице файлов манифеста сборки.</summary>
        <returns>Массив потоков, содержащий файлы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод работает с файлами ресурсов общедоступных и частных.  
  
 Эта перегрузка эквивалентно вызову <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> перегрузки и указав `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не найден.</exception>
        <exception cref="T:System.BadImageFormatException">Файл не является допустимой сборкой.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">Значение <see langword="true" />, если необходимо включать модули ресурсов; в противном случае — значение <see langword="false" />.</param>
        <summary>Получает файлы из таблицы манифеста сборки с указанием включать или не включать модули ресурсов.</summary>
        <returns>Массив потоков, содержащий файлы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод работает с файлами ресурсов общедоступных и частных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не найден.</exception>
        <exception cref="T:System.BadImageFormatException">Файл не является допустимой сборкой.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код данного экземпляра.</summary>
        <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает все загруженные модули, являющиеся частью этой сборки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает все загруженные модули, являющиеся частью этой сборки.</summary>
        <returns>Массив модулей.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">Значение <see langword="true" />, если необходимо включать модули ресурсов; в противном случае — значение <see langword="false" />.</param>
        <summary>Получает все загруженные модули, входящие в эту сборку, с заданием возможности включения модулей ресурсов.</summary>
        <returns>Массив модулей.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">Имя ресурса, зависящее от регистра.</param>
        <summary>Возвращает сведения о сохранении заданного ресурса.</summary>
        <returns>Объект со сведениями о топологии ресурса или <see langword="null" />, если ресурс не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения о ресурсах, возвращается только в том случае, если ресурс является видимым для вызывающего объекта, или вызывающий оператор имеет <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="resourceName" /> представляет собой пустую строку ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает имена всех ресурсов в этой сборке.</summary>
        <returns>Массив, который содержит имена всех ресурсов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имена всех ресурсов, можно использовать в массиве, возвращенное этим методом, следующим образом:  
  
-   Можно передать имя ресурса, чтобы <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> метод для получения дополнительных сведений о ресурсе.  
  
-   Если имя обозначает двоичный RESOURCES-файл, можно удалить его расширение RESOURCES-файла и передать его в <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> конструктора для создания диспетчера ресурсов.  
  
-   Можно передать имя ресурса, чтобы <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> метод для извлечения <xref:System.IO.Stream> объект, который затем можно передать <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> конструктор.  
  
-   Можно передать имя ресурса, чтобы <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> метод для извлечения <xref:System.IO.Stream> объект, который затем можно передать <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> конструктор.  
  
 Сведения о ресурсах, возвращается только в том случае, если ресурс является видимым для вызывающего объекта, или вызывающий оператор имеет <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает указанный ресурс манифеста из сборки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя запрашиваемого ресурса манифеста, зависящее от регистра.</param>
        <summary>Загружает указанный ресурс манифеста из сборки.</summary>
        <returns>Ресурс манифеста; или значение <see langword="null" />, если при компиляции не были заданы ресурсы или ресурс не является видимым для вызывающего объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ресурс манифеста является ресурсом (например, файл изображения), который внедряется в сборку во время компиляции. Дополнительные сведения о ресурсах манифеста см. в разделе [основы ресурсов Microsoft .NET Framework](https://go.microsoft.com/fwlink/?LinkId=204554) в библиотеке MSDN.  
  
 Сведения о ресурсах, возвращается только в том случае, если ресурс является видимым для вызывающего объекта, или вызывающий оператор имеет <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Этот метод возвращает `null` при доступе к закрытому ресурсу в другой сборке, и вызывающий объект не имеет <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> флаг.  
  
 Если файл ресурсов в манифесте сборки <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> возвращает <xref:System.IO.Stream> объекта, даже если не удается найти файл ресурсов на диске во время. Если файл ресурсов не найден, передав итоговый <xref:System.IO.Stream> объект <xref:System.Resources.ResourceReader> вызывает конструктор <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> представляет собой пустую строку ("").</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 Не удалось загрузить файл, который был найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="name" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> не является допустимой сборкой.</exception>
        <exception cref="T:System.NotImplementedException">Длина ресурса больше <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">Манифест сборки</related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип, пространством имен которого ограничена область действия имени ресурса манифеста.</param>
        <param name="name">Имя запрашиваемого ресурса манифеста, зависящее от регистра.</param>
        <summary>Загружает из сборки указанный ресурс манифеста с учетом ограничения области действия пространства имен по типу.</summary>
        <returns>Ресурс манифеста; или значение <see langword="null" />, если при компиляции не были заданы ресурсы или ресурс не является видимым для вызывающего объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например, если полное имя, указанное для `type` является «MyNameSpace.MyClasses» и `name` является «Net», этот метод перегрузки ищет ресурс с именем «MyNameSpace.Net».  
  
 Ресурс манифеста является ресурсом (например, файл изображения), который внедряется в сборку во время компиляции. Дополнительные сведения о ресурсах манифеста см. в разделе [основы ресурсов Microsoft .NET Framework](https://go.microsoft.com/fwlink/?LinkId=204554) в библиотеке MSDN.  
  
 Сведения о ресурсах, возвращается только в том случае, если ресурс является видимым для вызывающего объекта, или вызывающий оператор имеет <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Этот метод возвращает `null` при доступе к закрытому ресурсу в другой сборке, и вызывающий объект не имеет <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> флаг.  
  
 Если файл ресурсов в манифесте сборки <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> возвращает <xref:System.IO.Stream> объекта, даже если не удается найти файл ресурсов на диске во время. Если файл ресурсов не найден, передав итоговый <xref:System.IO.Stream> объект <xref:System.Resources.ResourceReader> вызывает конструктор <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> представляет собой пустую строку ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="name" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> не является допустимой сборкой.</exception>
        <exception cref="T:System.NotImplementedException">Длина ресурса больше <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">Манифест сборки</related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Имя запрашиваемого модуля.</param>
        <summary>Получает указанный модуль этой сборки.</summary>
        <returns>Запрашиваемый модуль или значение <see langword="null" />, если модуль не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод работает с именами файлов.  
  
 Классы в `Reflection.Emit` пространства имен порождают имя области для динамического модуля. Имя области можно определить с помощью <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> свойство. Тип модуля, чтобы передать `Assembly.GetModule`. Например, если требуется модуля, содержащего манифест сборки, передать имя области модуля `GetModule`. В противном случае передайте имя файла модуля. Сборки, загруженные в один из `Load` методы, которые имеют параметр byte [] содержат только один модуль, и модуль манифеста. Всегда следует выполнять поиск этих модулей, используя имя области.  
  
 Тип может быть извлечен из конкретного модуля с помощью <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>. Вызов `Module.GetType` модуля, содержащего манифест, не приведет к поиску для всей сборки. Чтобы получить тип из сборки, независимо от того, какой модуль он находится, необходимо вызвать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> представляет собой пустую строку ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти <paramref name="name" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> не является допустимой сборкой.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает все модули, являющиеся частью этой сборки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает все модули, являющиеся частью этой сборки.</summary>
        <returns>Массив модулей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод работает с файлами ресурсов общедоступных и частных.  
  
> [!NOTE]
>  Модули должны включаться с расширениями имен файлов.  
  
   
  
## Examples  
 Следующий пример отображает имя модуля в возвращаемый массив, содержащий манифест сборки.  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">В загружаемом модуле не указано расширение имени файла.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">Значение <see langword="true" />, если необходимо включать модули ресурсов; в противном случае — значение <see langword="false" />.</param>
        <summary>Получает все загруженные модули, входящие в эту сборку, с указанием возможности включения модулей ресурсов.</summary>
        <returns>Массив модулей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод работает с файлами ресурсов общедоступных и частных.  
  
> [!NOTE]
>  Модули должны включаться с расширениями имен файлов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает имя <see cref="T:System.Reflection.AssemblyName" /> для этой сборки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает имя <see cref="T:System.Reflection.AssemblyName" /> для этой сборки.</summary>
        <returns>Объект, содержащий полностью проанализированное отображаемое имя для этой сборки.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к пути сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="copiedName">Значение <see langword="true" />, чтобы значение свойства <see cref="P:System.Reflection.Assembly.CodeBase" /> указывало на расположение сборки после создания ее теневой копии; значение <see langword="false" />, если значение свойства <see cref="P:System.Reflection.Assembly.CodeBase" /> должно указывать на первоначальное расположение.</param>
        <summary>Возвращает значение <see cref="T:System.Reflection.AssemblyName" /> для этой сборки, база кода устанавливается в соответствии с параметром <paramref name="copiedName" />.</summary>
        <returns>Объект, содержащий полностью проанализированное отображаемое имя для этой сборки.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к пути сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Объект, для которого будут заполнены сведения о сериализации.</param>
        <param name="context">Контекст назначения сериализации.</param>
        <summary>Получает сведения сериализации со всеми данными, необходимыми для повторного создания экземпляра этой сборки.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> — <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объекты <see cref="T:System.Reflection.AssemblyName" /> для всех сборок, на которые ссылается данная сборка.</summary>
        <returns>Массив, содержащий полностью проанализированные отображаемые имена всех сборок, на которые ссылается данная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> свойство <xref:System.Reflection.AssemblyName> объект, который возвращается этим методом является <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> при хэш-алгоритм по связанной сборке, или в том случае, если хэш-алгоритм сборки, на которую указывает ссылка, не является определяется <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> перечисления. В предыдущих версиях .NET Framework <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> свойство, возвращенное <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> в этой ситуации.  
  
   
  
## Examples  
 В следующем примере кода показан вызов <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> метод. Данный пример кода является частью большего примера для <xref:System.Reflection.Assembly> класса.  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает вспомогательную сборку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Заданные язык и региональные параметры.</param>
        <summary>Получает сопутствующую сборку для указанной культуры.</summary>
        <returns>Указанная вспомогательная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вспомогательные сборки содержат локализованные ресурсы, в отличие от основного приложения сборки, содержащие не локализуемый исполняемый код и ресурсы для одного языка и региональных параметров, которые служат по умолчанию или нейтрального языка и региональных параметров.  
  
 Вызовите этот метод, чтобы использовать текущую версию сборки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти сборку.</exception>
        <exception cref="T:System.IO.FileLoadException">Вспомогательная сборка с соответствующим именем файла была найдена, но параметр <see langword="CultureInfo" /> не соответствует указанному.</exception>
        <exception cref="T:System.BadImageFormatException">Вспомогательная сборка не является допустимой сборкой.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="version" Type="System.Version" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Заданные язык и региональные параметры.</param>
        <param name="version">Версия вспомогательной сборки.</param>
        <summary>Получает указанную версию вспомогательной сборки для указанной культуры.</summary>
        <returns>Указанная вспомогательная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вспомогательные сборки содержат локализованные ресурсы, в отличие от основного приложения сборки, содержащие не локализуемый исполняемый код и ресурсы для одного языка и региональных параметров, которые служат по умолчанию или нейтрального языка и региональных параметров.  
  
 Вызовите <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> перегрузки, чтобы использовать текущую версию сборки.  
  
 Если `version` является `null`, используется текущая версия сборки используется в том случае, если подписываются как ресурс, так и основные сборки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Вспомогательная сборка с соответствующим именем файла была найдена, но <see langword="CultureInfo" /> или версия не соответствуют указанным.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти сборку.</exception>
        <exception cref="T:System.BadImageFormatException">Вспомогательная сборка не является допустимой сборкой.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает объект <see cref="T:System.Type" />, представляющий указанный тип.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Полное имя типа.</param>
        <summary>Возвращает объект <see cref="T:System.Type" /> с указанным именем в экземпляре сборки.</summary>
        <returns>Объект, представляющий указанный класс, или <see langword="null" />, если класс не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод осуществляет только текущего экземпляра сборки. `name` Параметр включает в себя пространство имен, но не сборку. Чтобы выполнить поиск других сборок для типа, используйте <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> перегрузку метода, которая может включать отображаемое имя сборки как часть имени типа.  
  
> [!NOTE]
>  Если тип был перемещен в другую сборку, он по-прежнему возвращается этим методом. Сведения о перенаправлении типов см. в разделе [Переадресация типа в системе Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
   
  
## Examples  
 В следующем примере определяется абстрактный `MeansOfTransportation` в класс `Transportation` пространства имен. Он вызывает <xref:System.Reflection.Assembly.GetType%28System.String%29> метод для извлечения его <xref:System.Type> объекта, вызывает <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> метод для получения массива <xref:System.Reflection.PropertyInfo> объекты, представляющие свойства типа и затем отображает информацию на типа абстрактного свойства. Обратите внимание, что вызов <xref:System.Reflection.Assembly.GetType%28System.String%29> метод использует полное имя типа (то есть, его пространство имен вместе с именем типа).  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> недопустим.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Для <paramref name="name" /> требуется зависимая сборка, которую не удается найти.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>Для 
          <paramref name="name" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.  
  
-или- 
Текущая сборка была загружена в контекст только для отражения, а для <paramref name="name" /> требуется зависимая сборка, которая не была предварительно загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Для <paramref name="name" /> требуется зависимая сборка, однако файл не является допустимой сборкой.  
  
-или- 
 Для <paramref name="name" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Полное имя типа.</param>
        <param name="throwOnError">Значение <see langword="true" /> для создания исключения, если тип не найден, в обратном случае — значение <see langword="false" />, в результате чего будет возвращено значение <see langword="null" />.</param>
        <summary>Возвращает объект <see cref="T:System.Type" /> с заданным именем в экземпляре сборки и может вызывать исключение, если тип не найден.</summary>
        <returns>Объект, представляющий указанный класс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод осуществляет только текущего экземпляра сборки. `name` Параметр включает в себя пространство имен, но не сборку. Чтобы выполнить поиск других сборок для типа, используйте <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> перегрузку метода, которая может включать отображаемое имя сборки как часть имени типа.  
  
> [!NOTE]
>  Если тип был перемещен в другую сборку, он по-прежнему возвращается этим методом. Сведения о перенаправлении типов см. в разделе [Переадресация типа в системе Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 `throwOnError` Параметр влияет только на что произойдет, если тип не найден. Он не влияет на другие исключения, которые могут быть вызваны. В частности, если найден тип, но не может быть загружен <xref:System.TypeLoadException> может быть создано даже в том случае, если `throwOnError` является `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> недопустим.  
  
-или- 
Длина <paramref name="name" /> превышает 1024 символа.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> является <see langword="true" />, не удается найти тип.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Для <paramref name="name" /> требуется зависимая сборка, которую не удается найти.</exception>
        <exception cref="T:System.IO.FileLoadException">Для <paramref name="name" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.  
  
-или- 
Текущая сборка была загружена в контекст только для отражения, а для <paramref name="name" /> требуется зависимая сборка, которая не была предварительно загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Для <paramref name="name" /> требуется зависимая сборка, однако файл не является допустимой сборкой.  
  
-или- 
 Для <paramref name="name" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Полное имя типа.</param>
        <param name="throwOnError">Значение <see langword="true" /> для создания исключения, если тип не найден, в обратном случае — значение <see langword="false" />, в результате чего будет возвращено значение <see langword="null" />.</param>
        <param name="ignoreCase">Значение <see langword="true" />, чтобы игнорировать регистр имени типа, в обратном случае — значение <see langword="false" />.</param>
        <summary>Возвращает объект <see cref="T:System.Type" /> с заданным именем в экземпляре сборки, с возможностями игнорировать регистр и вызвать исключение, если тип не найден.</summary>
        <returns>Объект, представляющий указанный класс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод осуществляет только текущего экземпляра сборки. `name` Параметр включает в себя пространство имен, но не сборку. Чтобы выполнить поиск других сборок для типа, используйте <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> перегрузку метода, которая может включать отображаемое имя сборки как часть имени типа.  
  
> [!NOTE]
>  Если тип был перемещен в другую сборку, он по-прежнему возвращается этим методом. Сведения о перенаправлении типов см. в разделе [Переадресация типа в системе Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 `throwOnError` Параметр влияет только на что произойдет, если тип не найден. Он не влияет на другие исключения, которые могут быть вызваны. В частности, если найден тип, но не может быть загружен <xref:System.TypeLoadException> может быть создано даже в том случае, если `throwOnError` является `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> недопустим.  
  
-или- 
Длина <paramref name="name" /> превышает 1024 символа.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> является <see langword="true" />, не удается найти тип.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Для <paramref name="name" /> требуется зависимая сборка, которую не удается найти.</exception>
        <exception cref="T:System.IO.FileLoadException">Для <paramref name="name" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.  
  
-или- 
Текущая сборка была загружена в контекст только для отражения, а для <paramref name="name" /> требуется зависимая сборка, которая не была предварительно загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Для <paramref name="name" /> требуется зависимая сборка, однако файл не является допустимой сборкой.  
  
-или- 
 Для <paramref name="name" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает типы, определенные в этой сборке.</summary>
        <returns>Массив, содержащий все типы, определенные в этой сборке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемый массив содержит вложенные типы.  
  
 Если <xref:System.Reflection.Assembly.GetTypes%2A> метод вызывается для сборки и тип, в том, что сборка зависит от типа в сборке, которая не была загружена (например, если он является производным от типа в сборке второй), <xref:System.Reflection.ReflectionTypeLoadException> возникает исключение. Например, это может произойти, если первая сборка была загружена с <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> или <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> методов, а вторая сборка не загружена. Это также может произойти с сборки, загруженные с помощью <xref:System.Reflection.Assembly.Load%2A> и <xref:System.Reflection.Assembly.LoadFile%2A> методов, если вторую сборку не удается найти, когда <xref:System.Reflection.Assembly.GetTypes%2A> вызывается метод.  
  
> [!NOTE]
>  Если тип был перемещен в другую сборку, он не включен в возвращаемый массив. Сведения о перенаправлении типов см. в разделе [Переадресация типа в системе Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Чтобы получить коллекцию <xref:System.Reflection.TypeInfo> объектов вместо массива <xref:System.Type> объекты, используют <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> свойство.  
  
   
  
## Examples  
 Следующий пример отображает параметры одного метода для типа в заданной сборке.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">Сборка содержит один или несколько типов, которые не удается загрузить. Массив, возвращаемый свойством <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> этого исключения, содержит объект <see cref="T:System.Type" /> для каждого типа, который был загружен, и объект <see langword="null" /> для каждого типа, который не удалось загрузить, тогда как свойство <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> содержит исключение для каждого типа, который не удалось загрузить.</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, была ли сборка загружена из глобального кэша сборок.</summary>
        <value>Значение <see langword="true" />, если сборка была загружена из глобального кэша сборок, в обратном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает контекст хост-сайта, с которым была загружена сборка.</summary>
        <value>Значение <see cref="T:System.Int64" />, которое указывает контекст узла, с которым была загружена сборка, при его наличии.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает строку, представляющую версию общеязыковой среды выполнения (CLR), сохраненной в файле, содержащем манифест.</summary>
        <value>Имя папки версии среды CLR. Указанный путь не является полным.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например значение для платформы .NET Framework версии 1.1 будет v1.1.4322. Двоичные файлы для этой версии будет находиться в пути % windir%\Microsoft.NET\Framework\v1.1.4322.  
  
 По умолчанию <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> задана версия среды CLR, используемый для построения сборки. Тем не менее он может было присвоено другое значение во время компиляции.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public virtual bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Reflection.Assembly.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, содержится ли объект в забираемом контексте <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</summary>
        <value><see langword="true" /> Если эта сборка хранится в забираемой <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Дополнительные сведения см. в разделе <see href="/en-us/dotnet/standard/assembly/unloadability-howto">способы использования и отладка unloadability сборки в .NET Core</see>.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType">Тип атрибута, который нужно проверить для данной сборки.</param>
        <param name="inherit">Данный аргумент не учитывается для объектов этого типа.</param>
        <summary>Указывает, применен ли конкретный атрибут к сборке.</summary>
        <returns>Значение <see langword="true" />, если атрибут был применен к сборке; в обратном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода применяется <xref:System.Reflection.AssemblyTitleAttribute> атрибут сборки, и затем использует <xref:System.Reflection.Assembly.IsDefined%2A> для указания того, была ли применена. Она также проверяет, который не был применен атрибут.  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" /> использует недопустимый тип.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее, была ли текущая сборка создана динамически в текущем процессе с помощью отражения.</summary>
        <value>Значение <see langword="true" />, если текущая сборка была создана динамически в текущем процессе; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Динамические сборки, представляются производного класса <xref:System.Reflection.Emit.AssemblyBuilder>.  
  
 При сохранении динамическую сборку на диск, сохраненную сборку не является динамическим. Если сохраненный сборка загружается в другой домен приложения или процесса, <xref:System.Reflection.Assembly.IsDynamic%2A> возвращает `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, загружена ли текущая сборка с полным доверием.</summary>
        <value>Значение <see langword="true" />, если текущая сборка загружена с полным доверием; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает сборку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Массив байтов, который является образом в формате COFF, содержащим созданную сборку.</param>
        <summary>Загружает сборку с образом в формате COFF, содержащим порожденную сборку. Сборка загружается в домен приложения вызывающего объекта.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Уровень доверия сборки, которая загружена с помощью этого метода является таким же, как уровень доверия вызывающей сборки. Чтобы загрузить сборку из массива байтов с уровнем доверия домена приложения, используйте <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> перегрузки метода. Дополнительные сведения об использовании доказательств с перегрузками <xref:System.Reflection.Assembly.Load%2A> метод, использующий байтовых массивов, см. в разделе <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> перегрузки метода.  
  
 Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>. Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла. Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.  
  
 Обратите внимание, что эта перегрузка метода всегда создает новый <xref:System.Reflection.Assembly> объекта с собственным сопоставлением.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> — <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Объект, описывающий загружаемую сборку.</param>
        <summary>Загружает сборку с заданным именем <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> возникает, если `assemblyRef` указывает полное имя сборки и первой сборки, которая соответствует простое имя имеет другой версии, языка и региональных параметров или маркер открытого ключа. Загрузчик не производит поиск других сборок, которые соответствуют простым именем. Начиная с .NET Framework 4, так как выполнение кода в удаленных сборок отключен по умолчанию <xref:System.IO.FileLoadException> возникает также в том случае, если `assemblyRef` указывает удаленную сборку. Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.     
  
> [!NOTE]
>  Не используйте <xref:System.Reflection.AssemblyName> только с <xref:System.Reflection.AssemblyName.CodeBase%2A> набор свойств. <xref:System.Reflection.AssemblyName.CodeBase%2A> Свойство не поддерживает какие-либо элементы удостоверения сборки (например, имя или версию), поэтому загрузка не происходит в соответствии с правилами load, удостоверения, как и следовало ожидать из <xref:System.Reflection.Assembly.Load%2A> метод. Вместо этого сборка загружается с помощью загрузить из правил. Сведения о недостатках использования контекст загрузки с см. в разделе <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> перегрузку метода или [советы и рекомендации для загрузки сборок](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 От свидетельства зависит, предоставляются ли сборке определенные разрешения. Далее приведены правила для сборки и слияние свидетельством безопасности.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются. Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.Load%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр для загрузки общего объекта файла формате COFF образа, свидетельство наследуется от вызывающей сборки. Это относится к .NET Framework версии 1.1 пакета обновления 1 (SP1) и последующих выпусков.  
  
    > [!NOTE]
    >  В .NET Framework версии 1.0 и в версии 1.1 без SP1, при использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр, чтобы загрузить образ COFF свидетельство объединяется. `Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство. Свидетельство вызывающей сборки и свидетельство образа в формате COFF учитывается.  
  
 Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>. Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла. Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.  
  
> [!NOTE]
>  Если оба <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> свойство и <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> имеет значение, первая попытка загрузить сборку использует отображаемое имя (включая версии, языка и региональных параметров и т. д., возвращенная <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> свойство). Если файл не найден, <xref:System.Reflection.AssemblyName.CodeBase%2A> используется для поиска сборки. Если сборка найдена с помощью <xref:System.Reflection.AssemblyName.CodeBase%2A>, противопоставляется отображаемое имя сборки. Если сопоставление завершается ошибкой, <xref:System.IO.FileLoadException> возникает исключение.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Reflection.AssemblyName> и использует его для загрузки `sysglobal.dll` сборки. Затем выводится полное имя сборки, открытые типы.  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" /> не найден.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 Не удалось загрузить файл, который был найден.

-или-

<paramref name="assemblyRef" /> указывает на удаленную сборку, но возможность выполнения кода в удаленных сборках отключена. См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" /> не является допустимой сборкой. -или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyRef" /> была скомпилирована в более поздней версии.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям, включенным в путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с «file://».</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на загрузку сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">Обнаружение сборок в среде выполнения</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Длинная форма имени сборки.</param>
        <summary>Загружает сборку, заданную длинной формой ее имени.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Длинная форма имени сборки состоит из его простое имя (например, «система» для сборки System.dll) вместе с его версия, язык и региональные параметры, токен открытого ключа и при необходимости архитектурой процессора. Он соответствует сборки <xref:System.Reflection.Assembly.FullName%2A> свойство. Следующий пример иллюстрирует использование длинное имя для загрузки сборки System.dll для .NET Framework 4.  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> возникает, если `assemblyString` указывает полное имя сборки и первой сборки, которая соответствует простое имя имеет другой версии, языка и региональных параметров или маркер открытого ключа. Загрузчик не производит поиск других сборок, которые соответствуют простым именем.  
  
 От свидетельства зависит, предоставляются ли сборке определенные разрешения. Далее приведены правила для сборки и слияние свидетельством безопасности.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются. Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.Load%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр для загрузки общего объекта файла формате COFF образа, свидетельство наследуется от вызывающей сборки. Это относится к .NET Framework версии 1.1 пакета обновления 1 (SP1) и последующих выпусков.  
  
    > [!NOTE]
    >  В .NET Framework версии 1.0 и в версии 1.1 без SP1, при использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр, чтобы загрузить образ COFF свидетельство объединяется. `Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство. Свидетельство вызывающей сборки и свидетельство образа в формате COFF учитывается.  
  
 Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>. Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла. Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.  
  
 В .NET Framework версии 2.0 архитектура процессора добавляется удостоверения сборки и может быть указан как часть строки имени сборки. Например «ProcessorArchitecture = msil». Тем не менее, чтобы указать имя сборки рекомендуется создать <xref:System.Reflection.AssemblyName> и передать его в соответствующую перегрузку <xref:System.Reflection.Assembly.Load%2A> метод. См. раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере загружает сборку с заданным его полное имя и перечисляются все типы, содержащиеся в указанной сборке. Для этого примера кода для запуска необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки, см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyString" /> представляет собой строку нулевой длины.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> не найден.</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyString" /> была скомпилирована в более поздней версии.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на загрузку сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">Обнаружение сборок в среде выполнения</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Массив байтов, который является образом в формате COFF, содержащим созданную сборку.</param>
        <param name="rawSymbolStore">Массив байтов, содержащий необработанные байты, которые представляют символы для сборки.</param>
        <summary>Загружает сборку с образом в формате COFF, содержащим выпущенную сборку и (дополнительно) символы для сборки. Сборка загружается в домен приложения вызывающего объекта.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Уровень доверия сборки, которая загружена с помощью этого метода является таким же, как уровень доверия вызывающей сборки. Чтобы загрузить сборку из массива байтов с уровнем доверия домена приложения, используйте <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> перегрузки метода. Дополнительные сведения об использовании доказательств с перегрузками <xref:System.Reflection.Assembly.Load%2A> метод, использующий байтовых массивов, см. в разделе <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> перегрузки метода.  
  
 Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>. Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла. Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.  
  
 Обратите внимание, что эта перегрузка метода всегда создает новый <xref:System.Reflection.Assembly> объекта с собственным сопоставлением.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> — <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Объект, описывающий загружаемую сборку.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <summary>Загружает сборку с заданным именем <see cref="T:System.Reflection.AssemblyName" />. Сборка загружена в домен вызывающего объекта с использованием переданного свидетельства.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> возникает, если `assemblyRef` указывает полное имя сборки и первой сборки, которая соответствует простое имя имеет другой версии, языка и региональных параметров или маркер открытого ключа. Загрузчик не производит поиск других сборок, которые соответствуют простым именем.  Начиная с .NET Framework 4, так как выполнение кода в удаленных сборок отключен по умолчанию <xref:System.IO.FileLoadException> возникает также в том случае, если `assemblyRef` указывает удаленную сборку. Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.   
  
> [!NOTE]
>  Не используйте <xref:System.Reflection.AssemblyName> только с <xref:System.Reflection.AssemblyName.CodeBase%2A> набор свойств. <xref:System.Reflection.AssemblyName.CodeBase%2A> Свойство не поддерживает какие-либо элементы удостоверения сборки (например, имя или версию), поэтому загрузка не происходит в соответствии с правилами load, удостоверения, как и следовало ожидать из <xref:System.Reflection.Assembly.Load%2A> метод. Вместо этого сборка загружается с помощью загрузить из правил. Сведения о недостатках использования контекст загрузки с см. в разделе <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> перегрузку метода или [советы и рекомендации для загрузки сборок](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 От свидетельства зависит, предоставляются ли сборке определенные разрешения. Далее приведены правила для сборки и слияние свидетельством безопасности.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются. Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.Load%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр для загрузки общего объекта файла формате COFF образа, свидетельство наследуется от вызывающей сборки. Это относится к .NET Framework версии 1.1 пакета обновления 1 (SP1) и последующих выпусков.  
  
    > [!NOTE]
    >  В .NET Framework версии 1.0 и в версии 1.1 без SP1, при использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр, чтобы загрузить образ COFF свидетельство объединяется. `Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство. Свидетельство вызывающей сборки и свидетельство образа в формате COFF учитывается.  
  
 Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>. Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла. Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.  
  
> [!NOTE]
>  Если оба <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> свойство и <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> имеет значение, первая попытка загрузить сборку использует отображаемое имя (включая версии, языка и региональных параметров и т. д., возвращенная <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> свойство). Если файл не найден, <xref:System.Reflection.AssemblyName.CodeBase%2A> используется для поиска сборки. Если сборка найдена с помощью <xref:System.Reflection.AssemblyName.CodeBase%2A>, противопоставляется отображаемое имя сборки. Если сопоставление завершается ошибкой, <xref:System.IO.FileLoadException> возникает исключение.  
  
 При вызове метода <xref:System.Reflection.Assembly.Load%2A> более чем один раз для одной сборки, но с разными свидетельствами, среда CLR не вызывает метод <xref:System.IO.FileLoadException> из-за невозможности проверки на равенство и целостность различных спецификаций свидетельства определить. Свидетельство сначала выполняется успешно, это свидетельство, который используется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyRef" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.

-или-

<paramref name="assemblyRef" /> указывает на удаленную сборку, но возможность выполнения кода в удаленных сборках отключена. См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям, включенным в путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с «file://».</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на загрузку сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">Обнаружение сборок в среде выполнения</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Отображаемое имя сборки.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <summary>Загружает сборку с заданным отображаемым именем. Сборка загружается в домен вызывающего объекта с использованием переданного основания.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> возникает, если `assemblyString` указывает полное имя сборки и первой сборки, которая соответствует простое имя имеет другой версии, языка и региональных параметров или маркер открытого ключа. Загрузчик не производит поиск других сборок, которые соответствуют простым именем.  
  
 От свидетельства зависит, предоставляются ли сборке определенные разрешения. Далее приведены правила для сборки и слияние свидетельством безопасности.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются. Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.Load%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр для загрузки общего объекта файла формате COFF образа, свидетельство наследуется от вызывающей сборки. Это относится к .NET Framework версии 1.1 пакета обновления 1 (SP1) и последующих выпусков.  
  
    > [!NOTE]
    >  В .NET Framework версии 1.0 и в версии 1.1 без SP1, при использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр, чтобы загрузить образ COFF свидетельство объединяется. `Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство. Свидетельство вызывающей сборки и свидетельство образа в формате COFF учитывается.  
  
 Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>. Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла. Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.  
  
 Если этот метод вызывается несколько раз к той же сборке, но с разными свидетельствами, среда CLR не создает исключение <xref:System.IO.FileLoadException> , так как невозможно определить равенство и целостность различных спецификаций свидетельства. Свидетельство сначала выполняется успешно, это свидетельство, который используется.  
  
 В .NET Framework версии 2.0 архитектура процессора добавляется удостоверения сборки и может быть указан как часть строки имени сборки. Например «ProcessorArchitecture = msil». Тем не менее, чтобы указать имя сборки рекомендуется создать <xref:System.Reflection.AssemblyName> и передать его в соответствующую перегрузку <xref:System.Reflection.Assembly.Load%2A> метод. См. раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyString" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.  
  
-или- 
Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на загрузку сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">Обнаружение сборок в среде выполнения</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Массив байтов, который является образом в формате COFF, содержащим созданную сборку.</param>
        <param name="rawSymbolStore">Массив байтов, содержащий необработанные байты, которые представляют символы для сборки.</param>
        <param name="securityEvidence">Свидетельство для загрузки сборки.</param>
        <summary>Загружает сборку с образом в формате COFF, содержащим выпущенную сборку и (необязательно) символы и свидетельство для сборки. Сборка загружается в домен приложения вызывающего объекта.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка загружена в домен вызывающего объекта с использованием переданного свидетельства. Также загружаются необработанные байты, представляющие собой символы для сборки.  
  
 От свидетельства зависит, предоставляются ли сборке определенные разрешения. Далее приведены правила для сборки и слияние свидетельством безопасности.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются. Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.Load%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр, чтобы загрузить образ COFF свидетельство наследуется от вызывающей сборки. Это относится к .NET Framework версии 1.1 пакета обновления 1 (SP1) и последующих выпусков.  
  
    > [!NOTE]
    >  В .NET Framework версии 1.0 и в версии 1.1 без SP1, при использовании <xref:System.Reflection.Assembly.Load%2A> перегрузку метода с `Byte[]` параметр, чтобы загрузить образ COFF свидетельство объединяется. `Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.  
  
-   При использовании <xref:System.Reflection.Assembly.Load%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство. Свидетельство вызывающей сборки и свидетельство образа в формате COFF, игнорируются.  
  
 Отражение исполняемых файлов C++ может вызывать <xref:System.BadImageFormatException>. Это наиболее вероятно, из-за компилятор C++ чередует адреса переадресации или `.reloc` разделе исполняемого файла. Чтобы сохранить `.reloc` адрес для исполняемого файла C++, укажите `/fixed:no` при компоновке.  
  
 При вызове метода [\], байтов\<xref:System.Reflection.Assembly.Load%2A > более чем один раз для одной сборки, но с разными свидетельствами, среда CLR не вызывает метод <xref:System.IO.FileLoadException> поскольку не удается определить равенство и целостность различных спецификаций свидетельства. Свидетельство сначала выполняется успешно, это свидетельство, который используется.  
  
 Обратите внимание, что эта перегрузка метода всегда создает новый <xref:System.Reflection.Assembly> объекта с собственным сопоставлением.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> — <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="securityEvidence" /> не является <see langword="null" />.  По умолчанию устаревшая политика CAS не включена в [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; если она не включена, параметр <paramref name="securityEvidence" /> должен иметь значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">возможность передать свидетельство. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Массив байтов, который является образом в формате COFF, содержащим созданную сборку.</param>
        <param name="rawSymbolStore">Массив байтов, содержащий необработанные байты, которые представляют символы для сборки.</param>
        <param name="securityContextSource">Источник контекста безопасности.</param>
        <summary>Загружает сборку с образом в формате COFF, содержащим выпущенную сборку и необязательно содержащим символы и задающим источник для контекста безопасности. Сборка загружается в домен приложения вызывающего объекта.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка загружается в домен приложения вызывающего объекта, используя указанный источник для контекста безопасности. Если `rawSymbolStore` был указан, также загружаются необработанные байты, которые представляют символы для сборки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> — <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> не является допустимой сборкой.  
  
-или- 
 Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="securityContextSource" /> не является одним из значений перечисления.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает содержимое файла сборки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Полный путь к загружаемому файлу.</param>
        <summary>Загружает содержимое файла сборки, находящегося по указанному пути.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Reflection.Assembly.LoadFile%2A> метод для загрузки и анализа сборок, которые имеют одинаковое удостоверение, но расположены в разных путей. <xref:System.Reflection.Assembly.LoadFile%2A> не загружает файлы в контекст загрузки с, а не разрешать зависимости, используя в качестве пути загрузки, <xref:System.Reflection.Assembly.LoadFrom%2A> делает метод. <xref:System.Reflection.Assembly.LoadFile%2A> полезно в этом сценарии ограниченной поскольку <xref:System.Reflection.Assembly.LoadFrom%2A> не может использоваться для загрузки сборок, имеющих одинаковые идентификаторы, но разные пути; он будет загружаться только первые такой сборки.  

Начиная с .NET Framework 4, если `path` указывает на сборку в удаленных расположениях, загрузка сборки отключено по умолчанию и `LoadFile` вызывает метод <xref:System.IO.FileLoadException>. Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Аргумент <paramref name="path" /> не является абсолютным путем.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.

-или-

Возможность выполнения кода в удаленных сборках отключена. См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Параметр <paramref name="path" /> представляет собой пустую строку ("") или не существует.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="path" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="path" /> была скомпилирована в более поздней версии.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям, включенным в путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на загрузку сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Полный путь к файлу сборки.</param>
        <param name="securityEvidence">Свидетельство для загрузки сборки.</param>
        <summary>Загружает сборку с заданным путем в домен вызывающего объекта с использованием переданного свидетельства.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Reflection.Assembly.LoadFile%2A> метод для загрузки и анализа сборок, которые имеют одинаковое удостоверение, но расположены в разных путей. <xref:System.Reflection.Assembly.LoadFile%2A> не загружает файлы в <xref:System.Reflection.Assembly.LoadFrom%2A> контекста и не разрешает зависимости, используя в качестве пути загрузки <xref:System.Reflection.Assembly.LoadFrom%2A> делает метод. <xref:System.Reflection.Assembly.LoadFile%2A> полезно в этом сценарии ограниченной поскольку <xref:System.Reflection.Assembly.LoadFrom%2A> не может использоваться для загрузки сборок, имеющих одинаковые идентификаторы, но разные пути; он будет загружаться только первые такой сборки.  

Начиная с .NET Framework 4, если `path` указывает на сборку в удаленных расположениях, загрузка сборки отключено по умолчанию и `LoadFile` вызывает метод <xref:System.IO.FileLoadException>. Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Аргумент <paramref name="path" /> не является абсолютным путем.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Параметр <paramref name="path" /> представляет собой пустую строку ("") или не существует.</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.

-или-

Возможность выполнения кода в удаленных сборках отключена. См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="path" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="path" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="securityEvidence" /> не является <see langword="null" />. По умолчанию устаревшая политика CAS не включена в [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; если она не включена, параметр <paramref name="securityEvidence" /> должен иметь значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям, включенным в путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на загрузку сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает сборку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

Начиная с .NET Framework 4, по умолчанию, а вызов отключена возможность выполнения кода в сборки, загруженные из удаленных расположений `LoadFrom` вызывает метод <xref:System.IO.FileLoadException>. Для загрузки сборки и выполнения его кода, необходимо:

- Явным образом создайте "песочницу" для сборки. (См. [Практическое руководство. Запустите частично доверенного кода в изолированной среде](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)

- Выполнять код сборки в режиме полного доверия, присвоив `enabled` атрибут [ `<loadFromRemoteSources>` элемента конфигурации](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) для `true`. Дополнительные сведения см. в разделе [ `<loadFromRemoteSources>` элемента конфигурации](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) статьи.

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего манифест сборки, либо путь к нему.</param>
        <summary>Загружает сборку с заданным именем или путем.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` Параметр должен ссылаться на URI без escape-символы. Этот метод предоставляет escape-символы для всех недопустимых символов в URI.  
  
> [!NOTE]
>  Протокол передачи файлов (FTP) не поддерживается. Если указан URI для `assemblyFile` является адресом FTP, сборка не загружается. Исключение не возникает.  
  
 `assemblyFile` может быть абсолютным или относительным для текущего каталога, и сборка загружается в домен вызывающего объекта.  
  
 Сборки могут загружаться в одном из трех контекстов или могут быть загружены без контекста:  
  
-   Контекст загрузки содержит сборки, обнаруженные в результате поиска: в глобальном кэше СБОРОК, в хранилище сборки хранить Если размещается среда выполнения или в <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A> домена приложения. В большинстве перегруженных версий метода <xref:System.Reflection.Assembly.Load%2A> сборки загружаются именно в этот контекст.  
  
-   Контекст загрузки с содержит сборки, для которых пользователь указал путь не включен в каталоги поиска проверки. К примерам методов, которые выполняют загрузку по указанному пути, относятся методы <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.AppDomain.ExecuteAssembly%2A>. 

    Начиная с .NET Framework 4, если URI `assemblyFile` указывает удаленного расположения, загрузка сборки отключен по умолчанию и `LoadFrom` вызывает метод <xref:System.IO.FileLoadException>. Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.    
  
-   Контекст только для отражения содержит сборки, загруженные с <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> и <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> методов; код в этих контекстах, не может быть выполнена.  
  
-   Если пользователь создается или найти сборку, это не в любом контексте. Это относится к сборкам, загруженным с помощью перегрузки <xref:System.Reflection.Assembly.Load%2A> метод, который указывается массив байтов, содержащий сборку, а чтобы временные динамические сборки, созданные с помощью отражения для создания и не сохраняются на диске.  
  
 Контекст загрузки с сборку необходимо загрузить из пути, не включается в область поиска и еще позволяет зависимости по этому пути, чтобы найти и загрузить, так как сведения о пути хранятся в контексте.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> Метод имеет следующие недостатки. Вместо этого рекомендуется использовать <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Если сборка с тем же идентификатором уже загружена, метод <xref:System.Reflection.Assembly.LoadFrom%2A> возвращает загруженную сборку даже в том случае, если был задан другой путь.  
  
-   Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>и последующие попытки загрузить ту же сборку по отображаемому имени сборки в контекст загрузки, попытка загрузки завершится неудачей. Это может произойти при десериализации сборки.  
  
-   Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>, и путь поиска сборок включает сборку с тем же идентификатором, но другое расположение, <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, или другие непредсказуемые последствия.  
  
-   Метод <xref:System.Reflection.Assembly.LoadFrom%2A> требует наличия флагов <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> или <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> либо наличия объекта <xref:System.Net.WebPermission> для заданного пути.  
  
-   Если образ в машинном коде для `assemblyFile`, он не используется. Сборка не может быть загружена как нейтральная к домену.  
  
-   В .NET Framework версий 1.0 и 1.1 политика не применяется.  
  
   
  
## Examples  
 В следующем примере загружается сборка, заданная его имя файла или путь.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyFile" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.

-или-

Возможность выполнения кода в удаленных сборках отключена. См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой. Например, это 32-разрядная сборка в 64-разрядном процессе. Дополнительные сведения см. в разделе исключений.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.Security.SecurityException">База кода, которая не начинается с "file://", была указана без требуемого разрешения <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="assemblyFile" /> представляет собой пустую строку ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина имени сборки превышает максимальную длину, определенную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения URI, который начинается с «file://». Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с «file://».</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего манифест сборки, либо путь к нему.</param>
        <param name="securityEvidence">Свидетельство для загрузки сборки.</param>
        <summary>Загружает сборку, заданную именем файла или путем к этому файлу и предоставленным свидетельством безопасности.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` Параметр должен ссылаться на URI без escape-символы. Этот метод предоставляет escape-символы для всех недопустимых символов в URI.  
  
> [!NOTE]
>  Протокол передачи файлов (FTP) не поддерживается. Если указан URI для `assemblyFile` является адресом FTP, сборка не загружается. Исключение не возникает.  
  
 `assemblyFile` может быть абсолютным или относительным для текущего каталога, и сборка загружается в домен вызывающего объекта.  
  
 Сборки могут загружаться в одном из трех контекстов или могут быть загружены без контекста:  
  
-   Контекст загрузки содержит сборки, обнаруженные в результате поиска: в глобальном кэше СБОРОК, в хранилище сборки хранить Если размещается среда выполнения или в <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A> домена приложения. В большинстве перегруженных версий метода <xref:System.Reflection.Assembly.Load%2A> сборки загружаются именно в этот контекст.  
  
-   Контекст загрузки с содержит сборки, для которых пользователь указал путь не включен в каталоги поиска проверки. К примерам методов, которые выполняют загрузку по указанному пути, относятся методы <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.AppDomain.ExecuteAssembly%2A>.

    Начиная с .NET Framework 4, если URI `assemblyFile` указывает удаленного расположения, загрузка сборки отключен по умолчанию и `LoadFrom` вызывает метод <xref:System.IO.FileLoadException>. Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.    
  
-   Контекст только для отражения содержит сборки, загруженные с <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> и <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> методов; код в этих контекстах, не может быть выполнена.  
  
-   Если пользователь создается или найти сборку, это не в любом контексте. Это относится к сборкам, загруженным с помощью перегрузки <xref:System.Reflection.Assembly.Load%2A> метод, который указывается массив байтов, содержащий сборку, а чтобы временные динамические сборки, созданные с помощью отражения для создания и не сохраняются на диске.  
  
 Контекст загрузки с сборку необходимо загрузить из пути, не включается в область поиска и еще позволяет зависимости по этому пути, чтобы найти и загрузить, так как сведения о пути хранятся в контексте.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> Метод имеет следующие недостатки. Вместо этого рекомендуется использовать <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Если сборка с тем же идентификатором уже загружена, метод <xref:System.Reflection.Assembly.LoadFrom%2A> возвращает загруженную сборку даже в том случае, если был задан другой путь.  
  
-   Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>и последующие попытки загрузить ту же сборку по отображаемому имени сборки в контекст загрузки, попытка загрузки завершится неудачей. Это может произойти при десериализации сборки.  
  
-   Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>, и путь поиска сборок включает сборку с тем же идентификатором, но другое расположение, <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, или другие непредсказуемые последствия.  
  
-   Метод <xref:System.Reflection.Assembly.LoadFrom%2A> требует наличия флагов <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> или <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> либо наличия объекта <xref:System.Net.WebPermission> для заданного пути.  
  
-   Если образ в машинном коде для `assemblyFile`, он не используется. Сборка не может быть загружена как нейтральная к домену.  
  
-   В .NET Framework версий 1.0 и 1.1 политика не применяется.  
  
 От свидетельства зависит, предоставляются ли сборке определенные разрешения. Далее приведены правила для сборки и слияние свидетельством безопасности.  
  
-   При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.  
  
-   При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются. Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.LoadFrom%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.  
  
-   Если этот метод вызывается несколько раз к той же сборке, но с разными свидетельствами, среда CLR не создает исключение <xref:System.IO.FileLoadException> , так как невозможно определить равенство и целостность различных спецификаций свидетельства. Свидетельство сначала выполняется успешно, это свидетельство, который используется.  
  
-   При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод с `Byte[]` параметр для загрузки общего объекта файла формате COFF образа, свидетельство объединяется. `Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.  
  
-   При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство. Свидетельство вызывающей сборки и свидетельство образа в формате COFF учитывается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyFile" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.  
  
-или- 
Параметр <paramref name="securityEvidence" /> не является неоднозначным и определяется как недопустимый.

-или-

Возможность выполнения кода в удаленных сборках отключена. См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой. Например, это 32-разрядная сборка в 64-разрядном процессе. Дополнительные сведения см. в разделе исключений.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.Security.SecurityException">База кода, которая не начинается с "file://", была указана без требуемого разрешения <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="assemblyFile" /> представляет собой пустую строку ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина имени сборки превышает максимальную длину, определенную в системе.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на загрузку сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения URI, который начинается с «file://». Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с «file://».</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего манифест сборки, либо путь к нему.</param>
        <param name="hashValue">Значение вычисленного хэш-кода.</param>
        <param name="hashAlgorithm">Алгоритм хэширования, используемый для хэширования файлов и генерации строгого имени.</param>
        <summary>Загружает сборку с заданным именем файла сборки или путем, хэш-значением и хэш-алгоритмом.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` Параметр должен ссылаться на URI без escape-символы. Этот метод предоставляет escape-символы для всех недопустимых символов в URI.  
  
> [!NOTE]
>  Протокол передачи файлов (FTP) не поддерживается. Если указан URI для `assemblyFile` является адресом FTP, сборка не загружается. Исключение не возникает.  
  
 `assemblyFile` может быть абсолютным или относительным для текущего каталога, и сборка загружается в домен вызывающего объекта.  
  
 Сборки могут загружаться в одном из трех контекстов или могут быть загружены без контекста:  
  
-   Контекст загрузки содержит сборки, обнаруженные в результате поиска: в глобальном кэше сборок, в хранилище сборки хранить Если размещается среда выполнения или в <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A> домена приложения. В большинстве перегруженных версий метода <xref:System.Reflection.Assembly.Load%2A> сборки загружаются именно в этот контекст.  
  
-   Контекст загрузки с содержит сборки, для которых пользователь указал путь, который не входит в область поиска. К примерам методов, которые выполняют загрузку по указанному пути, относятся методы <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.AppDomain.ExecuteAssembly%2A>.  

    Начиная с .NET Framework 4, если URI `assemblyFile` указывает удаленного расположения, загрузка сборки отключен по умолчанию и `LoadFrom` вызывает метод <xref:System.IO.FileLoadException>. Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.    
  
-   Контекст только для отражения содержит сборки, загруженные с <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> и <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> методов; код в этих контекстах, не может быть выполнена.  
  
-   Если пользователь создается или найти сборку, это не в любом контексте. Это относится к сборкам, загруженным с помощью перегрузки <xref:System.Reflection.Assembly.Load%2A> метод, который указывается массив байтов, содержащий сборку, а чтобы временные динамические сборки, созданные с помощью отражения для создания и не сохраняются на диске.  
  
 Контекст загрузки с позволяет сборки для загрузки, путь которой не включается в область поиска, а еще разрешает зависимости по этому пути, чтобы найти и загрузить, так как сведения о пути хранятся в контексте.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> Метод имеет следующие недостатки. Вместо этого рекомендуется использовать <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Если сборка с тем же идентификатором уже загружена, метод <xref:System.Reflection.Assembly.LoadFrom%2A> возвращает загруженную сборку даже в том случае, если был задан другой путь.  
  
-   Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>и последующие попытки загрузить ту же сборку по отображаемому имени сборки в контекст загрузки, попытка загрузки завершится неудачей. Это может произойти при десериализации сборки.  
  
-   Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>, и путь поиска сборок включает сборку с тем же идентификатором, но другое расположение, <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, или другие непредсказуемые последствия.  
  
-   Метод <xref:System.Reflection.Assembly.LoadFrom%2A> требует наличия флагов <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> или <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> либо наличия объекта <xref:System.Net.WebPermission> для заданного пути.  
  
-   Если образ в машинном коде для `assemblyFile`, он не используется. Сборка не может быть загружена как доменно-нейтральная.  
  
 Сборка загружается со свидетельством, предоставленным загрузчиком.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyFile" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.

-или-

Возможность выполнения кода в удаленных сборках отключена. См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой. Например, это 32-разрядная сборка в 64-разрядном процессе. Дополнительные сведения см. в разделе исключений.  
  
-или- 
 Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.Security.SecurityException">База кода, которая не начинается с "file://", была указана без требуемого разрешения <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="assemblyFile" /> представляет собой пустую строку ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина имени сборки превышает максимальную длину, определенную в системе.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на загрузку сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения URI, который начинается с «file://». Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с «file://».</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего манифест сборки, либо путь к нему.</param>
        <param name="securityEvidence">Свидетельство для загрузки сборки.</param>
        <param name="hashValue">Значение вычисленного хэш-кода.</param>
        <param name="hashAlgorithm">Алгоритм хэширования, используемый для хэширования файлов и генерации строгого имени.</param>
        <summary>Загружает сборку с заданным именем файла сборки или путем, свидетельством безопасности, хэш-значением и хэш-алгоритмом.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` Параметр должен ссылаться на URI без escape-символы. Этот метод предоставляет escape-символы для всех недопустимых символов в URI.  
  
> [!NOTE]
>  Протокол передачи файлов (FTP) не поддерживается. Если указан URI для `assemblyFile` является адресом FTP, сборка не загружается. Исключение не возникает.  
  
 `assemblyFile` может быть абсолютным или относительным для текущего каталога, и сборка загружается в домен вызывающего объекта.  
  
 Сборки могут загружаться в одном из трех контекстов или могут быть загружены без контекста:  
  
-   Контекст загрузки содержит сборки, обнаруженные в результате поиска: в глобальном кэше СБОРОК, в хранилище сборки хранить Если размещается среда выполнения или в <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A> домена приложения. В большинстве перегруженных версий метода <xref:System.Reflection.Assembly.Load%2A> сборки загружаются именно в этот контекст.  
  
-   Контекст загрузки с содержит сборки, для которых пользователь указал путь не включен в каталоги поиска проверки. К примерам методов, которые выполняют загрузку по указанному пути, относятся методы <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.AppDomain.ExecuteAssembly%2A>.  

    Начиная с .NET Framework 4, если URI `assemblyFile` указывает удаленного расположения, загрузка сборки отключен по умолчанию и `LoadFrom` вызывает метод <xref:System.IO.FileLoadException>. Чтобы включить выполнение кода, загруженного из удаленных расположений, можно использовать [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) элемента конфигурации.    
  
-   Контекст только для отражения содержит сборки, загруженные с <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> и <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> методов; код в этих контекстах, не может быть выполнена.  
  
-   Если пользователь создается или найти сборку, это не в любом контексте. Это относится к сборкам, загруженным с помощью перегрузки <xref:System.Reflection.Assembly.Load%2A> метод, который указывается массив байтов, содержащий сборку, а чтобы временные динамические сборки, созданные с помощью отражения для создания и не сохраняются на диске.  
  
 Контекст загрузки с сборку необходимо загрузить из пути, не включается в область поиска и еще позволяет зависимости по этому пути, чтобы найти и загрузить, так как сведения о пути хранятся в контексте.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> Метод имеет следующие недостатки. Вместо этого рекомендуется использовать <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Если сборка с тем же идентификатором уже загружена, метод <xref:System.Reflection.Assembly.LoadFrom%2A> возвращает загруженную сборку даже в том случае, если был задан другой путь.  
  
-   Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>и последующие попытки загрузить ту же сборку по отображаемому имени сборки в контекст загрузки, попытка загрузки завершится неудачей. Это может произойти при десериализации сборки.  
  
-   Если сборка загружается с <xref:System.Reflection.Assembly.LoadFrom%2A>, и путь поиска сборок включает сборку с тем же идентификатором, но другое расположение, <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, или другие непредсказуемые последствия.  
  
-   Метод <xref:System.Reflection.Assembly.LoadFrom%2A> требует наличия флагов <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> или <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> либо наличия объекта <xref:System.Net.WebPermission> для заданного пути.  
  
-   Если образ в машинном коде для `assemblyFile`, он не используется. Сборка не может быть загружена как нейтральная к домену.  
  
-   В .NET Framework версий 1.0 и 1.1 политика не применяется.  
  
 От свидетельства зависит, предоставляются ли сборке определенные разрешения. Далее приведены правила для сборки и слияние свидетельством безопасности.  
  
-   При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод, не имеющий <xref:System.Security.Policy.Evidence> параметр, сборка загружается со свидетельством, предоставленным загрузчиком.  
  
-   При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод с <xref:System.Security.Policy.Evidence> параметра, части свидетельства объединяются. Части свидетельство, предоставляемое в качестве аргумента <xref:System.Reflection.Assembly.LoadFrom%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.  
  
-   Если этот метод вызывается несколько раз к той же сборке, но с разными свидетельствами, среда CLR не создает исключение <xref:System.IO.FileLoadException> , так как невозможно определить равенство и целостность различных спецификаций свидетельства. Свидетельство сначала выполняется успешно, это свидетельство, который используется.  
  
-   При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод с `Byte[]` параметр для загрузки общего объекта файла формате COFF образа, свидетельство объединяется. `Zone`, `Url` и `Site` наследуются от вызывающей сборки и `Hash` и `StrongName` берутся из сборки COFF.  
  
-   При использовании <xref:System.Reflection.Assembly.LoadFrom%2A> метод с `Byte[]` параметр и <xref:System.Security.Policy.Evidence> для загрузки образа в формате COFF, используется только предоставленное свидетельство. Свидетельство вызывающей сборки и свидетельство образа в формате COFF учитывается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyFile" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.  
  
-или- 
Параметр <paramref name="securityEvidence" /> не является неоднозначным и определяется как недопустимый.

-или-

Возможность выполнения кода в удаленных сборках отключена. См. элемент <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой. Например, это 32-разрядная сборка в 64-разрядном процессе. Дополнительные сведения см. в разделе исключений.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.Security.SecurityException">База кода, которая не начинается с "file://", была указана без требуемого разрешения <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="assemblyFile" /> представляет собой пустую строку ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина имени сборки превышает максимальную длину, определенную в системе.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на загрузку сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения URI, который начинается с «file://». Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с «file://».</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает внутренний модуль этой сборки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="rawModule" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="moduleName">Имя модуля. Эта строка должна соответствовать имени файла в манифесте этой сборки.</param>
        <param name="rawModule">Массив байтов, который является COFF-образом, содержащим передаваемый модуль или ресурс.</param>
        <summary>Загружает модуль, внутренний для этой сборки, с образом в формате COFF, содержащим включенный модуль или файл ресурсов.</summary>
        <returns>Загруженный модуль.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="moduleName" /> или <paramref name="rawModule" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="moduleName" /> не соответствует записи файла в манифесте этой сборки.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawModule" /> не является допустимым модулем.</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы получить свидетельство. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="rawModule" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="moduleName">Имя модуля. Эта строка должна соответствовать имени файла в манифесте этой сборки.</param>
        <param name="rawModule">Массив байтов, который является COFF-образом, содержащим передаваемый модуль или ресурс.</param>
        <param name="rawSymbolStore">Массив байтов, содержащий необработанные байты, представляющие собой символы для модуля. Для файла ресурсов должно быть задано значение <see langword="null" />.</param>
        <summary>Загружает модуль, внутренний для этой сборки, с образом в формате COFF, содержащим включенный модуль или файл ресурсов. Также загружаются необработанные байты, представляющие собой символы для модуля.</summary>
        <returns>Загруженный модуль.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="moduleName" /> или <paramref name="rawModule" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="moduleName" /> не соответствует записи файла в манифесте этой сборки.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawModule" /> не является допустимым модулем.</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы получить свидетельство. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает сборку из каталога приложения или из глобального кэша сборок с использованием частичного имени.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Перегрузки <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> метод устарели и были сохранены для обеспечения обратной совместимости. Альтернативой устаревшим функциям служит метод <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="partialName">Отображаемое имя сборки.</param>
        <summary>Загружает сборку из каталога приложения или из глобального кэша сборок с использованием частичного имени.</summary>
        <returns>Загруженная сборка. Если значение <paramref name="partialName" /> не найдено, этот метод возвращает значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> Метод устарел и был сохранен для обратной совместимости. Альтернативой устаревшим функциям служит метод <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Приложения, загружающие сборки с помощью этого метода будет зависеть от обновления этих сборок. Таким образом не используйте этот метод; Измените приложение для использования <xref:System.Reflection.Assembly.Load%28System.String%29> перегрузку метода или <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> перегрузки метода.  
  
 Этот метод сначала вызывает <xref:System.Reflection.Assembly.Load%2A>. Если сборка не найдена, этот метод возвращает сборки из глобального кэша сборок с аналогичным простым именем и номером последней версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="partialName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="partialName" /> была скомпилирована в более поздней версии.</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="partialName">Отображаемое имя сборки.</param>
        <param name="securityEvidence">Свидетельство для загрузки сборки.</param>
        <summary>Загружает сборку из каталога приложения или из глобального кэша сборок с использованием частичного имени. Сборка загружена в домен вызывающего объекта с использованием переданного свидетельства.</summary>
        <returns>Загруженная сборка. Если значение <paramref name="partialName" /> не найдено, этот метод возвращает значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> Метод устарел и был сохранен для обратной совместимости. Альтернативой устаревшим функциям служит метод <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Свидетельство — это набор сведений, используемых для принятия решений политики безопасности, например, сведений о разрешениях, которые могут быть предоставлены коду.  
  
 Приложения, загружающие сборки с помощью этого метода будет зависеть от обновления этих сборок. Таким образом не используйте этот метод; Измените приложение для использования <xref:System.Reflection.Assembly.Load%2A> метод или <xref:System.Reflection.Assembly.LoadFrom%2A> метод.  
  
 Этот метод сначала вызывает <xref:System.Reflection.Assembly.Load%2A>. Если сборка не найдена, этот метод возвращает сборки из глобального кэша сборок с аналогичным простым именем и номером последней версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными наборами свидетельств.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="partialName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="partialName" /> была скомпилирована в более поздней версии.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода и на загрузку сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает полный путь либо UNC для расположения загруженного файла, содержащего манифест.</summary>
        <value>Местоположение загруженного файла, содержащего манифест. Если для загруженного файла был создан снимок состояния, местонахождение является местонахождением файла после теневого копирования. Если сборка загружается из массива байтов, например, при использовании метода перегрузки <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" />, возвращаемое значение является пустой строкой ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить расположение, прежде чем файл был теневого копирования, используйте <xref:System.Reflection.Assembly.CodeBase%2A> свойство.  
  
   
  
## Examples  
 Следующий пример отображает расположение загруженного файла, содержащего манифест.  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Текущая сборка является динамической сборкой, представленной объектом <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает модуль, содержащий манифест текущей сборки.</summary>
        <value>Модуль, содержащий манифест текущей сборки.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает, если загрузчик классов общеязыковой среды выполнения не может обработать ссылку на внутренний модуль сборки, используя обычные средства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие позволяет обратного вызова, чтобы найти и загрузить сам модуль и вернуть его.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию, содержащую модули в этой сборке.</summary>
        <value>Коллекция, содержащая модули в этой сборке.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">Сборка, сравниваемая со значением <paramref name="right" />.</param>
        <param name="right">Сборка, сравниваемая со значением <paramref name="left" />.</param>
        <summary>Определение равенства двух объектов <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns><see langword="true" />, если значения параметров <paramref name="left" /> и <paramref name="right" /> равны; в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">Сборка, сравниваемая со значением <paramref name="right" />.</param>
        <param name="right">Сборка, сравниваемая со значением <paramref name="left" />.</param>
        <summary>Определяет неравенство двух объектов <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns><see langword="true" />, если значения <paramref name="left" /> и <paramref name="right" /> не равны; в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает набор разрешений текущей сборки.</summary>
        <value>Набор разрешений текущей сборки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> объекты могут содержать конфиденциальные сведения, например пути. Таким образом для доступа к этим объектам требуется полное доверие.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение <see cref="T:System.Boolean" />, которое указывает, была ли эта сборка загружена в контекст, предназначенный только для отражения.</summary>
        <value>Значение <see langword="true" />, если сборка была загружена в контекст, предназначенный только для отражения вместо контекста выполнения; в обратном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если сборка была загружена в контекст только для отражения, с помощью <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> метода, нельзя выполнять код в сборке. Для выполнения кода, сборка должна быть загружена в контекст выполнения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает сборку в контекст, предназначенный только для отражения, где она может быть проанализирована, но не может быть выполнена.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Массив байтов, который является образом в формате COFF, содержащим созданную сборку.</param>
        <summary>Загружает сборку из образа в формате COFF, содержащего порожденную сборку. Сборка загружается в контекст, предназначенный только для отражения, который относится к домену приложения вызывающего объекта.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нельзя выполнять код из сборки, загруженной в контекст только для отражения. Для выполнения кода, сборка должна быть загружена в контекст выполнения, с помощью <xref:System.Reflection.Assembly.Load%2A> метод.  
  
 Контекст только для отражения ничем не отличается от других контекстах. Сборки, загруженные в контекст, могут быть выгружены путем выгрузки домена приложения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> — <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Не удается загрузить <paramref name="rawAssembly" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Отображаемое имя сборки, возвращаемое свойством <see cref="P:System.Reflection.AssemblyName.FullName" />.</param>
        <summary>Загружает сборку с заданным отображаемым именем в контекст, предназначенный только для отражения.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Зависимости не загружаются автоматически в контекст только для отражения.  
  
 Нельзя выполнять код из сборки, загруженной в контекст только для отражения. Для выполнения кода, сборка должна быть загружена в контекст выполнения, с помощью <xref:System.Reflection.Assembly.Load%2A> метод.  
  
 От свидетельства зависит, предоставляются ли сборке определенные разрешения. Далее приведены правила для сборки и слияние свидетельством безопасности.  
  
> [!NOTE]
>  Отражение на исполняемые файлы, скомпилированные в C++ может вызывать <xref:System.IO.FileLoadException>. Скорее всего, это вызвано компилятор C++ чередует адреса переадресации и раздел .reloc исполняемого файла. Чтобы сохранить адрес .reloc, укажите `/fixed:no` при компоновке.  
  
 Контекст только для отражения ничем не отличается от других контекстах. Сборки, загруженные в контекст, могут быть выгружены путем выгрузки домена приложения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="assemblyString" /> является пустой строкой ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> не найден.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="assemblyString" /> найден, но не может быть загружен.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyString" /> была скомпилирована в более поздней версии.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Путь к файлу, содержащему манифест сборки.</param>
        <summary>Загружает сборку с заданным путем в контекст, предназначенный только для отражения.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Зависимости не загружаются автоматически в контекст только для отражения. Чтобы автоматически загрузить зависимости, обрабатывать <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> событий и загрузка зависимостей в обработчике событий.  
  
 Нельзя выполнять код из сборки, который был загружен в контекст только для отражения. Для выполнения кода, загрузить сборку с <xref:System.Reflection.Assembly.LoadFile%2A> метод.  
  
 `assemblyFile` Параметр должен ссылаться на URI без escape-символы. Этот метод предоставляет escape-символы для всех недопустимых символов в URI.  
  
 Путь, указанный для `assemblyFile` задается относительно текущего каталога. Сборка загружается в домен вызывающего объекта.  
  
 Контекст только для отражения ничем не отличается от других контекстах. Сборки, загруженные в контекст, могут быть выгружены путем выгрузки домена приложения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyFile" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="assemblyFile" /> найден, но не может быть загружен.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.Security.SecurityException">База кода, которая не начинается с "file://", была указана без требуемого разрешения <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина имени сборки превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="assemblyFile" /> является пустой строкой ("").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения URI, который начинается с «file://». Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с «file://».</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее набор правил безопасности, которые применяются средой CLR к данной сборке.</summary>
        <value>Набор правил безопасности, которые применяются средой CLR к данной сборке.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию, сборки, компиляции с параметром [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] имеют прозрачность, несмотря на то, что вы можете явно сделать их вместо этого. Сборки, которые были скомпилированы с более ранними версиями платформы .NET Framework имеют прозрачность уровня 1.  
  
 См. раздел [Изменения системы безопасности](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md">Прозрачный для системы безопасности код</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Изменения системы безопасности в .NET Framework 4</related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает тип текущего экземпляра.</summary>
        <returns>Объект, представляющий тип <see cref="T:System.Reflection.Assembly" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает полное имя сборки, также называемое отображаемым именем.</summary>
        <returns>Полное имя сборки или имя класса, если полное имя сборки не может быть определено.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего манифест сборки, либо путь к нему.</param>
        <summary>Загружает сборку в контекст, из которого производится загрузка, обходя некоторые проверки безопасности.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет загрузить локальную сборку, которую операционная система пометила как загруженную из Интернета (например, временный файл, загруженный из Интернета или интрасети). Прежде чем [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], такие сборки автоматически загружались в изолированном домене приложения. Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], они загружаются с полным доверием.  
  
 В качестве альтернативы с помощью данного метода, можно применить [ &lt;NetFx40_LegacySecurityPolicy&gt; элемент](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) в файле конфигурации приложения. В результате среда CLR для возврата к политике безопасности [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
> [!CAUTION]
>  При использовании любого из этих решений, необходимо быть уверенным, что он безопасен для загрузки `assemblyFile` с полным доверием.  
  
 Обсуждение контекстов загрузки, включая контекст загрузки с см. в разделе <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> перегрузки метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyFile" /> не найден, или модуль, который вы пытаетесь загрузить, не указывает расширение имени файла.</exception>
        <exception cref="T:System.IO.FileLoadException">Не удалось загрузить файл, который был найден.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
 Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.Security.SecurityException">База кода, которая не начинается с "file://", была указана без требуемого разрешения <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="assemblyFile" /> представляет собой пустую строку ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина имени сборки превышает максимальную длину, определенную в системе.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
  </Members>
</Type>