<Type Name="Module" FullName="System.Reflection.Module">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="99434ae0ca2ae257e847cbb424c20883be128c2c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Module, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Module extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Module, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Module" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Module&#xA;Implements _Module, ICustomAttributeProvider, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Module abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Module, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Module</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Module))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="a6c68-101">Выполняет отражение для модуля.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a6c68-101">Performs reflection on a module.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-102">Модуль — переносимый исполняемый файл, например DLL или application.exe, состоящий из одного или нескольких классов и интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="a6c68-102">A module is a portable executable file, such as type.dll or application.exe, consisting of one or more classes and interfaces.</span></span> <span data-ttu-id="a6c68-103">В отдельном модуле может быть несколько пространств имен, а одно пространство имен может охватывать несколько модулей.</span><span class="sxs-lookup"><span data-stu-id="a6c68-103">There may be multiple namespaces contained in a single module, and a namespace may span multiple modules.</span></span>  
  
 <span data-ttu-id="a6c68-104">Один или несколько модулей, развертываемые как единое целое, образуют сборку.</span><span class="sxs-lookup"><span data-stu-id="a6c68-104">One or more modules deployed as a unit compose an assembly.</span></span> <span data-ttu-id="a6c68-105">Сведения о создании сборки с несколькими модулями см. в разделе [многофайловых сборок](~/docs/framework/app-domains/multifile-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="a6c68-105">For information about creating an assembly with more than one module, see [Multifile Assemblies](~/docs/framework/app-domains/multifile-assemblies.md).</span></span>  
  
 <span data-ttu-id="a6c68-106">Обратите внимание, что модуль .NET Framework не совпадает с модулем в Visual Basic, который используется программистами для организации функций и подпрограмм в приложении.</span><span class="sxs-lookup"><span data-stu-id="a6c68-106">Note that a .NET Framework module is not the same as a module in Visual Basic, which is used by a programmers to organize functions and subroutines in an application.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6c68-107">В следующем примере кода показано, как использовать отражение для получения сведений о модулях.</span><span class="sxs-lookup"><span data-stu-id="a6c68-107">The following code examples show how to use reflection to get information about modules:</span></span>  
  
 [!code-csharp[System.Reflection.Module#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module/CS/source.cs#1)]
 [!code-vb[System.Reflection.Module#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="a6c68-108">для полного доверия для разработчиков производных классов.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a6c68-108">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="a6c68-109">Этот класс не наследуется частично доверенным кодом.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a6c68-109">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Module ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Module();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-110">Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Module" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-110">Initializes a new instance of the <see cref="T:System.Reflection.Module" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-111">Этот конструктор вызывается производными классами во время создания <xref:System.Reflection.Module> объектов.</span><span class="sxs-lookup"><span data-stu-id="a6c68-111">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Module> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-112">Возвращает соответствующую сборку <see cref="T:System.Reflection.Assembly" /> для данного экземпляра <see cref="T:System.Reflection.Module" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-112">Gets the appropriate <see cref="T:System.Reflection.Assembly" /> for this instance of <see cref="T:System.Reflection.Module" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a6c68-113">Объект <see langword="Assembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-113">An <see langword="Assembly" /> object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a6c68-114">Следующий пример отображает полное имя сборки, указанной в указанном модуле.</span><span class="sxs-lookup"><span data-stu-id="a6c68-114">The following example displays the full name of the specified assembly in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.Assembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-115">Получает коллекцию, содержащая пользовательские атрибуты этого модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-115">Gets a collection that contains this module's custom attributes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a6c68-116">Коллекция, содержащая пользовательские атрибуты этого модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-116">A collection that contains this module's custom attributes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="a6c68-117">Объект, сравниваемый с данным экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-117">The object to compare with this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-118">Определяет, равны ли этот модуль и заданный объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-118">Determines whether this module and the specified object are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-119">Значение <see langword="true" />, если значение параметра <paramref name="o" /> равно данному экземпляру; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-119">
              <see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTypeName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeName" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeName As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-120">Объект <see langword="TypeFilter" />, который фильтрует список типов, определенных в этом модуле на основе имени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-120">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span>
          </span>
          <span data-ttu-id="a6c68-121">Это поле учитывает регистр и доступно только для чтения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-121">This field is case-sensitive and read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-122">Фильтр поддерживает символ «\*» подстановочный знак.</span><span class="sxs-lookup"><span data-stu-id="a6c68-122">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6c68-123">Следующий пример отображает имена модулей, которые соответствуют заданным критериям поиска.</span><span class="sxs-lookup"><span data-stu-id="a6c68-123">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FilterTypeNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeNameIgnoreCase As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-124">Объект <see langword="TypeFilter" />, который фильтрует список типов, определенных в этом модуле на основе имени.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-124">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span>
          </span>
          <span data-ttu-id="a6c68-125">Это поле доступно только для чтения. В нем не учитывается регистр.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-125">This field is case-insensitive and read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-126">Фильтр поддерживает символ «\*» подстановочный знак.</span><span class="sxs-lookup"><span data-stu-id="a6c68-126">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6c68-127">Следующий пример отображает имена модулей, которые соответствуют заданным критериям поиска, без учета регистра.</span><span class="sxs-lookup"><span data-stu-id="a6c68-127">The following example displays the module names that match the specified search criteria, ignoring the case.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] FindTypes (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindTypes(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindTypes (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindTypes(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">
          <span data-ttu-id="a6c68-128">Делегат, который используется для фильтрования классов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-128">The delegate used to filter the classes.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="a6c68-129">Объект, который используется для фильтрования классов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-129">An Object used to filter the classes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-130">Возвращает массив классов, удовлетворяющих указанному фильтру и критериям фильтра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-130">Returns an array of classes accepted by the given filter and filter criteria.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-131">Массив типа <see langword="Type" />, который содержит классы, удовлетворяющие критериям фильтра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-131">An array of type <see langword="Type" /> containing classes that were accepted by the filter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-132"><xref:System.Reflection.ReflectionTypeLoadException> — Это специальный класс нагрузки исключение.</span><span class="sxs-lookup"><span data-stu-id="a6c68-132"><xref:System.Reflection.ReflectionTypeLoadException> is a special class load exception.</span></span> <span data-ttu-id="a6c68-133">`ReflectionTypeLoadException.Types` Свойство содержит массив классов, которые были определены в модуле и загружены.</span><span class="sxs-lookup"><span data-stu-id="a6c68-133">The `ReflectionTypeLoadException.Types` property contains the array of classes that were defined in the module and were loaded.</span></span> <span data-ttu-id="a6c68-134">Этот массив может содержать значения null.</span><span class="sxs-lookup"><span data-stu-id="a6c68-134">This array may contain some null values.</span></span> <span data-ttu-id="a6c68-135">`ReflectionTypeLoadException.LoaderExceptions` Свойство представляет собой массив исключений, которые представляют исключения, которые были созданы загрузчиком классов.</span><span class="sxs-lookup"><span data-stu-id="a6c68-135">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the class loader.</span></span> <span data-ttu-id="a6c68-136">Уязвимости в массиве классов соответствуют исключения.</span><span class="sxs-lookup"><span data-stu-id="a6c68-136">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="a6c68-137">Делегат, определенный параметром `filter` вызывается для каждого класса в модуле, передавая `Type` объект, представляющий класс, а также данного `filterCriteria`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-137">The delegate given by `filter` is called for each class in the module, passing along the `Type` object representing the class as well as the given `filterCriteria`.</span></span> <span data-ttu-id="a6c68-138">Если `filter` возвращает определенного класса, что класс будут включены в возвращаемый массив.</span><span class="sxs-lookup"><span data-stu-id="a6c68-138">If `filter` returns a particular class, that class will be included in the returned array.</span></span> <span data-ttu-id="a6c68-139">Если `filter` возвращает `null`, возвращаются все классы, и `filterCriteria` учитывается.</span><span class="sxs-lookup"><span data-stu-id="a6c68-139">If `filter` returns `null`, all classes are returned and `filterCriteria` is ignored.</span></span>  
  
 <span data-ttu-id="a6c68-140">`FindTypes` не может использоваться для просмотра параметризованных типов, таких как массивы.</span><span class="sxs-lookup"><span data-stu-id="a6c68-140">`FindTypes` cannot be used to look up parameterized types such as arrays.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6c68-141">В следующем примере демонстрируется `FindTypes` метод.</span><span class="sxs-lookup"><span data-stu-id="a6c68-141">The following example demonstrates the `FindTypes` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">
          <span data-ttu-id="a6c68-142">Невозможно загрузить один или несколько классов в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-142">One or more classes in a module could not be loaded.</span>
          </span>
        </exception>
        <altmember cref="F:System.Reflection.Module.FilterTypeName" />
        <altmember cref="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public virtual string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-143">Возвращает строку, содержащую полное имя и путь к этому модулю.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-143">Gets a string representing the fully qualified name and path to this module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a6c68-144">Полное имя модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-144">The fully qualified module name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-145">Чтобы получить имя без пути, используйте <xref:System.Reflection.Module.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="a6c68-145">To get the name without the path, use <xref:System.Reflection.Module.Name%2A>.</span></span>  
  
 <span data-ttu-id="a6c68-146">Если сборка для этого модуля была загружена из массива байтов то `FullyQualifiedName` для модуля будут: \<Неизвестный >.</span><span class="sxs-lookup"><span data-stu-id="a6c68-146">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-147">Регистр имени модуля зависит от платформы.</span><span class="sxs-lookup"><span data-stu-id="a6c68-147">The case of module name is platform-dependent.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6c68-148">Следующий пример отображает полное имя заданного модуля.</span><span class="sxs-lookup"><span data-stu-id="a6c68-148">The following example displays the fully qualified name of the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="a6c68-149">У вызывающего объекта отсутствуют необходимые разрешения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-149">The caller does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="a6c68-150">для доступа к сведениям о пути.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-150">for access to information in the path.</span>
          </span>
          <span data-ttu-id="a6c68-151">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-151">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-152">Возвращает настраиваемые атрибуты.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-152">Returns custom attributes.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="a6c68-153">Данный аргумент не учитывается для объектов этого типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-153">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-154">Возвращает все настраиваемые атрибуты.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-154">Returns all custom attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-155">Массив типа <see langword="Object" />, содержащий все настраиваемые атрибуты.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-155">An array of type <see langword="Object" /> containing all custom attributes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a6c68-156">Следующий пример отображает имена модулей, которые соответствуют заданным критериям поиска.</span><span class="sxs-lookup"><span data-stu-id="a6c68-156">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="a6c68-157">Тип возвращаемого атрибута.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-157">The type of attribute to get.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="a6c68-158">Данный аргумент не учитывается для объектов этого типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-158">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-159">Возвращает настраиваемые атрибуты заданного типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-159">Gets custom attributes of the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-160">Массив объектов типа <see langword="Object" />, содержащий все пользовательские атрибуты заданного типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-160">An array of type <see langword="Object" /> containing all custom attributes of the specified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a6c68-161">Следующий пример отображает имена модулей заданного типа, соответствующих указанным условиям поиска.</span><span class="sxs-lookup"><span data-stu-id="a6c68-161">The following example displays the module names of the specified type that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a6c68-162">Свойство <paramref name="attributeType" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-162">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-163">Параметр <paramref name="attributeType" /> не является объектом <see cref="T:System.Type" />, предоставленным во время разработки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-163">
              <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span>
          </span>
          <span data-ttu-id="a6c68-164">Например, <paramref name="attributeType" /> является объектом <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-164">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-165">Возвращает список объектов <see cref="T:System.Reflection.CustomAttributeData" /> для текущего модуля, который можно использовать в контексте, предназначенном только для отражения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-165">Returns a list of <see cref="T:System.Reflection.CustomAttributeData" /> objects for the current module, which can be used in the reflection-only context.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-166">Универсальный список объектов <see cref="T:System.Reflection.CustomAttributeData" />, представляющих данные об атрибутах, которые были применены к текущему модулю.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-166">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current module.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-167">Этот метод можно используйте для исследования настраиваемых атрибутов кода в контексте только для отражения в случаях, где сами настраиваемые атрибуты определены в коде, который загружается в контекст только для отражения.</span><span class="sxs-lookup"><span data-stu-id="a6c68-167">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="a6c68-168">Такие методы, как <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> и <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> не может использоваться в таких случаях, поскольку они создают экземпляры атрибутов.</span><span class="sxs-lookup"><span data-stu-id="a6c68-168">Methods such as <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="a6c68-169">Не удается выполнить код в контексте только для отражения.</span><span class="sxs-lookup"><span data-stu-id="a6c68-169">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="a6c68-170">Дополнительные сведения и пример кода см. в разделе <xref:System.Reflection.CustomAttributeData> класса.</span><span class="sxs-lookup"><span data-stu-id="a6c68-170">For more information and example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-171">Возвращает заданное поле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-171">Returns a specified field.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a6c68-172">Имя поля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-172">The field name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-173">Возвращает поле с указанным именем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-173">Returns a field having the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-174">Объект <see langword="FieldInfo" /> с указанным именем или <see langword="null" />, если поле не существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-174">A <see langword="FieldInfo" /> object having the specified name, or <see langword="null" /> if the field does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a6c68-175">Параметр <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-175">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a6c68-176">Имя поля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-176">The field name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="a6c68-177">Один из битовых флагов <see langword="BindingFlags" />, используемых для управления поиском.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-177">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-178">Возвращает поле с указанным именем и атрибутами привязки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-178">Returns a field having the specified name and binding attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-179">Объект <see langword="FieldInfo" /> с указанным именем и атрибутами привязки или <see langword="null" />, если поле не существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-179">A <see langword="FieldInfo" /> object having the specified name and binding attributes, or <see langword="null" /> if the field does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a6c68-180">Параметр <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-180">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-181">Возвращает глобальные поля, определенные в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-181">Returns the global fields defined on the module.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-182">Возвращает глобальные поля, определенные в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-182">Returns the global fields defined on the module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-183">Массив объектов <see cref="T:System.Reflection.FieldInfo" />, представляющих глобальные поля, определенные в модуле. Если глобальные поля отсутствуют, возвращается пустой массив.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-183">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-184"><xref:System.Reflection.Module.GetFields%2A> Метод не возвращает поля в определенном порядке, например алфавитном или в порядке объявления.</span><span class="sxs-lookup"><span data-stu-id="a6c68-184">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="a6c68-185">Код не должен зависеть порядка, в котором возвращаются поля, так как этот порядок может меняться.</span><span class="sxs-lookup"><span data-stu-id="a6c68-185">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">
          <span data-ttu-id="a6c68-186">Битовая комбинация значений <see cref="T:System.Reflection.BindingFlags" />, которая определяет границы поиска.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-186">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-187">Возвращает глобальные поля, определенные в модуле, которые соответствуют заданным флагам привязки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-187">Returns the global fields defined on the module that match the specified binding flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-188">Массив типа <see cref="T:System.Reflection.FieldInfo" />, представляющий глобальные поля, определенные в модуле, который соответствует указанным флагам привязки. Если глобальные поля не соответствуют флагам привязки, возвращается пустой массив.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-188">An array of type <see cref="T:System.Reflection.FieldInfo" /> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-189"><xref:System.Reflection.Module.GetFields%2A> Метод не возвращает поля в определенном порядке, например алфавитном или в порядке объявления.</span><span class="sxs-lookup"><span data-stu-id="a6c68-189">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="a6c68-190">Код не должен зависеть порядка, в котором возвращаются поля, так как этот порядок может меняться.</span><span class="sxs-lookup"><span data-stu-id="a6c68-190">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-191">Возвращает хэш-код данного экземпляра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-191">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-192">Хэш-код в виде 32-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-192">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-193">Возвращает метод, отвечающий заданным критериям.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-193">Returns a method having the specified criteria.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a6c68-194">Имя метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-194">The method name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-195">Возвращает метод с указанным именем.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-195">Returns a method having the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-196">Объект <see langword="MethodInfo" /> с указанным именем или <see langword="null" />, если метод не существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-196">A <see langword="MethodInfo" /> object having the specified name, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a6c68-197">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-197">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a6c68-198">Имя метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-198">The method name.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="a6c68-199">Искомые типы параметров.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-199">The parameter types to search for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-200">Возвращает метод, имеющий указанные имя и типы параметров.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-200">Returns a method having the specified name and parameter types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-201">Объект <see langword="MethodInfo" /> в соответствии с указанными условиями или <see langword="null" />, если метод не существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-201">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a6c68-202">
            <paramref name="name" /> имеет значение <see langword="null" />, <paramref name="types" /> имеет значение <see langword="null" /> или <paramref name="types" /> (i) имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-202">
              <paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a6c68-203">Имя метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-203">The method name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="a6c68-204">Один из битовых флагов <see langword="BindingFlags" />, используемых для управления поиском.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-204">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="a6c68-205">Объект, реализующий <see langword="Binder" />, содержащий свойства, связанные с этим методом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-205">An object that implements <see langword="Binder" />, containing properties related to this method.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="a6c68-206">Соглашение о вызовах для метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-206">The calling convention for the method.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="a6c68-207">Искомые типы параметров.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-207">The parameter types to search for.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="a6c68-208">Массив модификаторов параметров, используемый для работы привязки с подписями параметров, в которых были изменены типы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-208">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-209">Возвращает метод, имеющий заданное имя, сведения о привязке, соглашение о вызовах и типы и модификаторы параметров.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-209">Returns a method having the specified name, binding information, calling convention, and parameter types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-210">Объект <see langword="MethodInfo" /> в соответствии с указанными условиями или <see langword="null" />, если метод не существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-210">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a6c68-211">
            <paramref name="name" /> имеет значение <see langword="null" />, <paramref name="types" /> имеет значение <see langword="null" /> или <paramref name="types" /> (i) имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-211">
              <paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a6c68-212">Имя метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-212">The method name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="a6c68-213">Один из битовых флагов <see langword="BindingFlags" />, используемых для управления поиском.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-213">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="a6c68-214">Объект, реализующий <see langword="Binder" />, содержащий свойства, связанные с этим методом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-214">An object that implements <see langword="Binder" />, containing properties related to this method.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="a6c68-215">Соглашение о вызовах для метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-215">The calling convention for the method.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="a6c68-216">Искомые типы параметров.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-216">The parameter types to search for.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="a6c68-217">Массив модификаторов параметров, используемый для работы привязки с подписями параметров, в которых были изменены типы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-217">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-218">Возвращает реализацию метода в соответствии с заданными критериями.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-218">Returns the method implementation in accordance with the specified criteria.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-219">Объект <see langword="MethodInfo" />, содержащий заданные сведения о реализации, или <see langword="null" />, если метод не существует.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-219">A <see langword="MethodInfo" /> object containing implementation information as specified, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="a6c68-220">Свойство <paramref name="types" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-220">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-221">Возвращает глобальные методы, определенные в этом модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-221">Returns the global methods defined on the module</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-222">Возвращает глобальные методы, определенные в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-222">Returns the global methods defined on the module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-223">Массив объектов <see cref="T:System.Reflection.MethodInfo" />, представляющих все глобальные методы, определенные в модуле. Если глобальные методы отсутствуют, возвращается пустой массив.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-223">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">
          <span data-ttu-id="a6c68-224">Битовая комбинация значений <see cref="T:System.Reflection.BindingFlags" />, которая определяет границы поиска.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-224">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-225">Возвращает глобальные методы, определенные в модуле, которые соответствуют заданным флагам привязки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-225">Returns the global methods defined on the module that match the specified binding flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-226">Массив типа <see cref="T:System.Reflection.MethodInfo" /> — представляет глобальные методы, определенные в модуле, который соответствует указанным флагам связывания. Если глобальные методы не соответствуют флагам привязки, возвращается пустой массив.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-226">An array of type <see cref="T:System.Reflection.MethodInfo" /> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="a6c68-227">Сведения и данные, необходимые для выполнения сериализации и десериализации объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-227">The information and data needed to serialize or deserialize an object.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="a6c68-228">Контекст для сериализации.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-228">The context for the serialization.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-229">Обеспечивает реализацию класса <see cref="T:System.Runtime.Serialization.ISerializable" /> для сериализованных объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-229">Provides an <see cref="T:System.Runtime.Serialization.ISerializable" /> implementation for serialized objects.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a6c68-230">Свойство <paramref name="info" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-230">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="a6c68-231">требуется полное доверие для непосредственно вызывающего метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-231">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="a6c68-232">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-232">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public virtual void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds&amp;" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">
          <span data-ttu-id="a6c68-233">Этот метод возвращает сочетание значений <see cref="T:System.Reflection.PortableExecutableKinds" />, определяющее характер кода в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-233">When this method returns, a combination of the <see cref="T:System.Reflection.PortableExecutableKinds" /> values indicating the nature of the code in the module.</span>
          </span>
        </param>
        <param name="machine">
          <span data-ttu-id="a6c68-234">Этот метод возвращает одно из значений <see cref="T:System.Reflection.ImageFileMachine" />, определяющее платформу, на которой применяется модуль.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-234">When this method returns, one of the <see cref="T:System.Reflection.ImageFileMachine" /> values indicating the platform targeted by the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-235">Возвращает пару значений, определяющих природу кода в модуле и платформе, на которой применяется этот модуль.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-235">Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-236">Возвращает объект <see langword="X509Certificate" />, соответствующий сертификату, включаемому в подпись Authenticode сборки, которой принадлежит этот модуль.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-236">Returns an <see langword="X509Certificate" /> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</span>
          </span>
          <span data-ttu-id="a6c68-237">Если сборка не имеет подписи Authenticode, возвращается значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-237">If the assembly has not been Authenticode signed, <see langword="null" /> is returned.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-238">Объект <see langword="X509Certificate" /> или значение <see langword="null" />, если сборка, содержащая этот модуль, не имеет подписи Authenticode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-238">An <see langword="X509Certificate" /> object, or <see langword="null" /> if the assembly to which this module belongs has not been Authenticode signed.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-239">Возвращает указанный тип.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-239">Returns the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">
          <span data-ttu-id="a6c68-240">Имя искомого типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-240">The name of the type to locate.</span>
          </span>
          <span data-ttu-id="a6c68-241">Имя должно содержать пространство имен.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-241">The name must be fully qualified with the namespace.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-242">Возвращает заданный тип (выполняет поиск с учетом регистра).</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-242">Returns the specified type, performing a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-243">Объект <see langword="Type" />, представляющий указанный тип, если тип находится в этом модуле. В противном случае возвращается значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-243">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-244">Если тип был перенаправлен в другую сборку, по-прежнему возвращается этим методом.</span><span class="sxs-lookup"><span data-stu-id="a6c68-244">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="a6c68-245">Сведения о перенаправлении типов см. в разделе [переадресации типов в общеязыковой](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="a6c68-245">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="a6c68-246">Тип может быть извлечен из конкретного модуля с помощью <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a6c68-246">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a6c68-247">Вызов <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> модуля, содержащего манифест не будут выполнять поиск всей сборке.</span><span class="sxs-lookup"><span data-stu-id="a6c68-247">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="a6c68-248">Чтобы получить тип из сборки, независимо от того, какой модуль он находится, необходимо вызвать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a6c68-248">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6c68-249">Следующий пример отображает имя типа в указанном модуле.</span><span class="sxs-lookup"><span data-stu-id="a6c68-249">The following example displays the name of a type in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a6c68-250">Свойство <paramref name="className" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-250">
              <paramref name="className" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="a6c68-251">Вызываются инициализаторы класса и создается исключение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-251">The class initializers are invoked and an exception is thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-252">
            <paramref name="className" /> представляет собой строку нулевой длины.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-252">
              <paramref name="className" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="a6c68-253">Для <paramref name="className" /> требуется зависимая сборка, которую не удается найти.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-253">
              <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="a6c68-254">Для <paramref name="className" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-254">
              <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="a6c68-255">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-255">-or-</span>
          </span>
          <span data-ttu-id="a6c68-256">Текущая сборка была загружена в контекст только для отражения, а для <paramref name="className" /> требуется зависимая сборка, которая не была предварительно загружена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-256">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="a6c68-257">Для <paramref name="className" /> требуется зависимая сборка, однако файл не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-257">
              <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="a6c68-258">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-258">-or-</span>
          </span>
          <span data-ttu-id="a6c68-259">Для <paramref name="className" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-259">
              <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">
          <span data-ttu-id="a6c68-260">Имя искомого типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-260">The name of the type to locate.</span>
          </span>
          <span data-ttu-id="a6c68-261">Имя должно содержать пространство имен.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-261">The name must be fully qualified with the namespace.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="a6c68-262">Значение <see langword="true" /> для поиска без учета регистра. В противном случае используется значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-262">
              <see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-263">Возвращает указанный тип, выполняя поиск в модуле с заданным требованием к учету регистра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-263">Returns the specified type, searching the module with the specified case sensitivity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-264">Объект <see langword="Type" />, представляющий указанный тип, если тип находится в этом модуле. В противном случае возвращается значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-264">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-265">Если тип был перенаправлен в другую сборку, по-прежнему возвращается этим методом.</span><span class="sxs-lookup"><span data-stu-id="a6c68-265">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="a6c68-266">Сведения о перенаправлении типов см. в разделе [переадресации типов в общеязыковой](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="a6c68-266">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="a6c68-267">Тип может быть извлечен из конкретного модуля с помощью <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a6c68-267">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a6c68-268">Вызов <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> модуля, содержащего манифест не будут выполнять поиск всей сборке.</span><span class="sxs-lookup"><span data-stu-id="a6c68-268">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="a6c68-269">Чтобы получить тип из сборки, независимо от того, какой модуль он находится, необходимо вызвать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a6c68-269">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6c68-270">Следующий пример отображает имя типа в указанном модуле, указав `false` для `ignoreCase` параметр, в этом случае не будут пропущены.</span><span class="sxs-lookup"><span data-stu-id="a6c68-270">The following example displays the name of a type in the specified module, specifying `false` for the `ignoreCase` parameter so that case will not be ignored.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a6c68-271">Свойство <paramref name="className" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-271">
              <paramref name="className" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="a6c68-272">Вызываются инициализаторы класса и создается исключение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-272">The class initializers are invoked and an exception is thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-273">
            <paramref name="className" /> представляет собой строку нулевой длины.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-273">
              <paramref name="className" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="a6c68-274">Для <paramref name="className" /> требуется зависимая сборка, которую не удается найти.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-274">
              <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="a6c68-275">Для <paramref name="className" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-275">
              <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="a6c68-276">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-276">-or-</span>
          </span>
          <span data-ttu-id="a6c68-277">Текущая сборка была загружена в контекст только для отражения, а для <paramref name="className" /> требуется зависимая сборка, которая не была предварительно загружена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-277">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="a6c68-278">Для <paramref name="className" /> требуется зависимая сборка, однако файл не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-278">
              <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="a6c68-279">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-279">-or-</span>
          </span>
          <span data-ttu-id="a6c68-280">Для <paramref name="className" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-280">
              <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">
          <span data-ttu-id="a6c68-281">Имя искомого типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-281">The name of the type to locate.</span>
          </span>
          <span data-ttu-id="a6c68-282">Имя должно содержать пространство имен.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-282">The name must be fully qualified with the namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="a6c68-283">Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-283">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="a6c68-284">Значение <see langword="true" /> для поиска без учета регистра. В противном случае используется значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-284">
              <see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-285">Возвращает указанный тип, определяя, следует ли учитывать регистр при поиске модуля и должно ли создаваться исключение, если не удалось обнаружить этот тип.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-285">Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-286">Объект <see cref="T:System.Type" />, представляющий указанный тип, если тип был объявлен в этом модуле; в противном случае — <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-286">A <see cref="T:System.Type" /> object representing the specified type, if the type is declared in this module; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-287">`throwOnError` Параметр влияет на только что произойдет, если тип не найден.</span><span class="sxs-lookup"><span data-stu-id="a6c68-287">The `throwOnError` parameter affects only what happens when the type is not found.</span></span> <span data-ttu-id="a6c68-288">Он не влияет на другие исключения, которые могут быть созданы.</span><span class="sxs-lookup"><span data-stu-id="a6c68-288">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="a6c68-289">В частности, если тип присутствует, но не может быть загружена <xref:System.TypeLoadException> может быть создано даже в том случае, если `throwOnError` — `false`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-289">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-290">Если тип был перенаправлен в другую сборку, по-прежнему возвращается этим методом.</span><span class="sxs-lookup"><span data-stu-id="a6c68-290">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="a6c68-291">Сведения о перенаправлении типов см. в разделе [переадресации типов в общеязыковой](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="a6c68-291">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="a6c68-292">Тип может быть извлечен из конкретного модуля с помощью <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a6c68-292">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a6c68-293">Вызов <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> модуля, содержащего манифест не будут выполнять поиск всей сборке.</span><span class="sxs-lookup"><span data-stu-id="a6c68-293">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="a6c68-294">Чтобы получить тип из сборки, независимо от того, какой модуль он находится, необходимо вызвать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a6c68-294">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6c68-295">Следующий пример отображает имя типа в указанном модуле.</span><span class="sxs-lookup"><span data-stu-id="a6c68-295">The following example displays the name of a type in the specified module.</span></span> <span data-ttu-id="a6c68-296">`throwOnError` И `ignoreCase` параметры задаются в виде `false`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-296">The `throwOnError` and `ignoreCase` parameters are specified as `false`.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a6c68-297">Свойство <paramref name="className" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-297">
              <paramref name="className" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="a6c68-298">Вызываются инициализаторы класса и создается исключение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-298">The class initializers are invoked and an exception is thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-299">
            <paramref name="className" /> представляет собой строку нулевой длины.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-299">
              <paramref name="className" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="a6c68-300">
            <paramref name="throwOnError" /> является <see langword="true" />, не удается найти тип.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-300">
              <paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="a6c68-301">Для <paramref name="className" /> требуется зависимая сборка, которую не удается найти.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-301">
              <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="a6c68-302">Для <paramref name="className" /> требуется зависимая сборка, которая была найдена, но ее не удалось загрузить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-302">
              <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="a6c68-303">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-303">-or-</span>
          </span>
          <span data-ttu-id="a6c68-304">Текущая сборка была загружена в контекст только для отражения, а для <paramref name="className" /> требуется зависимая сборка, которая не была предварительно загружена.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-304">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="a6c68-305">Для <paramref name="className" /> требуется зависимая сборка, однако файл не является допустимой сборкой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-305">
              <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="a6c68-306">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-306">-or-</span>
          </span>
          <span data-ttu-id="a6c68-307">Для <paramref name="className" /> требуется зависимая сборка, которая была скомпилирована для версии среды выполнения более поздней, чем текущая загруженная версия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-307">
              <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-308">Возвращает все типы, определенные в этом модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-308">Returns all the types defined within this module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-309">Массив типа <see langword="Type" />, содержащий типы, определенные в модуле, отраженном этим экземпляром.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-309">An array of type <see langword="Type" /> containing types defined within the module that is reflected by this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-310">`ReflectionTypeLoadException` — это специальные нагрузки исключение.</span><span class="sxs-lookup"><span data-stu-id="a6c68-310">`ReflectionTypeLoadException` is a special load exception.</span></span> <span data-ttu-id="a6c68-311">`ReflectionTypeLoadException.Types` Свойство содержит массив типов, которые были определены в модуле и загружены.</span><span class="sxs-lookup"><span data-stu-id="a6c68-311">The `ReflectionTypeLoadException.Types` property contains the array of types that were defined in the module and were loaded.</span></span> <span data-ttu-id="a6c68-312">Этот массив может содержать значения null.</span><span class="sxs-lookup"><span data-stu-id="a6c68-312">This array may contain some null values.</span></span> <span data-ttu-id="a6c68-313">`ReflectionTypeLoadException.LoaderExceptions` Свойство представляет собой массив исключений, которые представляют исключения, которые были созданы загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="a6c68-313">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the loader.</span></span> <span data-ttu-id="a6c68-314">Уязвимости в массиве классов соответствуют исключения.</span><span class="sxs-lookup"><span data-stu-id="a6c68-314">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="a6c68-315">Например, если инициализаторы одного из классов вызывает исключение во время они загружаются, `TargetInvocationException` хранятся в соответствующем элементе `LoaderExceptions` массива.</span><span class="sxs-lookup"><span data-stu-id="a6c68-315">For example, if the class initializers of one of the classes throws an exception while it is being loaded, a `TargetInvocationException` is stored in the corresponding element of the `LoaderExceptions` array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-316">Если тип был перенаправлен в другую сборку, он не включается в возвращаемый массив.</span><span class="sxs-lookup"><span data-stu-id="a6c68-316">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="a6c68-317">Сведения о перенаправлении типов см. в разделе [переадресации типов в общеязыковой](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="a6c68-317">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">
          <span data-ttu-id="a6c68-318">Невозможно загрузить один или несколько классов в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-318">One or more classes in a module could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="a6c68-319">У вызывающего объекта отсутствует необходимое разрешение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-319">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="a6c68-320">Разрешение отражения для текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-320">Reflection permission for the current module.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="a6c68-321">Тип настраиваемого атрибута для проверки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-321">The type of custom attribute to test for.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="a6c68-322">Данный аргумент не учитывается для объектов этого типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-322">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-323">Возвращает значение, обозначающее, применен ли к этому модулю указанный тип атрибутов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-323">Returns a value that indicates whether the specified attribute type has been applied to this module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-324">Значение <see langword="true" />, если к этому модулю применен один или несколько экземпляров <paramref name="attributeType" />, в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-324">
              <see langword="true" /> if one or more instances of <paramref name="attributeType" /> have been applied to this module; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a6c68-325">В следующем примере показано использование `IsDefined` метода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-325">The following example demonstrates a use of the `IsDefined` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a6c68-326">Свойство <paramref name="attributeType" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-326">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-327">Параметр <paramref name="attributeType" /> не является объектом <see cref="T:System.Type" />, предоставленным во время разработки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-327">
              <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span>
          </span>
          <span data-ttu-id="a6c68-328">Например, <paramref name="attributeType" /> является объектом <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-328">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public virtual bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsResource();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-329">Возвращает значение, указывающее, является ли объект ресурсом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-329">Gets a value indicating whether the object is a resource.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-330">Значение <see langword="true" />, если объект является ресурсом; в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-330">
              <see langword="true" /> if the object is a resource; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a6c68-331">В следующем примере показано использование `IsResource` метода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-331">The following example demonstrates a use of the `IsResource` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsResource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public virtual int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-332">Возвращает версию потока метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-332">Gets the metadata stream version.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a6c68-333">32-разрядное целое число, представляющее версию потока метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-333">A 32-bit integer representing the metadata stream version.</span>
          </span>
          <span data-ttu-id="a6c68-334">Два байта старшего разряда представляют основной номер версии, а два байта младшего разряда — дополнительный.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-334">The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-335">Дополнительные сведения о заголовке метаданных см. в разделе «Раздел II: определение метаданных и семантика» в документации по Common Language Infrastructure (CLI).</span><span class="sxs-lookup"><span data-stu-id="a6c68-335">For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</span></span> <span data-ttu-id="a6c68-336">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-336">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public virtual int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-337">Возвращает токен, который определяет модуль в метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-337">Gets a token that identifies the module in metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a6c68-338">Целочисленный токен, который идентифицирует текущий модуль в метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-338">An integer token that identifies the current module in metadata.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-339">Маркеры, полученные с помощью этого свойства может быть передан на неуправляемый интерфейс API отражения.</span><span class="sxs-lookup"><span data-stu-id="a6c68-339">The tokens obtained using this property can be passed to the unmanaged Reflection API.</span></span> <span data-ttu-id="a6c68-340">Дополнительные сведения см. в разделе [неуправляемый интерфейс API отражения](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span><span class="sxs-lookup"><span data-stu-id="a6c68-340">For more information, see [Unmanaged Reflection API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-341">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</span><span class="sxs-lookup"><span data-stu-id="a6c68-341">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a6c68-342">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-342">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleHandle">
      <MemberSignature Language="C#" Value="public ModuleHandle ModuleHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ModuleHandle ModuleHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModuleHandle As ModuleHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ModuleHandle ModuleHandle { ModuleHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ModuleHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-343">Возвращает дескриптор модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-343">Gets a handle for the module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a6c68-344">Структура <see cref="T:System.ModuleHandle" /> для текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-344">A <see cref="T:System.ModuleHandle" /> structure for the current module.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public virtual Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-345">Возвращает универсальный уникальный идентификатор (UUID), по которому можно различить две версии модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-345">Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a6c68-346">Значение свойства <see cref="T:System.Guid" />, по которому можно различить две версии модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-346">A <see cref="T:System.Guid" /> that can be used to distinguish between two versions of a module.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-347">В неуправляемых метаданных, возвращенный идентификатор GUID <xref:System.Reflection.Module.ModuleVersionId%2A> свойство называется `mvid`и хранятся в куче GUID.</span><span class="sxs-lookup"><span data-stu-id="a6c68-347">In unmanaged metadata, the GUID returned by the <xref:System.Reflection.Module.ModuleVersionId%2A> property is referred to as the `mvid`, and is stored in the GUID heap.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-348">Дополнительные сведения о метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</span><span class="sxs-lookup"><span data-stu-id="a6c68-348">More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a6c68-349">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-349">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-350">Возвращает строку <see langword="String" />, представляющую имя модуля без пути.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-350">Gets a <see langword="String" /> representing the name of the module with the path removed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a6c68-351">Имя модуля без пути.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-351">The module name with no path.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-352">`Name` является строкой, зависящей от платформы.</span><span class="sxs-lookup"><span data-stu-id="a6c68-352">`Name` is a platform-dependent string.</span></span>  
  
 <span data-ttu-id="a6c68-353">Если сборка для этого модуля была загружена из массива байтов то `FullyQualifiedName` для модуля будут: \<Неизвестный >.</span><span class="sxs-lookup"><span data-stu-id="a6c68-353">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
 <span data-ttu-id="a6c68-354">Чтобы получить имя и путь, используйте <xref:System.Reflection.Module.FullyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="a6c68-354">To get the name and the path, use <xref:System.Reflection.Module.FullyQualifiedName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6c68-355">В этом примере показано влияние `ScopeName`, `FullyQualifiedName`, и `Name` свойства.</span><span class="sxs-lookup"><span data-stu-id="a6c68-355">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.Name Example/CS/source.cs#1)]
 [!code-vb[Classic Module.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="a6c68-356">Первый из сравниваемых объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-356">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="a6c68-357">Второй из сравниваемых объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-357">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-358">Определение равенства двух объектов <see cref="T:System.Reflection.Module" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-358">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-359">
            <see langword="true" />, если значения параметров <paramref name="left" /> и <paramref name="right" /> равны; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-359">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="a6c68-360">Первый из сравниваемых объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-360">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="a6c68-361">Второй из сравниваемых объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-361">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-362">Определяет неравенство двух объектов <see cref="T:System.Reflection.Module" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-362">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-363">
            <see langword="true" />, если значения <paramref name="left" /> и <paramref name="right" /> не равны; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-363">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-364">Возвращает поле, определенное заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-364">Returns the field identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo ResolveField (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveField (metadataToken As Integer) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ ResolveField(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="a6c68-365">токен метаданных, определяющий поле в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-365">A metadata token that identifies a field in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-366">Возвращает поле, определенное заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-366">Returns the field identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-367">Объект <see cref="T:System.Reflection.FieldInfo" />, представляющий поле, которое определяется заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-367">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-368">Для решения, родительский токен метаданных, определяющий поле `TypeSpec` имеет сигнатуру, содержащую тип элемента `ELEMENT_TYPE_VAR` или `ELEMENT_TYPE_MVAR`, используйте <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> перегрузку, которая позволяет предоставить необходимый контекст.</span><span class="sxs-lookup"><span data-stu-id="a6c68-368">To resolve a metadata token that identifies a field whose parent `TypeSpec` has a signature containing element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="a6c68-369">То есть при разрешении токен метаданных для поля, которое зависит от параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер, необходимо использовать перегруженный метод, который делает возможным предоставление таких параметров типа.</span><span class="sxs-lookup"><span data-stu-id="a6c68-369">That is, when you are resolving a metadata token for a field that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-370">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</span><span class="sxs-lookup"><span data-stu-id="a6c68-370">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a6c68-371">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-371">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="a6c68-372">Код, который демонстрирует разрешение маркера с использованием универсального контекста (то есть параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер). в разделе <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> метод.</span><span class="sxs-lookup"><span data-stu-id="a6c68-372">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-373">Параметр <paramref name="metadataToken" /> не является маркером для поля в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-373">
              <paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span>
          </span>
          <span data-ttu-id="a6c68-374">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-374">-or-</span>
          </span>
          <span data-ttu-id="a6c68-375">Параметр <paramref name="metadataToken" /> определяет поле, родительская спецификация <see langword="TypeSpec" /> которого имеет подпись, содержащую сведения о типе элемента <see langword="var" /> (параметр типа для универсального типа) или <see langword="mvar" /> (параметр типа для универсального метода).</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-375">
              <paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a6c68-376">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-376">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="a6c68-377">токен метаданных, определяющий поле в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-377">A metadata token that identifies a field in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="a6c68-378">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для данного типа, если токен находится в области, либо значение <see langword="null" />, если этот тип не является универсальным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-378">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="a6c68-379">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для метода, если токен находится в области, либо значение <see langword="null" />, если этот метод не является универсальным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-379">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-380">Возвращает поле, определенное заданным токеном метаданных, в контексте, определенном заданными параметрами универсального типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-380">Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-381">Объект <see cref="T:System.Reflection.FieldInfo" />, представляющий поле, которое определяется заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-381">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-382">Используйте <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> метода типа где `metadataToken` находится в области, чтобы получить массив аргументов универсального типа для `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-382">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="a6c68-383">Используйте <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> метода на метод где `metadataToken` находится в области, чтобы получить массив аргументов универсального типа для `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-383">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="a6c68-384">Всегда можно безопасно предоставить эти аргументы, даже в том случае, если они не нужны.</span><span class="sxs-lookup"><span data-stu-id="a6c68-384">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-385">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</span><span class="sxs-lookup"><span data-stu-id="a6c68-385">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a6c68-386">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-386">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="a6c68-387">Код, который демонстрирует разрешение маркера с использованием универсального контекста (то есть параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер). в разделе <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> метод.</span><span class="sxs-lookup"><span data-stu-id="a6c68-387">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-388">Параметр <paramref name="metadataToken" /> не является маркером для поля в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-388">
              <paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span>
          </span>
          <span data-ttu-id="a6c68-389">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-389">-or-</span>
          </span>
          <span data-ttu-id="a6c68-390">Параметр <paramref name="metadataToken" /> определяет поле, родительская спецификация <see langword="TypeSpec" /> которого имеет подпись, содержащую сведения о типе элемента <see langword="var" /> (параметр типа для универсального типа) или <see langword="mvar" /> (параметр типа для универсального метода), а для метода <paramref name="genericTypeArguments" /> или <paramref name="genericMethodArguments" /> не предоставлены необходимые аргументы типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-390">
              <paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a6c68-391">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-391">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-392">Возвращает тип члена, определенный токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-392">Returns the type or member identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo ResolveMember (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMember (metadataToken As Integer) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MemberInfo ^ ResolveMember(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="a6c68-393">токен метаданных, определяющий тип или член в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-393">A metadata token that identifies a type or member in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-394">Возвращает тип члена, определенный заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-394">Returns the type or member identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-395">Объект <see cref="T:System.Reflection.MemberInfo" />, представляющий тип члена, который определяется заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-395">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-396">Чтобы разрешить токен метаданных для `MethodSpec` или `TypeSpec` , сигнатура которого содержит тип элемента `ELEMENT_TYPE_VAR` или `ELEMENT_TYPE_MVAR`, используйте <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> перегрузку, которая позволяет предоставить необходимый контекст.</span><span class="sxs-lookup"><span data-stu-id="a6c68-396">To resolve a metadata token for a `MethodSpec` or `TypeSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="a6c68-397">То есть при разрешении токен метаданных для элемента, который зависит от параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер, необходимо использовать перегруженный метод, который делает возможным предоставление таких параметров типа.</span><span class="sxs-lookup"><span data-stu-id="a6c68-397">That is, when you are resolving a metadata token for a member that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-398">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</span><span class="sxs-lookup"><span data-stu-id="a6c68-398">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a6c68-399">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-399">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="a6c68-400">Код, который демонстрирует разрешение маркера с использованием универсального контекста (то есть параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер). в разделе <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> метод.</span><span class="sxs-lookup"><span data-stu-id="a6c68-400">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-401">Параметр <paramref name="metadataToken" /> не является маркером для типа или члена в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-401">
              <paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span>
          </span>
          <span data-ttu-id="a6c68-402">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-402">-or-</span>
          </span>
          <span data-ttu-id="a6c68-403">Параметр <paramref name="metadataToken" /> содержит объект <see langword="MethodSpec" /> или <see langword="TypeSpec" />, чья подпись содержит тип элемента <see langword="var" /> (параметр типа для универсального типа) или <see langword="mvar" /> (параметр типа для универсального метода).</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-403">
              <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
          <span data-ttu-id="a6c68-404">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-404">-or-</span>
          </span>
          <span data-ttu-id="a6c68-405">Параметр <paramref name="metadataToken" /> определяет свойство или событие.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-405">
              <paramref name="metadataToken" /> identifies a property or event.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a6c68-406">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-406">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="a6c68-407">токен метаданных, определяющий тип или член в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-407">A metadata token that identifies a type or member in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="a6c68-408">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для данного типа, если токен находится в области, либо значение <see langword="null" />, если этот тип не является универсальным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-408">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="a6c68-409">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для метода, если токен находится в области, либо значение <see langword="null" />, если этот метод не является универсальным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-409">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-410">Возвращает тип или член, которые определены заданным токеном метаданных, в контексте, определенном заданными параметрами универсального типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-410">Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-411">Объект <see cref="T:System.Reflection.MemberInfo" />, представляющий тип члена, который определяется заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-411">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-412">Используйте <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> метода типа где `metadataToken` находится в области, чтобы получить массив аргументов универсального типа для `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-412">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="a6c68-413">Используйте <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> метода на метод где `metadataToken` находится в области, чтобы получить массив аргументов универсального типа для `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-413">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="a6c68-414">Всегда можно безопасно предоставить эти аргументы, даже в том случае, если они не нужны.</span><span class="sxs-lookup"><span data-stu-id="a6c68-414">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-415">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</span><span class="sxs-lookup"><span data-stu-id="a6c68-415">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a6c68-416">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-416">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="a6c68-417">Код, который демонстрирует разрешение маркера с использованием универсального контекста (то есть параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер). в разделе <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> метод.</span><span class="sxs-lookup"><span data-stu-id="a6c68-417">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-418">Параметр <paramref name="metadataToken" /> не является маркером для типа или члена в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-418">
              <paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span>
          </span>
          <span data-ttu-id="a6c68-419">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-419">-or-</span>
          </span>
          <span data-ttu-id="a6c68-420">Параметр <paramref name="metadataToken" /> является объектом <see langword="MethodSpec" /> или <see langword="TypeSpec" />, подпись которого содержит сведения о типе элемента <see langword="var" /> (параметр типа для универсального типа) или <see langword="mvar" /> (параметр типа для универсального метода), а для метода <paramref name="genericTypeArguments" /> или <paramref name="genericMethodArguments" /> не предоставлены необходимые аргументы типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-420">
              <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
          <span data-ttu-id="a6c68-421">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-421">-or-</span>
          </span>
          <span data-ttu-id="a6c68-422">Параметр <paramref name="metadataToken" /> определяет свойство или событие.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-422">
              <paramref name="metadataToken" /> identifies a property or event.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a6c68-423">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-423">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-424">Возвращает метод, определенный токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-424">Returns the method identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase ResolveMethod (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMethod (metadataToken As Integer) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodBase ^ ResolveMethod(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="a6c68-425">маркер метаданных, определяющий метод или конструктор в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-425">A metadata token that identifies a method or constructor in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-426">Возвращает метод или конструктор, определенный заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-426">Returns the method or constructor identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-427">Объект <see cref="T:System.Reflection.MethodBase" />, представляющий метод или конструктор, который определяется заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-427">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-428">Чтобы разрешить токен метаданных для `MethodSpec` , сигнатура которого содержит тип элемента `ELEMENT_TYPE_VAR` или `ELEMENT_TYPE_MVAR`, используйте <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> перегрузку, которая позволяет предоставить необходимый контекст.</span><span class="sxs-lookup"><span data-stu-id="a6c68-428">To resolve a metadata token for a `MethodSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="a6c68-429">То есть при разрешении токен метаданных для метода, который зависит от параметров универсального типа для универсального типа или универсального метода, в котором внедрен этот маркер, необходимо использовать перегруженный метод, который делает возможным предоставление таких параметров типа.</span><span class="sxs-lookup"><span data-stu-id="a6c68-429">That is, when you are resolving a metadata token for a method that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-430">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</span><span class="sxs-lookup"><span data-stu-id="a6c68-430">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a6c68-431">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-431">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6c68-432">Приведенный ниже показано, как использовать две перегрузки <xref:System.Reflection.Module.ResolveMethod%2A> метода для разрешения маркеров метаданных из вызова сайты в универсальных и неуниверсальных контекстов.</span><span class="sxs-lookup"><span data-stu-id="a6c68-432">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="a6c68-433">В примере кода определяется два универсальных типов, `G1<Tg1>` и `G2<Tg2>` (`G1(Of Tg1)` и `G2(Of Tg2)` в Visual Basic), каждый из которых содержит универсальный метод.</span><span class="sxs-lookup"><span data-stu-id="a6c68-433">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>` (`G1(Of Tg1)` and `G2(Of Tg2)` in Visual Basic), each of which has a generic method.</span></span> <span data-ttu-id="a6c68-434">`G1<Tg1>` также имеет неуниверсальный метод, который использует параметр типа `Tg1` для его параметра.</span><span class="sxs-lookup"><span data-stu-id="a6c68-434">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="a6c68-435">Универсальный метод `GM2<Tgm2>` в типе `G2<Tg2>` содержит несколько вызовов методов:</span><span class="sxs-lookup"><span data-stu-id="a6c68-435">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="a6c68-436">Вариант 1: Универсальный метод `GM1<Tgm1>` с использованием параметров типа `G2<Tg2>` и `GM2<Tgm2>` в качестве аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="a6c68-436">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="a6c68-437">Другими словами, типы параметров вызываемого метода будет зависеть от типов, которые используются для создания закрытого универсального типа из определения типа для `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-437">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="a6c68-438">Вариант 2: Неуниверсальный метод `M1` вызывается.</span><span class="sxs-lookup"><span data-stu-id="a6c68-438">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="a6c68-439">Параметр этого метода использует параметр типа, определяющего типа, `G1<Tg1>`, который заменяется в этом случае параметр типа включающего типа `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-439">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="a6c68-440">Вариант 3: Универсальный метод `GM1<Tgm1>` вызывается, указав <xref:System.Int32> и <xref:System.Object> для аргументы типа для универсального типа и универсального метода соответственно.</span><span class="sxs-lookup"><span data-stu-id="a6c68-440">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="a6c68-441">Вызов этого метода не зависит от параметров типа включающего типа или метода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-441">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="a6c68-442">Случай 4: Неуниверсальный метод `M1` из `Example` класс называется.</span><span class="sxs-lookup"><span data-stu-id="a6c68-442">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="a6c68-443">Вызов этого метода не зависит от параметров типа включающего типа или метода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-443">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="a6c68-444">Кроме того, в примере определяется неуниверсальные `Example` класса.</span><span class="sxs-lookup"><span data-stu-id="a6c68-444">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="a6c68-445">Этот класс содержит метод `M` , выполняется вызов универсального метода:</span><span class="sxs-lookup"><span data-stu-id="a6c68-445">This class has a method `M` that makes a call to a generic method:</span></span>  
  
-   <span data-ttu-id="a6c68-446">Случай 5: Универсальный метод `GM1` вызывается, указав <xref:System.Int32> и <xref:System.Object> для аргументы типа для универсального типа и универсального метода соответственно.</span><span class="sxs-lookup"><span data-stu-id="a6c68-446">Case 5: The generic method `GM1` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="a6c68-447">Контекст для этого метода не имеет включающего универсального типа или универсального метода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-447">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="a6c68-448">Для каждого варианта, в примере сначала создается <xref:System.Reflection.MethodInfo> , представляющий вызываемый метод и затем разрешает маркер с помощью <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> перегрузку метода, с помощью <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> и <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> методы для получения значения для `genericTypeArguments` и `genericMethodArguments` параметры.</span><span class="sxs-lookup"><span data-stu-id="a6c68-448">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="a6c68-449">Эта техника работает во всех случаях, так как они возвращают <xref:System.Type.EmptyTypes?displayProperty=nameWithType> для контекстов, не являющимися универсальными.</span><span class="sxs-lookup"><span data-stu-id="a6c68-449">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="a6c68-450">В примере сравнивается Разрешить <xref:System.Reflection.MethodInfo> с сконструированный <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="a6c68-450">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="a6c68-451">В примере затем предпринимается попытка использовать <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> перегрузка метода для разрешения маркера.</span><span class="sxs-lookup"><span data-stu-id="a6c68-451">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="a6c68-452">Это работает в случаях, 3, 4 и 5, так как вызовы методов не зависит от универсального контекста.</span><span class="sxs-lookup"><span data-stu-id="a6c68-452">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="a6c68-453">В случаях, 1 и 2 исключение из-за недостатка информации для разрешения маркера.</span><span class="sxs-lookup"><span data-stu-id="a6c68-453">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="a6c68-454">Значения маркера метаданных жестко запрограммированы в виде перечисления.</span><span class="sxs-lookup"><span data-stu-id="a6c68-454">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="a6c68-455">Если изменить этот пример кода, значения маркера, скорее всего, изменится.</span><span class="sxs-lookup"><span data-stu-id="a6c68-455">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="a6c68-456">Чтобы определить новые значения маркера, скомпилировать код и используйте Ildasm.exe с **/TOKENS** для просмотра сборки.</span><span class="sxs-lookup"><span data-stu-id="a6c68-456">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="a6c68-457">Токены можно найти в местах вызова.</span><span class="sxs-lookup"><span data-stu-id="a6c68-457">The tokens can be found at the points of call.</span></span> <span data-ttu-id="a6c68-458">Вставьте новые значения в перечислении и перекомпилировать пример.</span><span class="sxs-lookup"><span data-stu-id="a6c68-458">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-459">Параметр <paramref name="metadataToken" /> не является маркером для метода или конструктора в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-459">
              <paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span>
          </span>
          <span data-ttu-id="a6c68-460">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-460">-or-</span>
          </span>
          <span data-ttu-id="a6c68-461">Параметр <paramref name="metadataToken" /> является объектом <see langword="MethodSpec" />, сигнатура которого содержит тип элемента <see langword="var" /> (параметр типа для универсального типа) или <see langword="mvar" /> (параметр типа для универсального метода).</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-461">
              <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a6c68-462">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-462">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="a6c68-463">маркер метаданных, определяющий метод или конструктор в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-463">A metadata token that identifies a method or constructor in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="a6c68-464">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для данного типа, если токен находится в области, либо значение <see langword="null" />, если этот тип не является универсальным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-464">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="a6c68-465">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для метода, если токен находится в области, либо значение <see langword="null" />, если этот метод не является универсальным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-465">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-466">Возвращает метод или конструктор, определенный заданным маркером метаданных, в контексте, определенном заданными параметрами универсального типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-466">Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-467">Объект <see cref="T:System.Reflection.MethodBase" />, представляющий метод, определенный заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-467">A <see cref="T:System.Reflection.MethodBase" /> object representing the method that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-468">Используйте <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> метода типа где `metadataToken` находится в области, чтобы получить массив аргументов универсального типа для `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-468">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="a6c68-469">Используйте <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> метода на метод где `metadataToken` находится в области, чтобы получить массив аргументов универсального типа для `genericMethodArguments`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-469">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericMethodArguments`.</span></span> <span data-ttu-id="a6c68-470">Всегда можно безопасно предоставить эти аргументы, даже в том случае, если они не нужны.</span><span class="sxs-lookup"><span data-stu-id="a6c68-470">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-471">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</span><span class="sxs-lookup"><span data-stu-id="a6c68-471">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a6c68-472">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-472">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6c68-473">Приведенный ниже показано, как использовать две перегрузки <xref:System.Reflection.Module.ResolveMethod%2A> метода для разрешения маркеров метаданных из вызова сайты в универсальных и неуниверсальных контекстов.</span><span class="sxs-lookup"><span data-stu-id="a6c68-473">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="a6c68-474">В примере кода определяется два универсальных типов, `G1<Tg1>` и `G2<Tg2>`, каждый из которых содержит универсальный метод.</span><span class="sxs-lookup"><span data-stu-id="a6c68-474">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>`, each of which has a generic method.</span></span> <span data-ttu-id="a6c68-475">`G1<Tg1>` также имеет неуниверсальный метод, который использует параметр типа `Tg1` для его параметра.</span><span class="sxs-lookup"><span data-stu-id="a6c68-475">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="a6c68-476">Универсальный метод `GM2<Tgm2>` в типе `G2<Tg2>` содержит несколько вызовов методов:</span><span class="sxs-lookup"><span data-stu-id="a6c68-476">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="a6c68-477">Вариант 1: Универсальный метод `GM1<Tgm1>` с использованием параметров типа `G2<Tg2>` и `GM2<Tgm2>` в качестве аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="a6c68-477">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="a6c68-478">Другими словами, типы параметров вызываемого метода будет зависеть от типов, которые используются для создания закрытого универсального типа из определения типа для `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-478">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="a6c68-479">Вариант 2: Неуниверсальный метод `M1` вызывается.</span><span class="sxs-lookup"><span data-stu-id="a6c68-479">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="a6c68-480">Параметр этого метода использует параметр типа, определяющего типа, `G1<Tg1>`, который заменяется в этом случае параметр типа включающего типа `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-480">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="a6c68-481">Вариант 3: Универсальный метод `GM1<Tgm1>` вызывается, указав <xref:System.Int32> и <xref:System.Object> для аргументы типа для универсального типа и универсального метода соответственно.</span><span class="sxs-lookup"><span data-stu-id="a6c68-481">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="a6c68-482">Вызов этого метода не зависит от параметров типа включающего типа или метода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-482">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="a6c68-483">Случай 4: Неуниверсальный метод `M1` из `Example` класс называется.</span><span class="sxs-lookup"><span data-stu-id="a6c68-483">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="a6c68-484">Вызов этого метода не зависит от параметров типа включающего типа или метода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-484">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="a6c68-485">Кроме того, в примере определяется неуниверсальные `Example` класса.</span><span class="sxs-lookup"><span data-stu-id="a6c68-485">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="a6c68-486">Этот класс содержит метод `M` , выполняется вызов универсального метода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-486">This class has a method `M` that makes a call to a generic method.</span></span>  
  
-   <span data-ttu-id="a6c68-487">Случай 5: Универсальный метод `GM1<Tgm1>` вызывается, указав <xref:System.Int32> и <xref:System.Object> для аргументы типа для универсального типа и универсального метода соответственно.</span><span class="sxs-lookup"><span data-stu-id="a6c68-487">Case 5: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="a6c68-488">Контекст для этого метода не имеет включающего универсального типа или универсального метода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-488">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="a6c68-489">Для каждого варианта, в примере сначала создается <xref:System.Reflection.MethodInfo> , представляющий вызываемый метод и затем разрешает маркер с помощью <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> перегрузку метода, с помощью <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> и <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> методы для получения значения для `genericTypeArguments` и `genericMethodArguments` параметры.</span><span class="sxs-lookup"><span data-stu-id="a6c68-489">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="a6c68-490">Эта техника работает во всех случаях, так как они возвращают <xref:System.Type.EmptyTypes?displayProperty=nameWithType> для контекстов, не являющимися универсальными.</span><span class="sxs-lookup"><span data-stu-id="a6c68-490">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="a6c68-491">В примере сравнивается Разрешить <xref:System.Reflection.MethodInfo> с сконструированный <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="a6c68-491">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="a6c68-492">В примере затем предпринимается попытка использовать <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> перегрузка метода для разрешения маркера.</span><span class="sxs-lookup"><span data-stu-id="a6c68-492">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="a6c68-493">Это работает в случаях, 3, 4 и 5, так как вызовы методов не зависит от универсального контекста.</span><span class="sxs-lookup"><span data-stu-id="a6c68-493">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="a6c68-494">В случаях, 1 и 2 исключение из-за недостатка информации для разрешения маркера.</span><span class="sxs-lookup"><span data-stu-id="a6c68-494">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="a6c68-495">Значения маркера метаданных жестко запрограммированы в виде перечисления.</span><span class="sxs-lookup"><span data-stu-id="a6c68-495">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="a6c68-496">Если изменить этот пример кода, значения маркера, скорее всего, изменится.</span><span class="sxs-lookup"><span data-stu-id="a6c68-496">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="a6c68-497">Чтобы определить новые значения маркера, скомпилировать код и используйте Ildasm.exe с **/TOKENS** для просмотра сборки.</span><span class="sxs-lookup"><span data-stu-id="a6c68-497">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="a6c68-498">Токены можно найти в местах вызова.</span><span class="sxs-lookup"><span data-stu-id="a6c68-498">The tokens can be found at the points of call.</span></span> <span data-ttu-id="a6c68-499">Вставьте новые значения в перечислении и перекомпилировать пример.</span><span class="sxs-lookup"><span data-stu-id="a6c68-499">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-500">Параметр <paramref name="metadataToken" /> не является маркером для метода или конструктора в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-500">
              <paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span>
          </span>
          <span data-ttu-id="a6c68-501">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-501">-or-</span>
          </span>
          <span data-ttu-id="a6c68-502">Параметр <paramref name="metadataToken" /> является объектом <see langword="MethodSpec" />, сигнатура которого содержит сведения о типе элемента <see langword="var" /> (параметр типа для универсального типа) или <see langword="mvar" /> (параметр типа для универсального метода), а для <paramref name="genericTypeArguments" />, <paramref name="genericMethodArguments" /> или обоих параметров не предоставлены необходимые аргументы типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-502">
              <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a6c68-503">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-503">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public virtual byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="a6c68-504">токен метаданных, определяющий подпись в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-504">A metadata token that identifies a signature in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-505">Возвращает большой двоичный объект подписи, определенный токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-505">Returns the signature blob identified by a metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-506">Массив байтов, представляющий большой двоичный объект подписи.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-506">An array of bytes representing the signature blob.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-507">Сведения о сигнатуры и токены метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</span><span class="sxs-lookup"><span data-stu-id="a6c68-507">Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a6c68-508">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-508">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-509">Параметр <paramref name="metadataToken" /> не является допустимым объектом <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, сигнатурой или маркером <see langword="FieldDef" /> в области видимости текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-509">
              <paramref name="metadataToken" /> is not a valid <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, signature, or <see langword="FieldDef" /> token in the scope of the current module.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a6c68-510">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-510">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public virtual string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveString(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="a6c68-511">маркер метаданных, определяющий строку в куче строк модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-511">A metadata token that identifies a string in the string heap of the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-512">Возвращает строку, определенную заданным маркером метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-512">Returns the string identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-513">Объект <see cref="T:System.String" />, содержащий строковое значение из кучи строк метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-513">A <see cref="T:System.String" /> containing a string value from the metadata string heap.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-514">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</span><span class="sxs-lookup"><span data-stu-id="a6c68-514">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a6c68-515">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-515">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-516">Параметр <paramref name="metadataToken" /> не является маркером для строки в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-516">
              <paramref name="metadataToken" /> is not a token for a string in the scope of the current module.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a6c68-517">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-517">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-518">Возвращает тип, определенный токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-518">Returns the type identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public Type ResolveType (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type ResolveType(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveType (metadataToken As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ ResolveType(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="a6c68-519">Маркер метаданных, который определяет тип в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-519">A metadata token that identifies a type in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-520">Возвращает тип, определенный заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-520">Returns the type identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-521">Объект <see cref="T:System.Type" />, представляющий тип, который определяется заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-521">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-522">Чтобы разрешить токен метаданных для `TypeSpec` , сигнатура которого содержит `ELEMENT_TYPE_VAR` или `ELEMENT_TYPE_MVAR`, используйте <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> перегрузку, которая позволяет предоставить необходимый контекст.</span><span class="sxs-lookup"><span data-stu-id="a6c68-522">To resolve a metadata token for a `TypeSpec` whose signature contains `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="a6c68-523">То есть при разрешении токен метаданных для типа, который зависит от параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер, необходимо использовать перегруженный метод, который делает возможным предоставление таких параметров типа.</span><span class="sxs-lookup"><span data-stu-id="a6c68-523">That is, when you are resolving a metadata token for a type that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-524">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</span><span class="sxs-lookup"><span data-stu-id="a6c68-524">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a6c68-525">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-525">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-526">Параметр <paramref name="metadataToken" /> не является маркером для типа в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-526">
              <paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span>
          </span>
          <span data-ttu-id="a6c68-527">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-527">-or-</span>
          </span>
          <span data-ttu-id="a6c68-528">Параметр <paramref name="metadataToken" /> является объектом <see langword="TypeSpec" />, сигнатура которого содержит тип элемента <see langword="var" /> (параметр типа для универсального типа) или <see langword="mvar" /> (параметр типа для универсального метода).</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-528">
              <paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a6c68-529">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-529">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public virtual Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="a6c68-530">Маркер метаданных, который определяет тип в модуле.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-530">A metadata token that identifies a type in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="a6c68-531">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для данного типа, если токен находится в области, либо значение <see langword="null" />, если этот тип не является универсальным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-531">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="a6c68-532">Массив объектов <see cref="T:System.Type" />, представляющих аргументы типа для метода, если токен находится в области, либо значение <see langword="null" />, если этот метод не является универсальным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-532">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-533">Возвращает тип, определенный заданным токеном метаданных, в контексте, определенном заданными параметрами универсального типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-533">Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-534">Объект <see cref="T:System.Type" />, представляющий тип, который определяется заданным токеном метаданных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-534">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-535">Используйте <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> метода типа где `metadataToken` находится в области, чтобы получить массив аргументов универсального типа для `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-535">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="a6c68-536">Используйте <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> метода на метод где `metadataToken` находится в области, чтобы получить массив аргументов универсального типа для `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="a6c68-536">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="a6c68-537">Всегда можно безопасно предоставить эти аргументы, даже в том случае, если они не нужны.</span><span class="sxs-lookup"><span data-stu-id="a6c68-537">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a6c68-538">Сведения о маркерах метаданных можно найти в документации по Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</span><span class="sxs-lookup"><span data-stu-id="a6c68-538">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a6c68-539">Документация доступна через Интернет; в разделе [ECMA C# и общий стандарты инфраструктуры языка](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [стандарту ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на сайте ECMA.</span><span class="sxs-lookup"><span data-stu-id="a6c68-539">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="a6c68-540">Код, который демонстрирует разрешение маркера с использованием универсального контекста (то есть параметров универсального типа для универсального типа или метода, в котором внедрен этот маркер). в разделе <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> метод.</span><span class="sxs-lookup"><span data-stu-id="a6c68-540">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a6c68-541">Параметр <paramref name="metadataToken" /> не является маркером для типа в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-541">
              <paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span>
          </span>
          <span data-ttu-id="a6c68-542">- или -</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-542">-or-</span>
          </span>
          <span data-ttu-id="a6c68-543">Параметр <paramref name="metadataToken" /> является объектом <see langword="TypeSpec" />, сигнатура которого содержит сведения о типе элемента <see langword="var" /> (параметр типа для универсального типа) или <see langword="mvar" /> (параметр типа для универсального метода), а для <paramref name="genericTypeArguments" />, <paramref name="genericMethodArguments" /> или обоих параметров не предоставлены необходимые аргументы типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-543">
              <paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a6c68-544">Параметр <paramref name="metadataToken" /> не является допустимым маркером для поля в области текущего модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-544">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public virtual string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-545">Возвращает строку, представляющую имя модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-545">Gets a string representing the name of the module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a6c68-546">Имя модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-546">The module name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-547">`ScopeName` Свойство не используется средой CLR, но его можно использовать для хранения любой строки в свойстве при создании модуля с помощью интерфейсов API метаданных.</span><span class="sxs-lookup"><span data-stu-id="a6c68-547">The `ScopeName` property is not used by the common language runtime, but you can use it to store any string you want in the property when you emit a module using the metadata APIs.</span></span> <span data-ttu-id="a6c68-548">Средствами отражения не позволяют задать `ScopeName` свойства.</span><span class="sxs-lookup"><span data-stu-id="a6c68-548">Reflection itself does not allow you to set the `ScopeName` property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6c68-549">В этом примере показано влияние `ScopeName`, `FullyQualifiedName`, и `Name` свойства.</span><span class="sxs-lookup"><span data-stu-id="a6c68-549">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.ScopeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.ScopeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CS/source.cs#1)]
 [!code-vb[Classic Module.ScopeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Module.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Module.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Module::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="a6c68-550">Зарезервировано для будущего использования.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-550">Reserved for future use.</span>
          </span>
          <span data-ttu-id="a6c68-551">Должно быть равным IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-551">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="a6c68-552">Переданный массив имен, которые необходимо сопоставить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-552">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="a6c68-553">Количество сопоставляемых имен.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-553">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="a6c68-554">Контекст языкового стандарта для интерпретации имен.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-554">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="a6c68-555">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-555">Caller-allocated array that receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-556">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-556">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-557">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-557">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="a6c68-558">Дополнительные сведения о `IDispatch::GetIDsOfNames`, см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="a6c68-558">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="a6c68-559">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-559">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Module.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="a6c68-560">Возвращаемые сведения о типе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-560">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="a6c68-561">Идентификатор языкового стандарта для сведений о типе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-561">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="a6c68-562">Получает указатель на объект с запрошенными сведениями о типе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-562">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-563">Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-563">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-564">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-564">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="a6c68-565">Дополнительные сведения о `IDispatch::GetTypeInfo`, см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="a6c68-565">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="a6c68-566">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-566">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Module.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="a6c68-567">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-567">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-568">Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-568">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-569">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-569">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="a6c68-570">Дополнительные сведения о `IDispatch::GetTypeInfoCount`, см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="a6c68-570">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="a6c68-571">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-571">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.Invoke">
      <MemberSignature Language="C#" Value="void _Module.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Module.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Module::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="a6c68-572">Идентифицирует член.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-572">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="a6c68-573">Зарезервировано для будущего использования.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-573">Reserved for future use.</span>
          </span>
          <span data-ttu-id="a6c68-574">Должно быть равным IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-574">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="a6c68-575">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-575">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="a6c68-576">Флаги, описывающие контекст вызова.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-576">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="a6c68-577">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-577">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="a6c68-578">Указатель, по которому будет сохранен результат.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-578">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="a6c68-579">Указатель на структуру, содержащую сведения об исключении.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-579">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="a6c68-580">Индекс первого аргумента, вызвавшего ошибку.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-580">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a6c68-581">Предоставляет доступ к открытым свойствам и методам объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-581">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6c68-582">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-582">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="a6c68-583">Дополнительные сведения о `IDispatch::Invoke`, см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="a6c68-583">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="a6c68-584">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-584">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a6c68-585">Возвращает имя модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-585">Returns the name of the module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a6c68-586">Строка <see langword="String" />, представляющая имя этого модуля.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a6c68-586">A <see langword="String" /> representing the name of this module.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a6c68-587">В следующем примере показано использование `ToString` метода.</span><span class="sxs-lookup"><span data-stu-id="a6c68-587">The following example demonstrates a use of the `ToString` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.ToString Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>