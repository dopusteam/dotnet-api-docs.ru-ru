<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6a5cbc748c27e04d813a6551133350a431e76e76" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58460101" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type CodeDomProvider = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет базовый класс для реализаций <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />. Это абстрактный класс.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.CodeDom.Compiler.CodeDomProvider> можно использовать для создания и извлечения экземпляров генераторов кода и компиляторов. Генераторы кода применяются для создания кода на определенном языке, а компиляторы кода используются для компиляции кода в сборки.  
  
> [!NOTE]
>  В [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], методы доступны в генератор кода и компилятора кода доступны непосредственно из поставщика кода. Необходимо вызвать <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> или <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> для доступа к методам и эти методы помечены как устаревшие. Это относится к ранее существующим и новым реализациям поставщика кода.  
  
 Объект <xref:System.CodeDom.Compiler.CodeDomProvider> реализации обычно предоставляет код создания и/или код компиляции интерфейсы для генерации кода и управления компиляцией для отдельного языка программирования. Несколько языков поддерживается <xref:System.CodeDom.Compiler.CodeDomProvider> реализаций, входящие в состав [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)]. Эти языки C#, Visual Basic, C++ и JScript. Можно реализовать разработчиками или поставщиками компиляторов <xref:System.CodeDom.Compiler.ICodeGenerator> и <xref:System.CodeDom.Compiler.ICodeCompiler> интерфейсы и предоставить <xref:System.CodeDom.Compiler.CodeDomProvider> , расширяет поддержку CodeDOM на другие языки программирования.  
  
 [ &lt;System.codedom&gt; элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в конфигурации компьютера (Machine.config) файл предоставляет механизм для разработчики и поставщики компиляторов добавить параметры конфигурации для дополнительных <xref:System.CodeDom.Compiler.CodeDomProvider>реализаций.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider> Класс предоставляет статические методы для обнаружения и перечисления <xref:System.CodeDom.Compiler.CodeDomProvider> реализаций на компьютере. <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> Метод возвращает параметры для всех <xref:System.CodeDom.Compiler.CodeDomProvider> реализаций на компьютере. <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> Метод возвращает параметры для конкретного <xref:System.CodeDom.Compiler.CodeDomProvider> реализации, основанной на имя языка программирования. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> Метод возвращает экземпляр <xref:System.CodeDom.Compiler.CodeDomProvider> реализации для конкретного языка.  
  
 Дополнительные сведения о параметрах поставщика языка в файле конфигурации, см. в разделе [компилятора и схема параметров поставщиков языков](~/docs/framework/configure-apps/file-schema/compiler/index.md).  
  
> [!NOTE]
>  Этот класс выполняет запрос ссылки и требования наследования на уровне класса. Объект <xref:System.Security.SecurityException> создается, если непосредственный вызывающий оператор или производного класса не имеет разрешения полного доверия. Дополнительные сведения о требованиях безопасности см. в разделе [требования связывания](~/docs/framework/misc/link-demands.md) и [требования наследования](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/x4yx82e6(v=vs.100)).  
  
   
  
## Examples  
 В следующем примере программа может создать и компиляции исходного кода, на основе модели CodeDOM из программы, которая выводит «Hello, World!» с помощью <xref:System.Console> класса. Предоставляется пользовательский интерфейс Windows Forms. Пользователь может выбрать целевой язык из нескольких диапазонов: C#, Visual Basic и JScript.  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот класс не может использоваться частично доверенным кодом.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот класс не может наследоваться кодом с частичным доверием.</permission>
    <block subset="none" type="overrides"><para>В .NET Framework версий 1.0 и 1.1, поставщики кода состоят из реализаций <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, <see cref="T:System.CodeDom.Compiler.ICodeParser" />, и <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />. В [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />, <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />, и <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> методы являются устаревшими и методы <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> и <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> доступны непосредственно в <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> класса. Необходимо переопределить эти методы в реализации поставщика кода и не вызывать базовые методы.</para></block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
    <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот класс не может использоваться частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromDom (options, compilationUnits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CompilerParameters" />, задающий параметры компиляции.</param>
        <param name="compilationUnits">Массив типа <see cref="T:System.CodeDom.CodeCompileUnit" />, указывающий код для компиляции.</param>
        <summary>Компилирует сборку на основе деревьев <see cref="N:System.CodeDom" />, содержащихся в указанном массиве объектов <see cref="T:System.CodeDom.CodeCompileUnit" />, используя указанные параметры компилятора.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.CompilerResults" />, показывающий результаты компиляции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeCompiler> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeCompiler> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> метод в целях совместимости с помощью уже имеющихся поставщиков, использующих компиляторы кода. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует компилятор кода.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromFile (options, fileNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fileNames" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CompilerParameters" />, задающий параметры компиляции.</param>
        <param name="fileNames">Массив имен файлов для компиляции.</param>
        <summary>Компилирует сборку из исходного кода, содержащегося в указанных файлах, используя указанные параметры компилятора.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.CompilerResults" />, показывающий результаты компиляции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeCompiler> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeCompiler> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> метод в целях совместимости с помощью уже имеющихся поставщиков, использующих компиляторы кода. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует компилятор кода.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromSource (options, sources)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="sources" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CompilerParameters" />, задающий параметры компилятора для компиляции.</param>
        <param name="sources">Массив строк исходного кода для компиляции.</param>
        <summary>Компилирует сборку из указанного массива строк, содержащего исходный код, используя указанные параметры компилятора.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.CompilerResults" />, показывающий результаты компиляции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeCompiler> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeCompiler> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> метод в целях совместимости с помощью уже имеющихся поставщиков, использующих компиляторы кода. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует компилятор кода.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberSignature Language="F#" Value="abstract member CreateCompiler : unit -&gt; System.CodeDom.Compiler.ICodeCompiler" Usage="codeDomProvider.CreateCompiler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает новый компилятор кода.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />, который может использоваться для компиляции представлений исходного кода на основе <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является устаревшим в [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. Рекомендуемой альтернативой является вызов <xref:System.CodeDom.Compiler.ICodeCompiler> доступные методы непосредственно в код поставщика.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>В [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], следует реализовать <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> члены в <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> и также вызывают исключения <see cref="T:System.NotSupportedException" /> при вызове этого метода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateEscapedIdentifier : string -&gt; string&#xA;override this.CreateEscapedIdentifier : string -&gt; string" Usage="codeDomProvider.CreateEscapedIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка, для которой создается Escape-идентификатор.</param>
        <summary>Создает Escape-идентификатор для заданного значения.</summary>
        <returns>Escape-идентификатор для данного значения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> тесты ли идентификатор конфликтует с любого зарезервированных слов языка и если да, возвращает соответствующее имя с языковое форматирование кода. Это называется Escape-идентификатор. Escape-идентификатор содержит такое же `value` , но escape-код форматирования добавлено отличать его от ключевого слова. Двух примерах реализации `value` с «@» или скобок `value` с «[» и «]».  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе создает новый генератор кода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : unit -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает новый генератор кода.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, который может использоваться для генерации представлений исходного кода на основе <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является устаревшим в [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. Рекомендуемой альтернативой является вызов <xref:System.CodeDom.Compiler.ICodeGenerator> доступные методы непосредственно в <xref:System.CodeDom.Compiler.CodeDomProvider> класса.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>В [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], следует реализовать <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> члены в <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> и также вызывают исключения <see cref="T:System.NotSupportedException" /> при вызове этого метода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output">Объект <see cref="T:System.IO.TextWriter" />, который следует использовать для вывода.</param>
        <summary>При переопределении в производном классе создает новый генератор кода, используя для вывода указанный объект <see cref="T:System.IO.TextWriter" />.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, который может использоваться для генерации представлений исходного кода на основе <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует указанный <xref:System.IO.TextWriter> для выходных данных. Этот метод поддерживает дополнительные создания оптимизированного кода, который выполняет добавочное обновление исходного кода.  
  
> [!NOTE]
>  Реализация вызывает базовый класс <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метод, который является устаревшим в [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] и приводит к <xref:System.NotSupportedException> Если <xref:System.CodeDom.Compiler.ICodeGenerator> не возвращается.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла для выходных данных.</param>
        <summary>При переопределении в производном классе создает новый генератор кода, используя указанное имя файла для выходных данных.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, который может использоваться для генерации представлений исходного кода на основе <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует указанное имя файла для выходных данных.  
  
> [!NOTE]
>  Реализация вызывает базовый класс <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метод, который является устаревшим в [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] и приводит к <xref:System.NotSupportedException> Если <xref:System.CodeDom.Compiler.ICodeGenerator> не возвращается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberSignature Language="F#" Value="abstract member CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser&#xA;override this.CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser" Usage="codeDomProvider.CreateParser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeParser interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает новый анализатор кода.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.ICodeParser" />, который может использоваться для анализа исходного кода. Базовая реализация всегда возвращает значение <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает экземпляр <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> для заданного языка.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Имя языка.</param>
        <summary>Получает экземпляр <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> для заданного языка.</summary>
        <returns>Поставщик CodeDOM, реализованный для заданного имени языка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод обычно используется для создания экземпляра поставщика кода в приложении, которое может использовать один из нескольких поставщиков. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> можно указать во время выполнения для создания экземпляра поставщика кода. Если известно во время разработки, какой код поставщика будет использоваться, вы должны создать экземпляр этого поставщика кода вместо использования <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> метод.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> Возвращает <xref:System.CodeDom.Compiler.CodeDomProvider> для конкретного языка имя экземпляра; это аналогично вызову <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> метод с типом поставщика языка. Используйте <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> когда искомое динамически реализацию настроенного поставщика, имя языка.  
  
 Если более чем одной реализации поставщика настроен для имени языка, <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> возвращает экземпляр поставщика для последнего соответствующего элемента конфигурации.  
  
 Используйте <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> перегрузку метода, при реализации поставщика конкретного языка. Например, использовать <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> метод, чтобы получить экземпляр поставщика, который поддерживает имя языка `"CSharp"`; используйте <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> перегруженный метод, чтобы получить экземпляр поставщика специально для <xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType> реализации. Следует использовать [\], CultureInfo, объект\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D% 2CSystem.Globalization.CultureInfo%2CSystem.Object%5b%5D%29?displayProperty=nameWithType > метода, если у вас есть несколько поставщиков кода для языка и необходимы для создания экземпляра поставщика кода.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> Метод проверяет, поддерживает ли хотя бы один поставщик реализации конкретного языка. Вы можете проверить имя языка с помощью <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> перед их передачей <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>. Если передано имя язык не поддерживается для <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> возникает исключение.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> Метод может использоваться для определения всех <xref:System.CodeDom.Compiler.CodeDomProvider> реализаций на компьютере, включая дополнительные реализованных разработчики и поставщики компиляторов, которые определены в [ &lt;system.codedom &gt; Элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в файле конфигурации компьютера (Machine.config).  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> Метод возвращает экземпляр <xref:System.CodeDom.Compiler.CodeDomProvider> реализации для конкретного языка.  
  
 Имена языка не учитывается.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализацию для языка ввода, а также отображает настроенные параметры для поставщика языка. Данный пример кода является частью большего примера для <xref:System.CodeDom.Compiler.CompilerInfo> класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Для языка, заданного в параметре <paramref name="language" />, на данном компьютере не настроен поставщик.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="language" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider (language, providerOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Имя языка.</param>
        <param name="providerOptions">Коллекция параметров поставщика из файла конфигурации.</param>
        <summary>Получает экземпляр <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> для заданного языка и параметров поставщика.</summary>
        <returns>Поставщик CodeDOM, реализованный для заданного имени языка и параметров.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод обычно используется для создания экземпляра поставщика кода в приложении, которое может использовать один из нескольких поставщиков. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> позволяет указать версию поставщика кода, который вы хотите создать экземпляр, во время выполнения. Если вы знаете во время разработки, какой код поставщика будет использоваться, следует создавать экземпляры этого поставщика кода, вместо использования <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> метод.  
  
 Используйте <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> когда необходимо динамически найти реализацию настроенного поставщика для конкретного языка и параметры. Имена языка не учитывается. Сведения о поддерживаемых параметрах поставщика см. соответствующую документацию поставщика CodeDOM.  
  
 Сведения о проверке поставщика и вызова поставщика, если более чем одной реализации поставщика настроен для имени языка, см. в разделе "Примечания" <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29> метод.  
  
   
  
## Examples  
 В следующем примере показано, как для создания экземпляра поставщика с помощью `providerOptions` параметра.  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateValidIdentifier : string -&gt; string&#xA;override this.CreateValidIdentifier : string -&gt; string" Usage="codeDomProvider.CreateValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка, для которой создается допустимый идентификатор.</param>
        <summary>Создает допустимый идентификатор для указанного значения.</summary>
        <returns>Допустимый идентификатор для указанного значения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> проверяет, является ли идентификатор конфликтует с зарезервированными ключевыми словами языка, и если таким образом, попытается вернуть допустимый идентификатор имя, не конфликтуют. Обычно возвращаемый идентификатор лишь немного изменяется, чтобы отличать его от ключевого слова; например имя может предшествовать знак подчеркивания («_»).  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FileExtension : string" Usage="System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает расширение имени файла по умолчанию для использования в файлах исходного кода в текущем языке.</summary>
        <value>Расширение имени файла, соответствующее расширению исходных файлов текущего языка. Базовая реализация всегда возвращает значение <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется генераторами и компиляторы кода, чтобы указать, какие расширения файлов, которые следует создать или использовать.  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр <xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>. В примере отображается имя поставщика, хэш код и по умолчанию расширение имени файла для нового экземпляра поставщика.  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromCompileUnit (compileUnit, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="compileUnit">Объект <see cref="T:System.CodeDom.CodeCompileUnit" />, для которого создается код.</param>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />, указывающий параметры для использования при создании кода.</param>
        <summary>Создает код для указанной единицы компиляции объектной модели документов кода (CodeDOM) и направляет его указанному модулю записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A> метод для создания кода для приложения «Hello, World!» из <xref:System.CodeDom.CodeCompileUnit>. Этот пример является частью большего примера для <xref:System.CodeDom.Compiler.CodeDomProvider> класса.  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromExpression (expression, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression">Объект <see cref="T:System.CodeDom.CodeExpression" />, указывающий выражение, для которого создается код.</param>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />, указывающий параметры для использования при создании кода.</param>
        <summary>Создает код для указанного выражения объектной модели документов кода (CodeDOM) и направляет его указанному модулю записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromMember (member, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="member">Объект <see cref="T:System.CodeDom.CodeTypeMember" />, указывающий член, для которого создается код.</param>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />, указывающий параметры для использования при создании кода.</param>
        <summary>Создает код для указанного объявления члена объектной модели документов кода (CodeDOM) и направляет его указанному модулю записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывает реализацию базового класса <xref:System.NotImplementedException>. См. в разделе <xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType> для документации, описывающей реализацию этого метода.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A> метод, реализуемый <xref:Microsoft.CSharp.CSharpCodeProvider> и <xref:Microsoft.VisualBasic.VBCodeProvider> классы.  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Этот метод не переопределяется в производном классе.</exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromNamespace (codeNamespace, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeNamespace">Объект <see cref="T:System.CodeDom.CodeNamespace" />, указывающий пространство имен, для которого создается код.</param>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />, указывающий параметры для использования при создании кода.</param>
        <summary>Создает код для указанного пространства имен объектной модели документов кода (CodeDOM) и направляет его указанному модулю записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromStatement (statement, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="statement">Объект <see cref="T:System.CodeDom.CodeStatement" />, содержащий элементы CodeDOM, для которых генерируется код.</param>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />, указывающий параметры для использования при создании кода.</param>
        <summary>Создает код для указанного оператора языка объектной модели документов кода (CodeDOM) и направляет его указанному модулю записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromType (codeType, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeType">Объект <see cref="T:System.CodeDom.CodeTypeDeclaration" />, указывающий тип, для которого создается код.</param>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />, указывающий параметры для использования при создании кода.</param>
        <summary>Создает код для указанного объявления типа объектной модели документов кода (CodeDOM) и направляет его указанному модулю записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberSignature Language="F#" Value="static member GetAllCompilerInfo : unit -&gt; System.CodeDom.Compiler.CompilerInfo[]" Usage="System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает параметры поставщика и компилятора языка для данного компьютера.</summary>
        <returns>Массив типа <see cref="T:System.CodeDom.Compiler.CompilerInfo" />, представляющий параметры всех настроенных реализаций <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> метод перечислить параметры поставщика языка на компьютере.  
  
> [!NOTE]
>  В [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], поставщиков языка по умолчанию, предоставляемых платформой .NET Framework не указаны в [ &lt;system.codedom&gt; элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) конфигурации компилятора разделе и не могут быть удалены, поэтому эта метод возвращает сведения о поставщиков по умолчанию и все заданные в файле конфигурации.  
  
   
  
## Examples  
 В следующем примере кода перечисляет поставщиков языков на компьютере и отображает параметры конфигурации и компилятора для каждого поставщика языка. Данный пример кода является частью большего примера для <xref:System.CodeDom.Compiler.CompilerInfo> класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member GetCompilerInfo : string -&gt; System.CodeDom.Compiler.CompilerInfo" Usage="System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Имя языка.</param>
        <summary>Возвращает параметры поставщика и компилятора языка для заданного языка.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.CompilerInfo" />, заполненный параметрами настроенной реализации <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt; элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в конфигурации компьютера файл содержит параметры для каждого языка поставщика и компилятора конфигурации <xref:System.CodeDom.Compiler.CodeDomProvider> реализации на компьютере. Сведения о файлах конфигурации компьютера, см. в разделе файлов конфигурации компьютера в [Настройка приложений](~/docs/framework/configure-apps/index.md). <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> Метод выполняет поиск каждого элемента конфигурации поставщика для заданного имени языка. Возвращенный <xref:System.CodeDom.Compiler.CompilerInfo> экземпляр содержит настроенных языковых параметров поставщика и компилятора.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> Метод проверяет, поддерживает ли хотя бы один поставщик реализации конкретного языка. Вы можете проверить имя языка с помощью <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> перед их передачей <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>. Это предотвращает создание <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> при доступе к <xref:System.CodeDom.Compiler.CompilerInfo> экземпляр имени неподдерживаемый язык.  
  
 Если более чем одной реализации поставщика настроена для языка ввода имени, <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> Возвращает параметры из последнего соответствующий поставщик элемента конфигурации.  
  
 Имена языка не учитывается.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализацию для языка ввода, а также отображает настроенные параметры для поставщика языка. Данный пример кода является частью большего примера для <xref:System.CodeDom.Compiler.CompilerInfo> класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">Для языка, заданного в параметре <paramref name="language" />, на данном компьютере не настроен поставщик.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Значение параметра <paramref name="language" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetConverter : Type -&gt; System.ComponentModel.TypeConverter&#xA;override this.GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="codeDomProvider.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Тип объекта, для которого извлекается преобразователь типов.</param>
        <summary>Получает <see cref="T:System.ComponentModel.TypeConverter" /> для указанного типа данных.</summary>
        <returns><see cref="T:System.ComponentModel.TypeConverter" /> для указанного типа или <see langword="null" />, если <see cref="T:System.ComponentModel.TypeConverter" /> для указанного типа не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производный класс может переопределить этот метод для предоставления определенных типов преобразователей типов для определенных типов данных.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member GetLanguageFromExtension : string -&gt; string" Usage="System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension">Расширение имени файла.</param>
        <summary>Возвращает имя языка, связанное с определенным расширением имени файла, как настроено в разделе конфигурации компилятора <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</summary>
        <returns>Имя языка, связанное с определенным расширением имени файла, как настроено в параметрах конфигурации компилятора <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt; элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в конфигурации компьютера файл (Machine.config) содержит параметры для каждого языка поставщика и компилятора конфигурации <xref:System.CodeDom.Compiler.CodeDomProvider> реализации на компьютер. <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> Метод выполняет поиск каждого элемента конфигурации поставщика для указанного расширения имени файла.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> Метод проверяет, поддерживает ли хотя бы один поставщик реализацию определенного расширения имен файлов. Вы можете проверить расширение имени файла с помощью <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> перед их передачей <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>. Это предотвращает <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> возникновения <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> для расширением имени файла не поддерживается.  
  
 Если реализация поставщика поддерживает расширение имени входного файла, а также несколько поддерживаемых языков, настроенных для этого поставщика, затем <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> возвращает имя первого языка для данного поставщика. Если более чем одной реализации поставщика для расширения имени входного файла, <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> возвращает имя языка из последней соответствующий поставщик элемента конфигурации.  
  
 Имена языков и расширения имен файлов регистр не учитывается.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализации расширение имени входного файла и отображает настроенные параметры для поставщика языка. Данный пример кода является частью большего примера для <xref:System.CodeDom.Compiler.CompilerInfo> класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">Для языка, заданного в параметре <paramref name="extension" />, на данном компьютере не настроен поставщик языка.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Значение параметра <paramref name="extension" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string&#xA;override this.GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string" Usage="codeDomProvider.GetTypeOutput type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.CodeDom.CodeTypeReference" /> указывает возвращаемый тип.</param>
        <summary>Получает тип, на который указывает заданный объект <see cref="T:System.CodeDom.CodeTypeReference" />.</summary>
        <returns>Текстовое представление указанного типа, отформатированное для языка, на котором создается код данным генератором кода. Например, в Visual Basic передача объекта <see cref="T:System.CodeDom.CodeTypeReference" /> для типа <see cref="T:System.Int32" /> вернет "Integer".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member IsDefinedExtension : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension">Расширение имени файла.</param>
        <summary>Проверяет, имеется ли связанная ли с данным расширением имени файла реализация <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, настроенная на данном компьютере.</summary>
        <returns><see langword="true" />, если реализация <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> настроена для определенного имени файла; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt; элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в конфигурации компьютера файл (Machine.config) содержит параметры для каждого языка поставщика и компилятора конфигурации <xref:System.CodeDom.Compiler.CodeDomProvider> реализации на компьютер. <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> Метод выполняет поиск элементов конфигурации поставщика для указанного расширения имени файла.  
  
 Расширения имен файлов регистр не учитывается.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализации расширение имени входного файла и отображает настроенные параметры для поставщика языка. Данный пример кода является частью большего примера для <xref:System.CodeDom.Compiler.CompilerInfo> класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="extension" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member IsDefinedLanguage : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Имя языка.</param>
        <summary>Проверяет, имеется ли связанная ли с данным языком реализация <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, настроенная на данном компьютере.</summary>
        <returns><see langword="true" />, если реализация <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> настроена для заданного языка; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt; элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в конфигурации компьютера файл (Machine.config) содержит параметры для каждого языка поставщика и компилятора конфигурации <xref:System.CodeDom.Compiler.CodeDomProvider> реализации на компьютер. <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> Метод выполняет поиск элементов конфигурации поставщика для заданного имени языка.  
  
 Имена языка не учитывается.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализацию для языка ввода, а также отображает настроенные параметры для поставщика языка. Данный пример кода является частью большего примера для <xref:System.CodeDom.Compiler.CompilerInfo> класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="language" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsValidIdentifier : string -&gt; bool&#xA;override this.IsValidIdentifier : string -&gt; bool" Usage="codeDomProvider.IsValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Значение для проверки на допустимый идентификатор.</param>
        <summary>Возвращает значение, показывающее, является ли указанное значение допустимым идентификатором для текущего языка.</summary>
        <returns><see langword="true" />, если параметр <paramref name="value" /> является допустимым идентификатором; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод проверяет, является ли допустимым идентификатор. <xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A> Метод зависит от поставщика. Идентификаторы, допустимые для одного поставщика, не могут быть допустимыми для других поставщиков. Если `value` содержит символы вне диапазона символов ASCII, проверьте этот идентификатор для всех языков, которые могут использоваться для компиляции кода.  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" /> в производном классе, спроектировать метод вернет <see langword="true" /> только в том случае, если значение соответствует правилам языка и не конфликтует с ключевым словом.  
  
Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOptions : System.CodeDom.Compiler.LanguageOptions" Usage="System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор особенностей языка.</summary>
        <value><see cref="T:System.CodeDom.Compiler.LanguageOptions" /> указывает особенности языка.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberSignature Language="F#" Value="abstract member Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit&#xA;override this.Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomProvider.Parse codeStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeStream">Объект <see cref="T:System.IO.TextReader" />, используемый для чтения анализируемого кода.</param>
        <summary>Компилирует код, прочитанный из заданного текстового потока, в объект <see cref="T:System.CodeDom.CodeCompileUnit" />.</summary>
        <returns>Объект <see cref="T:System.CodeDom.CodeCompileUnit" />, содержащий представление анализируемого кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeParser> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeParser> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает средство синтаксического анализа в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие средства синтаксического анализа кода. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeParser" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует средство синтаксического анализа кода.</para></block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports generatorSupport" FrameworkAlternate="netframework-1.1;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports supports" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport">Объект <see cref="T:System.CodeDom.Compiler.GeneratorSupport" />, указывающий тип поддержки создания кода, который следует проверить.</param>
        <param name="supports">To be added.</param>
        <summary>Возвращает значение, показывающее, обеспечивается ли указанная поддержка создания кода.</summary>
        <returns><see langword="true" />, если указанная поддержка создания кода осуществляется; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться с количеством <xref:System.CodeDom.Compiler.GeneratorSupport> флагами, чтобы проверить набор возможностей путем объединения набора соответствующих флагов возможностей с помощью двоичного `OR` оператор (&#124;).  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>