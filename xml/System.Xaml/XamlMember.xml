<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a5bf358cf5bbfc2549fa0d48319a913cdf514495" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56357736" /></Metadata><TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Предоставляет системный идентификатор типа языка XAML для членов типов XAML. Этот идентификатор используется средствами чтения и записи XAML во время обработки узлов членов (когда средство чтения XAML находится в поле <see cref="F:System.Xaml.XamlNodeType.StartMember" />). Кроме того, он используется для общей логики системы типов XAML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember> можно использовать три методологии для возврата сведений о члене XAML: стандартные общие отражения среды CLR (CLR); флаги для API-интерфейсы, использовать оптимизированные для бита ссылки — только для отражения способ вызова внутреннего; или переопределениям виртуального вызова `Lookup*` API, предоставляемые возможности <xref:System.Xaml.XamlMember> подклассы. Для большинства задач API-интерфейсов служб XAML .NET Framework и <xref:System.Xaml.XamlMember> API, используйте контекст схемы XAML по умолчанию. Контекст схемы XAML по умолчанию для служб XAML .NET Framework использует для системы типов среды CLR. Это позволяет XAML модули чтения и записи XAML для работы с любой тип или член, который определен в, или в противном случае для, среда CLR и его методами отражения.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>API-интерфейсы поиска * и XamlMember производные классы  
 <xref:System.Xaml.XamlMember> определяет несколько виртуальных членов, которые производные классы могут переопределить. Эти члены имеют имена, которые всегда начинаются со строки `Lookup`. В оставшейся части API имя затем ссылки на свойство, которое влияет виртуальный метод. Например <xref:System.Xaml.XamlMember> производный класс может переопределить <xref:System.Xaml.XamlMember.LookupTargetType%2A> влияет на какие свойства определяемых базы <xref:System.Xaml.XamlMember.TargetType%2A> возвращает в производном классе. Можно предсказать возвращаемые значения таких свойств в <xref:System.Xaml.XamlMember> или существующих производных классов см. в документации по соответствующему `Lookup*` методы.  
  
 Цель `Lookup*` методы — предоставить метод расширения XAML тип системы, включающий <xref:System.Xaml.XamlMember> базового класса. Путем наследования от <xref:System.Xaml.XamlMember> и переопределение `Lookup` виртуальные члены можно определить концепцию члена XAML для схемы XAML в системе типов XAML без привязки к особенностям системой резервных типов или технологии. Можно также использовать предоставленный контекст схемы XAML в этой схеме и по-прежнему возвращать нужные результаты.  
  
 Например, рассмотрим <xref:System.Xaml.XamlMember> свойство <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Это свойство информирует вызывающие объекты этой операции, такие как с помощью <xref:System.Xaml.XamlWriter> для сериализации можно записать значение для этого элемента в целевом объекте. В реализации по умолчанию выполняется определение, является ли элемент для записи, используя методы отражения для резервный CLR <xref:System.Type> и его членах ( <xref:System.Reflection.MemberInfo>). Таким образом по умолчанию система типов XAML зависит от системы типов среды CLR. Тем не менее, можно удалить эту зависимость для XAML тип системы создания отчетов из <xref:System.Xaml.XamlMember.IsWritePublic%2A> путем переопределения API <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>. В рамках переопределения, можно использовать другие определения, например метаданные, относящиеся к технологии, главная таблица подстановки, оптимизированный для основного словаря XAML или ряд других стратегий для определения ли член XAML доступен для записи в вашей Словарь XAML.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Создав XamlMember без контекста схемы XAML  
 Большинство конструкторов <xref:System.Xaml.XamlMember> требуют <xref:System.Xaml.XamlSchemaContext> как часть их инициализации. <xref:System.Xaml.XamlSchemaContext> Также необходим для многих внутренних <xref:System.Xaml.XamlSchemaContext> операций, таких как получение сведения, которые пересылаются из резервного типа. При работе с <xref:System.Xaml.XamlMember> API, как правило, достаточно <xref:System.Xaml.XamlSchemaContext> , такие как доступные из окружающей конструкции <xref:System.Xaml.XamlWriter>. В этом случае вы можете передать <xref:System.Xaml.XamlSchemaContext> ссылаются через на любые вызовы системы типов XAML, которые требуется контекст схемы XAML.  
  
 Один определенный конструктор <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>, не требует <xref:System.Xaml.XamlSchemaContext>. Тем не менее <xref:System.Xaml.XamlMember> , созданный с <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> сигнатура возвращает `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Для пути загрузки, который включает в себя <xref:System.Xaml.XamlObjectWriter>, такой элемент не удается записать в граф объекта. С помощью реализации служб XAML .NET Framework, <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> вызова вызывает <xref:System.Xaml.XamlObjectWriterException> при соответствующие <xref:System.Xaml.XamlMember> отчеты `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Не следует создавать <xref:System.Xaml.XamlMember> , имеет значение `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A> Если ваша реализация может обрабатывать исключения из <xref:System.Xaml.XamlObjectWriter>, или у вас есть другие способы настройки <xref:System.Xaml.XamlObjectWriter> поведение. Например один или несколько из следующих может быть верно для реализации:  
  
-   Контекст схемы XAML доступен в более поздней версии.  
  
-   Можно использовать шаблон вызова члена.  
  
-   Вы намеренно переопределить <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> в пользовательский модуль записи XAML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
    <related type="Article" href="https://msdn.microsoft.com/library/7c11abec-1075-474c-9d9b-778e5dab21c3">Общее представление о понятиях и структурах потока узлов XAML</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Объект <see cref="T:System.Reflection.EventInfo" /> системы типов среды CLR, представляющий член события.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> объектами <see cref="T:System.Reflection.EventInfo" /> и <see cref="T:System.Xaml.XamlSchemaContext" /> системы типов среды CLR.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, если элемент представляет событие (свойство точки подключения обработчика событий).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Объект <see cref="T:System.Reflection.PropertyInfo" /> системы типов среды CLR, представляющий член свойства.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> объектами <see cref="T:System.Reflection.PropertyInfo" /> и <see cref="T:System.Xaml.XamlSchemaContext" /> системы типов среды CLR.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется в том случае, если член представляет свойство (и специально не является соединением обработчика событий).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Объект <see cref="T:System.Reflection.EventInfo" /> системы типов среды CLR, представляющий член события.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <param name="invoker">Реализация <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, которая обрабатывает вызовы отражения во время выполнения, адресованные объекту <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> объектами <see cref="T:System.Reflection.EventInfo" /> и <see cref="T:System.Xaml.XamlSchemaContext" /> системы типов среды CLR, включая сведения объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, если элемент представляет событие (или свойство точки подключения обработчика событий).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Объект <see cref="T:System.Reflection.PropertyInfo" /> системы типов среды CLR, представляющий член свойства.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <param name="invoker">Реализация <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, которая обрабатывает вызовы времени выполнения, адресованные объекту <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> объектами <see cref="T:System.Reflection.PropertyInfo" /> и <see cref="T:System.Xaml.XamlSchemaContext" /> отражения, включая сведения объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется только в том случае, если элемент представляет свойство, и если он не является соединением обработчика событий.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Строковое имя присоединяемого события.</param>
        <param name="adder">Объект <see cref="T:System.Reflection.MethodInfo" /> системы типов среды CLR для метода <see langword="Add" /> обработчика базовой реализации присоединяемого члена.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> для объекта <see cref="T:System.Xaml.XamlMember" />, представляющего присоединяемое событие.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, если элемент представляет элемент вложенного события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Строковое имя члена.</param>
        <param name="declaringType">Сведения <see cref="T:System.Xaml.XamlType" /> для объявляемого типа.</param>
        <param name="isAttachable">Значение <see langword="true" />, если необходимо указать, что член является присоединяемым; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" />, используя строковое имя и сведения об объявляющем типе <see cref="T:System.Xaml.XamlType" />. Объект <see cref="T:System.Xaml.XamlMember" />, созданный с данной сигнатурой, имеет значительные ограничения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Xaml.XamlMember> , созданный с <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> сигнатура возвращает `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Для пути загрузки, который включает в себя <xref:System.Xaml.XamlObjectWriter>, такой элемент не удается записать в граф объекта. С помощью реализации служб XAML .NET Framework, <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> вызова вызывает <xref:System.Xaml.XamlObjectWriterException> при соответствующие <xref:System.Xaml.XamlMember> отчеты `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Не следует создавать <xref:System.Xaml.XamlMember> с <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` Если ваша реализация может обрабатывать исключения из <xref:System.Xaml.XamlObjectWriter>, или у вас есть другие способы настройки <xref:System.Xaml.XamlObjectWriter> поведение. Например один или несколько из следующих может быть верно для реализации:  
  
-   Контекст схемы XAML доступен в более поздней версии.  
  
-   Можно использовать шаблон вызова члена.  
  
-   Вы намеренно переопределить <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> в пользовательский модуль записи XAML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="name" /> или <paramref name="declaringType" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Строковое имя присоединяемого свойства.</param>
        <param name="getter">Объект <see cref="T:System.Reflection.MethodInfo" /> системы типов среды CLR для метода доступа <see langword="get" /> базовой реализации присоединяемого члена.</param>
        <param name="setter">Объект <see cref="T:System.Reflection.MethodInfo" /> системы типов среды CLR для метода доступа <see langword="set" /> базовой реализации присоединяемого члена.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> для объекта <see cref="T:System.Xaml.XamlMember" />, представляющего присоединяемое свойство.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, если элемент представляет присоединяемое свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Строковое имя присоединяемого события.</param>
        <param name="adder">Объект <see cref="T:System.Reflection.MethodInfo" /> системы типов среды CLR для метода <see langword="Add" /> обработчика базовой реализации присоединяемого члена.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <param name="invoker">Реализация <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, которая обрабатывает вызовы времени выполнения, адресованные объекту <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> для объекта <see cref="T:System.Xaml.XamlMember" />, представляющего присоединяемое событие, включая сведения объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, если элемент представляет элемент вложенного события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Строковое имя присоединяемого свойства.</param>
        <param name="getter">Объект <see cref="T:System.Reflection.MethodInfo" /> системы типов среды CLR для метода доступа <see langword="get" /> базовой реализации присоединяемого члена.</param>
        <param name="setter">Объект <see cref="T:System.Reflection.MethodInfo" /> системы типов среды CLR для метода доступа <see langword="set" /> базовой реализации присоединяемого члена.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <param name="invoker">Реализация <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, которая обрабатывает вызовы времени выполнения, адресованные объекту <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> для объекта <see cref="T:System.Xaml.XamlMember" />, представляющего присоединяемое свойство, включая сведения объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, если элемент представляет элемент вложенного свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.XamlType" /> для типа, который объявляет член, связанный с этим объектом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Объект <see cref="T:System.Xaml.XamlType" /> для типа, который объявляет член, связанный с этим объектом <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение обычно устанавливается во время инициализации и обычно не `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A> данные могут передаваться в конструкторами для инициализации. Обращаясь напрямую базовые конструкторы, инициализации для <xref:System.Xaml.XamlMember> производных классов может пропускать некоторые проверки значения, которые вносятся в базовом классе. Таким образом производная инициализация можно изменить сведения о связях сообщаемые члена типа элемента XAML, таким образом, чтобы он больше не соответствуют ожидаемым образом информации о системе типов из его базового объявления CLR. Для объявления информации о типах проверок с точки зрения безопасности используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, используемый для отложенной загрузки объектов, объявленных в языке XAML.</summary>
        <value>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Xaml.XamlDeferringLoader" /> для универсального класса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.DeferringLoader%2A> вызывает <xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> или конкретного переопределения этого метода. Это происходит в случаях, где логика начального внутреннего отражения не уже настроен.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает список объектов <see cref="T:System.Xaml.XamlMember" />. Эти объекты сообщают о членах, в которых существуют отношения зависимости для порядка инициализации относительно данного объекта <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Список объектов <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.DependsOn%2A> вызывает <xref:System.Xaml.XamlMember.LookupDependsOn%2A> или конкретного переопределения этого метода. Это происходит в случаях, где логика начального внутреннего отражения не уже настроен.  
  
 `DependsOn` Модель может применяться к вариантам модели объекта, которые намеренно противоречат правило XAML. Общее правило XAML — это члены типа, которые передаются как текст инициализации (или методом фабрики в XAML 2009) должен уметь назначаться в любом порядке. Применяя `DependsOn` узор на член, можно указать модули записи XAML всегда обработать указанный член перед этим членом. Можно применить этот шаблон в ситуациях, где значение текущего элемента требует контекста или другие сведения, которые доступны только после установки другого элемента.  
  
 `DependsOn` Шаблон должен применен внимательно и зарезервирован для сценариев свойств, где он служит архитектурной цели. Большое количество зависимостей могут замедлить обработку XAML. Кроме того имеется возможность создать циклические зависимости, в этом случае поведение обработки XAML не определено.  
  
 Пример `DependsOn` сценарии из WPF включают некоторые свойства на <xref:System.Windows.Controls.ControlTemplate> и <xref:System.Windows.DataTemplate>на <xref:System.Windows.Trigger>, а затем на <xref:System.Windows.Setter>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Позволяет определить, равен ли текущий объект другому объекту.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, который требуется сравнить с данным объектом.</param>
        <summary>Позволяет определить, равен ли текущий объект другому объекту.</summary>
        <returns><see langword="true" />, если текущий объект равен параметру <paramref name="obj" />, в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        <summary>Указывает, равен ли текущий объект другому объекту того же типа.</summary>
        <returns><see langword="true" />, если текущий объект равен параметру <paramref name="other" />, в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для этого объекта.</summary>
        <returns>Целочисленный хэш-код.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает список пространств имен XAML, в которых может существовать этот член XAML.</summary>
        <returns>Список идентификаторов пространства имен XAML в виде строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> результат из вызова <xref:System.Xaml.XamlMember.DeclaringType%2A> , связанного с данным <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает реализацию объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, связанную с данным типом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Реализация объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, связанная с данным типом <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Invoker` Шаблон — это сложная и расширение системы типов XAML. `Invoker` Шаблон предоставляет способ вставки поведение сопоставления типов другую схему, при этом используя определения системы типов XAML из служб XAML .NET Framework.  
  
 Если <xref:System.Xaml.XamlMember.LookupInvoker%2A> переопределить возвращает `null`, или реализация по умолчанию возвращает `null` так, как у него нет <xref:System.Xaml.XamlMember.UnderlyingMember%2A> для данного <xref:System.Xaml.XamlMember>, <xref:System.Xaml.XamlMember.Invoker%2A> возвращает <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 Тип <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> используется по умолчанию. Это верно для большинства операций, которые используют служб XAML .NET Framework и контекст схемы XAML по умолчанию, и где переопределить конкретные `Invoker` шаблоны передаются для создания сущностей системы типов XAML.  
  
 Вызов <xref:System.Xaml.XamlMember.Invoker%2A> вызывает <xref:System.Xaml.XamlMember.LookupInvoker%2A> или конкретного переопределения этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли этот объект <see cref="T:System.Xaml.XamlMember" /> внешнее свойство.</summary>
        <value>Значение <see langword="true" />, если об объекте <see cref="T:System.Xaml.XamlMember" /> сообщается, что он является внешним свойством; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.IsAmbient%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> или конкретного переопределения этого метода. Это происходит в реализациях, где логика начального внутреннего отражения не уже настроен.  
  
 Проверка внешних свойств обычно являются частью логики обработки XAML, чтобы убедиться в том, что объекты и значения, которые зависят от использования окружения для уточнения типа может работать неправильно. API-интерфейсы служб XAML .NET Framework и контекст схемы XAML по умолчанию заполняет значение в зависимости от однозначного соответствия примитивов с <xref:System.Windows.Markup.AmbientAttribute>. Реализация по умолчанию <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> использует этот существующие <xref:System.Windows.Markup.AmbientAttribute> прием и она вернет `true` Если <xref:System.Windows.Markup.AmbientAttribute> существует в объявлении члена.  
  
 <xref:System.Windows.Markup.AmbientAttribute> имеет место на элементы из нескольких типов WPF, в том числе <xref:System.Windows.Application>, <xref:System.Windows.Setter>, и <xref:System.Windows.Style>. Также его обнаружении на <xref:System.Windows.ResourceDictionary> тип, который описывающая, что на любой член, который использует <xref:System.Windows.ResourceDictionary> как его тип должен считаться окружающим даже, если элемент не помечается с помощью специально.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли этот объект <see cref="T:System.Xaml.XamlMember" /> присоединяемым членом.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> является присоединяемым членом; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsAttachable%2A> Значение инициализируется в зависимости от того, какой конструктор использовался для создания <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли этот объект <see cref="T:System.Xaml.XamlMember" /> директивой XAML.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Xaml.XamlMember" /> является директивой XAML; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsDirective%2A> Значение инициализируется в зависимости от того, какой конструктор использовался для создания <xref:System.Xaml.XamlMember>. Базовый <xref:System.Xaml.XamlMember> конструкторы выполняют инициализацию, чтобы <xref:System.Xaml.XamlMember.IsDirective%2A> является `false`. Тем не менее <xref:System.Xaml.XamlDirective> класс ( <xref:System.Xaml.XamlMember> производного класса) инициализирует таким образом, чтобы <xref:System.Xaml.XamlMember.IsDirective%2A> является `true`.  
  
 Если необходимо получить отчет <xref:System.Xaml.XamlMember.IsDirective%2A> как `true` вызывающим объектам пользовательского класса схемы XAML для элементов XAML, убедитесь, что вы наследуете от <xref:System.Xaml.XamlDirective> потому что это единственный способ включить это поведение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, действительно ли этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член события.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет событие; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.IsEvent%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsEvent%2A> или конкретного переопределения этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, инициализирован ли этот объект <see cref="T:System.Xaml.XamlMember" /> допустимой строкой <see langword="xamlName" /> в качестве значения его свойства <see cref="P:System.Xaml.XamlMember.Name" />.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> инициализирован допустимой строкой <see langword="xamlName" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, действительно ли этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для чтения.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для чтения; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.IsReadOnly%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsReadOnly%2A> или конкретного переопределения этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли объект <see cref="T:System.Xaml.XamlMember" /> член с доступным для вызова открытым методом доступа <see langword="get" />.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет доступный для вызова открытый метод доступа <see langword="get" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsReadPublic%2A> Ли значение проверки <xref:System.Xaml.XamlMember.DeclaringType%2A> является открытым. Если <xref:System.Xaml.XamlMember.DeclaringType%2A> является закрытым, `get` метод доступа не может вызываться удобный, и <xref:System.Xaml.XamlMember.IsReadPublic%2A> возвращает `false`.  
  
 Вызов <xref:System.Xaml.XamlMember.IsReadPublic%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> или конкретного переопределения этого метода.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Метод является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (намеренно или иным способом) данные доступа члена XAML таким образом, чтобы он больше не соответствуют ожидаемым образом доступа к информации о системе типов из его базового объявления CLR. Для проверок с точки зрения безопасности уровни доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли этот член неразрешимым в базовой системе, используемой для разрешения типов и членов.</summary>
        <value>Значение <see langword="true" />, если этот член невозможно разрешить; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Xaml.XamlMember> , созданный с <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> сигнатура возвращает `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Для пути загрузки, который включает в себя <xref:System.Xaml.XamlObjectWriter>, <xref:System.Xaml.XamlMember> с `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A> не может быть записан в граф объекта. В реализации по умолчанию в API служб XAML .NET Framework <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> вызова вызывает <xref:System.Xaml.XamlObjectWriterException> при соответствующие <xref:System.Xaml.XamlMember> отчеты `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Не следует создавать <xref:System.Xaml.XamlMember> , имеет значение `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A> Если ваша реализация может обрабатывать исключения из <xref:System.Xaml.XamlObjectWriter>, или у вас есть другие способы настройки <xref:System.Xaml.XamlObjectWriter> поведение.  
  
 Вызов <xref:System.Xaml.XamlMember.IsUnknown%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsUnknown%2A> или конкретного переопределения этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, действительно ли этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для записи.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для записи; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.IsWriteOnly%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A> или конкретного переопределения этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли объект <see cref="T:System.Xaml.XamlMember" /> член с доступным для вызова открытым методом доступа <see langword="set" />.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет доступный для вызова открытый метод доступа <see langword="set" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsWritePublic%2A> Считает, что значение ли <xref:System.Xaml.XamlMember.DeclaringType%2A> является общим как часть определения. Если <xref:System.Xaml.XamlMember.DeclaringType%2A> является закрытым, `set` метод доступа не может вызываться удобный, и <xref:System.Xaml.XamlMember.IsWritePublic%2A> возвращает `false`.  
  
 Вызов <xref:System.Xaml.XamlMember.IsWritePublic%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> или конкретного переопределения этого метода.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Метод является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (намеренно или иным способом) данные доступа члена XAML таким образом, чтобы он больше не соответствуют ожидаемым образом доступа к информации о системе типов из его базового объявления CLR. Для проверок с точки зрения безопасности уровни доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При реализации в производном классе возвращает реализацию класса <see cref="T:System.Reflection.ICustomAttributeProvider" />.</summary>
        <returns>Реализация <see cref="T:System.Reflection.ICustomAttributeProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределите этот метод для предоставления внутреннее отражение альтернативный способ получения значений атрибутов CLR. В отсутствие переопределения, внутренний объект, отражающий использует типичные логику отражения среды CLR, такие как вызовы <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>.  
  
 Реализация по умолчанию возвращает значение `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, используемый для отложенной загрузки объектов, объявленных в XAML.</summary>
        <returns>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Xaml.XamlDeferringLoader" /> на универсальный класс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.DeferringLoader%2A> свойство. Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlMember.DeferringLoader%2A> возвращать значение, отличное от значения, которое включено по умолчанию внутреннего отражения, и если вы также предоставляете пользовательский <xref:System.Xaml.Schema.XamlMemberInvoker> сведения.  
  
 Реализация по умолчанию возвращает объект, либо путем чтения <xref:System.Windows.Markup.XamlDeferLoadAttribute> или с помощью <xref:System.Xaml.XamlDeferringLoader> от объявляющего типа. Если ни один из объектов доступна, этот метод может возвращать `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает список объектов <see cref="T:System.Xaml.XamlMember" />. Элементы списка сообщают о членах, в которых существуют отношения зависимости для порядка инициализации относительно данного объекта <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Список объектов <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.DependsOn%2A> свойство. Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlMember.DependsOn%2A> возвращать значение, отличное от значения, которое включено по умолчанию внутреннего отражения, и если вы также предоставляете пользовательский <xref:System.Xaml.Schema.XamlMemberInvoker> сведения.  
  
 Реализации WPF XAML чтения и записи атрибута этот случай с <xref:System.Windows.Markup.DependsOnAttribute>. Реализация по умолчанию использует этот существующий <xref:System.Windows.Markup.DependsOnAttribute> методика.  
  
 Переопределите этот метод, если вы не используете <xref:System.Windows.Markup.DependsOnAttribute> для этой цели и не собираетесь заменить этот прием для указания порядка обработки свойств собственной методикой. Если вы не собираетесь поддерживать порядок обработки свойства, можно использовать реализация по умолчанию, поскольку он не возвращает результатов, который подходит.  
  
 Список доступен только для чтения.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, связанный с данным типом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Сведения объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> для этого объекта <see cref="T:System.Xaml.XamlMember" /> или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается при вызове <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 Реализация по умолчанию не требует <xref:System.Xaml.XamlMember> создаваться с помощью одного из конструкторов, которые передают первоначальный <xref:System.Xaml.Schema.XamlMemberInvoker>. Тем не менее <xref:System.Xaml.XamlMember.UnderlyingMember%2A> значение должно существовать для <xref:System.Xaml.XamlMember>; в противном случае реализация по умолчанию возвращает `null`.  
  
 Переопределите этот метод, если вы наследуете от <xref:System.Xaml.Schema.XamlMemberInvoker> и должны возвращать производного класса. Если возвращается `null`, <xref:System.Xaml.XamlMember.Invoker%2A> возвращает <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> вызывающим объектам.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, рассматривается ли данный объект <see cref="T:System.Xaml.XamlMember" /> как внешнее свойство.</summary>
        <returns>Значение <see langword="true" />, если необходимо объявить этот объект <see cref="T:System.Xaml.XamlMember" /> внешним свойством; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается внутренних вызовов, которые проверяют данные свойства окружения XAML. Поведение внешнее свойство учитывается в поведении открытого API средства чтения XAML и записи XAML. Эти внутренние вызовы, которые ссылаются на <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> обычно являются частью логики обработки XAML, чтобы убедиться в том, что объекты и значения, которые зависят от использования окружения для уточнения типа может работать неправильно. Реализация служб XAML .NET Framework по умолчанию использует CLR с атрибутами для получения этих сведений из отражения резервных типов. В частности, реализация по умолчанию проверяет наличие <xref:System.Windows.Markup.AmbientAttribute> и возвращает `true` для <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> Если <xref:System.Windows.Markup.AmbientAttribute> существует для определения члена.  
  
 Переопределите этот метод, если вы не используете <xref:System.Windows.Markup.AmbientAttribute> для этой цели и не собираетесь заменить этот прием для указания внешние свойства XAML с помощью собственного метода.  
  
 Пример API-интерфейсы WPF, атрибут с <xref:System.Windows.Markup.AmbientAttribute> являются <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> и <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли данный объект <see cref="T:System.Xaml.XamlMember" /> событие.</summary>
        <returns>Значение <see langword="true" />, если необходимо объявить, что этот объект <see cref="T:System.Xaml.XamlMember" /> представляет событие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация проверок по умолчанию ли <xref:System.Xaml.XamlMember.UnderlyingMember%2A> имеет тип <xref:System.Reflection.EventInfo>и если это так, возвращает `true`.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.IsEvent%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданные, можно интерпретировать для определения XAML тип представления систем для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли объект <see cref="T:System.Xaml.XamlMember" /> требуемое свойство только для чтения.</summary>
        <returns>Значение <see langword="true" />, если необходимо объявить, что этот объект <see cref="T:System.Xaml.XamlMember" /> представляет ожидаемое свойство, доступное только для чтения; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает `true` Если <xref:System.Xaml.XamlMember.UnderlyingMember%2A> существует, но открытый `set` метод доступа не существует, что определяется внутреннего отражения.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.IsReadOnly%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданные, можно интерпретировать для определения XAML тип представления систем для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли объект <see cref="T:System.Xaml.XamlMember" /> свойство, имеющее открытый метод доступа <see langword="get" />.</summary>
        <returns>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет свойство, имеющее открытый метод доступа <see langword="get" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает результаты, либо на основе внутреннего отражения либо отрицание <xref:System.Xaml.XamlMember.IsWriteOnly%2A>, обработку в указанном порядке.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Возвращает, является ли сам элемент открытым; он возвращает `true` для на открытый член nonpublic, объявляющий тип. Используйте <xref:System.Xaml.XamlMember.IsReadPublic%2A> вместо этого, если вы хотите, чтобы учел видимость объявляющего типа.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.IsReadPublic%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Метод является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (намеренно или иным способом) данные доступа члена XAML таким образом, чтобы он больше не соответствуют ожидаемым образом доступа к информации о системе типов из его базового объявления CLR. Для проверок с точки зрения безопасности уровни доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли данный объект <see cref="T:System.Xaml.XamlMember" /> член, который не может быть разрешен в базовой системе, используемой для разрешения типов и членов.</summary>
        <returns>Значение <see langword="true" />, если данный объект <see cref="T:System.Xaml.XamlMember" /> представляет неразрешимый член; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.IsUnknown%2A>. Реализация по умолчанию возвращает результаты, которые находятся в зависимости от любого внутреннего отражения или для проверки `null` значение <xref:System.Xaml.XamlMember.UnderlyingMember%2A>, обработку в указанном порядке.  
  
 Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, действительно ли этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, имеющий открытый метод доступа <see langword="set" />, но не имеющий открытого метода доступа <see langword="get" />.</summary>
        <returns>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для записи; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает `true` Если <xref:System.Xaml.XamlMember.UnderlyingMember%2A> существует, имеющий открытый `set` метода доступа и закрытого `get` метод доступа, что определяется внутреннего отражения.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.IsWriteOnly%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, действительно ли этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, имеющий открытый метод доступа <see langword="set" />.</summary>
        <returns>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный для записи; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает результаты на основе внутреннего отражения или отрицанием <xref:System.Xaml.XamlMember.IsReadOnly%2A>, обработку в указанном порядке.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Метод является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (намеренно или иным способом) данные доступа члена XAML таким образом, чтобы он больше не соответствуют ожидаемым образом доступа к информации о системе типов из его базового объявления CLR. Для проверок с точки зрения безопасности уровни доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает символы открывающей и закрывающей скобок для расширения разметки.</summary>
        <returns>Коллекция, содержащая символы открывающих и закрывающих скобок.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xaml.XamlType" /> того типа, в котором может существовать объект <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Тип, в котором может существовать объект <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию проводится различие между присоединяемого и не присоединяемых членов. Не присоединяемых членов <xref:System.Xaml.XamlMember.LookupTargetType%2A> всегда возвращает <xref:System.Xaml.XamlMember.DeclaringType%2A>. Присоединяемых членов <xref:System.Xaml.XamlMember.LookupTargetType%2A> возвращает результат на основе анализа <xref:System.Xaml.XamlMember.UnderlyingMember%2A> тип параметра метода доступа и интерпретирует, что тип исходя из контекста схемы XAML.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.TargetType%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xaml.XamlType" /> того типа, который используется данным членом.</summary>
        <returns>Объект <see cref="T:System.Xaml.XamlType" /> того типа, который используется данным членом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.Type%2A>. Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlMember.Type%2A> возвращать значение, отличное от значения, которое включено по умолчанию внутреннего отражения, и если вы также предоставляете пользовательский <xref:System.Xaml.Schema.XamlMemberInvoker> сведения.  
  
 Реализация по умолчанию использует разных путей кода и концептуальные значения для возвращенного <xref:System.Xaml.XamlType> , основанный на ли это <xref:System.Xaml.XamlMember> представляет свойство, метод или событие.  
  
-   Для свойства, возвращенного <xref:System.Xaml.XamlType> — тип, который задает свойство или возвращаемое свойство.  
  
-   Для события, возвращенного <xref:System.Xaml.XamlType> — это тип обработчика событий (делегат в реализации CLR).  
  
-   Для метода <xref:System.Xaml.XamlType> является возвращаемым типом.  
  
 В каждом случае контекст схемы XAML используется для определения типа XAML с базовым системным типом.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.Type%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает реализацию преобразователя типов, связанного с данным объектом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Экземпляр <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.ComponentModel.TypeConverter" /> или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию использует следующую логику и порядок обработки:  
  
-   Если с атрибутами существует на уровне элементов (<xref:System.ComponentModel.TypeConverterAttribute>), сведения об атрибутах используется для вызова <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> в контексте схемы XAML.  
  
-   Если <xref:System.Xaml.XamlMember.Type%2A> является допустимым, возвращается преобразователь типов, который связан с типом.  
  
-   Если элемент является событием, возвращается преобразователь типов связанных с событием.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.TypeConverter%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает метод доступа <see langword="get" />, связанный с данным объектом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Объект <see cref="T:System.Reflection.MethodInfo" /> для связанного метода доступа <see langword="get" /> или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию интерпретирует <xref:System.Xaml.XamlMember.UnderlyingMember%2A> свойство как <xref:System.Reflection.PropertyInfo> и возвращает значение <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> (с параметром, имеющим `true`), что означает, что возвращаемый метод может быть закрытым. Это поведение может привести `null` некоторых случаях. включая случаи, когда связанный метод доступа не существует или член не является свойством.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> свойства в связанном <xref:System.Xaml.Schema.XamlMemberInvoker>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая. Убедитесь, что <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, и <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> таким образом, чтобы все они возвращают коррелированные результаты.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Reflection.MemberInfo" /> системы типов среды CLR, связанный с данным объектом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Объект <see cref="T:System.Reflection.MemberInfo" /> системы типов среды CLR, связанный с данным объектом <see cref="T:System.Xaml.XamlMember" />, или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает базовые сведения о члене, основанное на построение. Если <xref:System.Reflection.MemberInfo> объект создан с сигнатурой, которая не предоставляет достаточно сведений для установки базового элемента, этот метод возвращает `null`.  
  
 Если базовый член был задан во время построения, нет необходимости вызывать этот метод.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая. Убедитесь, что <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, и <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> таким образом, чтобы все они возвращают коррелированные результаты.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает метод доступа <see langword="set" />, связанный с данным объектом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Объект <see cref="T:System.Reflection.MethodInfo" /> для связанного метода доступа <see langword="set" /> или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию интерпретирует <xref:System.Xaml.XamlMember.UnderlyingMember%2A> как <xref:System.Reflection.PropertyInfo> и возвращает значение <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> (с параметром, имеющим `true`), что означает, что возвращаемый метод может быть закрытым. Это может привести `null` для некоторых случаев, включая случаи, когда такой метод доступа отсутствует, или член не является свойством.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> в связанном <xref:System.Xaml.Schema.XamlMemberInvoker>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая. Убедитесь, что <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, и <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> таким образом, чтобы все они возвращают коррелированные результаты.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает реализацию сериализатора значений, связанную с данным объектом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Экземпляр <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Windows.Markup.ValueSerializer" /> или <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию использует следующую логику и порядок обработки:  
  
-   Если с атрибутами существует на уровне элементов (<xref:System.Windows.Markup.ValueSerializerAttribute>), сведения об атрибутах используется для вызова <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> в контексте схемы XAML.  
  
-   Если <xref:System.Xaml.XamlMember.Type%2A> является допустимым, возвращается преобразователь значений, который связан с типом.  
  
-   Если предыдущие условия не применяются, `null` возвращается.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.ValueSerializer%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет символы открывающей и закрывающей скобок для расширения разметки.</summary>
        <value>Коллекция, содержащая символы открывающих и закрывающих скобок.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает строковое представление имени <see langword="xamlName" />, объявляющего этот объект <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Строковое представление имени <see langword="xamlName" />, объявляющего этот объект <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение всегда имеет значение во время построения. Конструкторы, которые реализуются <xref:System.Xaml.XamlMember> обычно создают исключение, если начальное имя не указано; таким образом, непредвиденным образом это свойство имело `null` или является пустой строкой, при использовании служб XAML .NET Framework по умолчанию в реализации.  
  
 [Грамматика XamlName](~/docs/framework/xaml-services/xamlname-grammar.md) и правилам именования для членов и типов CLR не образуют точного пересечения. Это можно объявить имя элемента, которое является допустимым в среде CLR, но не является допустимым в области имен XAML. По возможности следует избегать такой ситуации.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">
  <see cref="T:System.Xaml.XamlMember" /> или <see langword="null" />.</param>
        <param name="xamlMember2">
  <see cref="T:System.Xaml.XamlMember" /> или <see langword="null" />.</param>
        <summary>Определяет, совпадают ли значения двух указанных объектов <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Значение <see langword="true" />, если значение <paramref name="xamlMember1" /> совпадает со значением <paramref name="xamlMember2" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">
  <see cref="T:System.Xaml.XamlMember" /> или <see langword="null" />.</param>
        <param name="xamlMember2">
  <see cref="T:System.Xaml.XamlMember" /> или <see langword="null" />.</param>
        <summary>Определяет, различаются ли значения двух указанных объектов <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="xamlMember1" /> отличается от значения параметра <paramref name="xamlMember2" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает URI одного пространства имен XAML, определяющий первичное пространство имен XAML для этого объекта <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Идентификатор первичного пространства имен XAML для этого объекта <see cref="T:System.Xaml.XamlMember" /> в виде строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> Свойство предоставляет то же значение, что и вызов метода <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> и затем получение первой строки значение из возвращенного списка. Предпочтительный пространства имен XAML можно использовать при написании элемента к текст или другие представления, которые сохраняют сведения о пространстве имен XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />, указывающее, как визуальный конструктор должен обрабатывать этот член.</summary>
        <value>Значение перечисления <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />. Значение по умолчанию — <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.XamlType" /> того типа, в котором может существовать объект <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Тип, в котором может существовать объект <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемое значение отличается для присоединяемого и не присоединяемых членов. Не присоединяемых членов <xref:System.Xaml.XamlMember.TargetType%2A> возвращает <xref:System.Xaml.XamlMember.DeclaringType%2A>. Присоединяемых членов <xref:System.Xaml.XamlMember.LookupTargetType%2A> возвращает результат, основанный на эту логику:  
  
-   Если отражение не может разрешить резервирование (<xref:System.Xaml.XamlMember.IsUnknown%2A> `true`), этот метод возвращает внутреннюю константу, представляющую тип универсального объекта.  
  
-   Если предыдущее условие не применяется, <xref:System.Xaml.XamlMember.LookupTargetType%2A> вызывается. Реализация по умолчанию возвращает <xref:System.Xaml.XamlType> , основанный на изучение методов, реализующих `get` и `set` методы доступа. Класс может переопределить <xref:System.Xaml.XamlMember.LookupTargetType%2A> для использования другого поведения, такие, как другие метаданные форм может сообщить о целевых типов присоединяемых членов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строковое представление данного объекта <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Строковое представление данного объекта <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация возвращает <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.XamlType" /> того типа, который используется данным членом.</summary>
        <value>Объект <see cref="T:System.Xaml.XamlType" /> того типа, который используется данным членом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.Type%2A> вызывает <xref:System.Xaml.XamlMember.LookupType%2A> или конкретного переопределения этого метода. Это происходит, когда логика начального внутреннего отражения не уже настроен.  
  
 Поведение по умолчанию (не <xref:System.Xaml.XamlMember.LookupType%2A> переопределить), возвращенного <xref:System.Xaml.XamlType> может иметь разные общие значения. Применяемое значение зависит от того это <xref:System.Xaml.XamlMember> представляет свойство, метод или событие, как показано в следующем списке:  
  
-   Для свойства, возвращенного <xref:System.Xaml.XamlType> — тип, который задает свойство или возвращаемое свойство.  
  
-   Для события, возвращенного <xref:System.Xaml.XamlType> — это тип обработчика событий (делегат в реализации CLR).  
  
-   Для метода <xref:System.Xaml.XamlType> является тип возвращаемого значения этот метод, который может быть `null`.  
  
 В каждом случае контекст схемы XAML используется для определения типа XAML из резервного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, который может использоваться для создания конструкции преобразователя типов для объектов, объявленных в языке XAML.</summary>
        <value>Значение <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.ComponentModel.TypeConverter" /> для универсального класса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.TypeConverter%2A> вызывает <xref:System.Xaml.XamlMember.LookupTypeConverter%2A> или конкретного переопределения этого метода. Это происходит, когда логика начального внутреннего отражения не уже настроен.  
  
 Реализации, которые возвращают свойство отличное от null значение для <xref:System.Xaml.XamlMember.TypeConverter%2A> не обязательно являются рабочее <xref:System.ComponentModel.TypeConverter>. Ниже приведен список возможных возвращаемых значений от null для <xref:System.Xaml.XamlMember.TypeConverter%2A> и возможных значений:  
  
-   Возвращаемое значение сообщает преобразователь типов, помечается с членом, или более общем смысле конечный тип преобразователя. Такое поведение обычно какие большинство системы типов XAML и искать процессоры XAML для создания экземпляра преобразователя типов и вызова его методов.  
  
-   Возвращаемое значение сообщает преобразователь встроенных значений. Эти преобразователи существовать для некоторых внутренних операций, выполняемых модулем записи XAML. В частности эти встроенные преобразователи значений преобразования строковых значений атрибута строки примитивы языка XAML. Для реализации служб XAML .NET Framework эти встроенные преобразования типа часто пересылают в преобразователь типов, который определен в сборке System. Например, преобразование для <xref:System.Int32> значение встроен перенаправленных преобразования и, следовательно, <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> значение ссылки <xref:System.ComponentModel.Int32Converter>.  
  
-   Возвращаемое значение сообщает особого случая неограниченной объектной модели; то есть <xref:System.Xaml.XamlMember> имеет <xref:System.Xaml.XamlMember.Type%2A> значение <xref:System.Object>. В этом случае <xref:System.Xaml.Schema.XamlValueConverter%601> сообщает, что <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> — {`Object}`. Тем не менее <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> является `null` , так как не фактический тип или экземпляр, для выполнения этого преобразования. Вместо этого поведение модели объекта невозможно определить до времени выполнения, когда среда выполнения определенной технологии определяет обработку его графа объектов.  
  
 Если можно получить доступ к рабочей <xref:System.ComponentModel.TypeConverter> из <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>, можно вызывать его методы преобразования. Тем не менее многие методы преобразования зависит от контекста службы. Если у вас же контекст службы, доступные ожидает что преобразователь типов для стандартной роли записи объектов для графов объектов, методы преобразователя можно вызывать исключения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Reflection.MemberInfo" /> системы типов среды CLR, доступный для члена, который создан объектом <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodInfo" /> или <see cref="T:System.Reflection.EventInfo" />.</summary>
        <value>Сведения объекта <see cref="T:System.Reflection.MemberInfo" /> системы типов среды CLR, преобразованные из исходных параметров конструктора. Объект <see cref="T:System.Xaml.XamlMember" />, созданный с сигнатурой <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />, возвращает значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.UnderlyingMember%2A> вызывает <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> или конкретного переопределения этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, используемый для сериализации значений объектов, объявленных в языке XAML.</summary>
        <value>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Windows.Markup.ValueSerializer" /> для универсального класса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.ValueSerializer%2A> вызывает <xref:System.Xaml.XamlMember.LookupValueSerializer%2A> или конкретного переопределения этого метода. Это происходит, когда логика начального внутреннего отражения не уже настроен.  
  
 Не все варианты, которые возвращают свойство отличное от null значение для <xref:System.Xaml.XamlMember.ValueSerializer%2A> обязательно являются рабочее <xref:System.Windows.Markup.ValueSerializer>. См. в разделе <xref:System.Xaml.XamlMember.TypeConverter%2A>; эти же рекомендации будут применимы к <xref:System.Xaml.XamlMember.ValueSerializer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>