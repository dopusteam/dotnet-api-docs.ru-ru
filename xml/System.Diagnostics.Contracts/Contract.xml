<Type Name="Contract" FullName="System.Diagnostics.Contracts.Contract">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="18ccddeb7c646934cfcc1b40673135a0998cbc53" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30399708" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Contract" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Contract extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Contracts.Contract" />
  <TypeSignature Language="VB.NET" Value="Public Class Contract" />
  <TypeSignature Language="C++ CLI" Value="public ref class Contract abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="83d4c-101">Содержит статические методы для представления контрактов программы, таких как предусловие, постусловие и инвариантность объектов.</span>
      <span class="sxs-lookup">
        <span data-stu-id="83d4c-101">Contains static methods for representing program contracts such as preconditions, postconditions, and object invariants.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-102">Классы контрактов кода позволяют указать предусловия, постусловия и инварианты объектов в коде.</span><span class="sxs-lookup"><span data-stu-id="83d4c-102">Code contract classes let you specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="83d4c-103">Предусловия — это требования, которые должны быть выполнены при входе в метод или свойство.</span><span class="sxs-lookup"><span data-stu-id="83d4c-103">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="83d4c-104">Постусловия описывают ожидания во время выхода из кода метода или свойства.</span><span class="sxs-lookup"><span data-stu-id="83d4c-104">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="83d4c-105">Инварианты объектов описывают ожидаемое состояние для класса, который не представляет никаких проблем условие.</span><span class="sxs-lookup"><span data-stu-id="83d4c-105">Object invariants describe the expected state for a class that has no condition problems.</span></span> <span data-ttu-id="83d4c-106">Дополнительные сведения о предусловия, постусловия и инварианты объектов см. в разделе [контракты для кода](~/docs/framework/debug-trace-profile/code-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="83d4c-106">For more information about preconditions, postconditions, and object invariants, see [Code Contracts](~/docs/framework/debug-trace-profile/code-contracts.md).</span></span>  
  
 <span data-ttu-id="83d4c-107">Сведения о средствах и подробные инструкции по использованию контрактов кода см. на странице [Контракты кода](http://go.microsoft.com/fwlink/?LinkId=152461) на веб-сайте MSDN DevLabs.</span><span class="sxs-lookup"><span data-stu-id="83d4c-107">For tools and detailed instructions for using code contracts, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="83d4c-108">Необходимо использовать двоичный метод переопределения для вставки принудительного выполнения контрактов.</span><span class="sxs-lookup"><span data-stu-id="83d4c-108">You must use a binary rewriter to insert run-time enforcement of contracts.</span></span> <span data-ttu-id="83d4c-109">Например, в противном случае контракты <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> метод могут быть проверены только статически и не вызывают исключений во время выполнения в случае нарушения контракта.</span><span class="sxs-lookup"><span data-stu-id="83d4c-109">Otherwise, contracts such as the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> method can only be tested statically and will not throw exceptions during run time if a contract is violated.</span></span> <span data-ttu-id="83d4c-110">Двоичный модуль записи CCRewrite можно загрузить из [контракты для кода](http://go.microsoft.com/fwlink/?LinkId=152461) на сайте DevLabs MSDN.</span><span class="sxs-lookup"><span data-stu-id="83d4c-110">You can download the binary rewriter CCRewrite from [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span> <span data-ttu-id="83d4c-111">CCRewrite поставляется с надстройки Visual Studio, которая позволяет активировать принудительного выполнения контракта из проекта **свойства** страницы.</span><span class="sxs-lookup"><span data-stu-id="83d4c-111">CCRewrite comes with a Visual Studio add-in that enables you to activate run-time contract enforcement from the project **Properties** page.</span></span> <span data-ttu-id="83d4c-112">Двоичный модуль записи и надстройки Visual Studio не поставляются с [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] или Windows SDK.</span><span class="sxs-lookup"><span data-stu-id="83d4c-112">The binary rewriter and the Visual Studio add-in do not ship with [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] or the Windows SDK.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="83d4c-113">В отладочных построениях осуществляет проверку во время выполнения для указанного условия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-113">In debug builds, performs a run-time test for a specified condition.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="83d4c-114">Условное выражение, которое требуется подвергнуть проверке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-114">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-115">Проверяет условие; если условие имеет значение <see langword="false" />, следует политике эскалации, установленной для анализатора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-115">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set for the analyzer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-116">Политика расширения по умолчанию — уведомлять присоединенного отладчика о сбое контракта или отображения **Assert** диалоговое окно «», если не присоединен отладчик.</span><span class="sxs-lookup"><span data-stu-id="83d4c-116">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="83d4c-117">При необходимости анализатору может быть рекомендовано для создания исключения.</span><span class="sxs-lookup"><span data-stu-id="83d4c-117">Optionally, the analyzer can be instructed to throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="83d4c-118">Условное выражение, которое требуется подвергнуть проверке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-118">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="83d4c-119">Сообщение, отображаемое при несоответствии условия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-119">A message to display if the condition is not met.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-120">Проверяет условие; если условие имеет значение <see langword="false" />, следует политике эскалации, установленной анализатором, и отображает указанное сообщение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-120">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set by the analyzer and displays the specified message.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-121">Политика расширения по умолчанию — уведомлять присоединенного отладчика о сбое контракта или отображения **Assert** диалоговое окно «», если не присоединен отладчик.</span><span class="sxs-lookup"><span data-stu-id="83d4c-121">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="83d4c-122">При необходимости анализатору может быть рекомендовано для создания исключения.</span><span class="sxs-lookup"><span data-stu-id="83d4c-122">Optionally, the analyzer can be instructed to throw an exception.</span></span> <span data-ttu-id="83d4c-123">`userMessage` Параметр передается в выходные данные отладчика.</span><span class="sxs-lookup"><span data-stu-id="83d4c-123">The `userMessage` parameter is passed to the debugger output.</span></span> <span data-ttu-id="83d4c-124">Если `userMessage` не является строковой константы литерал, средства может отсутствовать на его чтение.</span><span class="sxs-lookup"><span data-stu-id="83d4c-124">If `userMessage` is not a constant string literal, tools may not be able to read it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Assume">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="83d4c-125">Инструктирует инструменты анализа кода полагать, что условием является <see langword="true" />, даже если статически невозможно подтвердить постоянное значение <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-125">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="83d4c-126">Предполагаемое условное выражение <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-126">The conditional expression to assume <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-127">Инструктирует инструменты анализа кода полагать, что указанным условием является <see langword="true" />, даже если статически невозможно подтвердить постоянное значение <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-127">Instructs code analysis tools to assume that the specified condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-128">Во время выполнения с помощью этого метода эквивалентно использованию <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> метод.</span><span class="sxs-lookup"><span data-stu-id="83d4c-128">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="83d4c-129">Предполагаемое условное выражение <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-129">The conditional expression to assume <see langword="true" />.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="83d4c-130">Сообщение, создаваемое при ошибочном предположении.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-130">The message to post if the assumption fails.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-131">Инструктирует инструменты анализа кода полагать, что условием является <see langword="true" />, даже если статически невозможно подтвердить постоянное значение <see langword="true" />, и отображает сообщение, если предположение было ошибочным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-131">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />, and displays a message if the assumption fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-132">Если `userMessage` не является строковой константы литерал, контракт может быть не распознан средствами.</span><span class="sxs-lookup"><span data-stu-id="83d4c-132">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 <span data-ttu-id="83d4c-133">Во время выполнения с помощью этого метода эквивалентно использованию <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> метод.</span><span class="sxs-lookup"><span data-stu-id="83d4c-133">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractFailed">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Contracts.Contract.ContractFailed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ContractFailed As EventHandler(Of ContractFailedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Diagnostics::Contracts::ContractFailedEventArgs ^&gt; ^ ContractFailed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="83d4c-134">Происходит, когда контракт не выполняется.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-134">Occurs when a contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-135">Сведения о событии для этого события является результатом <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> объект, передаваемый обработчику событий.</span><span class="sxs-lookup"><span data-stu-id="83d4c-135">The event information for this event is supplied by the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> object that is passed to the event handler.</span></span> <span data-ttu-id="83d4c-136">Это событие сообщает среде управляемого приложения, такие как интерактивный интерпретатор или веб-узел браузера, что контракт не удался.</span><span class="sxs-lookup"><span data-stu-id="83d4c-136">This event notifies a managed application environment such as an interactive interpreter or a Web browser host that a contract has failed.</span></span> <span data-ttu-id="83d4c-137">Прежде чем сделать это, он будет вызывать событие, которое приложение может обрабатывать, как считает нужным.</span><span class="sxs-lookup"><span data-stu-id="83d4c-137">Before doing so, it will raise an event that an application can handle as it sees fit.</span></span> <span data-ttu-id="83d4c-138">Например если код запускается в среде тестирования, можно войти сбоя теста и затем завершить тест.</span><span class="sxs-lookup"><span data-stu-id="83d4c-138">For example, if code is being run in a testing framework, you can log a test failure and then end the test.</span></span>  
  
 <span data-ttu-id="83d4c-139">Реализация по умолчанию <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> метод в библиотеке классов .NET Framework — вызывает каждый обработчик, зарегистрированный в <xref:System.Diagnostics.Contracts.Contract.ContractFailed> событий.</span><span class="sxs-lookup"><span data-stu-id="83d4c-139">The default implementation of the <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> method in the .NET Framework class library is to call each handler that is registered with the <xref:System.Diagnostics.Contracts.Contract.ContractFailed> event.</span></span> <span data-ttu-id="83d4c-140">Исключения, создаваемые обработчики учитываются, но каждый обработчик можно указать, является ли сбой обрабатывается путем вызова <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> метод для аргументов событий.</span><span class="sxs-lookup"><span data-stu-id="83d4c-140">Exceptions thrown by handlers are ignored, but each handler can indicate whether the failure is handled by calling the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> method for the event arguments.</span></span> <span data-ttu-id="83d4c-141">Если обработчик устанавливает сбой как обработанное, метод возвращает `null` и никакие дополнительные действия не выполняются.</span><span class="sxs-lookup"><span data-stu-id="83d4c-141">If any handler sets the failure as handled, the method returns `null` and no further action is taken.</span></span> <span data-ttu-id="83d4c-142">Кроме того, можно вызывать обработчики <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> метод, чтобы указать код для очистки.</span><span class="sxs-lookup"><span data-stu-id="83d4c-142">Alternatively, handlers can call the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> method to instruct the code to unwind.</span></span> <span data-ttu-id="83d4c-143">В этом случае исключение после выполнения всех обработчиков.</span><span class="sxs-lookup"><span data-stu-id="83d4c-143">In that case, an exception is thrown after all handlers have executed.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="83d4c-144">требуется полное доверие для непосредственно вызывающего метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-144">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="83d4c-145">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-145">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="EndContractBlock">
      <MemberSignature Language="C#" Value="public static void EndContractBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndContractBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EndContractBlock" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndContractBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndContractBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="83d4c-146">Помечает конец раздела контракта, когда контракты метода содержат только предусловия вида <see langword="if" />-<see langword="then" />-<see langword="throw" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-146">Marks the end of the contract section when a method's contracts contain only preconditions in the <see langword="if" />-<see langword="then" />-<see langword="throw" /> form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-147">Большая часть кода уже содержит определенную проверку параметров в виде `if` - `then` - `throw` кода.</span><span class="sxs-lookup"><span data-stu-id="83d4c-147">Most code already contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="83d4c-148">Средства контракта распознают `if` - `then` - `throw` операторы как предусловия при операторы идут первыми внутри метода, и следуют явные всегонаборатакихоператоров<xref:System.Diagnostics.Contracts.Contract> вызов метода, такие как <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, или <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="83d4c-148">The contract tools recognize `if`-`then`-`throw` statements as preconditions when the statements appear first inside a method, and the entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span></span>  
  
 <span data-ttu-id="83d4c-149">Когда `if` - `then` - `throw` операторы появляются в этой форме, средства контракта распознают их как устаревшие-инструкции.</span><span class="sxs-lookup"><span data-stu-id="83d4c-149">When `if`-`then`-`throw` statements appear in this form, the contract tools recognize them as legacy-require statements.</span></span> <span data-ttu-id="83d4c-150"><xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> Используется только в том случае, если нет других контрактов `if` - `then` - `throw` последовательности, но они по-прежнему должен быть отмечен как устаревший-требуется.</span><span class="sxs-lookup"><span data-stu-id="83d4c-150">The <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> form is used only if no other contracts follow the `if`-`then`-`throw` sequences, but they should still be tagged as legacy-requires.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ensures">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="83d4c-151">Указывает контракт постусловия для включающего метода или свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-151">Specifies a postcondition contract for the enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="83d4c-152">Условное выражение, которое требуется подвергнуть проверке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-152">The conditional expression to test.</span>
          </span>
          <span data-ttu-id="83d4c-153">Выражение может включать значения <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" /> и <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-153">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />, and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-154">Указывает контракт постусловия для включающего метода или свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-154">Specifies a postcondition contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-155">`condition` Указывает постусловие, для которого должно быть `true` при включающего метода или свойства возвращаются в обычном режиме.</span><span class="sxs-lookup"><span data-stu-id="83d4c-155">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="83d4c-156">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</span><span class="sxs-lookup"><span data-stu-id="83d4c-156">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83d4c-157">Необходимо использовать двоичный метод переопределения (найти по адресу [контракты для кода](http://go.microsoft.com/fwlink/?LinkId=152461) на сайте DevLabs MSDN) для принудительного выполнения данного постусловия.</span><span class="sxs-lookup"><span data-stu-id="83d4c-157">You must use the binary rewriter (available at [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="83d4c-158">В следующем примере показано, как использовать <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> метод, чтобы гарантировать, что возвращается с ожидаемым значением.</span><span class="sxs-lookup"><span data-stu-id="83d4c-158">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method to ensure that an expected value is returned.</span></span> <span data-ttu-id="83d4c-159">Данный пример кода является частью большего примера, приведенного для <xref:System.Diagnostics.Contracts.ContractClassAttribute> класса.</span><span class="sxs-lookup"><span data-stu-id="83d4c-159">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="83d4c-160">Условное выражение, которое требуется подвергнуть проверке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-160">The conditional expression to test.</span>
          </span>
          <span data-ttu-id="83d4c-161">Выражение может включать значения <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> и <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-161">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="83d4c-162">Сообщение, отображаемое в том случае, если выражение не является <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-162">The message to display if the expression is not <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-163">Указывает контракт постусловия для предоставленного выходного условия и сообщение, отображаемое, если условие имеет значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-163">Specifies a postcondition contract for a provided exit condition and a message to display if the condition is <see langword="false" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-164">`condition` Указывает постусловие, для которого должно быть `true` при включающего метода или свойства возвращаются в обычном режиме.</span><span class="sxs-lookup"><span data-stu-id="83d4c-164">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="83d4c-165">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</span><span class="sxs-lookup"><span data-stu-id="83d4c-165">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83d4c-166">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</span><span class="sxs-lookup"><span data-stu-id="83d4c-166">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83d4c-167">Необходимо использовать двоичный метод переопределения (найти по адресу [контракты для кода](http://go.microsoft.com/fwlink/?LinkId=152461) на сайте DevLabs MSDN) для принудительного выполнения данного постусловия.</span><span class="sxs-lookup"><span data-stu-id="83d4c-167">You must use the binary rewriter (available at [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="83d4c-168">Если `userMessage` не является строковой константы литерал, контракт может быть не распознан средствами.</span><span class="sxs-lookup"><span data-stu-id="83d4c-168">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnsuresOnThrow&lt;TException&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="83d4c-169">Задает контракт постусловия для включающего метода или свойства на основе предоставленных исключения и состояния.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-169">Specifies a postcondition contract for the enclosing method or property based on the provided exception and condition.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="83d4c-170">Тип исключения, вызвавшего проверку постусловия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-170">The type of exception that invokes the postcondition check.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="83d4c-171">Условное выражение, которое требуется подвергнуть проверке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-171">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-172">Задает контракт постусловия для включающего метода или свойства на основе предоставленных исключения и состояния.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-172">Specifies a postcondition contract for the enclosing method or property, based on the provided exception and condition.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-173">`condition` Указывает постусловие, для которого должно быть `true` при включающего метода или свойства аварийно завершает работу и исключение типа `TException` возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="83d4c-173">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span>  
  
-   <span data-ttu-id="83d4c-174">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</span><span class="sxs-lookup"><span data-stu-id="83d4c-174">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83d4c-175">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</span><span class="sxs-lookup"><span data-stu-id="83d4c-175">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83d4c-176">Необходимо использовать двоичный метод переопределения для принудительного выполнения данного постусловия.</span><span class="sxs-lookup"><span data-stu-id="83d4c-176">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="83d4c-177">Тип исключения, вызвавшего проверку постусловия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-177">The type of exception that invokes the postcondition check.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="83d4c-178">Условное выражение, которое требуется подвергнуть проверке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-178">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="83d4c-179">Отображаемое сообщение при выражении <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-179">The message to display if the expression is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-180">Задает контракт постусловия и сообщение, которое необходимо отобразить, если условие имеет значение <see langword="false" />, для включающего метода или свойства на основе предоставленных исключения и условия.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-180">Specifies a postcondition contract and a message to display if the condition is <see langword="false" /> for the enclosing method or property, based on the provided exception and condition.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-181">`condition` Указывает постусловие, для которого должно быть `true` при включающего метода или свойства аварийно завершает работу и исключение типа `TException` возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="83d4c-181">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span> <span data-ttu-id="83d4c-182">`message` Параметр задает сообщение, отображаемое, если условие равно `false`.</span><span class="sxs-lookup"><span data-stu-id="83d4c-182">The `message` parameter specifies a message to display if the condition is `false`.</span></span>  
  
-   <span data-ttu-id="83d4c-183">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</span><span class="sxs-lookup"><span data-stu-id="83d4c-183">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83d4c-184">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</span><span class="sxs-lookup"><span data-stu-id="83d4c-184">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83d4c-185">Необходимо использовать двоичный метод переопределения для принудительного выполнения данного постусловия.</span><span class="sxs-lookup"><span data-stu-id="83d4c-185">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="83d4c-186">Если `userMessage` не является строковой константы литерал, контракт может быть не распознан средствами.</span><span class="sxs-lookup"><span data-stu-id="83d4c-186">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="83d4c-187">Первое целое число для передачи в <c>predicate</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-187">The first integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="83d4c-188">Последнее целое число для передачи в <c>predicate</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-188">One more than the last integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="83d4c-189">Функция, оцениваемая на предмет любого значения целого числа в указанном диапазоне.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-189">The function to evaluate for any value of the integer in the specified range.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-190">Определяет, удовлетворяет ли проверке какое-либо целое число в диапазоне целых чисел.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-190">Determines whether a specified test is true for any integer within a range of integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="83d4c-191">Значение <see langword="true" />, если <paramref name="predicate" /> возвращает <see langword="true" /> для любого целого числа, начиная от <paramref name="fromInclusive" /> до <paramref name="toExclusive" /> минус один.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-191">
              <see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for any integer starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-192">`toExclusive` Параметр принадлежит к одному больше, чем последнее целое число для облегчения использования длины диапазон целых чисел, начиная с 0.</span><span class="sxs-lookup"><span data-stu-id="83d4c-192">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="83d4c-193">Например оно устанавливается равным 5 для целых чисел от 0 до 4.</span><span class="sxs-lookup"><span data-stu-id="83d4c-193">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="83d4c-194">Свойство <paramref name="predicate" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-194">
              <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="83d4c-195">Значение <paramref name="toExclusive" /> меньше <paramref name="fromInclusive" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-195">
              <paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="83d4c-196">Тип, который содержится в <c>коллекции</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-196">The type that is contained in <c>collection</c>.</span>
          </span>
        </typeparam>
        <param name="collection">
          <span data-ttu-id="83d4c-197">Коллекция, из которой будут извлекаться элементы типа <c>T</c> для передачи в <c>predicate</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-197">The collection from which elements of type <c>T</c> will be drawn to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="83d4c-198">Функция, оцениваемая на предмет элемента, содержащегося в параметре <c>collection</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-198">The function to evaluate for an element in <c>collection</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-199">Определяет, существует ли в рамках функции элемент в указанной коллекции элементов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-199">Determines whether an element within a collection of elements exists within a function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="83d4c-200">Значение <see langword="true" />, если и только если <paramref name="predicate" /> возвращает значение <see langword="true" /> для любого из элементов типа <paramref name="T" />, содержащихся в параметре <paramref name="collection" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-200">
              <see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for any element of type <paramref name="T" /> in <paramref name="collection" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="83d4c-201">Параметр <paramref name="collection" /> или <paramref name="predicate" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-201">
              <paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll">
      <MemberSignature Language="C#" Value="public static bool ForAll (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ForAll(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="83d4c-202">Первое целое число для передачи в <c>predicate</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-202">The first integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="83d4c-203">Последнее целое число для передачи в <c>predicate</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-203">One more than the last integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="83d4c-204">Функция, оцениваемая, чтобы установить существование целых чисел в указанном диапазоне.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-204">The function to evaluate for the existence of the integers in the specified range.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-205">Определяет, выполняется ли определенное условие для всех целых чисел в указанном диапазоне.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-205">Determines whether a particular condition is valid for all integers in a specified range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="83d4c-206">Значение <see langword="true" />, если <paramref name="predicate" /> возвращает <see langword="true" /> для всех целых чисел, начиная от <paramref name="fromInclusive" /> до <paramref name="toExclusive" /> минус один.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-206">
              <see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for all integers starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-207">`toExclusive` Параметр принадлежит к одному больше, чем последнее целое число для облегчения использования длины диапазон целых чисел, начиная с 0.</span><span class="sxs-lookup"><span data-stu-id="83d4c-207">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="83d4c-208">Например оно устанавливается равным 5 для целых чисел от 0 до 4.</span><span class="sxs-lookup"><span data-stu-id="83d4c-208">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="83d4c-209">В следующем примере демонстрируется использование <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> метод, чтобы определить, имеет ли массив элемент null.</span><span class="sxs-lookup"><span data-stu-id="83d4c-209">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether an array has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="83d4c-210">Свойство <paramref name="predicate" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-210">
              <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="83d4c-211">Значение <paramref name="toExclusive" /> меньше <paramref name="fromInclusive" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-211">
              <paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool ForAll(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="83d4c-212">Тип, который содержится в <c>коллекции</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-212">The type that is contained in <c>collection</c>.</span>
          </span>
        </typeparam>
        <param name="collection">
          <span data-ttu-id="83d4c-213">Коллекция, из которой будут извлекаться элементы типа <c>T</c> для передачи в <c>predicate</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-213">The collection from which elements of type <c>T</c> will be drawn to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="83d4c-214">Функция, оцениваемая на предмет наличия всех элементов, содержащихся в параметре <c>collection</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-214">The function to evaluate for the existence of all the elements in <c>collection</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-215">Определяет, существуют ли в рамках функции все элементы в коллекции.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-215">Determines whether all the elements in a collection exist within a function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="83d4c-216">Значение <see langword="true" />, если и только если <paramref name="predicate" /> возвращает значение <see langword="true" /> для всех элементов типа <paramref name="T" />, содержащихся в параметре <paramref name="collection" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-216">
              <see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for all elements of type <paramref name="T" /> in <paramref name="collection" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="83d4c-217">В следующем примере демонстрируется использование <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> метод, чтобы определить, содержит ли коллекция элемент null.</span><span class="sxs-lookup"><span data-stu-id="83d4c-217">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether a collection has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="83d4c-218">Параметр <paramref name="collection" /> или <paramref name="predicate" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-218">
              <paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invariant">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="83d4c-219">Указывает контракт для включающего метода или свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-219">Specifies a contract for an enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="83d4c-220">Условное выражение, которое требуется подвергнуть проверке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-220">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-221">Задает инвариантный контракт ля включающего метода или свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-221">Specifies an invariant contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> контракты внутри метода, который определяется параметром <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> атрибут; как правило, метод с именем `ObjectInvariant`.</span><span class="sxs-lookup"><span data-stu-id="83d4c-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="83d4c-223">Этот контракт может быть указаны только в выделенной инвариантный метод, который объявлен в классе.</span><span class="sxs-lookup"><span data-stu-id="83d4c-223">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span> <span data-ttu-id="83d4c-224">Если метод не запечатан, он должен указывать только на защищенные члены, не закрытые члены, чтобы быть уверенным в поддержке инвариантов подклассов.</span><span class="sxs-lookup"><span data-stu-id="83d4c-224">If the method is not sealed, it should refer only to protected members, not private members, so that subclasses can be sure to maintain the invariants.</span></span>  
  
-   <span data-ttu-id="83d4c-225">Этот контракт не открыт для клиентов; Таким образом он может ссылаться на элементы, которые менее видимы, чем у включающего метода.</span><span class="sxs-lookup"><span data-stu-id="83d4c-225">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="83d4c-226">Необходимо использовать двоичный метод переопределения для принудительного выполнения данной инвариантности.</span><span class="sxs-lookup"><span data-stu-id="83d4c-226">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="83d4c-227">Инварианты условно определяются на основе наличия из `CONTRACTS FULL` символов.</span><span class="sxs-lookup"><span data-stu-id="83d4c-227">Invariants are conditionally defined based on the presence of the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="83d4c-228">При проверке во время выполнения инварианты проверяются в конце каждого открытого метода.</span><span class="sxs-lookup"><span data-stu-id="83d4c-228">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="83d4c-229">Если инвариант упоминает открытый метод в том же классе, проверка инварианта, которая обычно происходит в конце этого открытого метода отключены и проверяется только в конце самого внешнего вызова метода для этого класса.</span><span class="sxs-lookup"><span data-stu-id="83d4c-229">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="83d4c-230">Это также происходит, если класс повторно вводится в результате вызова метода в другом классе.</span><span class="sxs-lookup"><span data-stu-id="83d4c-230">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="83d4c-231">Условное выражение, которое требуется подвергнуть проверке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-231">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="83d4c-232">Отображаемое сообщение при условии <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-232">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-233">Указывает инвариантный контракт для включающего метода или свойства и отображает сообщение, если условие для контракта не выполняется.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-233">Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> контракты внутри метода, который определяется параметром <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> атрибут; как правило, метод с именем `ObjectInvariant`.</span><span class="sxs-lookup"><span data-stu-id="83d4c-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="83d4c-235">Этот контракт может быть указаны только в выделенной инвариантный метод, который объявлен в классе.</span><span class="sxs-lookup"><span data-stu-id="83d4c-235">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span>  
  
-   <span data-ttu-id="83d4c-236">Этот контракт не открыт для клиентов; Таким образом он может ссылаться на элементы, которые менее видимы, чем у включающего метода.</span><span class="sxs-lookup"><span data-stu-id="83d4c-236">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="83d4c-237">Необходимо использовать двоичный метод переопределения для принудительного выполнения данной инвариантности.</span><span class="sxs-lookup"><span data-stu-id="83d4c-237">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="83d4c-238">Инварианты условно определяются на `CONTRACTS FULL` символов.</span><span class="sxs-lookup"><span data-stu-id="83d4c-238">Invariants are conditionally defined on the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="83d4c-239">При проверке во время выполнения инварианты проверяются в конце каждого открытого метода.</span><span class="sxs-lookup"><span data-stu-id="83d4c-239">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="83d4c-240">Если инвариант упоминает открытый метод в том же классе, проверка инварианта, которая обычно происходит в конце этого открытого метода отключены и проверяется только в конце самого внешнего вызова метода для этого класса.</span><span class="sxs-lookup"><span data-stu-id="83d4c-240">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="83d4c-241">Это также происходит, если класс повторно вводится в результате вызова метода в другом классе.</span><span class="sxs-lookup"><span data-stu-id="83d4c-241">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OldValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T OldValue&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T OldValue&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OldValue(Of T) (value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T OldValue(T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="83d4c-242">Тип значения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-242">The type of value.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="83d4c-243">Представляемое значение (поле или параметр).</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-243">The value to represent (field or parameter).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-244">Представляет значения, какими они были в начале метода или свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-244">Represents values as they were at the start of a method or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="83d4c-245">Значение параметра или поля при запуске метода или свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-245">The value of the parameter or field at the start of a method or property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-246">Этот метод может использоваться только в условного выражения для <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> контракта.</span><span class="sxs-lookup"><span data-stu-id="83d4c-246">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="83d4c-247">В следующем примере показано использование <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> метод, чтобы гарантировать, что подсчет был обновлен.</span><span class="sxs-lookup"><span data-stu-id="83d4c-247">The following example shows the use of the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method to ensure that a count has been updated.</span></span> <span data-ttu-id="83d4c-248">Данный пример кода является частью большего примера, приведенного для <xref:System.Diagnostics.Contracts.ContractClassAttribute> класса.</span><span class="sxs-lookup"><span data-stu-id="83d4c-248">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#5](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#5)]
 [!code-vb[ContractExample#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Requires">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="83d4c-249">Указывает контракт предусловия для включающего метода или свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-249">Specifies a precondition contract for an enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="83d4c-250">Условное выражение, которое требуется подвергнуть проверке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-250">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-251">Указывает контракт предусловия для включающего метода или свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-251">Specifies a precondition contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="83d4c-252">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</span><span class="sxs-lookup"><span data-stu-id="83d4c-252">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83d4c-253">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</span><span class="sxs-lookup"><span data-stu-id="83d4c-253">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83d4c-254">Используйте этот метод вместо <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> метод при обратной совместимости не заставляет выдачи исключения.</span><span class="sxs-lookup"><span data-stu-id="83d4c-254">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="83d4c-255">Условное выражение, которое требуется подвергнуть проверке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-255">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="83d4c-256">Отображаемое сообщение при условии <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-256">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-257">Указывает контракт предусловия для включающего метода или свойства и отображает сообщение, если условие для контракта не выполняется.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-257">Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="83d4c-258">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</span><span class="sxs-lookup"><span data-stu-id="83d4c-258">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83d4c-259">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</span><span class="sxs-lookup"><span data-stu-id="83d4c-259">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83d4c-260">Используйте этот метод вместо <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> метод при обратной совместимости не заставляет выдачи исключения.</span><span class="sxs-lookup"><span data-stu-id="83d4c-260">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="83d4c-261">Выдаваемое исключение при условии <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-261">The exception to throw if the condition is <see langword="false" />.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="83d4c-262">Условное выражение, которое требуется подвергнуть проверке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-262">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-263">Указывает контракт предусловия для включающего метода или свойства и выдает исключение, если условие для контракта не выполняется.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-263">Specifies a precondition contract for the enclosing method or property, and throws an exception if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="83d4c-264">Необходимо включить проверки для использования во время выполнения <xref:System.Diagnostics.Contracts.Contract.Requires%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="83d4c-264">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="83d4c-265">Если проверки во время выполнения отключен, процесс будет завершен.</span><span class="sxs-lookup"><span data-stu-id="83d4c-265">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="83d4c-266">Чтобы получить средства проверки среды выполнения, см. [контракты для кода](http://go.microsoft.com/fwlink/?LinkId=152461) на сайте DevLabs MSDN.</span><span class="sxs-lookup"><span data-stu-id="83d4c-266">To obtain the tools for runtime checking, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
-   <span data-ttu-id="83d4c-267">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</span><span class="sxs-lookup"><span data-stu-id="83d4c-267">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83d4c-268">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</span><span class="sxs-lookup"><span data-stu-id="83d4c-268">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83d4c-269">Используйте этот метод вместо <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> метод для создания исключения, если условие сбоя.</span><span class="sxs-lookup"><span data-stu-id="83d4c-269">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="83d4c-270">Выдаваемое исключение при условии <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-270">The exception to throw if the condition is <see langword="false" />.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="83d4c-271">Условное выражение, которое требуется подвергнуть проверке.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-271">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="83d4c-272">Отображаемое сообщение при условии <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-272">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-273">Задает контракт предусловия для включающего метода или свойства и создает исключение с предоставленным сообщением, если условие для контракта не выполняется.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-273">Specifies a precondition contract for the enclosing method or property, and throws an exception with the provided message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   > [!IMPORTANT]
    >  <span data-ttu-id="83d4c-274">Необходимо включить проверки для использования во время выполнения <xref:System.Diagnostics.Contracts.Contract.Requires%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="83d4c-274">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="83d4c-275">Если проверки во время выполнения отключен, процесс будет завершен.</span><span class="sxs-lookup"><span data-stu-id="83d4c-275">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="83d4c-276">Чтобы получить средства проверки среды выполнения, см. [контракты для кода](http://go.microsoft.com/fwlink/?LinkId=152461) на сайте DevLabs MSDN.</span><span class="sxs-lookup"><span data-stu-id="83d4c-276">To obtain the tools for runtime checking, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
     <span data-ttu-id="83d4c-277">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</span><span class="sxs-lookup"><span data-stu-id="83d4c-277">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83d4c-278">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</span><span class="sxs-lookup"><span data-stu-id="83d4c-278">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83d4c-279">Используйте этот метод вместо <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> метод для создания исключения, если условие сбоя.</span><span class="sxs-lookup"><span data-stu-id="83d4c-279">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Result&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Result&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Result``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Result(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Result();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="83d4c-280">Тип возвращаемого значения включающего метода или свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-280">Type of return value of the enclosing method or property.</span>
          </span>
        </typeparam>
        <summary>
          <span data-ttu-id="83d4c-281">Представляет возвращаемое значение метода или свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-281">Represents the return value of a method or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="83d4c-282">Возвращаемое значение включающего метода или свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-282">Return value of the enclosing method or property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-283">Этот метод может использоваться только в условного выражения для <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> контракта.</span><span class="sxs-lookup"><span data-stu-id="83d4c-283">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="83d4c-284">В следующем примере показано, как использовать <xref:System.Diagnostics.Contracts.Contract.Result%2A> метод, чтобы указать ожидаемое возвращаемое значение.</span><span class="sxs-lookup"><span data-stu-id="83d4c-284">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Result%2A> method to specify an expected return value.</span></span> <span data-ttu-id="83d4c-285">Данный пример кода является частью большего примера, приведенного для <xref:System.Diagnostics.Contracts.ContractClassAttribute> класса.</span><span class="sxs-lookup"><span data-stu-id="83d4c-285">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueAtReturn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ValueAtReturn&lt;T&gt; (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ValueAtReturn&lt;T&gt;([out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ValueAtReturn(Of T) (ByRef value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T ValueAtReturn([Runtime::InteropServices::Out] T % value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="83d4c-286">Тип параметра <see langword="out" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-286">The type of the <see langword="out" /> parameter.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="83d4c-287">Параметр <see langword="out" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-287">The <see langword="out" /> parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="83d4c-288">Представляет итоговое (выходное) значение параметра <see langword="out" /> по возвращении из метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-288">Represents the final (output) value of an <see langword="out" /> parameter when returning from a method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="83d4c-289">Выходное значение параметра <see langword="out" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="83d4c-289">The output value of the <see langword="out" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83d4c-290">Этот метод может использоваться только в условного выражения для <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> контракта.</span><span class="sxs-lookup"><span data-stu-id="83d4c-290">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span> <span data-ttu-id="83d4c-291">Как и в методе <xref:System.Diagnostics.Contracts.Contract.OldValue%2A>, вы можете опустить параметр универсального типа там, где компилятор способен вывести его тип.</span><span class="sxs-lookup"><span data-stu-id="83d4c-291">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="83d4c-292">Модуль переопределения контракта заменяет вызов метода значением параметра `out`.</span><span class="sxs-lookup"><span data-stu-id="83d4c-292">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="83d4c-293">Метод <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> может появляться только в постусловиях.</span><span class="sxs-lookup"><span data-stu-id="83d4c-293">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="83d4c-294">Аргумент метода должен быть параметром `out` или полем параметра `out` структуры.</span><span class="sxs-lookup"><span data-stu-id="83d4c-294">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="83d4c-295">Последний вариант также полезен при ссылке на поля в постусловии конструктора структуры.</span><span class="sxs-lookup"><span data-stu-id="83d4c-295">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>