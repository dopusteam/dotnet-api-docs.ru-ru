<Type Name="ChannelDispatcher" FullName="System.ServiceModel.Dispatcher.ChannelDispatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="64dc4c5d742c5867797292781de3cf5cf782be73" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53294634" /></Metadata><TypeSignature Language="C#" Value="public class ChannelDispatcher : System.ServiceModel.Dispatcher.ChannelDispatcherBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ChannelDispatcher extends System.ServiceModel.Dispatcher.ChannelDispatcherBase" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Dispatcher.ChannelDispatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class ChannelDispatcher&#xA;Inherits ChannelDispatcherBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChannelDispatcher : System::ServiceModel::Dispatcher::ChannelDispatcherBase" />
  <TypeSignature Language="F#" Value="type ChannelDispatcher = class&#xA;    inherit ChannelDispatcherBase" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Dispatcher.ChannelDispatcherBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Компонент, который принимает каналы и связывает их со службой.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> связывает интерфейс <xref:System.ServiceModel.Channels.IChannelListener> по определенному URI (называемом «URI прослушивания») с экземпляром службы. Каждый объект <xref:System.ServiceModel.ServiceHost> может иметь множество объектов <xref:System.ServiceModel.Dispatcher.ChannelDispatcher>, каждый из которых связан со своим прослушивателем и URI прослушивания для данной службы.  
  
 При поступлении сообщения диспетчер каналов <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> запрашивает все связанные объекты <xref:System.ServiceModel.Dispatcher.EndpointDispatcher>, может ли данная конечная точка принять это сообщение, и передает его соответствующей конечной точке. Объект <xref:System.ServiceModel.Dispatcher.EndpointDispatcher> отвечает за обработку сообщений от <xref:System.ServiceModel.Dispatcher.ChannelDispatcher>, если адрес назначения сообщения соответствует свойству <xref:System.ServiceModel.Dispatcher.EndpointDispatcher.AddressFilter%2A> и действие сообщения соответствует свойству <xref:System.ServiceModel.Dispatcher.EndpointDispatcher.ContractFilter%2A>.  
  
 Все свойства, которые управляют временем существования и поведением сеанса канала, доступны для проверки или изменения в объекте <xref:System.ServiceModel.Dispatcher.ChannelDispatcher>. Кроме <xref:System.ServiceModel.Dispatcher.EndpointDispatcher>, к ним относятся пользовательские объекты <xref:System.ServiceModel.Dispatcher.IChannelInitializer>, <xref:System.ServiceModel.Channels.IChannelListener>, <xref:System.ServiceModel.ServiceHost>, связанные объекты и <xref:System.ServiceModel.InstanceContext>.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/service.cs#0)]
 [!code-vb[S_UE_ChannelDispatcher#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/service.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Dispatcher.ChannelDispatcher" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ChannelDispatcher (System.ServiceModel.Channels.IChannelListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Channels.IChannelListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.#ctor(System.ServiceModel.Channels.IChannelListener)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (listener As IChannelListener)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ChannelDispatcher(System::ServiceModel::Channels::IChannelListener ^ listener);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Dispatcher.ChannelDispatcher : System.ServiceModel.Channels.IChannelListener -&gt; System.ServiceModel.Dispatcher.ChannelDispatcher" Usage="new System.ServiceModel.Dispatcher.ChannelDispatcher listener" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="listener" Type="System.ServiceModel.Channels.IChannelListener" />
      </Parameters>
      <Docs>
        <param name="listener">Объект <see cref="T:System.ServiceModel.Channels.IChannelListener" /> для диспетчера каналов.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Dispatcher.ChannelDispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Инициализирует новый экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> из предоставленного прослушивателя, с системными значениями времени ожидания по умолчанию.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#1)]
 [!code-vb[S_UE_ChannelDispatcher#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="listener" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ChannelDispatcher (System.ServiceModel.Channels.IChannelListener listener, string bindingName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Channels.IChannelListener listener, string bindingName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.#ctor(System.ServiceModel.Channels.IChannelListener,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (listener As IChannelListener, bindingName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ChannelDispatcher(System::ServiceModel::Channels::IChannelListener ^ listener, System::String ^ bindingName);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Dispatcher.ChannelDispatcher : System.ServiceModel.Channels.IChannelListener * string -&gt; System.ServiceModel.Dispatcher.ChannelDispatcher" Usage="new System.ServiceModel.Dispatcher.ChannelDispatcher (listener, bindingName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="listener" Type="System.ServiceModel.Channels.IChannelListener" />
        <Parameter Name="bindingName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="listener">Объект <see cref="T:System.ServiceModel.Channels.IChannelListener" /> для диспетчера каналов.</param>
        <param name="bindingName">Имя привязки, используемое для настройки службы.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Dispatcher.ChannelDispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Инициализирует новый экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> из предоставленного прослушивателя и привязки, с системными значениями времени ожидания по умолчанию.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#2)]
 [!code-vb[S_UE_ChannelDispatcher#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="listener" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ChannelDispatcher (System.ServiceModel.Channels.IChannelListener listener, string bindingName, System.ServiceModel.IDefaultCommunicationTimeouts timeouts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Channels.IChannelListener listener, string bindingName, class System.ServiceModel.IDefaultCommunicationTimeouts timeouts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.#ctor(System.ServiceModel.Channels.IChannelListener,System.String,System.ServiceModel.IDefaultCommunicationTimeouts)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (listener As IChannelListener, bindingName As String, timeouts As IDefaultCommunicationTimeouts)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ChannelDispatcher(System::ServiceModel::Channels::IChannelListener ^ listener, System::String ^ bindingName, System::ServiceModel::IDefaultCommunicationTimeouts ^ timeouts);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Dispatcher.ChannelDispatcher : System.ServiceModel.Channels.IChannelListener * string * System.ServiceModel.IDefaultCommunicationTimeouts -&gt; System.ServiceModel.Dispatcher.ChannelDispatcher" Usage="new System.ServiceModel.Dispatcher.ChannelDispatcher (listener, bindingName, timeouts)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="listener" Type="System.ServiceModel.Channels.IChannelListener" />
        <Parameter Name="bindingName" Type="System.String" />
        <Parameter Name="timeouts" Type="System.ServiceModel.IDefaultCommunicationTimeouts" />
      </Parameters>
      <Docs>
        <param name="listener">Объект <see cref="T:System.ServiceModel.Channels.IChannelListener" /> для службы.</param>
        <param name="bindingName">Имя привязки, используемое для настройки службы.</param>
        <param name="timeouts">Объект <see cref="T:System.ServiceModel.IDefaultCommunicationTimeouts" /> для службы.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Dispatcher.ChannelDispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Инициализирует новый экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> из предоставленного прослушивателя и привязки с указанными значениями времени ожидания по умолчанию.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#3)]
 [!code-vb[S_UE_ChannelDispatcher#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="listener" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsynchronousTransactedAcceptEnabled">
      <MemberSignature Language="C#" Value="public bool AsynchronousTransactedAcceptEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsynchronousTransactedAcceptEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.AsynchronousTransactedAcceptEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property AsynchronousTransactedAcceptEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AsynchronousTransactedAcceptEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AsynchronousTransactedAcceptEnabled : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.AsynchronousTransactedAcceptEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, являются ли вызовы метода приема на прослушивателе в рамках транзакции асинхронными.</summary>
        <value>Значение <see langword="true" />, если вызовы метода приема на прослушивателе в рамках транзакции являются асинхронными; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="protected override void Attach (System.ServiceModel.ServiceHostBase host);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Attach(class System.ServiceModel.ServiceHostBase host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.Attach(System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Attach (host As ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Attach(System::ServiceModel::ServiceHostBase ^ host);" />
      <MemberSignature Language="F#" Value="override this.Attach : System.ServiceModel.ServiceHostBase -&gt; unit" Usage="channelDispatcher.Attach host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="host">Объект <see cref="T:System.ServiceModel.ServiceHostBase" /> для службы.</param>
        <summary>Прикрепляет диспетчер каналов к узлу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка данного свойства возможна, только когда экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> находится в состоянии <xref:System.ServiceModel.CommunicationState.Created>, так как это единственное состояние, которое одновременно является изменяемым и не удаляется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Opening" /> или <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Closing" /> или <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindingName">
      <MemberSignature Language="C#" Value="public string BindingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BindingName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.BindingName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BindingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingName : string" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.BindingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя привязки, используемое для настройки службы.</summary>
        <value>Имя привязки службы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используется для получения имени для привязки, с которой связан данный диспетчер каналов.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#4)]
 [!code-vb[S_UE_ChannelDispatcher#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChannelInitializers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IChannelInitializer&gt; ChannelInitializers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SynchronizedCollection`1&lt;class System.ServiceModel.Dispatcher.IChannelInitializer&gt; ChannelInitializers" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.ChannelInitializers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChannelInitializers As SynchronizedCollection(Of IChannelInitializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IChannelInitializer ^&gt; ^ ChannelInitializers { System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IChannelInitializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChannelInitializers : System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IChannelInitializer&gt;" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.ChannelInitializers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IChannelInitializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает набор объектов <see cref="T:System.ServiceModel.Dispatcher.IChannelInitializer" />, которые можно использовать для проверки и добавления состояния к каналам при их создании.</summary>
        <value>Коллекция <see cref="T:System.Collections.Generic.SynchronizedCollection`1" /> объектов типа <see cref="T:System.ServiceModel.Dispatcher.IChannelInitializer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте это свойство для вставки пользовательского инициализатора канала в коллекцию инициализации для проверки и изменения состояния каналов при их создании. Это свойство также полезно для выполнения аналогичных действий с исходящими каналами, если контракт, связанный с диспетчером, является дуплексным.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#5)]
 [!code-vb[S_UE_ChannelDispatcher#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseInput">
      <MemberSignature Language="C#" Value="public override void CloseInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CloseInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.CloseInput" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CloseInput ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CloseInput();" />
      <MemberSignature Language="F#" Value="override this.CloseInput : unit -&gt; unit" Usage="channelDispatcher.CloseInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Заставляет прослушиватель прекратить прием новых каналов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода заставляет прослушиватель прекратить прослушивание.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCloseTimeout">
      <MemberSignature Language="C#" Value="protected override TimeSpan DefaultCloseTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultCloseTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.DefaultCloseTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultCloseTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property TimeSpan DefaultCloseTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCloseTimeout : TimeSpan" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.DefaultCloseTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает длительность временного интервала по умолчанию, выделенного для операции закрытия диспетчера каналов.</summary>
        <value>Значение <see cref="T:System.TimeSpan" />, которое задает длительность временного интервала по умолчанию, выделенного для операции закрытия диспетчера каналов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это время ожидания закрытия по умолчанию можно задать с помощью метода <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.%23ctor%28System.ServiceModel.Channels.IChannelListener%2CSystem.String%2CSystem.ServiceModel.IDefaultCommunicationTimeouts%29>. В противном случае используется значение по умолчанию для модели службы — 1 минута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultOpenTimeout">
      <MemberSignature Language="C#" Value="protected override TimeSpan DefaultOpenTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultOpenTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.DefaultOpenTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultOpenTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property TimeSpan DefaultOpenTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultOpenTimeout : TimeSpan" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.DefaultOpenTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает длительность временного интервала по умолчанию, выделенного для операции открытия диспетчера каналов.</summary>
        <value>Значение <see cref="T:System.TimeSpan" />, которое задает длительность временного интервала по умолчанию, выделенного для операции закрытия диспетчера каналов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это время ожидания открытия по умолчанию можно задать с помощью метода <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.%23ctor%28System.ServiceModel.Channels.IChannelListener%2CSystem.String%2CSystem.ServiceModel.IDefaultCommunicationTimeouts%29>. В противном случае используется значение по умолчанию для модели службы — 1 минута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Detach">
      <MemberSignature Language="C#" Value="protected override void Detach (System.ServiceModel.ServiceHostBase host);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Detach(class System.ServiceModel.ServiceHostBase host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.Detach(System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Detach (host As ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Detach(System::ServiceModel::ServiceHostBase ^ host);" />
      <MemberSignature Language="F#" Value="override this.Detach : System.ServiceModel.ServiceHostBase -&gt; unit" Usage="channelDispatcher.Detach host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="host">Объект <see cref="T:System.ServiceModel.ServiceHostBase" /> для службы.</param>
        <summary>Открепляет узел службы от диспетчера каналов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.ServiceModel.ServiceHostBase> может быть откреплен, только когда экземпляр объекта <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> находится в состоянии <xref:System.ServiceModel.CommunicationState.Created>, так как это единственное состояние, которое одновременно является изменяемым и не удаляется.  
  
 Задает объекту <xref:System.ServiceModel.ServiceHostBase>, связанному с диспетчером каналов, значение `null`.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#18](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#18)]
 [!code-vb[S_UE_ChannelDispatcher#18](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="host" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Параметр <paramref name="host" /> не является узлом диспетчера каналов.

-или-

Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Opening" /> или <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Closing" /> или <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Endpoints">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.EndpointDispatcher&gt; Endpoints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SynchronizedCollection`1&lt;class System.ServiceModel.Dispatcher.EndpointDispatcher&gt; Endpoints" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.Endpoints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Endpoints As SynchronizedCollection(Of EndpointDispatcher)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::EndpointDispatcher ^&gt; ^ Endpoints { System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::EndpointDispatcher ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Endpoints : System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.EndpointDispatcher&gt;" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.Endpoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.EndpointDispatcher&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает диспетчеры конечных точек, которые пересылают сообщения конечным точкам канала.</summary>
        <value>Коллекция <see cref="T:System.Collections.Generic.SynchronizedCollection`1" /> диспетчеров <see cref="T:System.ServiceModel.Dispatcher.EndpointDispatcher" />, которые пересылают сообщения конечным точкам канала.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> имеет отдельный объект <xref:System.ServiceModel.Dispatcher.EndpointDispatcher> для каждой конечной точки, поддерживаемой каналом.  
  
 Используйте <xref:System.ServiceModel.Dispatcher.EndpointDispatcher>, чтобы получить доступ к свойствам среды выполнения, которые позволяют настроить среду выполнения для конечной точки.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#6)]
 [!code-vb[S_UE_ChannelDispatcher#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorHandlers">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Dispatcher.IErrorHandler&gt; ErrorHandlers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Dispatcher.IErrorHandler&gt; ErrorHandlers" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorHandlers As Collection(Of IErrorHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Dispatcher::IErrorHandler ^&gt; ^ ErrorHandlers { System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Dispatcher::IErrorHandler ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ErrorHandlers : System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Dispatcher.IErrorHandler&gt;" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Dispatcher.IErrorHandler&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>возвращает набор объектов <see cref="T:System.ServiceModel.Dispatcher.IErrorHandler" />, которые можно использовать для вставки пользовательских функций обработки ошибок для конечной точки.</summary>
        <value>Коллекция <see cref="T:System.Collections.Generic.SynchronizedCollection`1" /> объектов <see cref="T:System.ServiceModel.Dispatcher.IErrorHandler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#7)]
 [!code-vb[S_UE_ChannelDispatcher#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.ServiceHostBase Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ServiceHostBase Host" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.Host" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Host As ServiceHostBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ServiceModel::ServiceHostBase ^ Host { System::ServiceModel::ServiceHostBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : System.ServiceModel.ServiceHostBase" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ServiceHostBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает узел для службы, связанной с диспетчером.</summary>
        <value>Объект <see cref="T:System.ServiceModel.ServiceHostBase" /> для службы, связанной с диспетчером.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый объект <xref:System.ServiceModel.ServiceHost> может иметь множество объектов <xref:System.ServiceModel.Dispatcher.ChannelDispatcher>, каждый из которых связан с различными объектами <xref:System.ServiceModel.Channels.IChannelListener> для данной службы.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#8)]
 [!code-vb[S_UE_ChannelDispatcher#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeExceptionDetailInFaults">
      <MemberSignature Language="C#" Value="public bool IncludeExceptionDetailInFaults { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeExceptionDetailInFaults" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.IncludeExceptionDetailInFaults" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeExceptionDetailInFaults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeExceptionDetailInFaults { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeExceptionDetailInFaults : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.IncludeExceptionDetailInFaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, следует ли включать сведения об исключении в сообщение об ошибке.</summary>
        <value>Значение <see langword="true" />, если сведения об исключении включаются в сообщения об ошибках; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка данного свойства возможна, только когда экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> находится в состоянии <xref:System.ServiceModel.CommunicationState.Created>, так как это единственное состояние, которое одновременно является изменяемым и не удаляется.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#19)]
 [!code-vb[S_UE_ChannelDispatcher#19](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Opening" /> или <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Closing" /> или <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsTransactedAccept">
      <MemberSignature Language="C#" Value="public bool IsTransactedAccept { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTransactedAccept" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.IsTransactedAccept" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTransactedAccept As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTransactedAccept { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTransactedAccept : bool" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.IsTransactedAccept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, выполняются ли вызовы метода приема на прослушивателе в рамках транзакции.</summary>
        <value>Значение <see langword="true" />, если вызовы метода приема на прослушивателе выполняются в рамках транзакции; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#9)]
 [!code-vb[S_UE_ChannelDispatcher#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTransactedReceive">
      <MemberSignature Language="C#" Value="public bool IsTransactedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTransactedReceive" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.IsTransactedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTransactedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTransactedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTransactedReceive : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.IsTransactedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, выполняются ли вызовы метода получения на прослушивателе в рамках транзакции.</summary>
        <value>Значение <see langword="true" />, если вызовы метода получения на прослушивателе выполняются в рамках транзакции; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка свойства <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.IsTransactedReceive%2A> возможна, только когда экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> находится в состоянии <xref:System.ServiceModel.CommunicationState.Created>, так как это единственное состояние, которое является изменяемым и не удаляется.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#10)]
 [!code-vb[S_UE_ChannelDispatcher#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Opening" /> или <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Closing" /> или <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listener">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener Listener { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.IChannelListener Listener" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.Listener" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Listener As IChannelListener" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ServiceModel::Channels::IChannelListener ^ Listener { System::ServiceModel::Channels::IChannelListener ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Listener : System.ServiceModel.Channels.IChannelListener" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.Listener" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает прослушиватель, связанный с диспетчером каналов.</summary>
        <value>Объект <see cref="T:System.ServiceModel.Channels.IChannelListener" />, связанный с данным диспетчером каналов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> связывает <xref:System.ServiceModel.Channels.IChannelListener> по определенному URI с экземпляром службы.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#11)]
 [!code-vb[S_UE_ChannelDispatcher#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManualAddressing">
      <MemberSignature Language="C#" Value="public bool ManualAddressing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ManualAddressing" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.ManualAddressing" />
      <MemberSignature Language="VB.NET" Value="Public Property ManualAddressing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ManualAddressing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ManualAddressing : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.ManualAddressing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, добавляет ли диспетчер каналов заголовки адресации в сообщения типа запрос-ответ.</summary>
        <value>Значение <see langword="true" />, если прокси не добавляет заголовки адресации; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка данного свойства возможна, только когда экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> находится в состоянии <xref:System.ServiceModel.CommunicationState.Created>, так как это единственное состояние, которое одновременно является изменяемым и не удаляется.  
  
 Задайте для свойства <xref:System.ServiceModel.Dispatcher.ClientRuntime.ManualAddressing%2A> значение `true`, если необходимо запретить клиенту добавлять заголовки адресации «Идентификатор сообщения» и «Ответить» в сообщения запросов и ответов, чтобы приложение могло управлять этими заголовками.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#12)]
 [!code-vb[S_UE_ChannelDispatcher#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Opening" /> или <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Closing" /> или <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxPendingReceives">
      <MemberSignature Language="C#" Value="public int MaxPendingReceives { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPendingReceives" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.MaxPendingReceives" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPendingReceives As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPendingReceives { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPendingReceives : int with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.MaxPendingReceives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество ожидающих сообщений на канал.</summary>
        <value>Целое число, представляющее максимальное количество сообщений.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxTransactedBatchSize">
      <MemberSignature Language="C#" Value="public int MaxTransactedBatchSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxTransactedBatchSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.MaxTransactedBatchSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxTransactedBatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxTransactedBatchSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxTransactedBatchSize : int with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.MaxTransactedBatchSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальный размер транзакционного пакета.</summary>
        <value>Максимальный размер транзакционного пакета.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка свойства <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.MaxTransactedBatchSize%2A> возможна, только когда экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> находится в состоянии <xref:System.ServiceModel.CommunicationState.Created>, так как это единственное состояние, которое является изменяемым и не удаляется.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#13)]
 [!code-vb[S_UE_ChannelDispatcher#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Заданное значение меньше нуля.</exception>
        <exception cref="T:System.InvalidOperationException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Opening" /> или <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Closing" /> или <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MessageVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageVersion MessageVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageVersion MessageVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.MessageVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageVersion As MessageVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageVersion ^ MessageVersion { System::ServiceModel::Channels::MessageVersion ^ get(); void set(System::ServiceModel::Channels::MessageVersion ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageVersion : System.ServiceModel.Channels.MessageVersion with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.MessageVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает используемые или ожидаемые версии сообщения SOAP и WS-Addressing.</summary>
        <value>Используемая или ожидаемая версия <see cref="T:System.ServiceModel.Channels.MessageVersion" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указывает версии SOAP и WS-Addressing, связанные с сообщением и его передачей.  
  
 Установка данного свойства возможна, только когда экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> находится в состоянии <xref:System.ServiceModel.CommunicationState.Created>, так как это единственное состояние, которое одновременно является изменяемым и не удаляется.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#20](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#20)]
 [!code-vb[S_UE_ChannelDispatcher#20](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Opening" /> или <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Closing" /> или <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnAbort">
      <MemberSignature Language="C#" Value="protected override void OnAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnAbort" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnAbort ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnAbort();" />
      <MemberSignature Language="F#" Value="override this.OnAbort : unit -&gt; unit" Usage="channelDispatcher.OnAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Прерывает работу прослушивателя, связанного с диспетчером.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginClose">
      <MemberSignature Language="C#" Value="protected override IAsyncResult OnBeginClose (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.IAsyncResult OnBeginClose(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnBeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnBeginClose (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override IAsyncResult ^ OnBeginClose(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginClose : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="channelDispatcher.OnBeginClose (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Значение <see cref="T:System.TimeSpan" />, которое задает время, выделенное для завершения операции закрытия до истечения времени ожидания.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, принимающий уведомление об асинхронном завершении операции закрытия.</param>
        <param name="state">Задаваемый приложением объект, который содержит сведения о состоянии, связанные с асинхронной операцией закрытия.</param>
        <summary>Начинает асинхронную операцию закрытия прослушивателя канала для диспетчера, которая должна завершиться в течение указанного временного интервала.</summary>
        <returns><see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию, чтобы закрыть прослушиватель канала для диспетчера.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginOpen">
      <MemberSignature Language="C#" Value="protected override IAsyncResult OnBeginOpen (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.IAsyncResult OnBeginOpen(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnBeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnBeginOpen (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override IAsyncResult ^ OnBeginOpen(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginOpen : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="channelDispatcher.OnBeginOpen (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Значение <see cref="T:System.TimeSpan" />, которое задает время, выделенное для завершения операции открытия до превышения времени ожидания.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, принимающий уведомление об асинхронном завершении операции открытия.</param>
        <param name="state">Заданный приложением объект, который содержит сведения о состоянии, связанные с асинхронной операцией открытия.</param>
        <summary>Начинает асинхронную операцию открытия прослушивателя канала для диспетчера, которая должна завершиться в течение указанного временного интервала.</summary>
        <returns><see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию, чтобы открыть прослушиватель канала для диспетчера.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове этого метода диспетчер каналов должен быть связан с узлом службы, отличным от `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Узел или версия сообщения имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnClose">
      <MemberSignature Language="C#" Value="protected override void OnClose (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnClose(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnClose(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnClose (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnClose(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="override this.OnClose : TimeSpan -&gt; unit" Usage="channelDispatcher.OnClose timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Значение <see cref="T:System.TimeSpan" />, которое задает длительность временного интервала, выделенного для операции закрытия прослушивателя.</param>
        <summary>Закрывает прослушиватель канала, связанный с диспетчером, в течение указанного временного интервала.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected override void OnClosed ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnClosed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnClosed" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnClosed ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnClosed();" />
      <MemberSignature Language="F#" Value="override this.OnClosed : unit -&gt; unit" Usage="channelDispatcher.OnClosed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обеспечивает трассировку закрытия диспетчеров конечных точек, связанных с диспетчером каналов.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndClose">
      <MemberSignature Language="C#" Value="protected override void OnEndClose (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEndClose(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnEndClose(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEndClose (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEndClose(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndClose : IAsyncResult -&gt; unit" Usage="channelDispatcher.OnEndClose result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, возвращенный вызовом метода <see cref="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnBeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />.</param>
        <summary>Завершает асинхронную операцию, чтобы закрыть прослушиватель канала для диспетчера.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndOpen">
      <MemberSignature Language="C#" Value="protected override void OnEndOpen (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEndOpen(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnEndOpen(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEndOpen (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEndOpen(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndOpen : IAsyncResult -&gt; unit" Usage="channelDispatcher.OnEndOpen result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, возвращенный вызовом метода <see cref="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnBeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />.</param>
        <summary>Завершает асинхронную операцию, чтобы открыть прослушиватель канала для диспетчера.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnOpen">
      <MemberSignature Language="C#" Value="protected override void OnOpen (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnOpen(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnOpen(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnOpen (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnOpen(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="override this.OnOpen : TimeSpan -&gt; unit" Usage="channelDispatcher.OnOpen timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Значение <see cref="T:System.TimeSpan" />, которое задает длительность временного интервала, выделенного для операции открытия прослушивателя.</param>
        <summary>Открывает прослушиватель, связанный с диспетчером каналов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове этого метода диспетчер каналов должен быть связан с узлом службы, отличным от `null`, и версия сообщения должна иметь значение, отличное от `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Узел или версия сообщения имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnOpened">
      <MemberSignature Language="C#" Value="protected override void OnOpened ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnOpened() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnOpened" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnOpened ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnOpened();" />
      <MemberSignature Language="F#" Value="override this.OnOpened : unit -&gt; unit" Usage="channelDispatcher.OnOpened " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Заполняет и проверяет таблицу фильтров, используемую для перенаправления к конечным точкам.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове этого метода диспетчер каналов должен быть связан с узлом службы, отличным от `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Узел имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnOpening">
      <MemberSignature Language="C#" Value="protected override void OnOpening ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnOpening() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnOpening" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnOpening ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnOpening();" />
      <MemberSignature Language="F#" Value="override this.OnOpening : unit -&gt; unit" Usage="channelDispatcher.OnOpening " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Проверяет, прикреплен ли диспетчер каналов к узлу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При открытии диспетчер каналов должен быть связан с узлом службы, отличным от `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Узел имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveContextEnabled">
      <MemberSignature Language="C#" Value="public bool ReceiveContextEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReceiveContextEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.ReceiveContextEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveContextEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReceiveContextEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveContextEnabled : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.ReceiveContextEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, включен ли ReceiveContext.</summary>
        <value>Значение <see langword="true" />, если ReceiveContext включен; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ReceiveContext управляет режимом обработки сообщений службой, например блокировкой сообщения в течение необходимого времени.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveSynchronously">
      <MemberSignature Language="C#" Value="public bool ReceiveSynchronously { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReceiveSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.ReceiveSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveSynchronously As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReceiveSynchronously { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveSynchronously : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.ReceiveSynchronously" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, использует ли диспетчер синхронные вызовы для чтения сообщений из каналов.</summary>
        <value>Значение <see langword="true" />, если диспетчер использует синхронные методы для чтения сообщений из каналов; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если привязка реализует <xref:System.ServiceModel.Channels.IBindingRuntimePreferences>, Windows Communication Foundation (WCF) присваивает значение <xref:System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously%2A> значение этого свойства. Поэтому, если это значение `true`, то значение по умолчанию `false` свойства <xref:System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously%2A> переопределяется.  
  
 Установка данного свойства возможна, только когда экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> находится в состоянии <xref:System.ServiceModel.CommunicationState.Created>, так как это единственное состояние, которое одновременно является изменяемым и не удаляется.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#14](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#14)]
 [!code-vb[S_UE_ChannelDispatcher#14](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Opening" /> или <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Closing" /> или <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsynchronously">
      <MemberSignature Language="C#" Value="public bool SendAsynchronously { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendAsynchronously" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.SendAsynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Property SendAsynchronously As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendAsynchronously { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendAsynchronously : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.SendAsynchronously" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, показывающее, отправляются ли сообщения в асинхронном режиме.</summary>
        <value>Значение <see langword="true" />, если сообщения отправляются асинхронно; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceThrottle">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.ServiceThrottle ServiceThrottle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.ServiceThrottle ServiceThrottle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.ServiceThrottle" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceThrottle As ServiceThrottle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::ServiceThrottle ^ ServiceThrottle { System::ServiceModel::Dispatcher::ServiceThrottle ^ get(); void set(System::ServiceModel::Dispatcher::ServiceThrottle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceThrottle : System.ServiceModel.Dispatcher.ServiceThrottle with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.ServiceThrottle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.ServiceThrottle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает регулирование для службы, связанной с диспетчером каналов.</summary>
        <value>Объект <see cref="T:System.ServiceModel.Dispatcher.ServiceThrottle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это обеспечивает доступ к элементам управления, используемым для оптимизации доступности и производительности службы.  
  
 Установка данного свойства возможна, только когда экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> находится в состоянии <xref:System.ServiceModel.CommunicationState.Created>, так как это единственное состояние, которое одновременно является изменяемым и не удаляется.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#15](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#15)]
 [!code-vb[S_UE_ChannelDispatcher#15](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Opening" /> или <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Closing" /> или <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public System.Transactions.IsolationLevel TransactionIsolationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Transactions.IsolationLevel TransactionIsolationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionIsolationLevel As IsolationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Transactions::IsolationLevel TransactionIsolationLevel { System::Transactions::IsolationLevel get(); void set(System::Transactions::IsolationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionIsolationLevel : System.Transactions.IsolationLevel with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionIsolationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Transactions.IsolationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает уровень изоляции по умолчанию для транзакций.</summary>
        <value>Одно из значений <see cref="T:System.Transactions.IsolationLevel" />. Значение по умолчанию — <see cref="F:System.Transactions.IsolationLevel.Unspecified" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionIsolationLevel%2A>, чтобы получить или задать уровень изоляции по умолчанию для новых транзакций, созданных диспетчером для службы.  
  
 Установка данного свойства возможна, только когда экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> находится в состоянии <xref:System.ServiceModel.CommunicationState.Created>, так как это единственное состояние, которое одновременно является изменяемым и не удаляется.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#16](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#16)]
 [!code-vb[S_UE_ChannelDispatcher#16](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Заданный уровень изоляции не определен.</exception>
        <exception cref="T:System.InvalidOperationException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Opening" /> или <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Closing" /> или <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan TransactionTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TransactionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TransactionTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionTimeout : TimeSpan with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее время ожидания по умолчанию для новых транзакций, созданных диспетчером от имени службы.</summary>
        <value>Значение <see cref="T:System.TimeSpan" />, которое представляет время ожидания по умолчанию для транзакций. Значение по умолчанию — <see cref="F:System.TimeSpan.Zero" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка данного свойства возможна, только когда экземпляр класса <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> находится в состоянии <xref:System.ServiceModel.CommunicationState.Created>, так как это единственное состояние, которое одновременно является изменяемым и не удаляется.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#17](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#17)]
 [!code-vb[S_UE_ChannelDispatcher#17](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Заданное значение меньше нуля или слишком велико.</exception>
        <exception cref="T:System.InvalidOperationException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Opening" /> или <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Closing" /> или <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Объект связи находится в состоянии <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>