<Type Name="ProcessThread" FullName="System.Diagnostics.ProcessThread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a034496d31deb52e51762f57f92d5533e7103a78" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48709953" /></Metadata><TypeSignature Language="C#" Value="public class ProcessThread : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessThread extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessThread" />
  <TypeSignature Language="VB.NET" Value="Public Class ProcessThread&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessThread : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ProcessThread = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет поток процесса операционной системы.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.ProcessThread> для получения сведений о потоке, который выполняется в данный момент в системе. Это позволит вам, например, для наблюдения за характеристиками производительности.  
  
> [!IMPORTANT]
>  Этот тип реализует <xref:System.IDisposable> интерфейс. Когда вы закончите, используя тип, следует освободить его прямо или косвенно. Чтобы удалить тип напрямую, вызовите его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы избавиться от его косвенно, используйте языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует IDisposable» <xref:System.IDisposable> разделу интерфейса.  
  
 Поток — это путь выполнения в программе. Он является наименьшей единицей выполнения, который планирует Win32. Он состоит из стека, состояния регистров ЦП и записи в списке выполнения системного планировщика.  
  
 Процесс состоит из одного или нескольких потоков и код, данные и другие ресурсы программы в памяти. Типичными ресурсами программы являются открытые файлы, семафоры и динамически выделенной памяти. Каждый ресурс процесса совместно используется всеми потоками процесса.  
  
 Программа выполняется, когда системный планировщик передает управление выполнением одному из потоков программы. Планировщик определяет, какой поток и когда. Поток с более низким приоритетом может быть вынужден ждать, пока потоки с более высоким приоритетом выполнения их задач. На многопроцессорных компьютерах планировщик может перемещать отдельные потоки на разные процессоры, таким образом балансировки нагрузки на ЦП.  
  
 Каждый процесс начинается с одним потоком, который известен как основной поток. Любой поток может создавать дополнительные потоки. Все потоки в процессе используют адресное пространство процесса.  
  
 Основной поток не обязательно находятся по первому индексу в коллекции.  
  
> [!NOTE]
>  Начиная с .NET Framework версии 2.0, возможность ссылаться на данные счетчика производительности на других компьютерах было устранено для многие свойства и методы платформы .NET Framework. Это изменение было внесено для повышения производительности и позволяет пользователям без прав администратора использовать <xref:System.Diagnostics.ProcessThread> класса. Таким образом, некоторые приложения, которые не получил исключения в более ранних версиях платформы .NET Framework теперь могут получить <xref:System.NotSupportedException>. Методы и свойства, которые затронуты, слишком много, перечислять которые здесь, но сведения об исключении добавлен в разделы затронутых элементов.  
  
 Потоки процесса выполняются отдельно и не знают о друг с другом, если не сделать их видимыми друг с другом. Тем не менее, потоки, которые совместно используют общие ресурсы необходимо координировать свою работу с помощью семафоров и других методов взаимодействия между процессами.  
  
 Чтобы получить коллекцию всех <xref:System.Diagnostics.ProcessThread> получить объекты, связанные с текущим процессом, <xref:System.Diagnostics.Process.Threads%2A> свойство <xref:System.Diagnostics.Process> экземпляра.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.Process" />
    <altmember cref="P:System.Diagnostics.Process.Threads" />
  </Docs>
  <Members>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.ProcessThread.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The base priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает базовый приоритет потока.</summary>
        <value>Базовый приоритет потока, вычисляемый операционной системой путем совмещения класса приоритета процесса с уровнем приоритета соответствующего потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.BasePriority%2A> Начальный приоритет потока процесса. Можно просмотреть сведения о базовый приоритет через базового приоритета счетчик системного монитора.  
  
 Операционная система вычисляет базовый приоритет потока, объединяя диапазона уровня приоритета потока с классом приоритета процесса. Можно задать процесс <xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=nameWithType> задается одно из значений в <xref:System.Diagnostics.ProcessPriorityClass> перечислении <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, или <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Можно задать потока <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> свойства диапазон значений, который ограничивает базовый приоритет потока. Win32 использует четыре класса приоритета 7 уровней базовый приоритет каждого класса.  
  
 Текущий приоритет потока может отклоняться от базового приоритета. Например, можно изменить операционную систему <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> прошло свойство, на основе времени или других показателях, если процесс необходимо поместить впереди другим пользователям для доступа к обработчику. Кроме того, можно задать <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> свойства для этого система временно увеличивать приоритет потока всякий раз, когда процесс выбирается из состояния ожидания. Приоритет сбрасывается при возвращении процесса в состояние ожидания.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPriority">
      <MemberSignature Language="C#" Value="public int CurrentPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentPriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPriority : int" Usage="System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The current priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadCurrentPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущий приоритет потока.</summary>
        <value>Текущий приоритет потока, который может отклоняться от базового, в зависимости от способа планирования потока в операционной системе. Для активного потока приоритет может быть временно увеличен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий приоритет потока может отклоняться от базового приоритета. Например, можно изменить операционную систему <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> прошло свойство, на основе времени или других показателях, когда процесс необходимо поместить впереди другим пользователям для доступа к обработчику. Кроме того, можно задать <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> свойства для этого система временно увеличивать приоритет потока всякий раз, когда процесс выбирается из состояния ожидания. Приоритет сбрасывается при возвращении процесса в состояние ожидания.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.ProcessThread.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The ID of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает уникальный идентификатор потока.</summary>
        <value>Уникальный идентификатор связан с конкретным потоком.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система повторно использует идентификационные номера потоков, которые определяют потоки только во время их жизни.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdealProcessor">
      <MemberSignature Language="C#" Value="public int IdealProcessor { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IdealProcessor" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Property IdealProcessor As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IdealProcessor {  void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IdealProcessor : int" Usage="System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает предпочтительный процессор для выполнения этого потока.</summary>
        <value>Предпочтительный процессор для потока, используемый при планировании потока системой для определения процессора, на котором будет выполняться поток.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> Значение отсчитывается от нуля.  Другими словами Чтобы задать сходство потоков для первого процессора, свойства равным нулю.  
  
 Система планирует потоки по предпочтительным процессорам по возможности.  
  
 Поток процесса может перемещаться с процессора на процессор, с каждую операцию миграции обновление кэша процессора. Задавая процессор для потока может повысить производительность при больших системных нагрузках, уменьшая число перезагрузок кэша процессора.  
  
   
  
## Examples  
 В следующем примере демонстрируется задание <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> свойство для экземпляра Блокнота для первого процессора.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Системе не удалось задать поток для запуска на указанном процессоре.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Данный процесс выполняется на удаленном компьютере.</exception>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Thread gets a priority boot when interactively used by a user.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должна ли операционная система временно увеличивать приоритет соответствующего потока всякий раз, когда основное окно процесса, которому принадлежит данный поток, получает фокус.</summary>
        <value>Значение <see langword="true" /> для увеличения приоритета потока при взаимодействии пользователя с интерфейсом процесса или значение <see langword="false" /> в противном случае. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> является `true`, система временно увеличивает приоритет потока всякий раз, когда связанный с ней процесс выбирается из состояния ожидания. Это действие предотвращает прерывание обработки текущего потока другими процессами. <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> Влияет на все существующие потоки, а также все потоки, созданные в процессе впоследствии. Чтобы восстановить нормальное поведение, задайте <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> свойства `false`.  
  
 <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> действует только в том случае, если поток выполняется в процессе, который имеет <xref:System.Diagnostics.Process.PriorityClass%2A> присвоено одно из значений перечисления динамического приоритета (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, или <xref:System.Diagnostics.ProcessPriorityClass.RealTime>).  
  
> [!NOTE]
>  Бустинг слишком высокого приоритета может привести к утечке ресурсов операционную систему и сетевые функции. Это может вызвать проблемы с другими задачами операционной системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается извлечь информацию о повышении приоритета.  
  
- или - 
Не удается задать информацию о повышении приоритета.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Данный процесс выполняется на удаленном компьютере.</exception>
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
      </Docs>
    </Member>
    <Member MemberName="PriorityLevel">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadPriorityLevel PriorityLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityLevel As ThreadPriorityLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadPriorityLevel PriorityLevel { System::Diagnostics::ThreadPriorityLevel get(); void set(System::Diagnostics::ThreadPriorityLevel value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityLevel : System.Diagnostics.ThreadPriorityLevel with get, set" Usage="System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority level of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadPriorityLevel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadPriorityLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает уровень приоритета потока.</summary>
        <value>Одно из значений <see cref="T:System.Diagnostics.ThreadPriorityLevel" />, задающих диапазон, который ограничивает приоритет потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Уровень приоритета не одно значение, а также диапазон значений. Операционная система вычисляет базовый приоритет потока с помощью процесса <xref:System.Diagnostics.Process.PriorityClass%2A> выбрать значение из диапазона, указанного в <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается извлечь информацию об уровне приоритета потока.  
  
- или - 
Не удается задать информацию об уровне приоритета потока.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Данный процесс выполняется на удаленном компьютере.</exception>
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in privileged mode.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает количество времени, затрачиваемое потоком на выполнение кода внутри ядра операционной системы.</summary>
        <value>Объект <see cref="T:System.TimeSpan" />, указывающий количество времени, которое поток потратил на выполнение кода внутри ядра операционной системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows использует несколько разных механизмов защиты и в корне всех их различие между пользователем и привилегированного режимов. <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> соответствует количество времени, затраченного на приложение в привилегированном режиме внутри ядра операционной системы. <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> Свойство указывает количество времени, которое приложение потратил на выполнение кода в пользовательском режиме, за пределами ядра системы.  
  
 Пользовательский режим ограничивает приложение два важных отличия. Во-первых приложение не может напрямую попасть периферийных устройств, но вместо этого необходимо вызвать для получения или задания данных ядра операционной системы. Таким образом, операционная система может гарантировать, что одно приложение не уничтожит данные, необходимые для другой. Во-вторых приложение не удается прочесть или изменить данные, которые поддерживает самой операционной системы. Это ограничение предотвращает приложений случайно или преднамеренно повреждения ядра. Если приложение должно операционной системы для выполнения операции, оно вызывает одну из системных процедур. Многие из них переходят в привилегированном режиме, выполнить операцию и спокойно возвращаются в пользовательском режиме.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удалось извлечь затраченное потоком время.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Данный процесс выполняется на удаленном компьютере.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity {  void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint" Usage="System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает процессоры, на которых может выполняться соответствующий поток.</summary>
        <value>Объект <see cref="T:System.IntPtr" />, указывающий на набор битов, каждый из которых представляет процессор, где может выполняться поток.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сходство процессоров потока — это набор процессоров, к которым он связан. Другими словами те, которые могут планироваться под управлением.  
  
 <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> как битовое представляет каждого процессора. Бит 0 представляет первый процессор, бит 1 представляет второй процессор и т. д. В следующей таблице показаны возможные подмножество <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> для четырехпроцессорной системы.  
  
|Значение свойства (в шестнадцатеричном формате)|Допустимые процессоры|  
|---------------------------------------|----------------------|  
|0x0001|1|  
|0x0002|2|  
|0x0003|1 или 2|  
|0x0004|3|  
|0x0005|1 или 3|  
|0x0007|1, 2 или 3|  
|0x000F|1, 2, 3 или 4|  
  
 Можно также указать один предпочтительный процессор для потока, задав <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> свойство. Поток процесса может перемещаться с процессора на процессор, с каждую операцию миграции обновление кэша процессора. Задавая процессор для потока может повысить производительность при больших системных нагрузках, уменьшая число перезагрузок кэша процессора.  
  
   
  
## Examples  
 В следующем примере показано, как задать <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> свойство для экземпляра Блокнота для первого процессора.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается задать сходство процессоров.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Данный процесс выполняется на удаленном компьютере.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="ResetIdealProcessor">
      <MemberSignature Language="C#" Value="public void ResetIdealProcessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetIdealProcessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessThread.ResetIdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetIdealProcessor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetIdealProcessor();" />
      <MemberSignature Language="F#" Value="member this.ResetIdealProcessor : unit -&gt; unit" Usage="processThread.ResetIdealProcessor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет идеальный процессор для данного потока, указывая тем самым на отсутствие единственного идеального процессора. Другими словами, для потока идеален любой процессор.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается сбросить идеальный процессор.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Данный процесс выполняется на удаленном компьютере.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="StartAddress">
      <MemberSignature Language="C#" Value="public IntPtr StartAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int StartAddress" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartAddress As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr StartAddress { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.StartAddress : nativeint" Usage="System.Diagnostics.ProcessThread.StartAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The start address in memory of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadStartAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает адрес функции в памяти, которая была вызвана операционной системой и запустила этот поток.</summary>
        <value>Начальный адрес потока, указывающий на определенную приложением функцию, которую выполняет данный поток.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый процесс начинается с одним потоком, который известен как основной поток. Любой поток может создавать дополнительные потоки.  
  
 Процесс имеет виртуальное адресное пространство, исполняемый код, данные, дескрипторов объектов, переменные среды, базовый приоритет и минимальным и максимальным размеров рабочего набора. Все потоки процесса используют его виртуального адресного пространства и системных ресурсов. Кроме того каждый поток поддерживает обработчики исключений, приоритет планирования и набор структур, в которых система сохраняет контекст потока во время ожидания потока для планирования. Контекст потока включает потока набор регистров компьютера, стек ядра, блок потоков среды и пользовательский стек в адресном пространстве процесса потока.  
  
 Каждый поток Windows фактически начинает выполнение в функции, предоставляемый системой, а не приложения. Начальный адрес для основного потока является, таким образом, одинаковым (так как он представляет собой адрес функции, предоставляемой системой) для всех процессов Windows в системе. Тем не менее <xref:System.Diagnostics.ProcessThread.StartAddress%2A> свойство позволит вам получить начальный адрес функции, относящиеся к приложению.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Данный процесс выполняется на удаленном компьютере.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.ProcessThread.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time this thread was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает время запуска потока операционной системой.</summary>
        <value>Класс <see cref="T:System.DateTime" />, представляющий системное время запуска потока операционной системой.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удалось извлечь затраченное потоком время.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Данный процесс выполняется на удаленном компьютере.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadState ThreadState { System::Diagnostics::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Diagnostics.ThreadState" Usage="System.Diagnostics.ProcessThread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The current state of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadThreadState")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущее состояние данного потока.</summary>
        <value>Объект <see cref="T:System.Diagnostics.ThreadState" />, указывающий на состояние выполнения потока, например, выполняется, ожидает или прекращен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.WaitReason%2A> Доступен, только если значение свойства <xref:System.Diagnostics.ProcessThread.ThreadState%2A> значение <xref:System.Diagnostics.ThreadState.Wait>. Таким образом, проверьте <xref:System.Diagnostics.ProcessThread.ThreadState%2A> значение до перехода <xref:System.Diagnostics.ProcessThread.WaitReason%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Данный процесс выполняется на удаленном компьютере.</exception>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The total amount of CPU time used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает общее количество времени, которое потратил поток на обработку процессором.</summary>
        <value>Объект <see cref="T:System.TimeSpan" />, указывающий количество времени, на протяжении которого поток контролировал процессор.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> Свойство указывает общее количество времени, что система вывести поток из состояния ожидания и предоставить ему приоритет на любом процессоре. В системе с несколькими процессорами это значение будет включать время, затраченное на каждый процессор, если поток использовал более одного процессора.  
  
 <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> Свойство представляет собой сумму <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> и <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> свойства.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удалось извлечь затраченное потоком время.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Данный процесс выполняется на удаленном компьютере.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in user mode.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает количество времени, которое поток потратил на выполнение кода внутри приложения.</summary>
        <value>Объект <see cref="T:System.TimeSpan" />, указывающий количество времени, которое поток потратил на выполнение кода внутри приложения, в отличие от выполнения в ядре операционной системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows NT использует несколько разных механизмов защиты и в корне всех их различие между пользователем и привилегированного режимов. <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> соответствует количество времени, которое приложение потратило на выполнение в пользовательском режиме, за пределами ядра операционной системы. <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> Соответствующее количество времени, которое приложение потратил на выполнение кода в привилегированном режиме внутри ядра системы.  
  
 Пользовательский режим ограничивает приложение два важных отличия. Во-первых приложение не может напрямую попасть периферийных устройств, но вместо этого необходимо вызвать для получения или задания данных ядра операционной системы. Таким образом, операционная система может гарантировать, что одно приложение не уничтожит данные, необходимые для другой. Во-вторых приложение не удается прочесть или изменить данные, которые поддерживает самой операционной системы. Это ограничение предотвращает приложений случайно или преднамеренно повреждения ядра. Если приложение должно операционной системы для выполнения операции, оно вызывает одну из системных процедур. Многие из них переходят в привилегированном режиме, выполнить операцию и спокойно возвращаются в пользовательском режиме.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удалось извлечь затраченное потоком время.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Данный процесс выполняется на удаленном компьютере.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="WaitReason">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadWaitReason WaitReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadWaitReason WaitReason" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.WaitReason" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitReason As ThreadWaitReason" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadWaitReason WaitReason { System::Diagnostics::ThreadWaitReason get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitReason : System.Diagnostics.ThreadWaitReason" Usage="System.Diagnostics.ProcessThread.WaitReason" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The reason why this thread is waiting.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadWaitReason")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadWaitReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает причину, по которой поток находится в состоянии ожидания.</summary>
        <value>Объект <see cref="T:System.Diagnostics.ThreadWaitReason" />, представляющий причину нахождения потока в состоянии ожидания.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.WaitReason%2A> Свойство доступен, только если <xref:System.Diagnostics.ProcessThread.ThreadState%2A> является <xref:System.Diagnostics.ThreadState.Wait>. Таким образом, проверьте <xref:System.Diagnostics.ProcessThread.ThreadState%2A> значение до перехода <xref:System.Diagnostics.ProcessThread.WaitReason%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток не находится в состоянии ожидания.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Данный процесс выполняется на удаленном компьютере.</exception>
        <altmember cref="T:System.Diagnostics.ThreadWaitReason" />
        <altmember cref="P:System.Diagnostics.ProcessThread.ThreadState" />
      </Docs>
    </Member>
  </Members>
</Type>