<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="80e4e84bd284d110a1b1c30c95d4a297c2b9611b" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37664672" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides access to local and remote processes and enables you to start and stop local system processes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Diagnostics.Process> компонент предоставляет доступ к процессу, который выполняется на компьютере. Процесс, проще говоря, — работающего приложения. Поток — это базовая единица, к которой операционная система выделяет время процессора. Поток может исполнять любую часть кода процесса, включая части, выполняющейся в данный момент другим потоком.  
  
 <xref:System.Diagnostics.Process> Компонент — это полезное средство для запуска и остановки, управление и наблюдение за приложениями. Можно использовать <xref:System.Diagnostics.Process> компонент, для получения списка процессов, работающих под управлением, или вы можете запустить новый процесс. Объект <xref:System.Diagnostics.Process> компонент используется для доступа к системным процессам. После <xref:System.Diagnostics.Process> инициализации компонента, его можно использовать для получения сведений о запущенном процессе. Такая информация включает в себя набор потоков, загруженные модули (файлы .dll и .exe), и информацию о производительности, таких как объем памяти, используемой процессом.  
  
 Этот тип реализует <xref:System.IDisposable> интерфейс. Когда вы закончите, используя тип, следует освободить его прямо или косвенно. Чтобы удалить тип напрямую, вызовите его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы избавиться от его косвенно, используйте языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует IDisposable» <xref:System.IDisposable> разделу интерфейса.  
  
> [!NOTE]
>  32-разрядных процессов не может получить доступ к модулям 64-разрядном процессе. При попытке получить сведения о 64-разрядном процессе из 32-разрядном процессе, вы получите <xref:System.ComponentModel.Win32Exception> исключение. 64-разрядный процесс, с другой стороны, можно получить доступ к модулям 32-разрядном процессе.  
  
 Компонент обработки получает сведения о группу свойств за один раз. После <xref:System.Diagnostics.Process> компонент получил информацию о один член, ни в одну группу, он будет кэшировать значения для других свойств в этой группе и не будет получать новые сведения о других членах группы до вызова метода <xref:System.Diagnostics.Process.Refresh%2A> метод. Таким образом, значение свойства, не обязательно будет новее, чем последнего вызова <xref:System.Diagnostics.Process.Refresh%2A> метод. Схемы групп, зависят от операционной системы.  
  
 Если у вас есть путь к переменной, объявленной в вашей системе, с помощью кавычки, необходимо полностью указать этот путь при запуске любого процесса, в этом расположении. В противном случае система не найдет путь. Например если `c:\mypath` не находится в системном пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо полностью указать любой процесс в `c:\mypath` при запуске.  
  
 Системный процесс однозначно идентифицируется в системе идентификатор процесса. Как и многие ресурсы Windows процесс также определяется его дескриптор, который не может быть уникальным на компьютере. Дескриптор является универсальный термин для идентификатора ресурса. Операционная система сохраняет дескриптор процесса, доступный через <xref:System.Diagnostics.Process.Handle%2A> свойство <xref:System.Diagnostics.Process> компонент, даже в том случае, если процесс завершился. Таким образом, можно получить процесса для администраторов информация, например <xref:System.Diagnostics.Process.ExitCode%2A> (обычно либо ноль для успеха или ненулевой код ошибки) и <xref:System.Diagnostics.Process.ExitTime%2A>. Дескрипторы являются чрезвычайно важным ресурсом, поэтому происходит утечка дескрипторов более опасна, чем утечка памяти.  
  
> [!NOTE]
>  Этот класс содержит запрос компоновки и требования наследования на уровне класса, который применяется ко всем элементам. Объект <xref:System.Security.SecurityException> возникает, если непосредственный вызывающий оператор или производного класса не имеет разрешения полного доверия. Дополнительные сведения о требованиях безопасности см. в разделе [требования связывания](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Примечания  
 В .NET Framework <xref:System.Diagnostics.Process> класс по умолчанию использует <xref:System.Console> кодировок, которые обычно являются кода кодировок страниц, для потоков ввода, вывода и ошибок. Пример кода, в системах, языком и региональными параметрами является английский (США), кодовую страницу 437, — это кодировка по умолчанию для <xref:System.Console> класса. Тем не менее [!INCLUDE[net_core](~/includes/net-core-md.md)] можно освободить только ограниченный набор этих кодировок. Если это так, он использует <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> качестве кодировки по умолчанию.  
  
 Если <xref:System.Diagnostics.Process> объекта зависит от конкретных кодовых страниц, вы можете по-прежнему сделать их доступными, выполнив указанные ниже *перед* вызова любых <xref:System.Diagnostics.Process> методов:  
  
1.  Добавьте ссылку на сборку System.Text.Encoding.CodePages.dll в проект.  
  
2.  Получить <xref:System.Text.EncodingProvider> объекта из <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> свойство.  
  
3.  Передайте <xref:System.Text.EncodingProvider> объект <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> метод для установки дополнительных кодировках, поддерживаемых поставщик кодировки.  
  
 <xref:System.Diagnostics.Process> Класс будет автоматически использовать кодировку системы по умолчанию вместо UTF8, при условии, что вы зарегистрировали поставщик кодировки перед вызовом любых <xref:System.Diagnostics.Process> методов.  
  
   
  
## Examples  
 В следующем примере используется экземпляр <xref:System.Diagnostics.Process> класса для запуска процесса.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 В следующем примере используется <xref:System.Diagnostics.Process> классов самого и статический <xref:System.Diagnostics.Process.Start%2A> метод для запуска процесса.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 В следующем примере F # определяет `runProc` функцию, которая запускает процесс, захватывает все выходные данные и сведения об ошибке и записывает количество миллисекунд, выполнения процесса.  `runProc` Функция имеет три параметра: имя приложения, чтобы запустить, аргументы для передачи в приложение и начальный каталог.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Код для `runProc` функции было написано с [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) и доступен в разделе [публичной лицензии Microsoft](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот класс не может использоваться частично доверенным кодом.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот класс не может наследоваться кодом с частичным доверием.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Process" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не укажете <xref:System.Diagnostics.Process.MachineName%2A> свойство, значение по умолчанию является локальный компьютер (».»).  
  
 Существует два варианта для сопоставления нового <xref:System.Diagnostics.Process> компонент процесса на компьютере. Первый вариант — использовать конструктор для создания <xref:System.Diagnostics.Process> набор компонентов, соответствующие члены <xref:System.Diagnostics.Process.StartInfo%2A> свойство и вызвать <xref:System.Diagnostics.Process.Start%2A> связываемый <xref:System.Diagnostics.Process> новым процессом system. Второй способ заключается в связать <xref:System.Diagnostics.Process> с к выполняющемуся процессу системы с помощью <xref:System.Diagnostics.Process.GetProcessById%2A> или один из <xref:System.Diagnostics.Process.GetProcesses%2A> возвращаемые значения.  
  
 Если вы используете `static` перегрузки <xref:System.Diagnostics.Process.Start%2A> метод для запуска нового процесса системы, метод создает новый <xref:System.Diagnostics.Process> компонент, который связывается с процессом.  
  
 Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> задано значение по умолчанию `true`, запуском приложений и документов в виде, аналогично использованию `Run` диалоговое окно Windows `Start` меню. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> является `false`, можно запускать только исполняемые файлы.  
  
 Любой исполняемый файл, который можно вызвать из командной строки можно запустить одним из двух способов: установив соответствующие члены <xref:System.Diagnostics.Process.StartInfo%2A> и вызова <xref:System.Diagnostics.Process.Start%2A> метод без параметров, либо путем передачи соответствующего параметра `static` <xref:System.Diagnostics.Process.Start%2A> член.  
  
 Можно создать <xref:System.Diagnostics.Process> компонент с помощью конструктора, одного из статических <xref:System.Diagnostics.Process.Start%2A> перегрузки или любой другой <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, или <xref:System.Diagnostics.Process.GetProcessesByName%2A> методы. После это сделано, вы можете просматривать связанного процесса. Это не динамическое представление, которое автоматически обновляется при изменении свойств процесса в памяти. Вместо этого необходимо вызвать <xref:System.Diagnostics.Process.Refresh%2A> компонента обновить <xref:System.Diagnostics.Process> сведения о свойствах в приложении.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the base priority of the associated process.</summary>
        <value>Базовый приоритет, который вычисляется свойством <see cref="P:System.Diagnostics.Process.PriorityClass" /> связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A> Процесса является стартовым приоритетом для потоков, созданных в связанном процессе. Можно просмотреть сведения о базовый приоритет через базового приоритета счетчик системного монитора.  
  
 На основе времени, затраченного или других показателях, операционной системы можно изменить базовый приоритет, если процесс должен размещаться перед другими пользователями.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> Свойство позволяет просмотреть начальный приоритет, назначенный процессу. Тем не менее, так как документ доступен только для чтения, нельзя использовать <xref:System.Diagnostics.Process.BasePriority%2A> для задания приоритета процесса. Чтобы изменить приоритет, используйте <xref:System.Diagnostics.Process.PriorityClass%2A> свойство. <xref:System.Diagnostics.Process.BasePriority%2A> Можно просматривать с помощью системного монитора, а <xref:System.Diagnostics.Process.PriorityClass%2A> не является. Как <xref:System.Diagnostics.Process.BasePriority%2A> и <xref:System.Diagnostics.Process.PriorityClass%2A> можно просмотреть программно. В следующей таблице показаны связи между <xref:System.Diagnostics.Process.BasePriority%2A> значения и <xref:System.Diagnostics.Process.PriorityClass%2A> значения.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process has exited.  -or-  The process has not started, so there is no process ID.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A> Возможность чтения потока, синхронно или асинхронно. Методы, такие как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> выполнять синхронные операции чтения в потоке вывода ошибок процесса. Эти синхронные чтение операции не завершаются до связанного <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardError%2A> потоковой передачи или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A> потока. Этот метод включает маршрутизируемый обработчик событий вывода потока и немедленно возвращает вызывающему объекту, который может выполнять другую работу, пока выходной поток направляется обработчику событий.  
  
 Выполните следующие действия для выполнения асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A> для <xref:System.Diagnostics.Process> :  
  
1.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> значение `false`.  
  
2.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> значение `true`.  
  
3.  Добавьте в обработчик событий для <xref:System.Diagnostics.Process.ErrorDataReceived> событий. Обработчик событий должен соответствовать <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> сигнатуре делегата.  
  
4.  Запустить <xref:System.Diagnostics.Process>.  
  
5.  Вызовите <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> для <xref:System.Diagnostics.Process>. Этот вызов запускает асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Когда запуск асинхронных операций чтения, обработчик событий вызывается каждый раз, когда связанный <xref:System.Diagnostics.Process> записывает строку текста для его <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Можно отменить асинхронную операцию чтения, вызвав <xref:System.Diagnostics.Process.CancelErrorRead%2A>. Операции чтения можно отменить в вызывающем объекте, или с помощью обработчика событий. После отмены, можно вызвать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> еще раз, чтобы возобновить операции асинхронного чтения.  
  
> [!NOTE]
>  Нельзя смешивать асинхронные и синхронные операции чтения в перенаправленном потоке. Один раз перенаправленного потока <xref:System.Diagnostics.Process> открыт в режиме асинхронной или синхронной, все дополнительные чтения операции в этом потоке должен быть в одном режиме. Например, не выполняйте <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> вызовом <xref:System.IO.StreamReader.ReadLine%2A> на <xref:System.Diagnostics.Process.StandardError%2A> потока, или наоборот. Тем не менее вы найдете в двух разных потоках в разных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> , а затем вызвать <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
   
  
## Examples  
 В следующем примере используется `net view` команду, чтобы вывести список доступных сетевых ресурсов на удаленном компьютере. Пользователь вводит имя конечного компьютера в качестве аргумента командной строки. Пользователь также может предоставить имя файла для вывода ошибок. Пример собирает выходные данные команды net, Ожидание завершения процесса, а затем запись в результаты вывода на консоль. Если пользователь вводит необязательный файл ошибок, ошибки в примере записываются в файл.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is <see langword="false" />.  \- or -  An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been used by a synchronous read operation.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A> Возможность чтения потока, синхронно или асинхронно. Методы, такие как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> выполнять синхронные операции чтения в выходной поток процесса. Эти синхронные чтение операции не завершаются до связанного <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardOutput%2A> потоковой передачи или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращает вызывающему объекту, который может выполнять другую работу, пока выходной поток направляется обработчику событий.  
  
 Выполните следующие действия для выполнения асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> для <xref:System.Diagnostics.Process> :  
  
1.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> значение `false`.  
  
2.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> значение `true`.  
  
3.  Добавьте в обработчик событий для <xref:System.Diagnostics.Process.OutputDataReceived> событий. Обработчик событий должен соответствовать <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> сигнатуре делегата.  
  
4.  Запустить <xref:System.Diagnostics.Process>.  
  
5.  Вызовите <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> для <xref:System.Diagnostics.Process>. Этот вызов запускает асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Когда запуск асинхронных операций чтения, обработчик событий вызывается каждый раз, когда связанный <xref:System.Diagnostics.Process> записывает строку текста для его <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
 Можно отменить асинхронную операцию чтения, вызвав <xref:System.Diagnostics.Process.CancelOutputRead%2A>. Операции чтения можно отменить в вызывающем объекте, или с помощью обработчика событий. После отмены, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> еще раз, чтобы возобновить операции асинхронного чтения.  
  
> [!NOTE]
>  Нельзя смешивать асинхронные и синхронные операции чтения в перенаправленном потоке. Один раз перенаправленного потока <xref:System.Diagnostics.Process> открыт в режиме асинхронной или синхронной, все дополнительные чтения операции в этом потоке должен быть в одном режиме. Например, не выполняйте <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> вызовом <xref:System.IO.StreamReader.ReadLine%2A> на <xref:System.Diagnostics.Process.StandardOutput%2A> потока, или наоборот. Тем не менее вы найдете в двух разных потоках в разных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , а затем вызвать <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
   
  
## Examples  
 Следующий пример иллюстрирует способ выполнения асинхронных операций чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> поток `sort` команды. `sort` Команда представляет собой консольное приложение, который считывает и сортирует ввода текста.  
  
 В примере создается делегат события для `SortOutputHandler` обработчик событий и связывает его с <xref:System.Diagnostics.Process.OutputDataReceived> событий. Обработчик событий получает строки текста из перенаправленного <xref:System.Diagnostics.Process.StandardOutput%2A> поток, форматирует текст и выводит текст на экран.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> property is <see langword="false" />.  \- or -  An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been used by a synchronous read operation.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of an application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Начинает асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardError%2A> потока. <xref:System.Diagnostics.Process.CancelErrorRead%2A> заканчивается операции асинхронного чтения.  
  
 После отмены, можно возобновить асинхронную операцию чтения, вызвав <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> еще раз.  
  
 При вызове <xref:System.Diagnostics.Process.CancelErrorRead%2A>, что все выполняющиеся операции чтения для <xref:System.Diagnostics.Process.StandardError%2A> завершены и затем отключен обработчик событий. Все дополнительные перенаправление выходных данных в <xref:System.Diagnostics.Process.StandardError%2A> сохраняется в буфере. Если вы включите обработчик событий с помощью вызова <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, сохраненные данные выводятся в обработчик событий, и возобновить операции асинхронного чтения. Если вы хотите изменить обработчик событий перед возобновлением асинхронных операций чтения, необходимо удалить существующий обработчик событий, прежде чем добавлять новый обработчик событий:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Нельзя смешивать асинхронные и синхронные операции чтения в перенаправленном <xref:System.Diagnostics.Process.StandardError%2A> потока. Один раз перенаправленного потока <xref:System.Diagnostics.Process> открыт в режиме асинхронной или синхронной, все дополнительные чтения операции в этом потоке должен быть в одном режиме. Если отменить асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardError%2A> и затем нужно считать из потока, необходимо использовать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> возобновить операции асинхронного чтения. Не выполняйте <xref:System.Diagnostics.Process.CancelErrorRead%2A> с помощью вызова для синхронного методы для чтения <xref:System.Diagnostics.Process.StandardError%2A> например <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, или <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 В следующем примере запускается `nmake` команды с пользователем заданные аргументы. Потоки ошибок и вывода считываются асинхронно; Накопленные строки текста на консоль выводятся, а также записываются в файл журнала. Если выходные данные команды превышает указанное число строк, будут отменены операции асинхронного чтения.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream is not enabled for asynchronous read operations.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of an application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Начинает асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. <xref:System.Diagnostics.Process.CancelOutputRead%2A> заканчивается операции асинхронного чтения.  
  
 После отмены, можно возобновить операции асинхронного чтения путем вызова <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> еще раз.  
  
 При вызове <xref:System.Diagnostics.Process.CancelOutputRead%2A>, что все выполняющиеся операции чтения для <xref:System.Diagnostics.Process.StandardOutput%2A> завершены и затем отключен обработчик событий. Все дополнительные перенаправление выходных данных в <xref:System.Diagnostics.Process.StandardOutput%2A> сохраняется в буфере. Если вы включите обработчик событий с помощью вызова <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, сохраненные данные выводятся в обработчик событий, и возобновить операции асинхронного чтения. Если вы хотите изменить обработчик событий перед возобновлением асинхронных операций чтения, необходимо удалить существующий обработчик событий, прежде чем добавлять новый обработчик событий:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Нельзя смешивать асинхронные и синхронные операции чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Один раз перенаправленного потока <xref:System.Diagnostics.Process> открыт в режиме асинхронной или синхронной, все дополнительные чтения операции в этом потоке должен быть в одном режиме. Если отменить асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> и затем нужно считать из потока, необходимо использовать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> возобновить операции асинхронного чтения. Не выполняйте <xref:System.Diagnostics.Process.CancelOutputRead%2A> с помощью вызова для синхронного методы для чтения <xref:System.Diagnostics.Process.StandardOutput%2A> например <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, или <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 В следующем примере запускается `nmake` команды с пользователем заданные аргументы. Потоки ошибок и вывода считываются асинхронно; Накопленные строки текста на консоль выводятся, а также записываются в файл журнала. Если выходные данные команды превышает указанное число строк, будут отменены операции асинхронного чтения.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream is not enabled for asynchronous read operations.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Frees all the resources that are associated with this component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A> Метод вызывает процесс остановки в состоянии ожидания выход, если он ожидал, закрывает дескриптор процесса и очищает свойства, относящиеся к процессу. <xref:System.Diagnostics.Process.Close%2A> не закрывайте стандартные выходные данные, входные данные и ошибки чтения и записи в случае, если они ссылаются извне.  
  
> [!NOTE]
>  Метод <xref:System.Diagnostics.Process.Dispose%2A> вызывает <xref:System.Diagnostics.Process.Close%2A>. Размещение <xref:System.Diagnostics.Process> объекта в `using` блок удаляет ресурсы без необходимости вызова <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем она получает использование физической памяти связанного процесса в 2-секундным интервалом не более 10 секунд. В данном примере отслеживается ли процесс завершается до истечения 10 секунд. Пример закрывает процесс, если оно по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes a process that has a user interface by sending a close message to its main window.</summary>
        <returns>
          <see langword="true" /> if the close message was successfully sent; <see langword="false" /> if the associated process does not have a main window or if the main window is disabled (for example if a modal dialog is being shown).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При выполнении процесса его цикл сообщений находится в состоянии ожидания. Цикл обработки сообщений выполняется каждый раз, отправляется сообщение Windows для процесса операционной системой. Вызов <xref:System.Diagnostics.Process.CloseMainWindow%2A> отправляет запрос на закрытие главного окна, которое закрывает дочерние окна и отменяет все выполняющиеся циклы сообщений для приложения в приложении правильного формата. Запрос на завершение процесса путем вызова <xref:System.Diagnostics.Process.CloseMainWindow%2A> не вынуждает приложения, чтобы выйти из программы. Приложение может запросить проверку пользователя перед завершением работы или она может отклонить выйти из программы. Чтобы принудительно запустить приложение, чтобы выйти из программы, используйте <xref:System.Diagnostics.Process.Kill%2A> метод. Поведение <xref:System.Diagnostics.Process.CloseMainWindow%2A> уже имеется у пользователя закрытие главного окна приложения, используя системное меню. Таким образом запрос на завершение процесса, закрыв главное окно не вынуждает приложения, чтобы немедленно выйти из программы.  
  
 Данные изменены процессом или ресурсы, выделенные для процесса могут быть потеряны при вызове метода <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> вызывает аварийного завершения процесса и должен использоваться только в случае необходимости. <xref:System.Diagnostics.Process.CloseMainWindow%2A> включает упорядоченной остановки процесса и закрывает все окна, поэтому рекомендуется для приложений с интерфейсом. Если <xref:System.Diagnostics.Process.CloseMainWindow%2A> завершается ошибкой, можно использовать <xref:System.Diagnostics.Process.Kill%2A> завершить процесс. <xref:System.Diagnostics.Process.Kill%2A> является единственным способом завершить процессы, не имеющих графического интерфейса.  
  
 Можно вызвать <xref:System.Diagnostics.Process.Kill%2A> и <xref:System.Diagnostics.Process.CloseMainWindow%2A> только для процессов, запущенных на локальном компьютере. Не удается вызвать процессов на удаленных компьютерах, чтобы выйти из. Кроме того, можно только просматривать информацию для процессов, выполняющихся на удаленных компьютерах.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем он получает использование физической памяти связанного процесса с 2-секундным интервалом не более 10 секунд. В данном примере отслеживается ли процесс завершается до истечения 10 секунд. Пример закрывает процесс, если оно по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Release all resources used by this process.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets whether the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the process terminates.</summary>
        <value>Значение <see langword="true" />, если событие <see cref="E:System.Diagnostics.Process.Exited" /> должно быть вызвано при завершении связанного процесса (выход или вызов метода <see cref="M:System.Diagnostics.Process.Kill" />); в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />. Обратите внимание, что <see cref="E:System.Diagnostics.Process.Exited" /> события даже в том случае, если значение <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> — <see langword="false" /> при завершении процесса во время или до выполнения пользователем <see cref="P:System.Diagnostics.Process.HasExited" /> проверки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Свойство предлагает, должны ли быть уведомлены компонента при операционной системы завершил работу процесса. <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Свойство используется при асинхронной обработке для уведомления приложения о завершении процесса. Чтобы заставить приложение синхронно ожидания события выхода (который прерывает обработку приложения, пока не произошло событие выхода), используйте <xref:System.Diagnostics.Process.WaitForExit%2A> метод.

> [!NOTE]
> Если вы используете Visual Studio и дважды щелкните <xref:System.Diagnostics.Process> компонента в проекте, <xref:System.Diagnostics.Process.Exited> делегат события и обработчик событий создаются автоматически. Дополнительный код задает <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> свойства `false`. Необходимо изменить это свойство, чтобы `true` для обработчика событий для выполнения при завершении связанного процесса.

Если компонента <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> значение `true`, или когда <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> — `false` и <xref:System.Diagnostics.Process.HasExited%2A> проверки вызывается компонентом, компонент может получить доступ к административной информации для связанного процесса, который остается хранит операционной системы. Такая информация включает <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.ExitCode%2A>.

После выхода из процесса, <xref:System.Diagnostics.Process.Handle%2A> компонента больше не указывает на существующий ресурс процесса. Вместо этого он может использоваться только для доступа к информации операционной системы о ресурсе процесса. Операционная система не знать о дескрипторах завершенных процессов, которые еще не были освобождены <xref:System.Diagnostics.Process> компонентов, поэтому она хранит <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.Handle%2A> информацию в памяти.

Есть затраты, связанные с наблюдением за завершением процесса. Если <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> — `true`, <xref:System.Diagnostics.Process.Exited> событие возникает при завершении связанного процесса. Процедуры <xref:System.Diagnostics.Process.Exited> события, время выполнения.

В некоторых случаях приложение запускает процесс, но не требует уведомление о его завершении. Например чтобы запустить приложение «Блокнот», чтобы разрешить пользователю редактировать текст, но больше не использовать приложение «Блокнот». Вы можете избежать уведомления при завершении процесса, так как он не имеет отношения к непрерывную работу приложения. Установка <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> для `false` позволяет сэкономить системные ресурсы.

## Examples  
В следующем примере кода создается процесс, который выводит файл. Он задает <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> свойство, чтобы процесс для вызова <xref:System.Diagnostics.Process.Exited> при выходе. <xref:System.Diagnostics.Process.Exited> Обработчик событий будет отображать сведения о процессе.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Puts a <see cref="T:System.Diagnostics.Process" /> component in state to interact with operating system processes that run in a special mode by enabling the native property <see langword="SeDebugPrivilege" /> on the current thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые процессы операционной системы выполните в специальном режиме. Чтение свойств или подключиться к этим процессам не поддерживается, если не был вызван <xref:System.Diagnostics.Process.EnterDebugMode%2A> в компоненте. Вызовите <xref:System.Diagnostics.Process.LeaveDebugMode%2A> при вам больше не нужен доступ к процессам, выполняющимся в специальном режиме.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an application writes to its redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived> Событие означает, что в свой перенаправленный записал процесса <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Это событие происходит только во время асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A>. Для запуска асинхронных операций чтения, необходимо перенаправить <xref:System.Diagnostics.Process.StandardError%2A> поток <xref:System.Diagnostics.Process>, добавьте в обработчик событий для <xref:System.Diagnostics.Process.ErrorDataReceived> событий и вызовов <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. После этого <xref:System.Diagnostics.Process.ErrorDataReceived> сообщения о событиях каждый раз, когда процесс записывает строку в перенаправленном <xref:System.Diagnostics.Process.StandardError%2A> потоковую передачу, пока процесс завершает работу или вызывает <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  Приложение, которое обрабатывается асинхронный выход должен вызывать <xref:System.Diagnostics.Process.WaitForExit> метод, чтобы гарантировать, что была записана в выходной буфер. Обратите внимание, что при указании времени ожидания с помощью <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> перегрузки *не* убедитесь, были записаны в выходной буфер.
  
   
  
## Examples  
 В следующем примере используется `net view` команду, чтобы вывести список доступных сетевых ресурсов на удаленном компьютере. Пользователь вводит имя конечного компьютера в качестве аргумента командной строки. Пользователь также может предоставить имя файла для вывода ошибок. Пример собирает выходные данные команды net, Ожидание завершения процесса, а затем запись в результаты вывода на консоль. Если пользователь вводит необязательный файл ошибок, ошибки в примере записываются в файл.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value that the associated process specified when it terminated.</summary>
        <value>Код, который задал связанный процесс при завершении.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.Process.ExitCode%2A> получить состояние, которое вернул системный процесс при завершении. Можно использовать код выхода во многом похож на возвращаемое значение из `main()` процедуры.  
  
 <xref:System.Diagnostics.Process.ExitCode%2A> Значение для процесса отражает конкретное соглашение, реализованные разработчиком приложения для этого процесса. При использовании значение кода выхода для принятия решений в коде, убедитесь, что вы знаете соглашения кода выхода, используемые в процессе приложения.  
  
 Разработчики обычно указывают успешный выход <xref:System.Diagnostics.Process.ExitCode%2A> значение ноль и обозначают ошибки ненулевыми значениями, которые вызывающий метод можно использовать для определения причины аварийного завершения процесса. Нет необходимости следуйте приведенным ниже рекомендациям, но они являются соглашением.  
  
 При попытке получить <xref:System.Diagnostics.Process.ExitCode%2A> прежде, чем процесс завершился, создаст исключение. Изучите <xref:System.Diagnostics.Process.HasExited%2A> свойство сначала, чтобы проверить, ли завершения связанного процесса.  
  
> [!NOTE]
>  Когда стандартный вывод был перенаправлен к асинхронных обработчиков событий, это возможно, что обработка вывода не будет завершена при <xref:System.Diagnostics.Process.HasExited%2A> возвращает `true`. Чтобы гарантировать завершение асинхронной обработки событий, вызвать <xref:System.Diagnostics.Process.WaitForExit> перегрузку, принимающую параметр не перед проверкой <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Можно использовать <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A> метода для завершения связанного процесса.  
  
 Существует два способа уведомления о завершении связанного процесса: синхронно и асинхронно. Синхронное уведомление основывается на вызове <xref:System.Diagnostics.Process.WaitForExit%2A> метод для приостановки выполнения приложения до выхода из сопоставленного компонента. Асинхронное уведомление основывается на <xref:System.Diagnostics.Process.Exited> событий. При использовании асинхронного уведомления <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> должно быть присвоено `true` для <xref:System.Diagnostics.Process> компонент для получения уведомления о завершении процесса.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process has not exited.  -or-  The process <see cref="P:System.Diagnostics.Process.Handle" /> is not valid.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitCode" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a process exits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited> Событие означает, что завершения связанного процесса. Это событие означает, что процесс прекращен (прерван) или успешно закрыт. Это событие может вызываться только в том случае, если значение <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> свойство `true`.  
  
 Существует два способа уведомления о завершении связанного процесса: синхронно и асинхронно. Синхронное уведомление означает вызов <xref:System.Diagnostics.Process.WaitForExit%2A> метод блокирует текущий поток до завершения работы процесса. Использует асинхронное уведомление <xref:System.Diagnostics.Process.Exited> событие, которое позволяет вызывающему потоку продолжить выполнение в то же время. В последнем случае <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> должно быть присвоено `true` для вызывающего приложения для получения события завершил работу.  
  
 При завершении работы процесса операционной системы он уведомляет все процессы, которые зарегистрировали обработчики для событий завершил работу. В настоящее время дескриптор процесса, который только что завершил работу можно использовать для доступа к некоторые свойства, такие как <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.HasExited%2A> что операционная система поддерживает до полностью освобождает этот дескриптор.  
  
> [!NOTE]
>  Даже если у вас есть дескриптор для завершенного процесса, нельзя вызывать <xref:System.Diagnostics.Process.Start%2A> еще раз, чтобы повторно подключиться к тот же процесс. Вызов <xref:System.Diagnostics.Process.Start%2A> автоматически освобождает процесса и подключается к процессу с тот же файл, но полностью нового <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Дополнительные сведения об использовании <xref:System.Diagnostics.Process.Exited> событий в приложениях Windows Forms, см. в разделе <xref:System.Diagnostics.Process.SynchronizingObject%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода создается процесс, который выводит файл. Он выдает <xref:System.Diagnostics.Process.Exited> событий при завершении процесса, так как <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> было установлено при создании процесса. <xref:System.Diagnostics.Process.Exited> Обработчик событий будет отображать сведения о процессе.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the associated process exited.</summary>
        <value>Класс <see cref="T:System.DateTime" />, показывающий время завершения связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если процесс не был завершен, при попытке получить <xref:System.Diagnostics.Process.ExitTime%2A> свойство вызывает исключение. Используйте <xref:System.Diagnostics.Process.HasExited%2A> перед получением <xref:System.Diagnostics.Process.ExitTime%2A> свойства, чтобы определить, ли завершения связанного процесса.  
  
   
  
## Examples  
 В следующем примере кода создается процесс, который выводит файл. Вызывает процесс <xref:System.Diagnostics.Process.Exited> при выходе и обработчик событий отображает <xref:System.Diagnostics.Process.ExitTime%2A> свойства и другие обработки информации.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a new <see cref="T:System.Diagnostics.Process" /> component and associates it with the currently active process.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> component associated with the process resource that is running the calling application.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания нового <xref:System.Diagnostics.Process> экземпляра и связать его с ресурсом процесса на локальном компьютере.  
  
 Как и подобные <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, и <xref:System.Diagnostics.Process.GetProcesses%2A> методы, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> связывает существующий ресурс с новым <xref:System.Diagnostics.Process> компонента.  
  
   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component, and associates it with the existing process resource that you specify.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">The system-unique identifier of a process resource.</param>
        <summary>Returns a new <see cref="T:System.Diagnostics.Process" /> component, given the identifier of a process on the local computer.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> component that is associated with the local process resource identified by the <paramref name="processId" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания нового <xref:System.Diagnostics.Process> компонента и связать его с ресурсом процесса на локальном компьютере. Ресурс процесса должен уже существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> не создает системный ресурс, а связывает ресурс с созданным приложением <xref:System.Diagnostics.Process> компонента. Процесс <xref:System.Diagnostics.Process.Id%2A> можно получить только для процесса, который выполняется в данный момент на компьютере. После завершения процесса, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> создает исключение, если он передается идентификатор с истекшим сроком действия.  
  
 На любом конкретном компьютере имеет уникальный идентификатор процесса. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> Возвращает по крайней мере один процесс. Если вы хотите получить все процессы, выполняющие определенное приложение, используйте <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Если существует несколько процессов на компьютере под управлением указанное приложение <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> возвращает массив, содержащий все связанные процессы. Вы можете запрашивать каждый из этих процессов, в свою очередь по его идентификатору. Идентификатор процесса можно просмотреть в `Processes` панели диспетчера задач Windows. `PID` Столбце отображается идентификатор, присвоенный процессу.  
  
   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The process specified by the <paramref name="processId" /> parameter is not running. The identifier might be expired.</exception>
        <exception cref="T:System.InvalidOperationException">The process was not started by this object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">The system-unique identifier of a process resource.</param>
        <param name="machineName">The name of a computer on the network.</param>
        <summary>Returns a new <see cref="T:System.Diagnostics.Process" /> component, given a process identifier and the name of a computer on the network.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> component that is associated with a remote process resource identified by the <paramref name="processId" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания нового <xref:System.Diagnostics.Process> компонента и связать его с ресурсом процесса на удаленном компьютере в сети. Ресурс процесса должен уже существовать на указанном компьютере, так как <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> не создает системный ресурс, а связывает ресурс с созданным приложением <xref:System.Diagnostics.Process> компонента. Процесс <xref:System.Diagnostics.Process.Id%2A> можно получить только для процесса, который выполняется в данный момент на компьютере. После завершения процесса, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> создает исключение, если он передается идентификатор с истекшим сроком действия.  
  
 На любом конкретном компьютере имеет уникальный идентификатор процесса. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> Возвращает по крайней мере один процесс. Если вы хотите получить все процессы, выполняющие определенное приложение, используйте <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Если существует несколько процессов на компьютере под управлением указанное приложение <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> возвращает массив, содержащий все связанные процессы. Вы можете запрашивать каждый из этих процессов, в свою очередь по его идентификатору. Идентификатор процесса можно просмотреть в `Processes` панели диспетчера задач Windows. `PID` Столбце отображается идентификатор, присвоенный процессу.  
  
 Если вы не укажете `machineName`, используется локальный компьютер. Кроме того, можно указать локальный компьютер, установив `machineName` значение «.» или пустую строку (»»).  
  
   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The process specified by the <paramref name="processId" /> parameter is not running. The identifier might be expired.  -or-  The <paramref name="machineName" /> parameter syntax is invalid. The name might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The process was not started by this object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with existing process resources.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the local computer.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the local computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process> компоненты и связать их со всеми ресурсами процесса на локальном компьютере. Ресурсы процесса уже должен существовать на локальном компьютере, так как <xref:System.Diagnostics.Process.GetProcesses%2A> не создает системных ресурсов, а связывает ресурсы с генерируемые приложением <xref:System.Diagnostics.Process> компонентов. Поскольку сама операционная система запускает фоновые процессы, этот массив никогда не пуст.  
  
 Если вы не хотите получить все процессы, выполняемые на компьютере, можно ограничить их количество, с помощью <xref:System.Diagnostics.Process.GetProcessById%2A> или <xref:System.Diagnostics.Process.GetProcessesByName%2A> метод. <xref:System.Diagnostics.Process.GetProcessById%2A> Создает <xref:System.Diagnostics.Process> компонент, связанный с процессом, определяется в системе по идентификатору процесса, который передается методу. <xref:System.Diagnostics.Process.GetProcessesByName%2A> Создает массив <xref:System.Diagnostics.Process> компоненты, связанные ресурсы используют исполняемого файла, передайте методу.  
  
> [!NOTE]
>  Несколько служб Windows могут быть загружены в одном экземпляре процесса узла службы (svchost.exe). GetProcesses не определяет таких отдельных служб. для этого см. в разделе <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">The computer from which to read the list of processes.</param>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the specified computer.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the specified computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process> компоненты и связать их со всеми ресурсами процесса на указанном компьютере (обычно удаленном). Ресурсы процесса уже должен существовать на локальном компьютере, так как <xref:System.Diagnostics.Process.GetProcesses%2A> не создает системных ресурсов, а связывает ресурсы с генерируемые приложением <xref:System.Diagnostics.Process> компонентов. Поскольку сама операционная система запускает фоновые процессы, этот массив никогда не пуст.  
  
 Если вы не хотите получить все процессы, выполняемые на компьютере, можно ограничить их количество, с помощью <xref:System.Diagnostics.Process.GetProcessById%2A> или <xref:System.Diagnostics.Process.GetProcessesByName%2A> метод. <xref:System.Diagnostics.Process.GetProcessById%2A> Создает <xref:System.Diagnostics.Process> компонент, связанный с процессом, определяется в системе по идентификатору процесса, который передается методу. <xref:System.Diagnostics.Process.GetProcessesByName%2A> Создает массив <xref:System.Diagnostics.Process> компоненты, связанные ресурсы используют исполняемого файла, передайте методу.  
  
 Эта перегрузка <xref:System.Diagnostics.Process.GetProcesses%2A> метод обычно используется для получения списка ресурсы процесса, выполняющегося на удаленном компьютере в сети, но можно указать локальный компьютер, передав «.».  
  
> [!NOTE]
>  Несколько служб Windows могут быть загружены в одном экземпляре процесса узла службы (svchost.exe). GetProcesses не определяет таких отдельных служб. для этого см. в разделе <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter syntax is invalid. It might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The operating system platform does not support this operation on remote computers.</exception>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A problem occurred accessing an underlying system API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with the existing process resources that all share the specified process name.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">The friendly name of the process.</param>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on the local computer that share the specified process name.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process> компоненты и связать их со всеми ресурсами процесса, работающих под управлением тот же исполняемый файл на локальном компьютере. Ресурсы процесса должен уже существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessesByName%2A> не создает системных ресурсов, а связывает их с генерируемые приложением <xref:System.Diagnostics.Process> компонентов. Объект `processName` может быть указан для исполняемого файла, который в настоящий момент не выполняется на локальном компьютере, поэтому этот метод возвращает массив может быть пустым.  
  
 Имя процесса — это понятное имя для процесса, например Outlook, который не поддерживает расширения .exe или путь. <xref:System.Diagnostics.Process.GetProcessesByName%2A> полезно для получения и обработки всех процессов, которые связаны с тот же исполняемый файл. Например, можно передать имя исполняемого файла как `processName` параметр, чтобы завершить работу всех выполняющихся экземпляров этого исполняемого файла.  
  
 Хотя процесс <xref:System.Diagnostics.Process.Id%2A> является уникальным для одного ресурса процесса в системе, несколько процессов на локальном компьютере могут работать под управлением приложения, указанного `processName` параметра. Таким образом <xref:System.Diagnostics.Process.GetProcessById%2A> возвращает один процесс по крайней мере, но <xref:System.Diagnostics.Process.GetProcessesByName%2A> возвращает массив, содержащий все связанные процессы. Если вам нужно управлять с помощью стандартных вызовов API, можно запросить каждый из этих процессов, в свою очередь по его идентификатору. Воспользоваться ресурсами процесса процесса только через имя, но, после получения массив <xref:System.Diagnostics.Process> компоненты, которые были связаны с ресурсами процесса, можно запустить, окончания и управлять ресурсами системы.  
  
   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">The friendly name of the process.</param>
        <param name="machineName">The name of a computer on the network.</param>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on a remote computer that share the specified process name.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process> компоненты и связать их со всеми ресурсами процесса, работающих под управлением тот же исполняемый файл на указанном компьютере. Ресурсы процесса должен уже существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessesByName%2A> не создает системных ресурсов, а связывает их с генерируемые приложением <xref:System.Diagnostics.Process> компонентов. Объект `processName` может быть указан для исполняемого файла, который в настоящий момент не выполняется на локальном компьютере, поэтому этот метод возвращает массив может быть пустым.  
  
 Имя процесса — это понятное имя для процесса, например Outlook, который не поддерживает расширения .exe или путь. <xref:System.Diagnostics.Process.GetProcessesByName%2A> полезно для получения и обработки всех процессов, которые связаны с тот же исполняемый файл. Например, можно передать имя исполняемого файла как `processName` параметр, чтобы завершить работу всех выполняющихся экземпляров этого исполняемого файла.  
  
 Хотя процесс <xref:System.Diagnostics.Process.Id%2A> является уникальным для одного ресурса процесса в системе, несколько процессов на локальном компьютере могут работать под управлением приложения, указанного `processName` параметра. Таким образом <xref:System.Diagnostics.Process.GetProcessById%2A> возвращает один процесс по крайней мере, но <xref:System.Diagnostics.Process.GetProcessesByName%2A> возвращает массив, содержащий все связанные процессы. Если вам нужно управлять с помощью стандартных вызовов API, можно запросить каждый из этих процессов, в свою очередь по его идентификатору. Воспользоваться ресурсами процесса процесса только через имя, но, после получения массив <xref:System.Diagnostics.Process> компоненты, которые были связаны с ресурсами процесса, можно запустить, окончания и управлять ресурсами системы.  
  
 Можно использовать эту перегрузку для получения процессов на локальном компьютере, а также на удаленном компьютере. Используйте «.» для указания локального компьютера. Существует другая перегрузка, которая по умолчанию используется локальный компьютер.  
  
 Процессы на удаленных компьютерах только для того, чтобы просмотреть сведения о процессах, например статистика, доступны. Невозможно закрыть, завершать (с помощью <xref:System.Diagnostics.Process.Kill%2A>), или запускать процессы на удаленных компьютерах.  
  
   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter syntax is invalid. It might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The operating system platform does not support this operation on remote computers.</exception>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A problem occurred accessing an underlying system API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на вызов неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle of the associated process.</summary>
        <value>Дескриптор, присвоенный процессу операционной системой при запуске. Система использует этот дескриптор для хранения атрибутов процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение может получить дескриптор к процессу, который может использоваться в качестве параметра для многих функций управления и обработки информации. Вы можете использовать этот дескриптор для инициализации <xref:System.Threading.WaitHandle> или вызывать вызова собственных методов с платформой.  
  
 Дескриптор процесса является закрытым для приложения — другими словами, обрабатывающим маркеры не могут совместно использоваться. Процесс также имеет <xref:System.Diagnostics.Process.Id%2A> которой, в отличие от <xref:System.Diagnostics.Process.Handle%2A>, является уникальным и, следовательно, допустимое во всей системе.  
  
 Только процессы, запущенные посредством вызова <xref:System.Diagnostics.Process.Start%2A> задать <xref:System.Diagnostics.Process.Handle%2A> свойства соответствующего элемента <xref:System.Diagnostics.Process> экземпляров.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process has not been started or has exited. The <see cref="P:System.Diagnostics.Process.Handle" /> property cannot be read because there is no process associated with this <see cref="T:System.Diagnostics.Process" /> instance.  -or-  The <see cref="T:System.Diagnostics.Process" /> instance has been attached to a running process but you do not have the necessary permissions to get a handle with full access rights.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.Handle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of handles opened by the process.</summary>
        <value>Число дескрипторов операционной системы, открытых процессом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дескрипторы предоставляют способ для процесса, для ссылки на объекты. Процесс может получать дескрипторы файлов, ресурсы, очереди сообщений и множество других объектов операционной системы. Операционная система освобождает память, связанный с процессом, только в том случае, когда значение счетчика дескрипторов равно нулю.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the associated process has been terminated.</summary>
        <value>Значение <see langword="true" />, если процесс операционной системы, на который ссылается компонент <see cref="T:System.Diagnostics.Process" />, был завершен; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `true` для <xref:System.Diagnostics.Process.HasExited%2A> указывает, что связанный процесс был завершен обычным образом или аварийно. Вы можете запросить или принудительно закрыть путем вызова связанного процесса <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Если дескриптор открыт к процессу, операционная система освобождает память процесса, когда процесс завершен, но сохраняет административную информацию о процессе, такие как дескриптор, код выхода и время выхода. Чтобы получить эти сведения, можно использовать <xref:System.Diagnostics.Process.ExitCode%2A> и <xref:System.Diagnostics.Process.ExitTime%2A> свойства. Эти свойства заполняются автоматически для процессов, которые были запущены этим компонентом. Административные сведения раскрываются при всех <xref:System.Diagnostics.Process> компоненты, связанные с системным процессом, уничтожаются и больше не содержат дескрипторов завершенных процессов.  
  
 Процесс может завершиться независимо от кода. Если вы начали процесс, с помощью этого компонента, система обновляет значение <xref:System.Diagnostics.Process.HasExited%2A> автоматически, даже если связанный процесс завершается независимо друг от друга.  
  
> [!NOTE]
>  Когда стандартный вывод был перенаправлен к асинхронных обработчиков событий, это возможно, что обработка вывода не будет завершена, когда это свойство возвращает `true`. Чтобы гарантировать завершение асинхронной обработки событий, вызвать <xref:System.Diagnostics.Process.WaitForExit> перегрузку, принимающую параметр не перед проверкой <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем он получает использование физической памяти связанного процесса с 2-секундным интервалом не более 10 секунд. В данном примере отслеживается ли процесс завершается до истечения 10 секунд. Пример закрывает процесс, если оно по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There is no process associated with the object.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The exit code for the process could not be retrieved.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.HasExited" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the unique identifier for the associated process.</summary>
        <value>Созданный системой уникальный идентификатор, на который ссылается этот экземпляр <see cref="T:System.Diagnostics.Process" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Процесс <xref:System.Diagnostics.Process.Id%2A> не допускается, если связанный процесс не выполняется. Таким образом, следует убедиться, что процесс выполняется до получения <xref:System.Diagnostics.Process.Id%2A> свойство. До завершения процесса, идентификатор процесса однозначно идентифицирует процесс во всей системе.  
  
 Вы можете подключиться к процессу, выполняющемуся на локальном или удаленном компьютере в новый <xref:System.Diagnostics.Process> экземпляр, передав идентификатор процесса для <xref:System.Diagnostics.Process.GetProcessById%2A> метод. <xref:System.Diagnostics.Process.GetProcessById%2A> — `static` метод, который создает новый компонент и задает <xref:System.Diagnostics.Process.Id%2A> свойства для нового <xref:System.Diagnostics.Process> экземпляр автоматически.  
  
 Идентификаторы процессов может многократно использоваться системой. <xref:System.Diagnostics.Process.Id%2A> Значение свойства является уникальным только в том случае, пока выполняется связанный процесс. После завершения процесса, можно повторно использовать системы <xref:System.Diagnostics.Process.Id%2A> значение свойства для несвязанного процесса.  
  
 Так как этот идентификатор уникален в системе, можно передать его для других потоков в качестве альтернативы для передачи <xref:System.Diagnostics.Process> экземпляра. Это действие может сэкономить ресурсы системы, но гарантирует, что процесс определяется правильно.  
  
   
  
## Examples  
 В следующем примере демонстрируется получение <xref:System.Diagnostics.Process.Id%2A> для всех экземпляров приложения. Код создает новый экземпляр блокнота, выводит список всех экземпляров Блокнота и затем позволяет пользователю ввести <xref:System.Diagnostics.Process.Id%2A> номер для удаления конкретного экземпляра.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process's <see cref="P:System.Diagnostics.Process.Id" /> property has not been set.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Immediately stops the associated process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> Принудительное завершение процесса, хотя <xref:System.Diagnostics.Process.CloseMainWindow%2A> только запрашивает завершения. При выполнении процесса с графическим интерфейсом, цикл сообщений находится в состоянии ожидания. Цикл обработки сообщений выполняется каждый раз, отправляется сообщение Windows для процесса операционной системой. Вызов <xref:System.Diagnostics.Process.CloseMainWindow%2A> отправляет запрос на закрытие главного окна, которое закрывает дочерние окна и отменяет все выполняющиеся циклы сообщений для приложения в приложении правильного формата. Запрос на завершение процесса путем вызова <xref:System.Diagnostics.Process.CloseMainWindow%2A> не вынуждает приложения, чтобы выйти из программы. Приложение может запросить проверку пользователя перед завершением работы или она может отклонить выйти из программы. Чтобы принудительно запустить приложение, чтобы выйти из программы, используйте <xref:System.Diagnostics.Process.Kill%2A> метод. Поведение <xref:System.Diagnostics.Process.CloseMainWindow%2A> уже имеется у пользователя закрытие главного окна приложения, используя системное меню. Таким образом запрос на завершение процесса, закрыв главное окно не вынуждает приложения, чтобы немедленно выйти из программы.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A> Метод выполняется асинхронно. После вызова метода <xref:System.Diagnostics.Process.Kill%2A> мы вызываем метод <xref:System.Diagnostics.Process.WaitForExit%2A> метод для ожидания завершения выполнения или проверка процесса <xref:System.Diagnostics.Process.HasExited%2A> свойства, чтобы определить, если процесс завершился.  
  
 Данные изменены процессом или ресурсы, выделенные для процесса могут быть потеряны при вызове метода <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> вызывает аварийного завершения процесса и должен использоваться только в случае необходимости. <xref:System.Diagnostics.Process.CloseMainWindow%2A> включает упорядоченной остановки процесса и закрывает все окна, поэтому рекомендуется для приложений с интерфейсом. Если <xref:System.Diagnostics.Process.CloseMainWindow%2A> завершается ошибкой, можно использовать <xref:System.Diagnostics.Process.Kill%2A> завершить процесс. <xref:System.Diagnostics.Process.Kill%2A> является единственным способом завершить процессы, не имеющих графического интерфейса.  
  
 Можно вызвать <xref:System.Diagnostics.Process.Kill%2A> и <xref:System.Diagnostics.Process.CloseMainWindow%2A> только для процессов, запущенных на локальном компьютере. Не удается вызвать процессов на удаленных компьютерах, чтобы выйти из. Кроме того, можно только просматривать информацию для процессов, выполняющихся на удаленных компьютерах.  
  
> [!NOTE]
>  Если вызов <xref:System.Diagnostics.Process.Kill%2A> метод выполняется, хотя в настоящее время выполняется завершение процесса, <xref:System.ComponentModel.Win32Exception> для отказано в доступе возникает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The associated process could not be terminated.  -or-  The process is terminating.  -or-  The associated process is a Win16 executable.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to call <see cref="M:System.Diagnostics.Process.Kill" /> for a process that is running on a remote computer. The method is available only for processes running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process has already exited.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Takes a <see cref="T:System.Diagnostics.Process" /> component out of the state that lets it interact with operating system processes that run in a special mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые процессы операционной системы выполните в специальном режиме. Чтение свойств или подключиться к этим процессам не поддерживается, если не был вызван <xref:System.Diagnostics.Process.EnterDebugMode%2A> в компоненте. Вызовите <xref:System.Diagnostics.Process.LeaveDebugMode%2A> при вам больше не нужен доступ к процессам, выполняющимся в специальном режиме.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the computer the associated process is running on.</summary>
        <value>Имя компьютера, на котором выполняется связанный процесс.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно просмотреть статистические данные и сведения о процессе для процессов, запущенных на удаленном компьютере, но не может вызвать <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, или <xref:System.Diagnostics.Process.Kill%2A> на удаленных компьютерах.  
  
> [!NOTE]
>  При выполнении процесса на локальном компьютере, это свойство возвращает точку (".») для имени компьютера. Следует использовать <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство для получения имени правильный.  
  
   
  
## Examples  
 Для использования в следующем примере, необходимо сначала запустите хотя бы один экземпляр блокнота на удаленном компьютере. Приведенный пример запрашивает имя удаленного компьютера, на котором выполняется Блокнот, а затем отображает соответствующие <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, и <xref:System.Diagnostics.Process.MachineName%2A> свойства для каждого экземпляра.  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the main module for the associated process.</summary>
        <value>Модуль <see cref="T:System.Diagnostics.ProcessModule" />, который был использован для запуска процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Модуль процесса представляет файл.dll или .exe, загруженный в определенный процесс. <xref:System.Diagnostics.Process.MainModule%2A> Свойство позволяет просматривать сведения об исполняемом файле, используемая для запуска процесса, включая имя модуля, имя файла и сведения о модуле памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainModule" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A 32-bit process is trying to access the modules of a 64-bit process.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the window handle of the main window of the associated process.</summary>
        <value>Созданный системой дескриптор главного окна связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Главное окно является окном, открытых процессом, который в данный момент имеет фокус ( <xref:System.Windows.Forms.Form.TopLevel%2A> формы). Необходимо использовать <xref:System.Diagnostics.Process.Refresh%2A> метод для обновления <xref:System.Diagnostics.Process> объекта, чтобы получить текущий дескриптор главного окна, если он был изменен. Как правило, так как дескриптор окна кэшируется, использовать <xref:System.Diagnostics.Process.Refresh%2A> заранее, чтобы гарантировать, что вы сможете извлекать текущий дескриптор.  
  
 Вы можете получить <xref:System.Diagnostics.Process.MainWindowHandle%2A> свойство только для процессов, запущенных на локальном компьютере. <xref:System.Diagnostics.Process.MainWindowHandle%2A> Свойство имеет значение, которое однозначно определяет окно, связанный с процессом.  
  
 Процесс имеет главное окно, связанное с ним, только в том случае, если процесс имеет графический интерфейс. Если связанный процесс не имеет главного окна, <xref:System.Diagnostics.Process.MainWindowHandle%2A> значение равно нулю. Значение равно нулю для процессов, которые были скрыты, то есть процессов, которые не отображаются на панели задач. Это может быть справедливо для процессов, которые отображаются в области уведомлений в правой части панели задач в виде значков.  
  
 Если вы только что запущен процесс и хотите использовать дескриптор главного окна, рассмотрите возможность использования <xref:System.Diagnostics.Process.WaitForInputIdle%2A> метод, который позволяет процессу завершить запуск, убедившись, что был создан дескриптор главного окна. В противном случае будет создаваться исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> is not defined because the process has exited.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the caption of the main window of the process.</summary>
        <value>Заголовок главного окна процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Процесс имеет главное окно, связанное с ним, только в том случае, если процесс имеет графический интерфейс. Если связанный процесс не имеет главного окна (таким образом, чтобы <xref:System.Diagnostics.Process.MainWindowHandle%2A> равно нулю), <xref:System.Diagnostics.Process.MainWindowTitle%2A> является пустой строкой (»»). Если вы только что запущен процесс и хотите использовать заголовок главного окна, рассмотрите возможность использования <xref:System.Diagnostics.Process.WaitForInputIdle%2A> метод, который позволяет процессу завершить запуск, убедившись, что был создан дескриптор главного окна. В противном случае система создает исключение.  
  
> [!NOTE]
>  Главное окно — окно, которое в данный момент имеет фокус; Обратите внимание на то, что это может быть основного окна процесса. Необходимо использовать <xref:System.Diagnostics.Process.Refresh%2A> метод для обновления <xref:System.Diagnostics.Process> объекта, чтобы получить текущий дескриптор главного окна, если он был изменен.  
  
   
  
## Examples  
 Следующий пример запускает экземпляр блокнота и получает заголовок главного окна процесса.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property is not defined because the process has exited.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum allowable working set size, in bytes, for the associated process.</summary>
        <value>Максимальный размер рабочего множества в байтах, доступного в памяти для процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рабочий набор процесса — это набор страниц памяти, видимой в данный момент к процессу в физической памяти ОЗУ. Эти страницы являются резидентными и доступны для приложения для использования без создания ошибки страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые приложения, включая страницы в DLL-файлы и файлы system.dll. При увеличении размера рабочего набора, увеличивает требуемый объем памяти.  
  
 Процесс имеет минимальный и Максимальный рабочий набор размеров. Каждый раз, когда создается ресурс процесса, система резервирует объем памяти, равным минимальный размер рабочего множества для процесса. Диспетчер виртуальной памяти пытается сохранить по крайней мере минимальный объем памяти резидентной, когда процесс активен, но никогда не хранит больше, чем максимальный размер.  
  
 Система устанавливает значение по умолчанию размеров рабочего набора. Вы можете изменить эти размеры, используя <xref:System.Diagnostics.Process.MaxWorkingSet%2A> и <xref:System.Diagnostics.Process.MinWorkingSet%2A> членов. Тем не менее настройке этих значений не гарантирует что память будет зарезервированной или находящейся.  
  
> [!NOTE]
>  При увеличении размера рабочего множества процесса, можно воспользоваться физической памяти отдельно от системы. Убедитесь в том, не требуют размер минимальное или максимальное рабочего набора, в которой слишком велика, поскольку это может снизить производительность системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The maximum working set size is invalid. It must be greater than or equal to the minimum working set size.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Working set information cannot be retrieved from the associated process resource.  -or-  The process identifier or process handle is zero because the process has not been started.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the minimum allowable working set size, in bytes, for the associated process.</summary>
        <value>Минимальный размер рабочего множества в байтах, требуемый в памяти для процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рабочий набор процесса — это набор страниц памяти, видимой в данный момент к процессу в физической памяти ОЗУ. Эти страницы являются резидентными и доступны для приложения для использования без создания ошибки страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые приложения, включая страницы в DLL-файлы и файлы system.dll. При увеличении размера рабочего набора, увеличивает требуемый объем памяти.  
  
 Процесс имеет минимальный и Максимальный рабочий набор размеров. Каждый раз, когда создается ресурс процесса, система резервирует объем памяти, равным минимальный размер рабочего множества для процесса. Диспетчер виртуальной памяти пытается сохранить по крайней мере минимальный объем памяти резидентной, когда процесс активен, но никогда не хранит больше, чем максимальный размер.  
  
 Система устанавливает значение по умолчанию размеров рабочего набора. Вы можете изменить эти размеры, используя <xref:System.Diagnostics.Process.MaxWorkingSet%2A> и <xref:System.Diagnostics.Process.MinWorkingSet%2A> членов. Тем не менее настройке этих значений не гарантирует что память будет зарезервированной или находящейся.  
  
> [!NOTE]
>  При увеличении размера рабочего множества процесса, можно воспользоваться физической памяти отдельно от системы. Убедитесь в том, не требуют размер минимальное или максимальное рабочего набора, в которой слишком велика, поскольку это может снизить производительность системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The minimum working set size is invalid. It must be less than or equal to the maximum working set size.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Working set information cannot be retrieved from the associated process resource.  -or-  The process identifier or process handle is zero because the process has not been started.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the modules that have been loaded by the associated process.</summary>
        <value>Массив объектов типа <see cref="T:System.Diagnostics.ProcessModule" />, который предоставляет модули, загруженные связанным процессом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Модуль процесса представляет файл.dll или .exe, загруженный в определенный процесс. Объект <xref:System.Diagnostics.ProcessModule> экземпляра позволяет просматривать сведения о модуле, включая имя модуля, имя файла и сведения о модуле памяти.  
  
 Процесс можно загрузить несколько модулей в память. Например файлы .exe, которые загружают Дополнительные DLL-файлы имеют несколько модулей.  
  
 После запуска процесса, эта коллекция пуста, пока процесс загрузки системы. Если процесс имеет главное окно, можно вызвать <xref:System.Diagnostics.Process.WaitForInputIdle%2A> до получения этого свойства, чтобы убедиться, что коллекция не пуста при получения списка.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for either the system process or the idle process. These processes do not have modules.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</summary>
        <value>Объем памяти в байтах, выделенной системой для связанного процесса, который нельзя записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</summary>
        <value>Объем системной памяти в байтах, выделенной для связанного процесса, которую нельзя записать в файл подкачки виртуальной памяти.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер невыгружаемой системной памяти, используемой процессом, в байтах. Системной памяти — это физическая память, используемые операционной системой и делится разбитого на страницы и невыгружаемые пулы. Выделение памяти в невыгружаемом страничном остаются в системной памяти и не выгружаются в файл подкачки виртуальной памяти.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **байт в невыгружаемом страничном пуле** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises the <see cref="E:System.Diagnostics.Process.Exited" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> — метод API, который вызывает <xref:System.Diagnostics.Process.Exited> событий. Вызов <xref:System.Diagnostics.Process.OnExited%2A> вызывает <xref:System.Diagnostics.Process.Exited> возникновения события и является единственным способом для вызова событий с помощью <xref:System.Diagnostics.Process> компонента. <xref:System.Diagnostics.Process.OnExited%2A> используется главным образом при наследовании классов от компонента.  
  
 Как альтернативу <xref:System.Diagnostics.Process.OnExited%2A>, можно написать собственный обработчик событий. Вы создадите собственный делегат обработчика событий и собственного метода обработки событий.  
  
> [!NOTE]
>  Если вы используете среду Visual Studio, делегат обработчика событий (AddOnExited) и метод обработки событий (Process1_Exited) создаются автоматически при перетаскивании <xref:System.Diagnostics.Process> компонента в форму и дважды щелкните значок. Создаваемый код, необходимо выполнить после <xref:System.Diagnostics.Process.Exited> вводится в процедуру Process1_Exited событием. Необходимо создать <xref:System.Diagnostics.Process.OnExited%2A> члена, так как он реализуется автоматически.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Diagnostics.Process.OnExited%2A> метод в производном классе.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs each time an application writes a line to its redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived> Указывает, что связанный <xref:System.Diagnostics.Process> написал линию, завершается с символом новой строки в свой перенаправленный <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
 Событие включено во время асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>. Для запуска асинхронных операций чтения, необходимо перенаправить <xref:System.Diagnostics.Process.StandardOutput%2A> поток <xref:System.Diagnostics.Process>, добавьте в обработчик событий для <xref:System.Diagnostics.Process.OutputDataReceived> событий и вызовов <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. После этого <xref:System.Diagnostics.Process.OutputDataReceived> сообщения о событиях каждый раз, когда процесс записывает строку в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> потоковую передачу, пока процесс завершает работу или вызывает <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  Приложение, которое обрабатывается асинхронный выход должен вызывать <xref:System.Diagnostics.Process.WaitForExit%2A> метод, чтобы гарантировать, что была записана в выходной буфер.  
  
   
  
## Examples  
 Следующий пример иллюстрирует способ выполнения асинхронных операций чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> поток `ipconfig` команды.  
  
 В примере создается делегат события для `OutputHandler` обработчик событий и связывает его с <xref:System.Diagnostics.Process.OutputDataReceived> событий. Обработчик событий получает строки текста из перенаправленного <xref:System.Diagnostics.Process.StandardOutput%2A> поток, форматирует текст и сохраняет его в выходной строке, который более поздней версии отображается в окне консоли данного примера.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of paged memory, in bytes, allocated for the associated process.</summary>
        <value>Объем памяти в байтах, выделенной связанным процессом, который можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of paged memory, in bytes, allocated for the associated process.</summary>
        <value>Объем памяти в байтах, выделенной в файле подкачки виртуальной памяти для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер памяти в файл подкачки виртуальной памяти, используемой процессом, в байтах. Операционная система использует файл подкачки виртуальной памяти в сочетании с физической памяти для управления виртуального адресного пространства для каждого процесса. После выгружаемой памяти не используется, его можно переместить в файл подкачки виртуальной памяти на диске. Чтобы получить объем памяти, используемой операционной системы для процесса, используйте <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> свойство.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **байт файла подкачки** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр программы Блокнот и извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</summary>
        <value>Объем памяти в байтах, выделенной системой для связанного процесса, который можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</summary>
        <value>Объем системной памяти в байтах, выделенной для связанного процесса, которую можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое значение этого свойства представляет текущий объем выгружаемой системной памяти, используемой процессом, в байтах. Системной памяти — это физическая память, используемые операционной системой и делится разбитого на страницы и невыгружаемые пулы. После выгружаемой памяти не используется, его можно переместить в файл подкачки виртуальной памяти на диске. Чтобы получить объем памяти приложения, используемые в процессе, используйте <xref:System.Diagnostics.Process.PagedMemorySize64%2A> свойство.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **байт в выгружаемом страничном пуле** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</summary>
        <value>Максимальный объем памяти в байтах, выделенной связанным процессом, который можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</summary>
        <value>Максимальный объем памяти в байтах, выделенной в файле подкачки виртуальной памяти для связанного процесса с момента его запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое значение этого свойства представляет максимальный размер памяти в файле подкачки виртуальной памяти, используемой процессом с момента его запуска, в байтах. Операционная система использует файл подкачки виртуальной памяти в сочетании с физической памяти для управления виртуального адресного пространства для каждого процесса. После выгружаемой памяти не используется, его можно переместить в файл подкачки виртуальной памяти на диске.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **байтов файла подкачки (пик)** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</summary>
        <value>Максимальный объем виртуальной памяти в байтах, запрошенной связанным процессом.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</summary>
        <value>Максимальный объем виртуальной памяти в байтах, выделенной для связанного процесса с момента его запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством представляет максимальный объем виртуальной памяти, используемой процессом с момента его запуска, в байтах. Операционная система сопоставляет виртуального адресного пространства для каждого процесса, либо на страницы загрузки в физической памяти, или на страницы хранятся в файле подкачки виртуальной памяти на диске.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **виртуальных байт (пик)** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the peak working set size for the associated process, in bytes.</summary>
        <value>Максимальный объем физической памяти, запрошенной связанным процессом одновременно (в байтах).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рабочий набор процесса — это набор страниц памяти, видимой в данный момент к процессу в физической памяти ОЗУ. Эти страницы являются резидентными и доступны для приложения для использования без создания ошибки страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая модули процессов и системных библиотек.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of physical memory, in bytes, used by the associated process.</summary>
        <value>Максимальный объем физической памяти в байтах, выделенной для связанного процесса с момента его запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством представляет максимальный размер памяти рабочего множества, используемой процессом с момента его запуска, в байтах. Рабочий набор процесса — это набор страниц памяти, видимой в данный момент к процессу в физической памяти ОЗУ. Эти страницы являются резидентными и доступны для приложения для использования без создания ошибки страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая инструкции из модулей процесса и системных библиотек.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **рабочий набор пик** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</summary>
        <value>Значение <see langword="true" />, если требуется динамическое увеличение приоритета процесса, когда процесс выходит из состояния ожидания; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если поток выполняется в процессе, для которого класс приоритета имеет одно из значений перечисления динамического приоритета (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, или <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), система временно увеличивает приоритет потока, когда он извлекается из состояния ожидания. Это действие предотвращает прерывание обработки текущего потока другими процессами. <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Влияет на все существующие потоки и все потоки, созданные в процессе впоследствии. Чтобы восстановить нормальное поведение, задайте <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> свойства `false`.  
  
> [!NOTE]
>  Бустинг слишком высокого приоритета может привести к утечке ресурсов операционную систему и сетевые функции, вызывающих проблемы с другими задачами операционной системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Priority boost information could not be retrieved from the associated process resource.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the overall priority category for the associated process.</summary>
        <value>Категория приоритета для связанного процесса, из которой вычисляется свойство <see cref="P:System.Diagnostics.Process.BasePriority" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс приоритета процесса включает диапазон уровней приоритета потоков. Потоки с различными приоритетами, которые выполняются в процессе выполнения по отношению к классу приоритета процесса. Win32 использует четыре класса приоритета 7 уровней базовый приоритет каждого класса. Эти классы приоритета процесса, будут записываться в <xref:System.Diagnostics.ProcessPriorityClass> перечисления, который позволяет присвоить приоритет процесса <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, или <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. На основе времени, затраченного или других показателях, базовый уровень приоритета может быть изменен в операционной системе, когда процесс необходимо поставить перед другим пользователям для доступа к процессору. Кроме того, можно задать <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> временно повысить уровень приоритета потоков, которые были взяты из состояния ожидания. Приоритет сбрасывается при возвращении процесса в состояние ожидания.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> Свойство позволяет просмотреть начальный приоритет, назначенный к процессу. Тем не менее, так как документ доступен только для чтения, нельзя использовать <xref:System.Diagnostics.Process.BasePriority%2A> свойство для задания приоритета процесса. Чтобы изменить приоритет, используйте <xref:System.Diagnostics.Process.PriorityClass%2A> свойство, которое получает или задает общую категорию приоритета для процесса.  
  
 Класс приоритета нельзя просмотреть с помощью системного монитора. В следующей таблице показаны связи между <xref:System.Diagnostics.Process.BasePriority%2A> и <xref:System.Diagnostics.Process.PriorityClass%2A> значения.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Process priority information could not be set or retrieved from the associated process resource.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityClass" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <exception cref="T:System.PlatformNotSupportedException">You have set the <see cref="P:System.Diagnostics.Process.PriorityClass" /> to <see langword="AboveNormal" /> or <see langword="BelowNormal" /> when using Windows 98 or Windows Millennium Edition (Windows Me). These platforms do not support those values for the priority class.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Priority class cannot be set because it does not use a valid value, as defined in the <see cref="T:System.Diagnostics.ProcessPriorityClass" /> enumeration.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of private memory, in bytes, allocated for the associated process.</summary>
        <value>Число байтов, выделенных связанным процессом, которые не могут быть доступны другим процессам.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of private memory, in bytes, allocated for the associated process.</summary>
        <value>Объем памяти в байтах, выделенное для связанного процесса, которое не может быть доступно другим процессам.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством представляет текущий объем памяти, используемой процессом, в байтах, которые нельзя использовать совместно с другими процессами.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **байт исключительного пользования** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the privileged processor time for this process.</summary>
        <value>Класс <see cref="T:System.TimeSpan" />, показывающий количество времени, которое процесс потратил на выполнение кода внутри ядра операционной системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the process.</summary>
        <value>Имя, которое использует система для идентификации процесса для пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A> Свойство содержит имя исполняемого файла, например Outlook, который не поддерживает расширения .exe или путь. Это полезно для получения и обработки всех процессов, которые связаны с тот же исполняемый файл.  
  
> [!NOTE]
>  На [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] операционных систем, <xref:System.Diagnostics.Process.ProcessName%2A> свойство может быть усечена до 15 символов, если не удается получить сведения о процессе модуля.  
  
 Можно вызвать <xref:System.Diagnostics.Process.GetProcessesByName%2A>, передавая ему имя исполняемого файла, чтобы получить массив, содержащий каждого запущенного экземпляра на указанном компьютере. Этот массив, например, можно использовать для завершения работы всех выполняющихся экземпляров исполняемого файла.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have an identifier, or no process is associated with the <see cref="T:System.Diagnostics.Process" />.  -or-  The associated process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">The process is not on this computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the processors on which the threads in this process can be scheduled to run.</summary>
        <value>Битовая маска, представляющая процессоры, на которых могут выполняться потоки связанного процесса. По умолчанию маска зависит от числа процессоров в компьютере. Значение по умолчанию — 2 <sup>n</sup> -1, где n — число процессоров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В Windows 2000 и более поздних версиях поток в процессе можно перенести из процессора на процессор, с помощью каждую операцию миграции обновление кэша процессора. При больших системных нагрузках указав какой процессор должен выполняться в определенном потоке может повысить производительность за счет сокращения числа перезагрузок кэша процессора. Связь между процессор и поток называется соответствием процессоров.  
  
 Каждый процессор представляется как битовое. Бит 0 — это первый процессор, 1-й бит — второй процессор и т. д. Если задать бита значение 1, соответствующий процессор будет выбрана для назначения потоков. При задании <xref:System.Diagnostics.Process.ProcessorAffinity%2A> значение, равное нулю, операционной системы планирование алгоритмов набора сходство потоков. Когда <xref:System.Diagnostics.Process.ProcessorAffinity%2A> значение задано любое ненулевое значение, значение интерпретируется как битовую маску, определяющую процессоры, годные для выбора.  
  
 В следующей таблице показаны подборку <xref:System.Diagnostics.Process.ProcessorAffinity%2A> значения для восьмипроцессорной системы.  
  
|Битовая маска|Двоичное значение|Подходящие процессоры|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 и 2|  
|0x0007|00000000 00000111|1, 2 и 3|  
|0x0009|00000000 00001001|1 и 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 и 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> information could not be set or retrieved from the associated process resource.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> was not available.  -or-  The process has exited.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Discards any information about the associated process that has been cached inside the process component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После <xref:System.Diagnostics.Process.Refresh%2A> вызывается, первый запрос для сведения о каждом свойстве компонент процесса получает новое значение из связанного процесса.  
  
 Когда <xref:System.Diagnostics.Process> компонент связан с ресурсом процесса, значения свойств <xref:System.Diagnostics.Process> немедленно заполняются в соответствии с состояние связанного процесса. Если сведения о связанном процессе впоследствии изменяется, эти изменения не отражаются в <xref:System.Diagnostics.Process> компонента кэшированных значений. <xref:System.Diagnostics.Process> Компонент является моментальным снимком ресурса процесса на момент они связаны. Чтобы просмотреть текущие значения для связанного процесса, вызовите <xref:System.Diagnostics.Process.Refresh%2A> метод.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем он получает использование физической памяти связанного процесса с 2-секундным интервалом не более 10 секунд. В данном примере отслеживается ли процесс завершается до истечения 10 секунд. Пример закрывает процесс, если оно по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the user interface of the process is responding.</summary>
        <value>Значение <see langword="true" />, если пользовательский интерфейс связанного процесса отвечает системе; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если процесс имеет пользовательский интерфейс, <xref:System.Diagnostics.Process.Responding%2A> связывается пользовательский интерфейс, чтобы определить, отвечает ли процесс на ввод данных пользователем. Если интерфейс не отвечает немедленно, <xref:System.Diagnostics.Process.Responding%2A> возвращает `false`. Используйте это свойство, чтобы определить, является ли интерфейс связанного процесса перестал отвечать.  
  
 Если процесс не имеет <xref:System.Diagnostics.Process.MainWindowHandle%2A>, это свойство возвращает `true`.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.Responding" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle to this process.</summary>
        <value>Собственный дескриптор процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дескриптор доступен только в том случае, если вызывающий компонент запущен процесс.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Terminal Services session identifier for the associated process.</summary>
        <value>Идентификатор сеанса служба терминалов для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A> Свойство идентифицирует сеанс, в котором выполняется приложение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">There is no session associated with this process.</exception>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this session identifier.  -or-  The associated process is not on this machine.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The <see cref="P:System.Diagnostics.Process.SessionId" /> property is not supported on Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to read the error output of the application.</summary>
        <value>Объект <see cref="T:System.IO.StreamReader" />, используемый для чтения стандартного потока ошибок приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.Process> записывает текст в его стандартный поток ошибок, что текст обычно отображается в консоли. Перенаправляя <xref:System.Diagnostics.Process.StandardError%2A> потока, можно подавить вывод ошибок, процесса или управления ею. Например можно фильтровать текст, отформатируйте его по-разному или записывать выходные данные консоли и назначенный файл журнала.  
  
> [!NOTE]
>  Чтобы использовать <xref:System.Diagnostics.Process.StandardError%2A>, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> для `false`, и необходимо указать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> для `true`. В противном случае считывание <xref:System.Diagnostics.Process.StandardError%2A> поток вызывает исключение.  
  
 Перенаправленного <xref:System.Diagnostics.Process.StandardError%2A> возможность чтения потока, синхронно или асинхронно. Методы, такие как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> выполнять синхронные операции чтения в потоке вывода ошибок процесса. Эти синхронные чтение операции не завершаются до связанного <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardError%2A> потоковой передачи или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A> потока. Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращает вызывающему объекту, который может выполнять другую работу, пока выходной поток направляется обработчику событий.  
  
 Синхронное чтение операций вводит зависимость между считыванием из вызывающего <xref:System.Diagnostics.Process.StandardError%2A> потока и дочерний процесс записи в поток. Эти зависимости можно привести в состоянии взаимоблокировки. Когда вызывающий объект считывает из перенаправленного потока дочернего процесса, он зависит от дочернего. Вызывающий объект ожидает операции считывания дочерние записывает в поток или закрывает поток. Когда дочерний процесс записывает достаточно данных для заполнения своего перенаправленного потока, он зависит от родительского. Дочерний процесс ожидает следующей операции записи до родительского считывает из полного потока или закрывает поток. Взаимоблокировка возникает, когда вызывающий объект и дочерний процесс ждут друг от друга, для завершения операции и не может продолжить работу. Взаимоблокировок можно избежать, оценивая зависимости между вызывающим и дочерний процесс.  
  
 Следующий код C#, например, показано, как считывание из перенаправленного потока и ожидание завершения дочернего процесса.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 В примере кода позволяет избежать взаимоблокировки, вызвав `p.StandardError.ReadToEnd` перед `p.WaitForExit`. Если родительский обработки вызовов может привести к взаимоблокировки `p.WaitForExit` перед `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса. Дочерний процесс будет ожидать неопределенно долго родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Есть аналогичная проблема возникает при считывании весь текст из стандартного вывода и потоков стандартной ошибки. Например, следующий код C#, выполняет операции чтения в обоих потоках.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 В примере кода позволяет избежать взаимоблокировки, выполняя асинхронные операции чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Взаимоблокировка возникает, если родительский обрабатывать вызовы `p.StandardOutput.ReadToEnd` следуют `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения его поток сообщений об ошибках. Родительский процесс будет ожидать неопределенно долго дочерний процесс закрыть его <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Дочерний процесс будет ожидать неопределенно долго родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Чтобы избежать этих зависимостей и возможных взаимоблокировок можно использовать асинхронных операций чтения. Кроме того можно избежать этого состояния взаимоблокировки путем создания двух потоков и чтении выходных данных каждого потока в отдельном потоке.  
  
> [!NOTE]
>  Нельзя смешивать асинхронные и синхронные операции чтения в перенаправленном потоке. Один раз перенаправленного потока <xref:System.Diagnostics.Process> открыт в режиме асинхронной или синхронной, все дополнительные чтения операции в этом потоке должен быть в одном режиме. Например, не выполняйте <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> вызовом <xref:System.IO.StreamReader.ReadLine%2A> на <xref:System.Diagnostics.Process.StandardError%2A> потока, или наоборот. Тем не менее вы найдете в двух разных потоках в разных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , а затем вызвать <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
   
  
## Examples  
 В следующем примере используется `net use` команду с пользователя указан аргумент для сопоставления сетевому ресурсу. Затем считывается в стандартный поток ошибок сетевой команды и записывается в консоль.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to write the input of the application.</summary>
        <value>Объект <see cref="T:System.IO.StreamWriter" />, используемый для записи стандартного входного потока приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Diagnostics.Process> может считывать входной текст из его стандартного входного потока, обычно клавиатуры. Перенаправляя <xref:System.Diagnostics.Process.StandardInput%2A> потока, можно программно задать входные данные. Например вместо ввода с клавиатуры, можно предоставить текст из содержимого указанного файла или выходные данные из другого приложения.  
  
> [!NOTE]
>  Чтобы использовать <xref:System.Diagnostics.Process.StandardInput%2A>, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> для `false`, и необходимо указать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> для `true`. В противном случае запись <xref:System.Diagnostics.Process.StandardInput%2A> поток вызывает исключение.  
  
   
  
## Examples  
 Следующий пример иллюстрирует способ перенаправления <xref:System.Diagnostics.Process.StandardInput%2A> потока процесса. В примере запускается `sort` с перенаправленным вводом. Затем он запрашивает у пользователя текст и передает его `sort` процесса с помощью перенаправленного <xref:System.Diagnostics.Process.StandardInput%2A> потока. `sort` Результаты отображаются пользователю на консоль.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardInput" /> stream has not been defined because <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> is set to <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to read the textual output of the application.</summary>
        <value>Объект <see cref="T:System.IO.StreamReader" />, используемый для чтения стандартного потока вывода приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.Process> записывает текст в свой стандартный поток, что текст обычно отображается в консоли. Перенаправляя <xref:System.Diagnostics.Process.StandardOutput%2A> stream, вы можете управлять или подавлять вывод процесса. Например можно фильтровать текст, отформатируйте его по-разному или записывать выходные данные консоли и назначенный файл журнала.  
  
> [!NOTE]
>  Чтобы использовать <xref:System.Diagnostics.Process.StandardOutput%2A>, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> для `false`, и необходимо указать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> для `true`. В противном случае считывание <xref:System.Diagnostics.Process.StandardOutput%2A> поток вызывает исключение.  
  
 Перенаправленного <xref:System.Diagnostics.Process.StandardOutput%2A> возможность чтения потока, синхронно или асинхронно. Методы, такие как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> выполнять синхронные операции чтения в выходной поток процесса. Эти синхронные чтение операции не завершаются до связанного <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardOutput%2A> потоковой передачи или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращает вызывающему объекту, который может выполнять другую работу, пока выходной поток направляется обработчику событий.  
  
 Синхронное чтение операций вводит зависимость между считыванием из вызывающего <xref:System.Diagnostics.Process.StandardOutput%2A> потока и дочерний процесс записи в поток. Эти зависимости можно привести в состоянии взаимоблокировки. Когда вызывающий объект считывает из перенаправленного потока дочернего процесса, он зависит от дочернего. Вызывающий объект ожидает операции считывания дочерние записывает в поток или закрывает поток. Когда дочерний процесс записывает достаточно данных для заполнения своего перенаправленного потока, он зависит от родительского. Дочерний процесс ожидает следующей операции записи до родительского считывает из полного потока или закрывает поток. Взаимоблокировка возникает, когда вызывающий объект и дочерний процесс ждут друг от друга, для завершения операции и не может продолжить работу. Взаимоблокировок можно избежать, оценивая зависимости между вызывающим и дочерний процесс.  
  
 Следующий код C#, например, показано, как считывание из перенаправленного потока и ожидание завершения дочернего процесса.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 В примере кода позволяет избежать взаимоблокировки, вызвав `p.StandardOutput.ReadToEnd` перед `p.WaitForExit`. Если родительский обработки вызовов может привести к взаимоблокировки `p.WaitForExit` перед `p.StandardOutput.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса. Дочерний процесс будет ожидать неопределенно долго родительским для чтения из полной <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
 Есть аналогичная проблема возникает при считывании весь текст из стандартного вывода и потоков стандартной ошибки. Например, следующий код C#, выполняет операции чтения в обоих потоках.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 В примере кода позволяет избежать взаимоблокировки, выполняя асинхронные операции чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Взаимоблокировка возникает, если родительский обрабатывать вызовы `p.StandardOutput.ReadToEnd` следуют `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения его поток сообщений об ошибках. Родительский процесс будет ожидать неопределенно долго дочерний процесс закрыть его <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Дочерний процесс будет ожидать неопределенно долго родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Чтобы избежать этих зависимостей и возможных взаимоблокировок можно использовать асинхронных операций чтения. Кроме того можно избежать этого состояния взаимоблокировки путем создания двух потоков и чтении выходных данных каждого потока в отдельном потоке.  
  
> [!NOTE]
>  Нельзя смешивать асинхронные и синхронные операции чтения в перенаправленном потоке. Один раз перенаправленного потока <xref:System.Diagnostics.Process> открыт в режиме асинхронной или синхронной, все дополнительные чтения операции в этом потоке должен быть в одном режиме. Например, не выполняйте <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> вызовом <xref:System.IO.StreamReader.ReadLine%2A> на <xref:System.Diagnostics.Process.StandardOutput%2A> потока, или наоборот. Тем не менее вы найдете в двух разных потоках в разных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , а затем вызвать <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
   
  
## Examples  
 В следующем примере выполняется команда ipconfig.exe и перенаправляет его стандартные выходные данные в окно консоли для данного примера.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Starts a process resource and associates it with a <see cref="T:System.Diagnostics.Process" /> component.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts (or reuses) the process resource that is specified by the <see cref="P:System.Diagnostics.Process.StartInfo" /> property of this <see cref="T:System.Diagnostics.Process" /> component and associates it with the component.</summary>
        <returns>
          <see langword="true" /> if a process resource is started; <see langword="false" /> if no new process resource is started (for example, if an existing process is reused).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для запуска ресурса процесса и связывания его с текущим <xref:System.Diagnostics.Process> компонента. Возвращаемое значение `true` указывает, что новый ресурс процесса запущен. Если ресурс процесса, указанный свойством <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> членом <xref:System.Diagnostics.Process.StartInfo%2A> свойство уже выполняется на компьютере, ресурса не дополнительный процесс был запущен. Вместо этого выполняющийся процесс ресурсов используется повторно и `false` возвращается.  
  
 Можно запустить приложение ClickOnce, указав расположение (например, веб-адрес), из которого изначально устанавливалось приложение. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
> [!NOTE]
>  Если вы используете Visual Studio, эта перегрузка <xref:System.Diagnostics.Process.Start%2A> метод является тот, который можно вставить в код после перетаскивания <xref:System.Diagnostics.Process> компонента в конструктор. Используйте `Properties` окна, чтобы развернуть `StartInfo` категории и записи соответствующего значения в `FileName` свойство. Внесенные изменения будут отображены в форме `InitializeComponent` процедуры.  
  
 Эта перегрузка <xref:System.Diagnostics.Process.Start%2A> не `static` метод. Необходимо вызвать его из экземпляра <xref:System.Diagnostics.Process> класса. Перед вызовом <xref:System.Diagnostics.Process.Start%2A>, прежде всего необходимо указать <xref:System.Diagnostics.Process.StartInfo%2A> сведения о свойстве для данного <xref:System.Diagnostics.Process> экземпляра, так как эта информация используется для определения ресурса процесса для запуска.  
  
 Другие перегрузки <xref:System.Diagnostics.Process.Start%2A> метод `static` членов. Необходимо создать экземпляр <xref:System.Diagnostics.Process> компонента перед вызовом этих перегрузок метода. Вместо этого можно вызвать <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> класса б, а новый <xref:System.Diagnostics.Process> компонент создается в том случае, если процесс был запущен. Или, `null` возвращается, если процесс был использован заново. Ресурс процесса автоматически связывается с новым <xref:System.Diagnostics.Process> компонент, который возвращается методом <xref:System.Diagnostics.Process.Start%2A> метод.  
  
 <xref:System.Diagnostics.Process.StartInfo%2A> Члены могут использоваться для дублируют функциональность `Run` диалоговое окно Windows `Start` меню. Все, что можно ввести в командной строке можно запустить, задав соответствующие значения <xref:System.Diagnostics.Process.StartInfo%2A> свойство. Единственным <xref:System.Diagnostics.Process.StartInfo%2A> является свойством, которое необходимо задать <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойства. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Свойство не нужно быть исполняемым файлом. Он может быть любой тип файла, для которого была связана с приложением, установленные в системе расширения. Например <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или он может иметь расширение .doc, при наличии файлов с помощью средства обработки текста, таких как Microsoft Word.  
  
 В командной строке можно указать действия для обработки определенных типов файлов. Например можно распечатать документы или редактирования текстовых файлов. Укажите эти действия с помощью <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> членом <xref:System.Diagnostics.Process.StartInfo%2A> свойство. Для других типов файлов, можно указать аргументы командной строки при запуске файла из `Run` диалоговое окно. Например, можно передать URL-адрес в качестве аргумента, если задать обозреватель в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Эти аргументы могут быть заданы в <xref:System.Diagnostics.Process.StartInfo%2A> свойства <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> член.  
  
 Если у вас есть путь к переменной, объявленной в вашей системе, с помощью кавычки, необходимо полностью указать этот путь при запуске любого процесса, в этом расположении. В противном случае система не найдет путь. Например если `c:\mypath` не находится в системном пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо полностью указать любой процесс в `c:\mypath` при запуске.  
  
> [!NOTE]
>  Код элемента управления страницы и сервера веб-ASP.NET выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  Если вы используете <xref:System.Diagnostics.Process.Start%2A> выполнения нового процесса метода в веб-страницы ASP.NET или серверный элемент управления, на веб-сервере с ограниченными разрешениями. Процесс не запускается в контексте клиентского браузера и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его, или существует риск потери системных ресурсов. Закрыть процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A> свойство.  
  
 Примечание о состояния подразделения в управляемых потоках здесь не требуется. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` на компонент обработки <xref:System.Diagnostics.Process.StartInfo%2A> свойство, убедитесь, что установки потоковой модели приложения, задав атрибуту `[STAThread]` на `main()` метод. В противном случае может быть управляемый поток в `unknown` состояние или поместить в `MTA` state, последний который конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> , `true`. Некоторые методы требуют состояние подразделения не `unknown`. Если состояние не задано явно, когда приложение обнаруживает такой метод, по умолчанию `MTA`, а затем состояние подразделения не может быть изменено. Тем не менее `MTA` приводит к возникновению исключения, исключение, когда оболочке операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере используется экземпляр <xref:System.Diagnostics.Process> класса для запуска процесса.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified in the <see cref="T:System.Diagnostics.Process" /> component's <see cref="P:System.Diagnostics.Process.StartInfo" />.
-or- The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property is <see langword="true" /> while <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that contains the information that is used to start the process, including the file name and any command-line arguments.</param>
        <summary>Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, чтобы запустить ресурс процесса путем указания <xref:System.Diagnostics.ProcessStartInfo> экземпляра. Перегрузка связывает ресурс с новым <xref:System.Diagnostics.Process> объекта.  
  
> [!NOTE]
>  Если URL-адрес назначен адрес для запуска исполняемого файла, процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Использование этой перегрузки с <xref:System.Diagnostics.ProcessStartInfo> параметр можно использовать вместо явного действия по созданию нового <xref:System.Diagnostics.Process> экземпляра, установка его <xref:System.Diagnostics.Process.StartInfo%2A> свойств и вызова <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 С помощью <xref:System.Diagnostics.ProcessStartInfo> экземпляра как параметр дает возможность вызывать <xref:System.Diagnostics.Process.Start%2A> с полностью управлять содержимым, передаваемым в вызов для запуска процесса. Если вам нужно передать только имя файла или имя файла с аргументами, нет необходимости создавать новый <xref:System.Diagnostics.ProcessStartInfo> экземпляра, несмотря на то, что это возможно. Единственным <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> является свойством, которое необходимо задать <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойства. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Свойство не нужно предоставлять исполняемый файл. Он может быть любой тип файла, для которого была связана с приложением, установленные в системе расширения. Например <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или он может иметь расширение .doc, при наличии файлов с помощью средства обработки текста, таких как Microsoft Word.  
  
 Можно запустить приложение ClickOnce, указав расположение (например, веб-адрес), из которого изначально устанавливалось приложение. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
 Если <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> и <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> свойства <xref:System.Diagnostics.Process.StartInfo%2A> экземпляр заданы, неуправляемой `CreateProcessWithLogonW` вызывается функция, которая запускает процесс в новый даже если окно <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> свойство имеет значение `true` или <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> свойство имеет значение <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Если <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> свойство `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> свойство должно быть в формате имени участника-пользователя, *пользователя*@*DNS_domain_name*.   
  
 В отличие от других перегрузок, перегрузка <xref:System.Diagnostics.Process.Start%2A> , не имеющего параметров не `static` член. Использовать полученный перегружать, если вы уже создали <xref:System.Diagnostics.Process> экземпляра указанной начальной сведения (включая имя файла) и нужно запустить ресурс процесса и связать его с существующим <xref:System.Diagnostics.Process> экземпляра. Используйте один из `static` перегрузок, если вы хотите создать новый <xref:System.Diagnostics.Process> компонента, а не запустить процесс для существующего компонента. Эта перегрузка и перегрузку, которая не имеет параметров позволяют пользователю указать сведения о запуске для ресурса процесса с помощью <xref:System.Diagnostics.ProcessStartInfo> экземпляра.  
  
 Если у вас есть путь к переменной, объявленной в вашей системе, с помощью кавычки, необходимо полностью указать этот путь при запуске любого процесса, в этом расположении. В противном случае система не найдет путь. Например если `c:\mypath` не находится в системном пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо полностью указать любой процесс в `c:\mypath` при запуске.  
  
> [!NOTE]
>  Код элемента управления страницы и сервера веб-ASP.NET выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  Если вы используете <xref:System.Diagnostics.Process.Start%2A> выполнения нового процесса метода в веб-страницы ASP.NET или серверный элемент управления, на веб-сервере с ограниченными разрешениями. Процесс не запускается в контексте клиентского браузера и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его, или существует риск потери системных ресурсов. Закрыть процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A> свойство.  
  
 Примечание о состояния подразделения в управляемых потоках здесь не требуется. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` на `startInfo` параметр, убедитесь, что установки потоковой модели приложения, задав атрибуту `[STAThread]` на `main()` метод. В противном случае может быть управляемый поток в `unknown` состояние или поместить в `MTA` state, последний который конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> , `true`. Некоторые методы требуют состояние подразделения не `unknown`. Если состояние не задано явно, когда приложение обнаруживает такой метод, по умолчанию `MTA`, а затем состояние подразделения не может быть изменено. Тем не менее `MTA` приводит к возникновению исключения, исключение, когда оболочке операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере сначала создается экземпляр Internet Explorer и отображает содержимое папки "Избранное" в браузере. Затем запускаются несколько других экземпляров Internet Explorer и отображает несколько определенных страниц или сайтов. И наконец Internet Explorer запускается с окном, минимизируется при переходе на указанном сайте.  
  
 Дополнительные примеры других применений этого метода см. отдельные свойства <xref:System.Diagnostics.ProcessStartInfo> класса.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property.  -or-  The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is also <see langword="true" />.  -or-  The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> property is not <see langword="null" /> or empty or the <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> property is not <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="startInfo" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property could not be found.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the process exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of a document or application file to run in the process.</param>
        <summary>Starts a process resource by specifying the name of a document or application file and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, чтобы запустить ресурс процесса путем указания имени файла. Перегрузка связывает ресурс с новым <xref:System.Diagnostics.Process> объекта.  
  
> [!NOTE]
>  Если URL-адрес назначен адрес для запуска исполняемого файла, процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явного действия по созданию нового <xref:System.Diagnostics.Process> экземпляра, установка <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> членом <xref:System.Diagnostics.Process.StartInfo%2A> и вызова <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 Можно запустить приложение ClickOnce, задав `fileName` параметр в папку (например, веб-адрес), из которого изначально установлены приложения. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
 Запуск процесса путем указания имени файла похож на запуск с `Run` диалоговое окно Windows `Start` меню. Таким образом имя файла не нужно предоставлять исполняемый файл. Он может быть любой тип файла, для которого модуль был связан с приложением, установленные в системе. Например имя файла может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или он может иметь расширение .doc, при наличии файлов с помощью средства обработки текста, таких как Microsoft Word. Аналогичным образом, в том же образом, как `Run` диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширение .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот».  
  
 Эта перегрузка не поддерживает аргументы командной строки для процесса. Если необходимо указать один или несколько аргументов командной строки для процесса, используйте <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> или <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> перегрузки.  
  
 В отличие от других перегрузок, перегрузка <xref:System.Diagnostics.Process.Start%2A> , не имеющего параметров не `static` член. Использовать полученный перегружать, если вы уже создали <xref:System.Diagnostics.Process> экземпляра указанной начальной сведения (включая имя файла) и нужно запустить ресурс процесса и связать его с существующим <xref:System.Diagnostics.Process> экземпляра. Используйте один из `static` перегрузок, если вы хотите создать новый <xref:System.Diagnostics.Process> компонента, а не запустить процесс для существующего компонента. Эта перегрузка и перегрузку, которая не имеет параметров позволяют пользователю указать имя файла ресурса процесса для запуска.  
  
 Если у вас есть путь к переменной, объявленной в вашей системе, с помощью кавычки, необходимо полностью указать этот путь при запуске любого процесса, в этом расположении. В противном случае система не найдет путь. Например если `c:\mypath` не находится в системном пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо полностью указать любой процесс в `c:\mypath` при запуске.  
  
> [!NOTE]
>  Код элемента управления страницы и сервера веб-ASP.NET выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  Если вы используете <xref:System.Diagnostics.Process.Start%2A> выполнения нового процесса метода в веб-страницы ASP.NET или серверный элемент управления, на веб-сервере с ограниченными разрешениями. Процесс не запускается в контексте клиентского браузера и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его, или существует риск потери системных ресурсов. Закрыть процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A> свойство.  
  
 Примечание о состояния подразделения в управляемых потоках здесь не требуется. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` на компонент обработки <xref:System.Diagnostics.Process.StartInfo%2A> свойство, убедитесь, что установки потоковой модели приложения, задав атрибуту `[STAThread]` на `main()` метод. В противном случае может быть управляемый поток в `unknown` состояние или поместить в `MTA` state, последний который конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> , `true`. Некоторые методы требуют состояние подразделения не `unknown`. Если состояние не задано явно, когда приложение обнаруживает такой метод, по умолчанию `MTA`, а затем состояние подразделения не может быть изменено. Тем не менее `MTA` приводит к возникновению исключения, исключение, когда оболочке операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере сначала создается экземпляр Internet Explorer и отображает содержимое папки "Избранное" в браузере. Затем запускаются несколько других экземпляров Internet Explorer и отображает несколько определенных страниц или сайтов. И наконец Internet Explorer запускается с окном, минимизируется при переходе на указанном сайте.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The PATH environment variable has a string containing quotes.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="arguments">Command-line arguments to pass when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, чтобы запустить ресурс процесса путем указания имени файла и аргументы командной строки. Перегрузка связывает ресурс с новым <xref:System.Diagnostics.Process> объекта.  
  
> [!NOTE]
>  Если URL-адрес назначен адрес для запуска исполняемого файла, процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явного действия по созданию нового <xref:System.Diagnostics.Process> экземпляра, установка <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> и <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> членами <xref:System.Diagnostics.Process.StartInfo%2A> и вызова <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 Запуск процесса путем указания имени файла и аргументы похож на ввод имени файла и аргументы командной строки в `Run` диалоговое окно Windows `Start` меню. Таким образом имя файла не нужно предоставлять исполняемый файл. Он может быть любой тип файла, для которого модуль был связан с приложением, установленные в системе. Например имя файла может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или он может иметь расширение .doc, при наличии файлов с помощью средства обработки текста, таких как Microsoft Word. Аналогичным образом, в том же образом, как `Run` диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширение .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот». Если `fileName` параметр представляет собой исполняемый файл, `arguments` параметр может представлять действия, такие как текстовый файл в файл `Notepad.exe myfile.txt`. Если `fileName` параметр представляет командный (cmd) файл, `arguments` необходимо включить параметр "`/c`«или»`/k`" аргумент, чтобы указать ли командное окно завершает работу или остается после завершения.  
  
 В отличие от других перегрузок, перегрузка <xref:System.Diagnostics.Process.Start%2A> , не имеющего параметров не `static` член. Использовать полученный перегружать, если вы уже создали <xref:System.Diagnostics.Process> экземпляра указанной начальной сведения (включая имя файла) и нужно запустить ресурс процесса и связать его с существующим <xref:System.Diagnostics.Process> экземпляра. Используйте один из `static` перегрузок, если вы хотите создать новый <xref:System.Diagnostics.Process> компонента, а не запустить процесс для существующего компонента. Эта перегрузка и перегрузку, которая не имеет параметров позволяют пользователю указать имя файла ресурса процесса для запуска и аргументы командной строки для передачи.  
  
 Если у вас есть путь к переменной, объявленной в вашей системе, с помощью кавычки, необходимо полностью указать этот путь при запуске любого процесса, в этом расположении. В противном случае система не найдет путь. Например если `c:\mypath` не находится в системном пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо полностью указать любой процесс в `c:\mypath` при запуске.  
  
> [!NOTE]
>  Код элемента управления страницы и сервера веб-ASP.NET выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  Если вы используете <xref:System.Diagnostics.Process.Start%2A> выполнения нового процесса метода в веб-страницы ASP.NET или серверный элемент управления, на веб-сервере с ограниченными разрешениями. Процесс не запускается в контексте клиентского браузера и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его, или существует риск потери системных ресурсов. Закрыть процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A> свойство...  
  
 Примечание о состояния подразделения в управляемых потоках здесь не требуется. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` на компонент обработки <xref:System.Diagnostics.Process.StartInfo%2A> свойство, убедитесь, что установки потоковой модели приложения, задав атрибуту `[STAThread]` на `main()` метод. В противном случае может быть управляемый поток в `unknown` состояние или поместить в `MTA` state, последний который конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> , `true`. Некоторые методы требуют состояние подразделения не `unknown`. Если состояние не задано явно, когда приложение обнаруживает такой метод, по умолчанию `MTA`, а затем состояние подразделения не может быть изменено. Тем не менее `MTA` приводит к возникновению исключения, исключение, когда оболочке операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере сначала создается экземпляр Internet Explorer и отображает содержимое папки "Избранное" в браузере. Затем запускаются несколько других экземпляров Internet Explorer и отображает несколько определенных страниц или сайтов. И наконец Internet Explorer запускается с окном, минимизируется при переходе на указанном сайте.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <paramref name="fileName" /> or <paramref name="arguments" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the process exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The PATH environment variable has a string containing quotes.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="userName">The user name to use when starting the process.</param>
        <param name="password">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</param>
        <param name="domain">The domain to use when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для создания нового процесса и основной поток, указав его имя файла, имя пользователя, пароль и домен. Указанный исполняемый файл запустит новый процесс в контексте безопасности указанные учетные данные (пользователя, домен и пароль).  
  
> [!NOTE]
>  Если исполняемый файл, находится на удаленном диске, необходимо определить общий сетевой ресурс, используя универсальный код ресурса (URI), не связанный с буквой диска.  
  
> [!NOTE]
>  Если URL-адрес назначен адрес для запуска исполняемого файла, процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явного действия по созданию нового <xref:System.Diagnostics.Process> экземпляра, установка <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, и <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> свойства <xref:System.Diagnostics.Process.StartInfo%2A> и вызова <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 Аналогичным образом, в том же образом, как **запуска** диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширение .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот». Если `fileName` параметр представляет собой исполняемый файл, `arguments` параметр может представлять действия, такие как текстовый файл в файл `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Имя файла должно предоставлять исполняемый файл в <xref:System.Diagnostics.Process.Start%2A> перегрузок, имеющих `userName`, `password`, и `domain` параметров.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его, или существует риск потери системных ресурсов. Закрыть процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A> свойство...  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать эту перегрузку, чтобы запустить исполняемый файл, а также демонстрируется возникновение <xref:System.ComponentModel.Win32Exception> при попытке запуска приложения, связанного с файлом неисполняемые.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on Linux or macOS (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="arguments">Command-line arguments to pass when starting the process.</param>
        <param name="userName">The user name to use when starting the process.</param>
        <param name="password">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</param>
        <param name="domain">The domain to use when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application, a set of command-line arguments, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для создания нового процесса и основной поток, указав имя файла, аргументы командной строки, имя пользователя, пароль и домен. Указанный исполняемый файл запустит новый процесс в контексте безопасности указанные учетные данные (пользователя, домен и пароль).  
  
> [!NOTE]
>  Если исполняемый файл, находится на удаленном диске, необходимо определить общий сетевой ресурс, используя универсальный код ресурса (URI), не связанный с буквой диска.  
  
> [!NOTE]
>  Если URL-адрес назначен адрес для запуска исполняемого файла, процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явного действия по созданию нового <xref:System.Diagnostics.Process> экземпляра, установка <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, и <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> свойства <xref:System.Diagnostics.Process.StartInfo%2A> и вызова <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 Аналогичным образом, в том же образом, как **запуска** диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширение .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот». Если `fileName` параметр представляет собой исполняемый файл, `arguments` параметр может представлять действия, такие как текстовый файл в файл `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Имя файла должно предоставлять исполняемый файл в <xref:System.Diagnostics.Process.Start%2A> перегрузок, имеющих `userName`, `password`, и `domain` параметров.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его, или существует риск потери системных ресурсов. Закрыть процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A> свойство...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the associated file exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on Linux or macOS (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the properties to pass to the <see cref="M:System.Diagnostics.Process.Start" /> method of the <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>Класс <see cref="T:System.Diagnostics.ProcessStartInfo" />, который представляет данные для запуска процесса. Эти аргументы включают имя исполняемого файла или документа, использованного для запуска процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> Представляет набор параметров, используемые для запуска процесса. Когда <xref:System.Diagnostics.Process.Start%2A> вызове <xref:System.Diagnostics.Process.StartInfo%2A> используется для указания процесса для запуска. Только необходимые <xref:System.Diagnostics.Process.StartInfo%2A> — члена <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство. Запуск процесса путем указания <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство похоже на запуск в **запуска** диалоговое окно Windows **запустить** меню. Таким образом <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство не нужно предоставлять исполняемый файл. Он может быть любой тип файла, для которого модуль был связан с приложением, установленные в системе. Например <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или он может иметь расширение .doc, при наличии файлов с помощью средства обработки текста, таких как Microsoft Word. Аналогичным образом, в том же образом, как **запуска** диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширение .exe является необязательным в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> член. Например, можно задать <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство «Notepad.exe» или «Блокнот».  
  
 Можно запустить приложение ClickOnce, задав <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство в папку (например, веб-адрес), из которого изначально установлены приложения. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
 Если имя файла включает в себя неисполняемые файла, например DOC-файл, можно включить команду, задающую какое действие следует предпринять для файла. Например, можно задать <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> «Print» для файла, расширение .doc. Имя файла, указанное в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство не указано расширение, если вы вручную вводите значение для <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> свойство. Тем не менее если вы используете <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> свойство, чтобы определить, какие команды доступны, необходимо включить расширение.  
  
 Можно изменить параметры, заданные в <xref:System.Diagnostics.Process.StartInfo%2A> свойство вплоть до времени, который вы вызываете <xref:System.Diagnostics.Process.Start%2A> метод на процесс. После запуска процесса, изменив <xref:System.Diagnostics.Process.StartInfo%2A> значения не влияет на и перезапуска процесса. При вызове метода <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> метод с <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> и <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> набором свойств, неуправляемой `CreateProcessWithLogonW` вызывается функция, которая запускает процесс в новый даже если окно <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> свойство имеет значение `true` или <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> свойство имеет значение <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Если вы не использовали <xref:System.Diagnostics.Process.Start%2A> метод для запуска процесса, <xref:System.Diagnostics.Process.StartInfo%2A> свойство не отражает параметров, используемых для запуска процесса. Например, если вы используете <xref:System.Diagnostics.Process.GetProcesses%2A> для получения массива процессов, запущенных на компьютере, <xref:System.Diagnostics.Process.StartInfo%2A> каждого элемента <xref:System.Diagnostics.Process> не содержит имя исходного файла и аргументы, используемые для запуска процесса.  
  
 Когда запускается процесс, имя файла — файл, который заполняет (только для чтения) <xref:System.Diagnostics.Process.MainModule%2A> свойство. Если вы хотите получить исполняемый файл, связанный с процессом после запуска процесса, используйте <xref:System.Diagnostics.Process.MainModule%2A> свойство. Если вы хотите задать исполняемый файл <xref:System.Diagnostics.Process> экземпляра, для которого связанного процесса не был запущен, используйте <xref:System.Diagnostics.Process.StartInfo%2A> свойства <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> член. Так как члены <xref:System.Diagnostics.Process.StartInfo%2A> свойства, аргументы, передаваемые <xref:System.Diagnostics.Process.Start%2A> метод процесса, изменив <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство после начала процесса не приведет к сбросу <xref:System.Diagnostics.Process.MainModule%2A> свойство. Эти свойства используются только для инициализации процесса.  
  
   
  
## Examples  
 В следующем примере <xref:System.Diagnostics.Process.StartInfo%2A> с выполняемого файла, действием над ней и должен ли отображаться пользовательский интерфейс. Дополнительные примеры см. на страницах справочника для свойства <xref:System.Diagnostics.ProcessStartInfo> класса.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value that specifies the <see cref="P:System.Diagnostics.Process.StartInfo" /> is <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the associated process was started.</summary>
        <value>Объект, показывающий время запуска процесса. Если процесс не выполняется, возникает исключение.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.StartTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process has exited.  -or-  The process has not been started.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred in the call to the Windows function.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object used to marshal the event handler calls that are issued as a result of a process exit event.</summary>
        <value>Объект <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, используемый для маршалинга вызовов обработчика событий, возникающих в результате события <see cref="E:System.Diagnostics.Process.Exited" /> в процессе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> — `null`, методы, обрабатывающие <xref:System.Diagnostics.Process.Exited> событие, называются в поток из системного пула потоков. Дополнительные сведения о системе пулов потоков, см. в разделе <xref:System.Threading.ThreadPool>.  
  
 Когда <xref:System.Diagnostics.Process.Exited> событие обрабатывается с помощью визуального компонента Windows Forms, такие как <xref:System.Windows.Forms.Button>, обращение к компоненту через пул потоков системы могут работать неправильно, или может привести к исключению. Избежать этого, задав <xref:System.Diagnostics.Process.SynchronizingObject%2A> в компонент Windows Forms, который вызывает методы, обрабатывающие <xref:System.Diagnostics.Process.Exited> событий, вызываемый в том же потоке, в котором был создан компонент.  
  
 Если <xref:System.Diagnostics.Process> используется внутри [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] в конструкторе Windows Forms, <xref:System.Diagnostics.Process.SynchronizingObject%2A> автоматически устанавливается в элемент управления, содержащий <xref:System.Diagnostics.Process>. Например, если вы поместите <xref:System.Diagnostics.Process> конструктору `Form1` (который наследуется от <xref:System.Windows.Forms.Form>) <xref:System.Diagnostics.Process.SynchronizingObject%2A> свойство <xref:System.Diagnostics.Process> присваивается экземпляр `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 Как правило это свойство задается при компонент размещается внутри элемента управления или формы, так как эти компоненты привязаны к определенному потоку.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the set of threads that are running in the associated process.</summary>
        <value>Массив объектов типа <see cref="T:System.Diagnostics.ProcessThread" />, представляющий потоки операционной системы, которые в настоящий момент выполняются в связанном процессе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток выполняет код в процессе. Каждый процесс запускается с одним потоком, основной поток. Любой поток может создавать дополнительные потоки. Потоки процесса разделяют адресное пространство процесса.  
  
 Используйте <xref:System.Diagnostics.ProcessThread> можно получить все потоки, связанные с текущим процессом. Основной поток в данный момент не обязательно с нулевым индексом в массиве.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">The process does not have an <see cref="P:System.Diagnostics.Process.Id" />, or no process is associated with the <see cref="T:System.Diagnostics.Process" /> instance.  -or-  The associated process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formats the process's name as a string, combined with the parent component type, if applicable.</summary>
        <returns>The <see cref="P:System.Diagnostics.Process.ProcessName" />, combined with the base component's <see cref="M:System.Object.ToString" /> return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" /> is not supported on Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the total processor time for this process.</summary>
        <value>Объект <see cref="T:System.TimeSpan" />, указывающий количество времени, потраченного процессом на загрузку ЦП. Это значение является суммой значений свойств <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> и <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the user processor time for this process.</summary>
        <value>Класс <see cref="T:System.TimeSpan" />, показывающий количество времени, которое связанный процесс потратил на выполнение кода внутри приложения (не внутри ядра операционной системы).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size of the process's virtual memory, in bytes.</summary>
        <value>Объем виртуальной памяти в байтах, запрошенной связанным процессом.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of the virtual memory, in bytes, allocated for the associated process.</summary>
        <value>Объем виртуальной памяти в байтах, выделенной для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер виртуальной памяти, используемой процессом, в байтах. Операционная система сопоставляет виртуального адресного пространства для каждого процесса, либо на страницы загрузки в физической памяти, или на страницы хранятся в файле подкачки виртуальной памяти на диске.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **байт виртуальной памяти** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the period of time to wait for the associated process to exit, and blocks the current thread of execution until the time has elapsed or the process has exited. To avoid blocking the current thread, use the <see cref="E:System.Diagnostics.Process.Exited" /> event.  For code examples, see the <see cref="P:System.Diagnostics.Process.StandardError" /> and the <see cref="P:System.Diagnostics.Process.ExitCode" /> property reference pages.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to exit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> делает текущий поток ждал до завершения связанного процесса.  Его следует вызывать после вызова всех остальных методов для процесса. Чтобы избежать блокировки текущего потока, используйте событие <xref:System.Diagnostics.Process.Exited>.  
  
 Указывает, что этот метод <xref:System.Diagnostics.Process> ожидания неограниченного количества времени для процесса и обработчики событий для выхода. Это может вызвать приложение перестает отвечать на запросы. Например, если вы вызываете <xref:System.Diagnostics.Process.CloseMainWindow%2A> для процесса, который имеет пользовательский интерфейс, запрос к операционной системе на завершение процесса может быть не обработан, если запись процесса не нужно вводить его цикл обработки сообщений.  
  
> [!NOTE]
>  В [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] и более ранних версий <xref:System.Diagnostics.Process.WaitForExit> ожидание перегрузки <xref:System.Int32.MaxValue> миллисекунд (приблизительно 24 дней), не бесконечно. Кроме того, предыдущие версии были ожидает обработчики событий выход в случае полной <xref:System.Int32.MaxValue> достигнуто время.  
  
 Эта перегрузка гарантирует, что вся обработка завершения, включая обработку асинхронных событий для перенаправленного стандартного вывода. Эту перегрузку следует использовать после вызова <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> перегрузки, когда был перенаправлен стандартный поток вывода для асинхронных обработчиков событий.  
  
 При завершении связанного процесса (то есть, когда его работа была завершена функцией операционной системы через нормальное или аварийное завершение), система сохраняет административную информацию о процессе и возвращает к компоненту, вызвавшему метод <xref:System.Diagnostics.Process.WaitForExit>. <xref:System.Diagnostics.Process> Может получить доступ к сведения, а также <xref:System.Diagnostics.Process.ExitTime%2A>, с помощью <xref:System.Diagnostics.Process.Handle%2A> завершенных процессов.  
  
 Так как связанный процесс завершился, <xref:System.Diagnostics.Process.Handle%2A> свойства компонента больше не указывает на существующий ресурс процесса. Вместо этого дескриптор может использоваться только для доступа к операционной системы сведения о ресурсе процесса. Система известно о дескрипторах завершенных процессов, которые не были освобождены <xref:System.Diagnostics.Process> компонентов, поэтому она хранит <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.Handle%2A> информацию в памяти до <xref:System.Diagnostics.Process> компонента, в частности, освобождает ресурсы. По этой причине при каждом вызове <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра, вызовите <xref:System.Diagnostics.Process.Close%2A> при связанный процесс был завершен, и больше не нужны административной информации о нем. <xref:System.Diagnostics.Process.Close%2A> Освобождает память, выделенную завершенных процессов.  
  
   
  
## Examples  
 См. в разделе "Примечания" <xref:System.Diagnostics.Process.StandardError%2A> справочной странице.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The wait setting could not be accessed.</exception>
        <exception cref="T:System.SystemException">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.  -or-  You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit" /> for a process that is running on a remote computer. This method is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">The amount of time, in milliseconds, to wait for the associated process to exit. The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system.</param>
        <summary>Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to exit.</summary>
        <returns>
          <see langword="true" /> if the associated process has exited; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> делает текущий поток ждал до завершения связанного процесса. Его следует вызывать после вызова всех остальных методов для процесса. Чтобы избежать блокировки текущего потока, используйте событие <xref:System.Diagnostics.Process.Exited>.  
  
 Указывает, что этот метод <xref:System.Diagnostics.Process> ожидания конечное количество времени для завершения процесса. Если связанный процесс не завершится по истечении интервала из-за отказа в запросе на завершение `false` возвращается вызвавшей процедуре. Можно указать <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> для `milliseconds`, и <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> будет вести себя так же, как <xref:System.Diagnostics.Process.WaitForExit> перегрузки. Если методу передается 0 (ноль), он возвращает `true` только в том случае, если процесс уже завершился; в противном случае он немедленно возвращает `false`.  
  
> [!NOTE]
>  В [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] и более ранних версий, если `milliseconds` -1, <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> ожидание перегрузки <xref:System.Int32.MaxValue> миллисекунд (приблизительно 24 дней), не бесконечно.  
  
 Когда стандартный вывод был перенаправлен к асинхронных обработчиков событий, вполне возможно, что обработка вывода не будет завершена при возвращении данного метода. Чтобы гарантировать завершение асинхронной обработки событий, вызвать <xref:System.Diagnostics.Process.WaitForExit> перегрузку, принимающую параметр не после получения `true` из этой перегрузки. Чтобы обеспечить <xref:System.Diagnostics.Process.Exited> правильную обработку событий в приложениях Windows Forms, задайте <xref:System.Diagnostics.Process.SynchronizingObject%2A> свойство.  
  
 При завершении связанного процесса (завершает работу операционной системой через обычный или аварийное завершение), система сохраняет административную информацию о процессе и возвращает к компоненту, вызвавшему метод <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. <xref:System.Diagnostics.Process> Может получить доступ к сведения, а также <xref:System.Diagnostics.Process.ExitTime%2A>, с помощью <xref:System.Diagnostics.Process.Handle%2A> завершенных процессов.  
  
 Так как связанный процесс завершился, <xref:System.Diagnostics.Process.Handle%2A> свойства компонента больше не указывает на существующий ресурс процесса. Вместо этого дескриптор может использоваться только для доступа к операционной системы сведения о ресурсе процесса. Система известно о дескрипторах завершенных процессов, которые не были освобождены <xref:System.Diagnostics.Process> компонентов, поэтому она хранит <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.Handle%2A> информацию в памяти до <xref:System.Diagnostics.Process> компонента, в частности, освобождает ресурсы. По этой причине при каждом вызове <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра, вызовите <xref:System.Diagnostics.Process.Close%2A> при связанный процесс был завершен, и больше не нужны административной информации о нем. <xref:System.Diagnostics.Process.Close%2A> Освобождает память, выделенную завершенных процессов.  
  
   
  
## Examples  
 См. в примере кода <xref:System.Diagnostics.Process.ExitCode%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The wait setting could not be accessed.</exception>
        <exception cref="T:System.SystemException">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.  -or-  You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> for a process that is running on a remote computer. This method is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait for the associated process to enter an idle state.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to enter an idle state. This overload applies only to processes with a user interface and, therefore, a message loop.</summary>
        <returns>
          <see langword="true" /> if the associated process has reached an idle state.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.Process.WaitForInputIdle> включить обработку приложения, чтобы подождать, пока цикл обработки сообщений вернулась в состояние бездействия. При выполнении процесса с пользовательским интерфейсом, цикл сообщений выполняется каждый раз, отправляется сообщение Windows для процесса операционной системой. Затем процесс возвращается в цикл обработки сообщений. Это процесс называется быть в состоянии простоя, когда он ожидает сообщений внутри цикла обработки сообщений. Это состояние, полезно, например, когда приложение должно ожидать запуска процесса завершить создание основного окна, прежде чем приложение взаимодействует с этим окном.  
  
 Если процесс не содержит цикл обработки сообщений, <xref:System.Diagnostics.Process.WaitForInputIdle> вызывает <xref:System.InvalidOperationException>.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle> Перегрузка указывает, что <xref:System.Diagnostics.Process> компонента для неограниченного времени ожидания для процесса в состояние бездействия в цикл обработки сообщений. Эта инструкция может вызвать приложение перестает отвечать на запросы. Например, если процесс написан так, чтобы всегда выйти из цикла сообщений сразу же, как показано в фрагменте кода `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have a graphical interface.  -or-  An unknown error occurred. The process failed to enter an idle state.  -or-  The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">A value of 1 to <see cref="F:System.Int32.MaxValue" /> that specifies the amount of time, in milliseconds, to wait for the associated process to become idle. A value of 0 specifies an immediate return, and a value of -1 specifies an infinite wait.</param>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to enter an idle state. This overload applies only to processes with a user interface and, therefore, a message loop.</summary>
        <returns>
          <see langword="true" /> if the associated process has reached an idle state; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> включить обработку приложения, чтобы подождать, пока цикл обработки сообщений вернулась в состояние бездействия. При выполнении процесса с пользовательским интерфейсом, цикл сообщений выполняется каждый раз, отправляется сообщение Windows для процесса операционной системой. Затем процесс возвращается в цикл обработки сообщений. Это процесс называется быть в состоянии простоя, когда он ожидает сообщений внутри цикла обработки сообщений. Это состояние, полезно, например, когда приложение должно ожидать запуска процесса завершить создание основного окна, прежде чем приложение взаимодействует с этим окном.  
  
 Если процесс не содержит цикл обработки сообщений, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> вызывает <xref:System.InvalidOperationException>.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> Перегрузка указывает, что <xref:System.Diagnostics.Process> ожидания конечное количество времени для процесса в состояние бездействия в цикл обработки сообщений. Если связанный процесс не стало простаивающим в конце интервала, так как цикл обработки сообщений, `false` возвращается вызвавшей процедуре.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have a graphical interface.  -or-  An unknown error occurred. The process failed to enter an idle state.  -or-  The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the associated process's physical memory usage, in bytes.</summary>
        <value>Общий объем физической памяти в байтах, используемой связанный процесс.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством представляет текущий размер рабочего набора памяти, используемой процессом, в байтах. Рабочий набор процесса — это набор страниц памяти, видимой в данный момент к процессу в физической памяти ОЗУ. Эти страницы являются резидентными и доступны для приложения для использования без создания ошибки страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая модули процессов и системных библиотек.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of physical memory, in bytes, allocated for the associated process.</summary>
        <value>Объем физической памяти в байтах, выделенной для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством представляет текущий размер рабочего набора памяти, используемой процессом, в байтах. Рабочий набор процесса — это набор страниц памяти, видимой в данный момент к процессу в физической памяти ОЗУ. Эти страницы являются резидентными и доступны для приложения для использования без создания ошибки страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая инструкции в модули процессов и системных библиотек.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **рабочий набор** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>