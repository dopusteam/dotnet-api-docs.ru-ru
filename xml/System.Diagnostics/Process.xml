<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="738e978e4247fe3d388927b8137573b1f560c992" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58456994" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет доступ к локальным и удаленным процессам и позволяет запускать и останавливать локальные системные процессы.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Diagnostics.Process> компонент предоставляет доступ к процессу, который выполняется на компьютере. Процесс, проще говоря, — работающего приложения. Поток — это базовая единица, к которой операционная система выделяет время процессора. Поток может исполнять любую часть кода процесса, включая части, выполняющейся в данный момент другим потоком.  
  
 <xref:System.Diagnostics.Process> Компонент — это полезное средство для запуска и остановки, управление и наблюдение за приложениями. Можно использовать <xref:System.Diagnostics.Process> компонент, для получения списка процессов, работающих под управлением, или вы можете запустить новый процесс. Объект <xref:System.Diagnostics.Process> компонент используется для доступа к системным процессам. После <xref:System.Diagnostics.Process> инициализации компонента, его можно использовать для получения сведений о запущенном процессе. Такая информация включает в себя набор потоков, загруженные модули (файлы .dll и .exe), и информацию о производительности, таких как объем памяти, используемой процессом.  
  
 Этот тип реализует <xref:System.IDisposable> интерфейс. Когда вы закончите, используя тип, следует освободить его прямо или косвенно. Чтобы удалить тип напрямую, вызовите его <xref:System.IDisposable.Dispose%2A> метод в `try` / `finally` блока. Чтобы избавиться от его косвенно, используйте языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует IDisposable» <xref:System.IDisposable> разделу интерфейса.  
  
> [!NOTE]
>  32-разрядных процессов не может получить доступ к модулям 64-разрядном процессе. При попытке получить сведения о 64-разрядном процессе из 32-разрядном процессе, вы получите <xref:System.ComponentModel.Win32Exception> исключение. 64-разрядный процесс, с другой стороны, можно получить доступ к модулям 32-разрядном процессе.  
  
 Компонент обработки получает сведения о группу свойств за один раз. После <xref:System.Diagnostics.Process> компонент получил информацию о один член, ни в одну группу, он будет кэшировать значения для других свойств в этой группе и не будет получать новые сведения о других членах группы до вызова метода <xref:System.Diagnostics.Process.Refresh%2A> метод. Таким образом, значение свойства, не обязательно будет новее, чем последнего вызова <xref:System.Diagnostics.Process.Refresh%2A> метод. Схемы групп, зависят от операционной системы.  
  
 Если у вас есть путь к переменной, объявленной в вашей системе, с помощью кавычки, необходимо полностью указать этот путь при запуске любого процесса, в этом расположении. В противном случае система не найдет путь. Например если `c:\mypath` не находится в системном пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо полностью указать любой процесс в `c:\mypath` при запуске.  
  
 Системный процесс однозначно идентифицируется в системе идентификатор процесса. Как и многие ресурсы Windows процесс также определяется его дескриптор, который не может быть уникальным на компьютере. Дескриптор является универсальный термин для идентификатора ресурса. Операционная система сохраняет дескриптор процесса, доступный через <xref:System.Diagnostics.Process.Handle%2A> свойство <xref:System.Diagnostics.Process> компонент, даже в том случае, если процесс завершился. Таким образом, можно получить процесса для администраторов информация, например <xref:System.Diagnostics.Process.ExitCode%2A> (обычно либо ноль для успеха или ненулевой код ошибки) и <xref:System.Diagnostics.Process.ExitTime%2A>. Дескрипторы являются чрезвычайно важным ресурсом, поэтому происходит утечка дескрипторов более опасна, чем утечка памяти.  
  
> [!NOTE]
>  Этот класс содержит запрос компоновки и требования наследования на уровне класса, который применяется ко всем элементам. Объект <xref:System.Security.SecurityException> возникает, если непосредственный вызывающий оператор или производного класса не имеет разрешения полного доверия. Дополнительные сведения о требованиях безопасности см. в разделе [требования связывания](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Примечания  
 В .NET Framework <xref:System.Diagnostics.Process> класс по умолчанию использует <xref:System.Console> кодировок, которые обычно являются кода кодировок страниц, для потоков ввода, вывода и ошибок. Пример кода, в системах, языком и региональными параметрами является английский (США), кодовую страницу 437, — это кодировка по умолчанию для <xref:System.Console> класса. Тем не менее [!INCLUDE[net_core](~/includes/net-core-md.md)] можно освободить только ограниченный набор этих кодировок. Если это так, он использует <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> качестве кодировки по умолчанию.  
  
 Если <xref:System.Diagnostics.Process> объекта зависит от конкретных кодовых страниц, вы можете по-прежнему сделать их доступными, выполнив указанные ниже *перед* вызова любых <xref:System.Diagnostics.Process> методов:  
  
1.  Добавьте ссылку на сборку System.Text.Encoding.CodePages.dll в проект.  
  
2.  Получить <xref:System.Text.EncodingProvider> объекта из <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> свойство.  
  
3.  Передайте <xref:System.Text.EncodingProvider> объект <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> метод для установки дополнительных кодировках, поддерживаемых поставщик кодировки.  
  
 <xref:System.Diagnostics.Process> Класс будет автоматически использовать кодировку системы по умолчанию вместо UTF8, при условии, что вы зарегистрировали поставщик кодировки перед вызовом любых <xref:System.Diagnostics.Process> методов.  
  
   
  
## Examples  
 В следующем примере используется экземпляр <xref:System.Diagnostics.Process> класса для запуска процесса.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 В следующем примере используется <xref:System.Diagnostics.Process> классов самого и статический <xref:System.Diagnostics.Process.Start%2A> метод для запуска процесса.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 Следующие F# примере определяется `runProc` функцию, которая запускает процесс, захватывает все выходные данные и сведения об ошибке и записывает количество миллисекунд, выполнения процесса.  `runProc` Функция имеет три параметра: имя приложения, чтобы запустить, аргументы для передачи в приложение и начальный каталог.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Код для `runProc` функции было написано с [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) и доступен в разделе [публичной лицензии Microsoft](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот класс не может использоваться частично доверенным кодом.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот класс не может наследоваться кодом с частичным доверием.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">С помощью класса .NET процесса</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.Process" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не укажете <xref:System.Diagnostics.Process.MachineName%2A> свойство, значение по умолчанию является локальный компьютер (».»).  
  
 Существует два варианта для сопоставления нового <xref:System.Diagnostics.Process> компонент процесса на компьютере. Первый вариант — использовать конструктор для создания <xref:System.Diagnostics.Process> набор компонентов, соответствующие члены <xref:System.Diagnostics.Process.StartInfo%2A> свойство и вызвать <xref:System.Diagnostics.Process.Start%2A> связываемый <xref:System.Diagnostics.Process> новым процессом system. Второй способ заключается в связать <xref:System.Diagnostics.Process> с к выполняющемуся процессу системы с помощью <xref:System.Diagnostics.Process.GetProcessById%2A> или один из <xref:System.Diagnostics.Process.GetProcesses%2A> возвращаемые значения.  
  
 Если вы используете `static` перегрузки <xref:System.Diagnostics.Process.Start%2A> метод для запуска нового процесса системы, метод создает новый <xref:System.Diagnostics.Process> компонент, который связывается с процессом.  
  
 Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> задано значение по умолчанию `true`, запуском приложений и документов в виде, аналогично использованию `Run` диалоговое окно Windows `Start` меню. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> является `false`, можно запускать только исполняемые файлы.  
  
 Любой исполняемый файл, который можно вызвать из командной строки можно запустить одним из двух способов: установив соответствующие члены <xref:System.Diagnostics.Process.StartInfo%2A> и вызова <xref:System.Diagnostics.Process.Start%2A> метод без параметров, либо путем передачи соответствующего параметра `static` <xref:System.Diagnostics.Process.Start%2A> член.  
  
 Можно создать <xref:System.Diagnostics.Process> компонент с помощью конструктора, одного из статических <xref:System.Diagnostics.Process.Start%2A> перегрузки или любой другой <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, или <xref:System.Diagnostics.Process.GetProcessesByName%2A> методы. После это сделано, вы можете просматривать связанного процесса. Это не динамическое представление, которое автоматически обновляется при изменении свойств процесса в памяти. Вместо этого необходимо вызвать <xref:System.Diagnostics.Process.Refresh%2A> компонента обновить <xref:System.Diagnostics.Process> сведения о свойствах в приложении.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает базовый приоритет связанного процесса.</summary>
        <value>Базовый приоритет, который вычисляется свойством <see cref="P:System.Diagnostics.Process.PriorityClass" /> связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A> Процесса является стартовым приоритетом для потоков, созданных в связанном процессе. Можно просмотреть сведения о базовый приоритет через базового приоритета счетчик системного монитора.  
  
 На основе времени, затраченного или других показателях, операционной системы можно изменить базовый приоритет, если процесс должен размещаться перед другими пользователями.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> Свойство позволяет просмотреть начальный приоритет, назначенный процессу. Тем не менее, так как документ доступен только для чтения, нельзя использовать <xref:System.Diagnostics.Process.BasePriority%2A> для задания приоритета процесса. Чтобы изменить приоритет, используйте <xref:System.Diagnostics.Process.PriorityClass%2A> свойство. <xref:System.Diagnostics.Process.BasePriority%2A> Можно просматривать с помощью системного монитора, а <xref:System.Diagnostics.Process.PriorityClass%2A> не является. Как <xref:System.Diagnostics.Process.BasePriority%2A> и <xref:System.Diagnostics.Process.PriorityClass%2A> можно просмотреть программно. В следующей таблице показаны связи между <xref:System.Diagnostics.Process.BasePriority%2A> значения и <xref:System.Diagnostics.Process.PriorityClass%2A> значения.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для свойства <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс завершен.  
  
-или- 
Процесс не запущен, поэтому нет идентификатора процесса.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает операции асинхронного чтения с перенаправленного потока <see cref="P:System.Diagnostics.Process.StandardError" /> приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A> Возможность чтения потока, синхронно или асинхронно. Методы, такие как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> выполнять синхронные операции чтения в потоке вывода ошибок процесса. Эти синхронные чтение операции не завершаются до связанного <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardError%2A> потоковой передачи или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A> потока. Этот метод включает маршрутизируемый обработчик событий вывода потока и немедленно возвращает вызывающему объекту, который может выполнять другую работу, пока выходной поток направляется обработчику событий.  
  
 Выполните следующие действия для выполнения асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A> для <xref:System.Diagnostics.Process> :  
  
1.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> значение `false`.  
  
2.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> значение `true`.  
  
3.  Добавьте в обработчик событий для <xref:System.Diagnostics.Process.ErrorDataReceived> событий. Обработчик событий должен соответствовать <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> сигнатуре делегата.  
  
4.  Запустить <xref:System.Diagnostics.Process>.  
  
5.  Вызовите <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> для <xref:System.Diagnostics.Process>. Этот вызов запускает асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Когда запуск асинхронных операций чтения, обработчик событий вызывается каждый раз, когда связанный <xref:System.Diagnostics.Process> записывает строку текста для его <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Можно отменить асинхронную операцию чтения, вызвав <xref:System.Diagnostics.Process.CancelErrorRead%2A>. Операции чтения можно отменить в вызывающем объекте, или с помощью обработчика событий. После отмены, можно вызвать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> еще раз, чтобы возобновить операции асинхронного чтения.  
  
> [!NOTE]
>  Нельзя смешивать асинхронные и синхронные операции чтения в перенаправленном потоке. Один раз перенаправленного потока <xref:System.Diagnostics.Process> открыт в режиме асинхронной или синхронной, все дополнительные чтения операции в этом потоке должен быть в одном режиме. Например, не выполняйте <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> вызовом <xref:System.IO.StreamReader.ReadLine%2A> на <xref:System.Diagnostics.Process.StandardError%2A> потока, или наоборот. Тем не менее вы найдете в двух разных потоках в разных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> , а затем вызвать <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
   
  
## Examples  
 В следующем примере используется `net view` команду, чтобы вывести список доступных сетевых ресурсов на удаленном компьютере. Пользователь вводит имя конечного компьютера в качестве аргумента командной строки. Пользователь также может предоставить имя файла для вывода ошибок. Пример собирает выходные данные команды net, Ожидание завершения процесса, а затем запись в результаты вывода на консоль. Если пользователь вводит необязательный файл ошибок, ошибки в примере записываются в файл.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение свойства <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> — <see langword="false" />.  
  
-или- 
Асинхронная операция чтения уже выполняется в потоке <see cref="P:System.Diagnostics.Process.StandardError" />.  
  
-или- 
Поток <see cref="P:System.Diagnostics.Process.StandardError" /> используется синхронной операцией чтения.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает операции асинхронного чтения с перенаправленного потока <see cref="P:System.Diagnostics.Process.StandardOutput" /> приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A> Возможность чтения потока, синхронно или асинхронно. Методы, такие как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> выполнять синхронные операции чтения в выходной поток процесса. Эти синхронные чтение операции не завершаются до связанного <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardOutput%2A> потоковой передачи или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращает вызывающему объекту, который может выполнять другую работу, пока выходной поток направляется обработчику событий.  
  
 Выполните следующие действия для выполнения асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> для <xref:System.Diagnostics.Process> :  
  
1.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> значение `false`.  
  
2.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> значение `true`.  
  
3.  Добавьте в обработчик событий для <xref:System.Diagnostics.Process.OutputDataReceived> событий. Обработчик событий должен соответствовать <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> сигнатуре делегата.  
  
4.  Запустить <xref:System.Diagnostics.Process>.  
  
5.  Вызовите <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> для <xref:System.Diagnostics.Process>. Этот вызов запускает асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Когда запуск асинхронных операций чтения, обработчик событий вызывается каждый раз, когда связанный <xref:System.Diagnostics.Process> записывает строку текста для его <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
 Можно отменить асинхронную операцию чтения, вызвав <xref:System.Diagnostics.Process.CancelOutputRead%2A>. Операции чтения можно отменить в вызывающем объекте, или с помощью обработчика событий. После отмены, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> еще раз, чтобы возобновить операции асинхронного чтения.  
  
> [!NOTE]
>  Нельзя смешивать асинхронные и синхронные операции чтения в перенаправленном потоке. Один раз перенаправленного потока <xref:System.Diagnostics.Process> открыт в режиме асинхронной или синхронной, все дополнительные чтения операции в этом потоке должен быть в одном режиме. Например, не выполняйте <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> вызовом <xref:System.IO.StreamReader.ReadLine%2A> на <xref:System.Diagnostics.Process.StandardOutput%2A> потока, или наоборот. Тем не менее вы найдете в двух разных потоках в разных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , а затем вызвать <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
   
  
## Examples  
 Следующий пример иллюстрирует способ выполнения асинхронных операций чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> поток `sort` команды. `sort` Команда представляет собой консольное приложение, который считывает и сортирует ввода текста.  
  
 В примере создается делегат события для `SortOutputHandler` обработчик событий и связывает его с <xref:System.Diagnostics.Process.OutputDataReceived> событий. Обработчик событий получает строки текста из перенаправленного <xref:System.Diagnostics.Process.StandardOutput%2A> поток, форматирует текст и выводит текст на экран.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение свойства <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> — <see langword="false" />.  
  
-или- 
Асинхронная операция чтения уже выполняется в потоке <see cref="P:System.Diagnostics.Process.StandardOutput" />.  
  
-или- 
Поток <see cref="P:System.Diagnostics.Process.StandardOutput" /> используется синхронной операцией чтения.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет операцию асинхронного чтения в перенаправленном потоке <see cref="P:System.Diagnostics.Process.StandardError" /> приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Начинает асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardError%2A> потока. <xref:System.Diagnostics.Process.CancelErrorRead%2A> заканчивается операции асинхронного чтения.  
  
 После отмены, можно возобновить асинхронную операцию чтения, вызвав <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> еще раз.  
  
 При вызове <xref:System.Diagnostics.Process.CancelErrorRead%2A>, что все выполняющиеся операции чтения для <xref:System.Diagnostics.Process.StandardError%2A> завершены и затем отключен обработчик событий. Все дополнительные перенаправление выходных данных в <xref:System.Diagnostics.Process.StandardError%2A> будут потеряны. Если вы включите обработчик событий с помощью вызова <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>асинхронных чтение возобновить операции. Если вы хотите изменить обработчик событий перед возобновлением асинхронных операций чтения, необходимо удалить существующий обработчик событий, прежде чем добавлять новый обработчик событий:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Нельзя смешивать асинхронные и синхронные операции чтения в перенаправленном <xref:System.Diagnostics.Process.StandardError%2A> потока. Один раз перенаправленного потока <xref:System.Diagnostics.Process> открыт в режиме асинхронной или синхронной, все дополнительные чтения операции в этом потоке должен быть в одном режиме. Если отменить асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardError%2A> и затем нужно считать из потока, необходимо использовать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> возобновить операции асинхронного чтения. Не выполняйте <xref:System.Diagnostics.Process.CancelErrorRead%2A> с помощью вызова для синхронного методы для чтения <xref:System.Diagnostics.Process.StandardError%2A> например <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, или <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 В следующем примере запускается `nmake` команды с пользователем заданные аргументы. Потоки ошибок и вывода считываются асинхронно; Накопленные строки текста на консоль выводятся, а также записываются в файл журнала. Если выходные данные команды превышает указанное число строк, будут отменены операции асинхронного чтения.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток <see cref="P:System.Diagnostics.Process.StandardError" /> не включен для асинхронных операций чтения.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет операцию асинхронного чтения в перенаправленном потоке <see cref="P:System.Diagnostics.Process.StandardOutput" /> приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Начинает асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. <xref:System.Diagnostics.Process.CancelOutputRead%2A> заканчивается операции асинхронного чтения.  
  
 После отмены, можно возобновить операции асинхронного чтения путем вызова <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> еще раз.  
  
 При вызове <xref:System.Diagnostics.Process.CancelOutputRead%2A>, что все выполняющиеся операции чтения для <xref:System.Diagnostics.Process.StandardOutput%2A> завершены и затем отключен обработчик событий. Все дополнительные перенаправление выходных данных в <xref:System.Diagnostics.Process.StandardOutput%2A> сохраняется в буфере. Если вы включите обработчик событий с помощью вызова <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, сохраненные данные выводятся в обработчик событий, и возобновить операции асинхронного чтения. Если вы хотите изменить обработчик событий перед возобновлением асинхронных операций чтения, необходимо удалить существующий обработчик событий, прежде чем добавлять новый обработчик событий:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Нельзя смешивать асинхронные и синхронные операции чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Один раз перенаправленного потока <xref:System.Diagnostics.Process> открыт в режиме асинхронной или синхронной, все дополнительные чтения операции в этом потоке должен быть в одном режиме. Если отменить асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> и затем нужно считать из потока, необходимо использовать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> возобновить операции асинхронного чтения. Не выполняйте <xref:System.Diagnostics.Process.CancelOutputRead%2A> с помощью вызова для синхронного методы для чтения <xref:System.Diagnostics.Process.StandardOutput%2A> например <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, или <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 В следующем примере запускается `nmake` команды с пользователем заданные аргументы. Потоки ошибок и вывода считываются асинхронно; Накопленные строки текста на консоль выводятся, а также записываются в файл журнала. Если выходные данные команды превышает указанное число строк, будут отменены операции асинхронного чтения.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток <see cref="P:System.Diagnostics.Process.StandardOutput" /> не включен для асинхронных операций чтения.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, связанные с этим компонентом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A> Метод вызывает процесс остановки в состоянии ожидания выход, если он ожидал, закрывает дескриптор процесса и очищает свойства, относящиеся к процессу. <xref:System.Diagnostics.Process.Close%2A> не закрывайте стандартные выходные данные, входные данные и ошибки чтения и записи в случае, если они ссылаются извне.  
  
> [!NOTE]
>  Метод <xref:System.Diagnostics.Process.Dispose%2A> вызывает <xref:System.Diagnostics.Process.Close%2A>. Размещение <xref:System.Diagnostics.Process> объекта в `using` блок удаляет ресурсы без необходимости вызова <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем она получает использование физической памяти связанного процесса в 2-секундным интервалом не более 10 секунд. В данном примере отслеживается ли процесс завершается до истечения 10 секунд. Пример закрывает процесс, если оно по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает процесс, имеющий пользовательский интерфейс, посылая сообщение о закрытии главному окну процесса.</summary>
        <returns>Значение <see langword="true" />, если сообщение о закрытии было успешно отправлено; <see langword="false" />, если связанный процесс не имеет главного окна или если главное окно отключено (например, если отображается модальное диалоговое окно).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При выполнении процесса его цикл сообщений находится в состоянии ожидания. Цикл обработки сообщений выполняется каждый раз, отправляется сообщение Windows для процесса операционной системой. Вызов <xref:System.Diagnostics.Process.CloseMainWindow%2A> отправляет запрос на закрытие главного окна, которое закрывает дочерние окна и отменяет все выполняющиеся циклы сообщений для приложения в приложении правильного формата. Запрос на завершение процесса путем вызова <xref:System.Diagnostics.Process.CloseMainWindow%2A> не вынуждает приложения, чтобы выйти из программы. Приложение может запросить проверку пользователя перед завершением работы или она может отклонить выйти из программы. Чтобы принудительно запустить приложение, чтобы выйти из программы, используйте <xref:System.Diagnostics.Process.Kill%2A> метод. Поведение <xref:System.Diagnostics.Process.CloseMainWindow%2A> уже имеется у пользователя закрытие главного окна приложения, используя системное меню. Таким образом запрос на завершение процесса, закрыв главное окно не вынуждает приложения, чтобы немедленно выйти из программы.  
  
 Данные изменены процессом или ресурсы, выделенные для процесса могут быть потеряны при вызове метода <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> вызывает аварийного завершения процесса и должен использоваться только в случае необходимости. <xref:System.Diagnostics.Process.CloseMainWindow%2A> включает упорядоченной остановки процесса и закрывает все окна, поэтому рекомендуется для приложений с интерфейсом. Если <xref:System.Diagnostics.Process.CloseMainWindow%2A> завершается ошибкой, можно использовать <xref:System.Diagnostics.Process.Kill%2A> завершить процесс. <xref:System.Diagnostics.Process.Kill%2A> является единственным способом завершить процессы, не имеющих графического интерфейса.  
  
 Можно вызвать <xref:System.Diagnostics.Process.Kill%2A> и <xref:System.Diagnostics.Process.CloseMainWindow%2A> только для процессов, запущенных на локальном компьютере. Не удается вызвать процессов на удаленных компьютерах, чтобы выйти из. Кроме того, можно только просматривать информацию для процессов, выполняющихся на удаленных компьютерах.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем он получает использование физической памяти связанного процесса с 2-секундным интервалом не более 10 секунд. В данном примере отслеживается ли процесс завершается до истечения 10 секунд. Пример закрывает процесс, если оно по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для свойства <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Этот процесс уже завершился.  
  
-или- 
Нет процессов, связанных с этим объектом <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Освобождает все ресурсы, используемые этим процессом.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, следует ли вызывать событие <see cref="E:System.Diagnostics.Process.Exited" /> при прекращении процесса.</summary>
        <value>Значение <see langword="true" />, если событие <see cref="E:System.Diagnostics.Process.Exited" /> должно быть вызвано при завершении связанного процесса (выход или вызов метода <see cref="M:System.Diagnostics.Process.Kill" />); в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />. Обратите внимание, что <see cref="E:System.Diagnostics.Process.Exited" /> события даже в том случае, если значение <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> — <see langword="false" /> при завершении процесса во время или до выполнения пользователем <see cref="P:System.Diagnostics.Process.HasExited" /> проверки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Свойство предлагает, должны ли быть уведомлены компонента при операционной системы завершил работу процесса. <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Свойство используется при асинхронной обработке для уведомления приложения о завершении процесса. Чтобы заставить приложение синхронно ожидания события выхода (который прерывает обработку приложения, пока не произошло событие выхода), используйте <xref:System.Diagnostics.Process.WaitForExit%2A> метод.

> [!NOTE]
> Если вы используете Visual Studio и дважды щелкните <xref:System.Diagnostics.Process> компонента в проекте, <xref:System.Diagnostics.Process.Exited> делегат события и обработчик событий создаются автоматически. Дополнительный код задает <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> свойства `false`. Необходимо изменить это свойство, чтобы `true` для обработчика событий для выполнения при завершении связанного процесса.

Если компонента <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> значение `true`, или когда <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> — `false` и <xref:System.Diagnostics.Process.HasExited%2A> проверки вызывается компонентом, компонент может получить доступ к административной информации для связанного процесса, который остается хранит операционной системы. Такая информация включает <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.ExitCode%2A>.

После выхода из процесса, <xref:System.Diagnostics.Process.Handle%2A> компонента больше не указывает на существующий ресурс процесса. Вместо этого он может использоваться только для доступа к информации операционной системы о ресурсе процесса. Операционная система не знать о дескрипторах завершенных процессов, которые еще не были освобождены <xref:System.Diagnostics.Process> компонентов, поэтому она хранит <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.Handle%2A> информацию в памяти.

Есть затраты, связанные с наблюдением за завершением процесса. Если <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> — `true`, <xref:System.Diagnostics.Process.Exited> событие возникает при завершении связанного процесса. Процедуры <xref:System.Diagnostics.Process.Exited> события, время выполнения.

В некоторых случаях приложение запускает процесс, но не требует уведомление о его завершении. Например чтобы запустить приложение «Блокнот», чтобы разрешить пользователю редактировать текст, но больше не использовать приложение «Блокнот». Вы можете избежать уведомления при завершении процесса, так как он не имеет отношения к непрерывную работу приложения. Установка <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> для `false` позволяет сэкономить системные ресурсы.

## Examples  
В следующем примере кода создается процесс, который выводит файл. Он задает <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> свойство, чтобы процесс для вызова <xref:System.Diagnostics.Process.Exited> при выходе. <xref:System.Diagnostics.Process.Exited> Обработчик событий будет отображать сведения о процессе.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Помещает компонент <see cref="T:System.Diagnostics.Process" /> в состояние взаимодействия с работающим системным процессом, выполняющимся в специальном режиме путем включения встроенного свойства <see langword="SeDebugPrivilege" /> в данном потоке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые процессы операционной системы выполните в специальном режиме. Чтение свойств или подключиться к этим процессам не поддерживается, если не был вызван <xref:System.Diagnostics.Process.EnterDebugMode%2A> в компоненте. Вызовите <xref:System.Diagnostics.Process.LeaveDebugMode%2A> при вам больше не нужен доступ к процессам, выполняющимся в специальном режиме.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда приложение выполняет запись в свой перенаправленный поток <see cref="P:System.Diagnostics.Process.StandardError" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived> Событие означает, что в свой перенаправленный записал процесса <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Это событие происходит только во время асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A>. Для запуска асинхронных операций чтения, необходимо перенаправить <xref:System.Diagnostics.Process.StandardError%2A> поток <xref:System.Diagnostics.Process>, добавьте в обработчик событий для <xref:System.Diagnostics.Process.ErrorDataReceived> событий и вызовов <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. После этого <xref:System.Diagnostics.Process.ErrorDataReceived> сообщения о событиях каждый раз, когда процесс записывает строку в перенаправленном <xref:System.Diagnostics.Process.StandardError%2A> потоковую передачу, пока процесс завершает работу или вызывает <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  Приложение, которое обрабатывается асинхронный выход должен вызывать <xref:System.Diagnostics.Process.WaitForExit> метод, чтобы гарантировать, что была записана в выходной буфер. Обратите внимание, что при указании времени ожидания с помощью <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> перегрузки *не* убедитесь, были записаны в выходной буфер.
  
   
  
## Examples  
 В следующем примере используется `net view` команду, чтобы вывести список доступных сетевых ресурсов на удаленном компьютере. Пользователь вводит имя конечного компьютера в качестве аргумента командной строки. Пользователь также может предоставить имя файла для вывода ошибок. Пример собирает выходные данные команды net, Ожидание завершения процесса, а затем запись в результаты вывода на консоль. Если пользователь вводит необязательный файл ошибок, ошибки в примере записываются в файл.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, заданное связанным процессом при завершении.</summary>
        <value>Код, который задал связанный процесс при завершении.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.Process.ExitCode%2A> получить состояние, которое вернул системный процесс при завершении. Можно использовать код выхода во многом похож на возвращаемое значение из `main()` процедуры.  
  
 <xref:System.Diagnostics.Process.ExitCode%2A> Значение для процесса отражает конкретное соглашение, реализованные разработчиком приложения для этого процесса. При использовании значение кода выхода для принятия решений в коде, убедитесь, что вы знаете соглашения кода выхода, используемые в процессе приложения.  
  
 Разработчики обычно указывают успешный выход <xref:System.Diagnostics.Process.ExitCode%2A> значение ноль и обозначают ошибки ненулевыми значениями, которые вызывающий метод можно использовать для определения причины аварийного завершения процесса. Нет необходимости следуйте приведенным ниже рекомендациям, но они являются соглашением.  
  
 При попытке получить <xref:System.Diagnostics.Process.ExitCode%2A> прежде, чем процесс завершился, создаст исключение. Изучите <xref:System.Diagnostics.Process.HasExited%2A> свойство сначала, чтобы проверить, ли завершения связанного процесса.  
  
> [!NOTE]
>  Когда стандартный вывод был перенаправлен к асинхронных обработчиков событий, это возможно, что обработка вывода не будет завершена при <xref:System.Diagnostics.Process.HasExited%2A> возвращает `true`. Чтобы гарантировать завершение асинхронной обработки событий, вызвать <xref:System.Diagnostics.Process.WaitForExit> перегрузку, принимающую параметр не перед проверкой <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Можно использовать <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A> метода для завершения связанного процесса.  
  
 Существует два способа уведомления о завершении связанного процесса: синхронно и асинхронно. Синхронное уведомление основывается на вызове <xref:System.Diagnostics.Process.WaitForExit%2A> метод для приостановки выполнения приложения до выхода из сопоставленного компонента. Асинхронное уведомление основывается на <xref:System.Diagnostics.Process.Exited> событий. При использовании асинхронного уведомления <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> должно быть присвоено `true` для <xref:System.Diagnostics.Process> компонент для получения уведомления о завершении процесса.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не был завершен.  
  
-или- 
Процесс <see cref="P:System.Diagnostics.Process.Handle" /> не является допустимым.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.ExitCode" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при завершении процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited> Событие означает, что завершения связанного процесса. Это событие означает, что процесс прекращен (прерван) или успешно закрыт. Это событие может вызываться только в том случае, если значение <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> свойство `true`.  
  
 Существует два способа уведомления о завершении связанного процесса: синхронно и асинхронно. Синхронное уведомление означает вызов <xref:System.Diagnostics.Process.WaitForExit%2A> метод блокирует текущий поток до завершения работы процесса. Использует асинхронное уведомление <xref:System.Diagnostics.Process.Exited> событие, которое позволяет вызывающему потоку продолжить выполнение в то же время. В последнем случае <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> должно быть присвоено `true` для вызывающего приложения для получения события завершил работу.  
  
 При завершении работы процесса операционной системы он уведомляет все процессы, которые зарегистрировали обработчики для событий завершил работу. В настоящее время дескриптор процесса, который только что завершил работу можно использовать для доступа к некоторые свойства, такие как <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.HasExited%2A> что операционная система поддерживает до полностью освобождает этот дескриптор.  
  
> [!NOTE]
>  Даже если у вас есть дескриптор для завершенного процесса, нельзя вызывать <xref:System.Diagnostics.Process.Start%2A> еще раз, чтобы повторно подключиться к тот же процесс. Вызов <xref:System.Diagnostics.Process.Start%2A> автоматически освобождает процесса и подключается к процессу с тот же файл, но полностью нового <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Дополнительные сведения об использовании <xref:System.Diagnostics.Process.Exited> событий в приложениях Windows Forms, см. в разделе <xref:System.Diagnostics.Process.SynchronizingObject%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода создается процесс, который выводит файл. Он выдает <xref:System.Diagnostics.Process.Exited> событий при завершении процесса, так как <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> было установлено при создании процесса. <xref:System.Diagnostics.Process.Exited> Обработчик событий будет отображать сведения о процессе.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время завершения связанного процесса.</summary>
        <value>Класс <see cref="T:System.DateTime" />, показывающий время завершения связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если процесс не был завершен, при попытке получить <xref:System.Diagnostics.Process.ExitTime%2A> свойство вызывает исключение. Используйте <xref:System.Diagnostics.Process.HasExited%2A> перед получением <xref:System.Diagnostics.Process.ExitTime%2A> свойства, чтобы определить, ли завершения связанного процесса.  
  
   
  
## Examples  
 В следующем примере кода создается процесс, который выводит файл. Вызывает процесс <xref:System.Diagnostics.Process.Exited> при выходе и обработчик событий отображает <xref:System.Diagnostics.Process.ExitTime%2A> свойства и другие обработки информации.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.ExitTime" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает новый компонент <see cref="T:System.Diagnostics.Process" /> и связывает его с активным в данный момент процессом.</summary>
        <returns>Новый компонент <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом выполняющегося процесса в вызывающем приложении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания нового <xref:System.Diagnostics.Process> экземпляра и связать его с ресурсом процесса на локальном компьютере.  
  
 Как и подобные <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, и <xref:System.Diagnostics.Process.GetProcesses%2A> методы, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> связывает существующий ресурс с новым <xref:System.Diagnostics.Process> компонента.  
  
   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый компонент <see cref="T:System.Diagnostics.Process" /> и связывает его с существующим заданным ресурсом процесса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">Уникальный в системе идентификатор ресурса процесса.</param>
        <summary>Возвращает новый компонент <see cref="T:System.Diagnostics.Process" />, по заданному идентификатору процесса на локальном компьютере.</summary>
        <returns>Компонент <see cref="T:System.Diagnostics.Process" />, связанный с локальным ресурсом процесса, определенного параметром <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания нового <xref:System.Diagnostics.Process> компонента и связать его с ресурсом процесса на локальном компьютере. Ресурс процесса должен уже существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> не создает системный ресурс, а связывает ресурс с созданным приложением <xref:System.Diagnostics.Process> компонента. Процесс <xref:System.Diagnostics.Process.Id%2A> можно получить только для процесса, который выполняется в данный момент на компьютере. После завершения процесса, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> создает исключение, если он передается идентификатор с истекшим сроком действия.  
  
 На любом конкретном компьютере имеет уникальный идентификатор процесса. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> Возвращает по крайней мере один процесс. Если вы хотите получить все процессы, выполняющие определенное приложение, используйте <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Если существует несколько процессов на компьютере под управлением указанное приложение <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> возвращает массив, содержащий все связанные процессы. Вы можете запрашивать каждый из этих процессов, в свою очередь по его идентификатору. Идентификатор процесса можно просмотреть в `Processes` панели диспетчера задач Windows. `PID` Столбце отображается идентификатор, присвоенный процессу.  
  
 `processId` Параметр <xref:System.Int32> (32-разрядное знаковое целое число), несмотря на то, что использует основной API Windows `DWORD` (32-разрядное целое число без знака) для аналогичный API. Это по историческим причинам.
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Процесс, указанный параметром <paramref name="processId" />, не выполняется. Возможно, истек срок действия идентификатора.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс не был запущен этим объектом.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">Уникальный в системе идентификатор ресурса процесса.</param>
        <param name="machineName">Имя компьютера в сети.</param>
        <summary>Возвращает новый компонент <see cref="T:System.Diagnostics.Process" /> по заданному идентификатору процесса и имени компьютера в сети.</summary>
        <returns>Компонент <see cref="T:System.Diagnostics.Process" />, связанный с удаленным ресурсом процесса, определенного параметром <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания нового <xref:System.Diagnostics.Process> компонента и связать его с ресурсом процесса на удаленном компьютере в сети. Ресурс процесса должен уже существовать на указанном компьютере, так как <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> не создает системный ресурс, а связывает ресурс с созданным приложением <xref:System.Diagnostics.Process> компонента. Процесс <xref:System.Diagnostics.Process.Id%2A> можно получить только для процесса, который выполняется в данный момент на компьютере. После завершения процесса, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> создает исключение, если он передается идентификатор с истекшим сроком действия.  
  
 На любом конкретном компьютере имеет уникальный идентификатор процесса. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> Возвращает по крайней мере один процесс. Если вы хотите получить все процессы, выполняющие определенное приложение, используйте <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Если существует несколько процессов на компьютере под управлением указанное приложение <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> возвращает массив, содержащий все связанные процессы. Вы можете запрашивать каждый из этих процессов, в свою очередь по его идентификатору. Идентификатор процесса можно просмотреть в `Processes` панели диспетчера задач Windows. `PID` Столбце отображается идентификатор, присвоенный процессу.  
  
 Если вы не укажете `machineName`, используется локальный компьютер. Кроме того, можно указать локальный компьютер, установив `machineName` значение «.» или пустую строку (»»).  
  
 `processId` Параметр <xref:System.Int32> (32-разрядное знаковое целое число), несмотря на то, что использует основной API Windows `DWORD` (32-разрядное целое число без знака) для аналогичный API. Это по историческим причинам.   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Процесс, указанный параметром <paramref name="processId" />, не выполняется. Возможно, истек срок действия идентификатора.  
  
-или- 
Недопустимый синтаксис параметра <paramref name="machineName" />. Возможно, имя имеет нулевую длину (0).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="machineName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс не был запущен этим объектом.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает массив из новых компонентов <see cref="T:System.Diagnostics.Process" /> и связывает их с существующими ресурсами процесса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый компонент <see cref="T:System.Diagnostics.Process" /> для каждого ресурса процесса на локальном компьютере.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.Process" />, представляющий все ресурсы процесса, выполняющегося на локальном компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process> компоненты и связать их со всеми ресурсами процесса на локальном компьютере. Ресурсы процесса уже должен существовать на локальном компьютере, так как <xref:System.Diagnostics.Process.GetProcesses%2A> не создает системных ресурсов, а связывает ресурсы с генерируемые приложением <xref:System.Diagnostics.Process> компонентов. Поскольку сама операционная система запускает фоновые процессы, этот массив никогда не пуст.  
  
 Если вы не хотите получить все процессы, выполняемые на компьютере, можно ограничить их количество, с помощью <xref:System.Diagnostics.Process.GetProcessById%2A> или <xref:System.Diagnostics.Process.GetProcessesByName%2A> метод. <xref:System.Diagnostics.Process.GetProcessById%2A> Создает <xref:System.Diagnostics.Process> компонент, связанный с процессом, определяется в системе по идентификатору процесса, который передается методу. <xref:System.Diagnostics.Process.GetProcessesByName%2A> Создает массив <xref:System.Diagnostics.Process> компоненты, связанные ресурсы используют исполняемого файла, передайте методу.  
  
> [!NOTE]
>  Несколько служб Windows могут быть загружены в одном экземпляре процесса узла службы (svchost.exe). GetProcesses не определяет таких отдельных служб. для этого см. в разделе <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Компьютер, из которого читается список процессов.</param>
        <summary>Создает новый компонент <see cref="T:System.Diagnostics.Process" /> для каждого ресурса процесса на указанном компьютере.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.Process" />, представляющий все ресурсы процесса, выполняющегося на указанном компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process> компоненты и связать их со всеми ресурсами процесса на указанном компьютере (обычно удаленном). Ресурсы процесса уже должен существовать на локальном компьютере, так как <xref:System.Diagnostics.Process.GetProcesses%2A> не создает системных ресурсов, а связывает ресурсы с генерируемые приложением <xref:System.Diagnostics.Process> компонентов. Поскольку сама операционная система запускает фоновые процессы, этот массив никогда не пуст.  
  
 Если вы не хотите получить все процессы, выполняемые на компьютере, можно ограничить их количество, с помощью <xref:System.Diagnostics.Process.GetProcessById%2A> или <xref:System.Diagnostics.Process.GetProcessesByName%2A> метод. <xref:System.Diagnostics.Process.GetProcessById%2A> Создает <xref:System.Diagnostics.Process> компонент, связанный с процессом, определяется в системе по идентификатору процесса, который передается методу. <xref:System.Diagnostics.Process.GetProcessesByName%2A> Создает массив <xref:System.Diagnostics.Process> компоненты, связанные ресурсы используют исполняемого файла, передайте методу.  
  
 Эта перегрузка <xref:System.Diagnostics.Process.GetProcesses%2A> метод обычно используется для получения списка ресурсы процесса, выполняющегося на удаленном компьютере в сети, но можно указать локальный компьютер, передав «.».  
  
> [!NOTE]
>  Несколько служб Windows могут быть загружены в одном экземпляре процесса узла службы (svchost.exe). GetProcesses не определяет таких отдельных служб. для этого см. в разделе <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый синтаксис параметра <paramref name="machineName" />. Он может иметь нулевую длину (0).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="machineName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Платформа операционной системы не поддерживает эту операцию на удаленных компьютерах.</exception>
        <exception cref="T:System.InvalidOperationException">Существуют проблемы при доступе к API счетчиков производительности, которые используются для получения сведений о процессе. Это исключение характерно для Windows NT, Windows 2000 и Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла проблема при доступе к базовому системному API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает массив из новых компонентов <see cref="T:System.Diagnostics.Process" /> и связывает их с существующими ресурсами процесса, для которых имя процесса является общедоступным.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Понятное имя процесса.</param>
        <summary>Создает массив из новых компонентов <see cref="T:System.Diagnostics.Process" /> и связывает их со всеми ресурсами процесса на локальном компьютере, для которых заданное имя процесса является общедоступным.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.Process" />, представляющий ресурсы процесса, выполняющего указанное приложение или файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process> компоненты и связать их со всеми ресурсами процесса, работающих под управлением тот же исполняемый файл на локальном компьютере. Ресурсы процесса должен уже существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessesByName%2A> не создает системных ресурсов, а связывает их с генерируемые приложением <xref:System.Diagnostics.Process> компонентов. Объект `processName` может быть указан для исполняемого файла, который в настоящий момент не выполняется на локальном компьютере, поэтому этот метод возвращает массив может быть пустым.  
  
 Имя процесса — это понятное имя для процесса, например Outlook, который не поддерживает расширения .exe или путь. <xref:System.Diagnostics.Process.GetProcessesByName%2A> полезно для получения и обработки всех процессов, которые связаны с тот же исполняемый файл. Например, можно передать имя исполняемого файла как `processName` параметр, чтобы завершить работу всех выполняющихся экземпляров этого исполняемого файла.  
  
 Хотя процесс <xref:System.Diagnostics.Process.Id%2A> является уникальным для одного ресурса процесса в системе, несколько процессов на локальном компьютере могут работать под управлением приложения, указанного `processName` параметра. Таким образом <xref:System.Diagnostics.Process.GetProcessById%2A> возвращает один процесс по крайней мере, но <xref:System.Diagnostics.Process.GetProcessesByName%2A> возвращает массив, содержащий все связанные процессы. Если вам нужно управлять с помощью стандартных вызовов API, можно запросить каждый из этих процессов, в свою очередь по его идентификатору. Воспользоваться ресурсами процесса процесса только через имя, но, после получения массив <xref:System.Diagnostics.Process> компоненты, которые были связаны с ресурсами процесса, можно запустить, окончания и управлять ресурсами системы.  
  
   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Существуют проблемы при доступе к API счетчиков производительности, которые используются для получения сведений о процессе. Это исключение характерно для Windows NT, Windows 2000 и Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Понятное имя процесса.</param>
        <param name="machineName">Имя компьютера в сети.</param>
        <summary>Создает массив из новых компонентов <see cref="T:System.Diagnostics.Process" /> и связывает их со всеми ресурсами процесса на удаленном компьютере, для которых заданное имя процесса является общедоступным.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.Process" />, представляющий ресурсы процесса, выполняющего указанное приложение или файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process> компоненты и связать их со всеми ресурсами процесса, работающих под управлением тот же исполняемый файл на указанном компьютере. Ресурсы процесса должен уже существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessesByName%2A> не создает системных ресурсов, а связывает их с генерируемые приложением <xref:System.Diagnostics.Process> компонентов. Объект `processName` может быть указан для исполняемого файла, который в настоящий момент не выполняется на локальном компьютере, поэтому этот метод возвращает массив может быть пустым.  
  
 Имя процесса — это понятное имя для процесса, например Outlook, который не поддерживает расширения .exe или путь. <xref:System.Diagnostics.Process.GetProcessesByName%2A> полезно для получения и обработки всех процессов, которые связаны с тот же исполняемый файл. Например, можно передать имя исполняемого файла как `processName` параметр, чтобы завершить работу всех выполняющихся экземпляров этого исполняемого файла.  
  
 Хотя процесс <xref:System.Diagnostics.Process.Id%2A> является уникальным для одного ресурса процесса в системе, несколько процессов на локальном компьютере могут работать под управлением приложения, указанного `processName` параметра. Таким образом <xref:System.Diagnostics.Process.GetProcessById%2A> возвращает один процесс по крайней мере, но <xref:System.Diagnostics.Process.GetProcessesByName%2A> возвращает массив, содержащий все связанные процессы. Если вам нужно управлять с помощью стандартных вызовов API, можно запросить каждый из этих процессов, в свою очередь по его идентификатору. Воспользоваться ресурсами процесса процесса только через имя, но, после получения массив <xref:System.Diagnostics.Process> компоненты, которые были связаны с ресурсами процесса, можно запустить, окончания и управлять ресурсами системы.  
  
 Можно использовать эту перегрузку для получения процессов на локальном компьютере, а также на удаленном компьютере. Используйте «.» для указания локального компьютера. Существует другая перегрузка, которая по умолчанию используется локальный компьютер.  
  
 Процессы на удаленных компьютерах только для того, чтобы просмотреть сведения о процессах, например статистика, доступны. Невозможно закрыть, завершать (с помощью <xref:System.Diagnostics.Process.Kill%2A>), или запускать процессы на удаленных компьютерах.  
  
   
  
## Examples  
 Следующий пример извлекает сведения текущего процесса, запущенного на локальном компьютере, все экземпляры Блокнота, выполняющиеся на локальном компьютере и определенного процесса на локальном компьютере. Затем он извлекает сведения для те же процессы на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый синтаксис параметра <paramref name="machineName" />. Он может иметь нулевую длину (0).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="machineName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Платформа операционной системы не поддерживает эту операцию на удаленных компьютерах.</exception>
        <exception cref="T:System.InvalidOperationException">Попытка подключиться к <paramref name="machineName" /> завершилась ошибкой.

-или- 
Существуют проблемы при доступе к API счетчиков производительности, которые используются для получения сведений о процессе. Это исключение характерно для Windows NT, Windows 2000 и Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла проблема при доступе к базовому системному API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">на вызов неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает собственный дескриптор связанного процесса.</summary>
        <value>Дескриптор, присвоенный процессу операционной системой при запуске. Система использует этот дескриптор для хранения атрибутов процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение может получить дескриптор к процессу, который может использоваться в качестве параметра для многих функций управления и обработки информации. Вы можете использовать этот дескриптор для инициализации <xref:System.Threading.WaitHandle> или вызывать вызова собственных методов с платформой.  
  
 Дескриптор процесса является закрытым для приложения — другими словами, обрабатывающим маркеры не могут совместно использоваться. Процесс также имеет <xref:System.Diagnostics.Process.Id%2A> которой, в отличие от <xref:System.Diagnostics.Process.Handle%2A>, является уникальным и, следовательно, допустимое во всей системе.  
  
 Только процессы, запущенные посредством вызова <xref:System.Diagnostics.Process.Start%2A> задать <xref:System.Diagnostics.Process.Handle%2A> свойства соответствующего элемента <xref:System.Diagnostics.Process> экземпляров.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не был запущен или был завершен. Невозможно прочитать свойство <see cref="P:System.Diagnostics.Process.Handle" />, поскольку ни один процесс не связан с этим экземпляром <see cref="T:System.Diagnostics.Process" />.  
  
-или- 
Экземпляр <see cref="T:System.Diagnostics.Process" /> был присоединен к запущенному процессу, но у вас нет необходимых разрешений для получения маркера с полными правами доступа.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.Handle" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает число дескрипторов, открытых процессом.</summary>
        <value>Число дескрипторов операционной системы, открытых процессом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дескрипторы предоставляют способ для процесса, для ссылки на объекты. Процесс может получать дескрипторы файлов, ресурсы, очереди сообщений и множество других объектов операционной системы. Операционная система освобождает память, связанный с процессом, только в том случае, когда значение счетчика дескрипторов равно нулю.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для свойства <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее завершение связанного процесса.</summary>
        <value>Значение <see langword="true" />, если процесс операционной системы, на который ссылается компонент <see cref="T:System.Diagnostics.Process" />, был завершен; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `true` для <xref:System.Diagnostics.Process.HasExited%2A> указывает, что связанный процесс был завершен обычным образом или аварийно. Вы можете запросить или принудительно закрыть путем вызова связанного процесса <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Если дескриптор открыт к процессу, операционная система освобождает память процесса, когда процесс завершен, но сохраняет административную информацию о процессе, такие как дескриптор, код выхода и время выхода. Чтобы получить эти сведения, можно использовать <xref:System.Diagnostics.Process.ExitCode%2A> и <xref:System.Diagnostics.Process.ExitTime%2A> свойства. Эти свойства заполняются автоматически для процессов, которые были запущены этим компонентом. Административные сведения раскрываются при всех <xref:System.Diagnostics.Process> компоненты, связанные с системным процессом, уничтожаются и больше не содержат дескрипторов завершенных процессов.  
  
 Процесс может завершиться независимо от кода. Если вы начали процесс, с помощью этого компонента, система обновляет значение <xref:System.Diagnostics.Process.HasExited%2A> автоматически, даже если связанный процесс завершается независимо друг от друга.  
  
> [!NOTE]
>  Когда стандартный вывод был перенаправлен к асинхронных обработчиков событий, это возможно, что обработка вывода не будет завершена, когда это свойство возвращает `true`. Чтобы гарантировать завершение асинхронной обработки событий, вызвать <xref:System.Diagnostics.Process.WaitForExit> перегрузку, принимающую параметр не перед проверкой <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем он получает использование физической памяти связанного процесса с 2-секундным интервалом не более 10 секунд. В данном примере отслеживается ли процесс завершается до истечения 10 секунд. Пример закрывает процесс, если оно по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">С объектом не связаны никакие процессы.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удалось получить код выхода для процесса.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.HasExited" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает уникальный идентификатор связанного процесса.</summary>
        <value>Созданный системой уникальный идентификатор, на который ссылается этот экземпляр <see cref="T:System.Diagnostics.Process" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Процесс <xref:System.Diagnostics.Process.Id%2A> не допускается, если связанный процесс не выполняется. Таким образом, следует убедиться, что процесс выполняется до получения <xref:System.Diagnostics.Process.Id%2A> свойство. До завершения процесса, идентификатор процесса однозначно идентифицирует процесс во всей системе.  
  
 Вы можете подключиться к процессу, выполняющемуся на локальном или удаленном компьютере в новый <xref:System.Diagnostics.Process> экземпляр, передав идентификатор процесса для <xref:System.Diagnostics.Process.GetProcessById%2A> метод. <xref:System.Diagnostics.Process.GetProcessById%2A> — `static` метод, который создает новый компонент и задает <xref:System.Diagnostics.Process.Id%2A> свойства для нового <xref:System.Diagnostics.Process> экземпляр автоматически.  
  
 Идентификаторы процессов может многократно использоваться системой. <xref:System.Diagnostics.Process.Id%2A> Значение свойства является уникальным только в том случае, пока выполняется связанный процесс. После завершения процесса, можно повторно использовать системы <xref:System.Diagnostics.Process.Id%2A> значение свойства для несвязанного процесса.  
  
 Так как этот идентификатор уникален в системе, можно передать его для других потоков в качестве альтернативы для передачи <xref:System.Diagnostics.Process> экземпляра. Это действие может сэкономить ресурсы системы, но гарантирует, что процесс определяется правильно.  
  
   
  
## Examples  
 В следующем примере демонстрируется получение <xref:System.Diagnostics.Process.Id%2A> для всех экземпляров приложения. Код создает новый экземпляр блокнота, выводит список всех экземпляров Блокнота и затем позволяет пользователю ввести <xref:System.Diagnostics.Process.Id%2A> номер для удаления конкретного экземпляра.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Diagnostics.Process.Id" /> процесса не задано.  
  
-или- 
С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для свойства <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Немедленно останавливает связанный процесс.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> Принудительное завершение процесса, хотя <xref:System.Diagnostics.Process.CloseMainWindow%2A> только запрашивает завершения. При выполнении процесса с графическим интерфейсом, цикл сообщений находится в состоянии ожидания. Цикл обработки сообщений выполняется каждый раз, отправляется сообщение Windows для процесса операционной системой. Вызов <xref:System.Diagnostics.Process.CloseMainWindow%2A> отправляет запрос на закрытие главного окна, которое закрывает дочерние окна и отменяет все выполняющиеся циклы сообщений для приложения в приложении правильного формата. Запрос на завершение процесса путем вызова <xref:System.Diagnostics.Process.CloseMainWindow%2A> не вынуждает приложения, чтобы выйти из программы. Приложение может запросить проверку пользователя перед завершением работы или она может отклонить выйти из программы. Чтобы принудительно запустить приложение, чтобы выйти из программы, используйте <xref:System.Diagnostics.Process.Kill%2A> метод. Поведение <xref:System.Diagnostics.Process.CloseMainWindow%2A> уже имеется у пользователя закрытие главного окна приложения, используя системное меню. Таким образом запрос на завершение процесса, закрыв главное окно не вынуждает приложения, чтобы немедленно выйти из программы.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A> Метод выполняется асинхронно. После вызова метода <xref:System.Diagnostics.Process.Kill%2A> мы вызываем метод <xref:System.Diagnostics.Process.WaitForExit%2A> метод для ожидания завершения выполнения или проверка процесса <xref:System.Diagnostics.Process.HasExited%2A> свойства, чтобы определить, если процесс завершился.  
  
 Данные изменены процессом или ресурсы, выделенные для процесса могут быть потеряны при вызове метода <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> вызывает аварийного завершения процесса и должен использоваться только в случае необходимости. <xref:System.Diagnostics.Process.CloseMainWindow%2A> включает упорядоченной остановки процесса и закрывает все окна, поэтому рекомендуется для приложений с интерфейсом. Если <xref:System.Diagnostics.Process.CloseMainWindow%2A> завершается ошибкой, можно использовать <xref:System.Diagnostics.Process.Kill%2A> завершить процесс. <xref:System.Diagnostics.Process.Kill%2A> является единственным способом завершить процессы, не имеющих графического интерфейса.  
  
 Можно вызвать <xref:System.Diagnostics.Process.Kill%2A> и <xref:System.Diagnostics.Process.CloseMainWindow%2A> только для процессов, запущенных на локальном компьютере. Не удается вызвать процессов на удаленных компьютерах, чтобы выйти из. Кроме того, можно только просматривать информацию для процессов, выполняющихся на удаленных компьютерах.  
  
> [!NOTE]
>  Если вызов <xref:System.Diagnostics.Process.Kill%2A> метод выполняется, хотя в настоящее время выполняется завершение процесса, <xref:System.ComponentModel.Win32Exception> для отказано в доступе возникает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Связанный процесс не может быть завершен.  
  
-или- 
Выполняется завершение процесса.  
  
-или- 
Связанный процесс является исполняемым файлом Win16.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь вызвать метод <see cref="M:System.Diagnostics.Process.Kill" /> для процесса, выполняющегося на удаленном компьютере. Этот метод доступен только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Этот процесс уже завершился.  
  
-или- 
С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill (bool entireProcessTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill(bool entireProcessTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (entireProcessTree As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill(bool entireProcessTree);" />
      <MemberSignature Language="F#" Value="member this.Kill : bool -&gt; unit" Usage="process.Kill entireProcessTree" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entireProcessTree" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="entireProcessTree">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выбирает компонент <see cref="T:System.Diagnostics.Process" /> из состояния, позволяющего ему взаимодействовать с процессами операционной системы, запущенными в специальном режиме.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые процессы операционной системы выполните в специальном режиме. Чтение свойств или подключиться к этим процессам не поддерживается, если не был вызван <xref:System.Diagnostics.Process.EnterDebugMode%2A> в компоненте. Вызовите <xref:System.Diagnostics.Process.LeaveDebugMode%2A> при вам больше не нужен доступ к процессам, выполняющимся в специальном режиме.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя компьютера, на котором выполняется связанный процесс.</summary>
        <value>Имя компьютера, на котором выполняется связанный процесс.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно просмотреть статистические данные и сведения о процессе для процессов, запущенных на удаленном компьютере, но не может вызвать <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, или <xref:System.Diagnostics.Process.Kill%2A> на удаленных компьютерах.  
  
> [!NOTE]
>  При выполнении процесса на локальном компьютере, это свойство возвращает точку (".») для имени компьютера. Следует использовать <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство для получения имени правильный.  
  
   
  
## Examples  
 Для использования в следующем примере, необходимо сначала запустите хотя бы один экземпляр блокнота на удаленном компьютере. Приведенный пример запрашивает имя удаленного компьютера, на котором выполняется Блокнот, а затем отображает соответствующие <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, и <xref:System.Diagnostics.Process.MachineName%2A> свойства для каждого экземпляра.  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает главный модуль связанного процесса.</summary>
        <value>Модуль <see cref="T:System.Diagnostics.ProcessModule" />, который был использован для запуска процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Модуль процесса представляет файл.dll или .exe, загруженный в определенный процесс. <xref:System.Diagnostics.Process.MainModule%2A> Свойство позволяет просматривать сведения об исполняемом файле, используемая для запуска процесса, включая имя модуля, имя файла и сведения о модуле памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MainModule" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32-разрядный процесс пытается получить доступ к модулям 64-разрядного процесса.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.  
  
-или- 
Процесс завершен.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает дескриптор главного окна связанного процесса.</summary>
        <value>Созданный системой дескриптор главного окна связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Главное окно является окном, открытых процессом, который в данный момент имеет фокус ( <xref:System.Windows.Forms.Form.TopLevel%2A> формы). Необходимо использовать <xref:System.Diagnostics.Process.Refresh%2A> метод для обновления <xref:System.Diagnostics.Process> объекта, чтобы получить текущий дескриптор главного окна, если он был изменен. Как правило, так как дескриптор окна кэшируется, использовать <xref:System.Diagnostics.Process.Refresh%2A> заранее, чтобы гарантировать, что вы сможете извлекать текущий дескриптор.  
  
 Вы можете получить <xref:System.Diagnostics.Process.MainWindowHandle%2A> свойство только для процессов, запущенных на локальном компьютере. <xref:System.Diagnostics.Process.MainWindowHandle%2A> Свойство имеет значение, которое однозначно определяет окно, связанный с процессом.  
  
 Процесс имеет главное окно, связанное с ним, только в том случае, если процесс имеет графический интерфейс. Если связанный процесс не имеет главного окна, <xref:System.Diagnostics.Process.MainWindowHandle%2A> значение равно нулю. Значение равно нулю для процессов, которые были скрыты, то есть процессов, которые не отображаются на панели задач. Это может быть справедливо для процессов, которые отображаются в области уведомлений в правой части панели задач в виде значков.  
  
 Если вы только что запущен процесс и хотите использовать дескриптор главного окна, рассмотрите возможность использования <xref:System.Diagnostics.Process.WaitForInputIdle%2A> метод, который позволяет процессу завершить запуск, убедившись, что был создан дескриптор главного окна. В противном случае будет создаваться исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> не определено, так как процесс завершился.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает заголовок главного окна процесса.</summary>
        <value>Заголовок главного окна процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Процесс имеет главное окно, связанное с ним, только в том случае, если процесс имеет графический интерфейс. Если связанный процесс не имеет главного окна (таким образом, чтобы <xref:System.Diagnostics.Process.MainWindowHandle%2A> равно нулю), <xref:System.Diagnostics.Process.MainWindowTitle%2A> является пустой строкой (»»). Если вы только что запущен процесс и хотите использовать заголовок главного окна, рассмотрите возможность использования <xref:System.Diagnostics.Process.WaitForInputIdle%2A> метод, который позволяет процессу завершить запуск, убедившись, что был создан дескриптор главного окна. В противном случае система создает исключение.  
  
> [!NOTE]
>  Главное окно — окно, которое в данный момент имеет фокус; Обратите внимание на то, что это может быть основного окна процесса. Необходимо использовать <xref:System.Diagnostics.Process.Refresh%2A> метод для обновления <xref:System.Diagnostics.Process> объекта, чтобы получить текущий дескриптор главного окна, если он был изменен.  
  
   
  
## Examples  
 Следующий пример запускает экземпляр блокнота и получает заголовок главного окна процесса.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> не определено, так как процесс завершился.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальный допустимый размер рабочего множества (в байтах) для связанного процесса.</summary>
        <value>Максимальный размер рабочего множества в байтах, доступного в памяти для процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рабочий набор процесса — это набор страниц памяти, видимой в данный момент к процессу в физической памяти ОЗУ. Эти страницы являются резидентными и доступны для приложения для использования без создания ошибки страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые приложения, включая страницы в DLL-файлы и файлы system.dll. При увеличении размера рабочего набора, увеличивает требуемый объем памяти.  
  
 Процесс имеет минимальный и Максимальный рабочий набор размеров. Каждый раз, когда создается ресурс процесса, система резервирует объем памяти, равным минимальный размер рабочего множества для процесса. Диспетчер виртуальной памяти пытается сохранить по крайней мере минимальный объем памяти резидентной, когда процесс активен, но никогда не хранит больше, чем максимальный размер.  
  
 Система устанавливает значение по умолчанию размеров рабочего набора. Вы можете изменить эти размеры, используя <xref:System.Diagnostics.Process.MaxWorkingSet%2A> и <xref:System.Diagnostics.Process.MinWorkingSet%2A> членов. Тем не менее настройке этих значений не гарантирует что память будет зарезервированной или находящейся.  
  
> [!NOTE]
>  При увеличении размера рабочего множества процесса, можно воспользоваться физической памяти отдельно от системы. Убедитесь в том, не требуют размер минимальное или максимальное рабочего набора, в которой слишком велика, поскольку это может снизить производительность системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Максимальный размер рабочего множества является недопустимым. Это значение должно быть больше минимального размера рабочего множества или равно ему.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается получить сведения о рабочем множестве из ресурса связанного процесса.  
  
-или- 
Идентификатор или дескриптор процесса равен нулю, так как процесс не запущен.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.  
  
-или- 
Процесс завершен.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает минимальный допустимый размер рабочего множества (в байтах) для связанного процесса.</summary>
        <value>Минимальный размер рабочего множества в байтах, требуемый в памяти для процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рабочий набор процесса — это набор страниц памяти, видимой в данный момент к процессу в физической памяти ОЗУ. Эти страницы являются резидентными и доступны для приложения для использования без создания ошибки страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые приложения, включая страницы в DLL-файлы и файлы system.dll. При увеличении размера рабочего набора, увеличивает требуемый объем памяти.  
  
 Процесс имеет минимальный и Максимальный рабочий набор размеров. Каждый раз, когда создается ресурс процесса, система резервирует объем памяти, равным минимальный размер рабочего множества для процесса. Диспетчер виртуальной памяти пытается сохранить по крайней мере минимальный объем памяти резидентной, когда процесс активен, но никогда не хранит больше, чем максимальный размер.  
  
 Система устанавливает значение по умолчанию размеров рабочего набора. Вы можете изменить эти размеры, используя <xref:System.Diagnostics.Process.MaxWorkingSet%2A> и <xref:System.Diagnostics.Process.MinWorkingSet%2A> членов. Тем не менее настройке этих значений не гарантирует что память будет зарезервированной или находящейся.  
  
> [!NOTE]
>  При увеличении размера рабочего множества процесса, можно воспользоваться физической памяти отдельно от системы. Убедитесь в том, не требуют размер минимальное или максимальное рабочего набора, в которой слишком велика, поскольку это может снизить производительность системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Минимальный размер рабочего множества является недопустимым. Это значение должно быть не больше максимального размера рабочего множества.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается получить сведения о рабочем множестве из ресурса связанного процесса.  
  
-или- 
Идентификатор или дескриптор процесса равен нулю, так как процесс не запущен.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.  
  
-или- 
Процесс завершен.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает модули, которые были загружены связанным процессом.</summary>
        <value>Массив объектов типа <see cref="T:System.Diagnostics.ProcessModule" />, который предоставляет модули, загруженные связанным процессом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Модуль процесса представляет файл.dll или .exe, загруженный в определенный процесс. Объект <xref:System.Diagnostics.ProcessModule> экземпляра позволяет просматривать сведения о модуле, включая имя модуля, имя файла и сведения о модуле памяти.  
  
 Процесс можно загрузить несколько модулей в память. Например файлы .exe, которые загружают Дополнительные DLL-файлы имеют несколько модулей.  
  
 После запуска процесса, эта коллекция пуста, пока процесс загрузки системы. Если процесс имеет главное окно, можно вызвать <xref:System.Diagnostics.Process.WaitForInputIdle%2A> до получения этого свойства, чтобы убедиться, что коллекция не пуста при получения списка.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.Modules" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.Modules" /> системного или бездействующего процесса. Эти процессы не имеют модулей.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем невыгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенной системой для связанного процесса, который нельзя записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем невыгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Количество системной памяти в байтах, выделенной для связанного процесса, которую нельзя записать в файл подкачки виртуальной памяти.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер невыгружаемой системной памяти, используемой процессом, в байтах. Системной памяти — это физическая память, используемые операционной системой и делится разбитого на страницы и невыгружаемые пулы. Выделение памяти в невыгружаемом страничном остаются в системной памяти и не выгружаются в файл подкачки виртуальной памяти.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **байт в невыгружаемом страничном пуле** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает событие <see cref="E:System.Diagnostics.Process.Exited" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> — метод API, который вызывает <xref:System.Diagnostics.Process.Exited> событий. Вызов <xref:System.Diagnostics.Process.OnExited%2A> вызывает <xref:System.Diagnostics.Process.Exited> возникновения события и является единственным способом для вызова событий с помощью <xref:System.Diagnostics.Process> компонента. <xref:System.Diagnostics.Process.OnExited%2A> используется главным образом при наследовании классов от компонента.  
  
 Как альтернативу <xref:System.Diagnostics.Process.OnExited%2A>, можно написать собственный обработчик событий. Вы создадите собственный делегат обработчика событий и собственного метода обработки событий.  
  
> [!NOTE]
>  Если вы используете среду Visual Studio, делегат обработчика событий (AddOnExited) и метод обработки событий (Process1_Exited) создаются автоматически при перетаскивании <xref:System.Diagnostics.Process> компонента в форму и дважды щелкните значок. Создаваемый код, необходимо выполнить после <xref:System.Diagnostics.Process.Exited> вводится в процедуру Process1_Exited событием. Необходимо создать <xref:System.Diagnostics.Process.OnExited%2A> члена, так как он реализуется автоматически.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Diagnostics.Process.OnExited%2A> метод в производном классе.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда приложение записывает строку в свой перенаправленный поток <see cref="P:System.Diagnostics.Process.StandardOutput" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived> Указывает, что связанный <xref:System.Diagnostics.Process> написал линию, завершается с символом новой строки в свой перенаправленный <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
 Событие включено во время асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>. Для запуска асинхронных операций чтения, необходимо перенаправить <xref:System.Diagnostics.Process.StandardOutput%2A> поток <xref:System.Diagnostics.Process>, добавьте в обработчик событий для <xref:System.Diagnostics.Process.OutputDataReceived> событий и вызовов <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. После этого <xref:System.Diagnostics.Process.OutputDataReceived> сообщения о событиях каждый раз, когда процесс записывает строку в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> потоковую передачу, пока процесс завершает работу или вызывает <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  Приложение, которое обрабатывается асинхронный выход должен вызывать <xref:System.Diagnostics.Process.WaitForExit%2A> метод, чтобы гарантировать, что была записана в выходной буфер.  
  
   
  
## Examples  
 Следующий пример иллюстрирует способ выполнения асинхронных операций чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> поток `ipconfig` команды.  
  
 В примере создается делегат события для `OutputHandler` обработчик событий и связывает его с <xref:System.Diagnostics.Process.OutputDataReceived> событий. Обработчик событий получает строки текста из перенаправленного <xref:System.Diagnostics.Process.StandardOutput%2A> поток, форматирует текст и сохраняет его в выходной строке, который более поздней версии отображается в окне консоли данного примера.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенной связанным процессом, который можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенной в файле подкачки виртуальной памяти для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер памяти в файл подкачки виртуальной памяти, используемой процессом, в байтах. Операционная система использует файл подкачки виртуальной памяти в сочетании с физической памяти для управления виртуального адресного пространства для каждого процесса. После выгружаемой памяти не используется, его можно переместить в файл подкачки виртуальной памяти на диске. Чтобы получить объем памяти, используемой операционной системы для процесса, используйте <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> свойство.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **байт файла подкачки** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр программы Блокнот и извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенной системой для связанного процесса, который можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Количество системной памяти в байтах, выделенной для связанного процесса, которую можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое значение этого свойства представляет текущий объем выгружаемой системной памяти, используемой процессом, в байтах. Системной памяти — это физическая память, используемые операционной системой и делится разбитого на страницы и невыгружаемые пулы. После выгружаемой памяти не используется, его можно переместить в файл подкачки виртуальной памяти на диске. Чтобы получить объем памяти приложения, используемые в процессе, используйте <xref:System.Diagnostics.Process.PagedMemorySize64%2A> свойство.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **байт в выгружаемом страничном пуле** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем памяти в байтах в файле подкачки виртуальной памяти, используемой связанным процессом.</summary>
        <value>Максимальный объем памяти в байтах, выделенной связанным процессом, который можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем памяти в байтах в файле подкачки виртуальной памяти, используемой связанным процессом.</summary>
        <value>Максимальное количество памяти в байтах, выделенной в файле подкачки виртуальной памяти для связанного процесса с момента его запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое значение этого свойства представляет максимальный размер памяти в файле подкачки виртуальной памяти, используемой процессом с момента его запуска, в байтах. Операционная система использует файл подкачки виртуальной памяти в сочетании с физической памяти для управления виртуального адресного пространства для каждого процесса. После выгружаемой памяти не используется, его можно переместить в файл подкачки виртуальной памяти на диске.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **байтов файла подкачки (пик)** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем виртуальной памяти (в байтах), используемой связанным процессом.</summary>
        <value>Максимальный объем виртуальной памяти в байтах, запрошенной связанным процессом.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем виртуальной памяти (в байтах), используемой связанным процессом.</summary>
        <value>Максимальное количество виртуальной памяти в байтах, выделенной для связанного процесса с момента его запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством представляет максимальный объем виртуальной памяти, используемой процессом с момента его запуска, в байтах. Операционная система сопоставляет виртуального адресного пространства для каждого процесса, либо на страницы загрузки в физической памяти, или на страницы хранятся в файле подкачки виртуальной памяти на диске.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **виртуальных байт (пик)** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальный размер рабочего множества для связанного процесса (в байтах).</summary>
        <value>Максимальный объем физической памяти, запрошенной связанным процессом одновременно (в байтах).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рабочий набор процесса — это набор страниц памяти, видимой в данный момент к процессу в физической памяти ОЗУ. Эти страницы являются резидентными и доступны для приложения для использования без создания ошибки страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая модули процессов и системных библиотек.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем физической памяти (в байтах), используемой связанным процессом.</summary>
        <value>Максимальный объем физической памяти в байтах, выделенной для связанного процесса с момента его запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством представляет максимальный размер памяти рабочего множества, используемой процессом с момента его запуска, в байтах. Рабочий набор процесса — это набор страниц памяти, видимой в данный момент к процессу в физической памяти ОЗУ. Эти страницы являются резидентными и доступны для приложения для использования без создания ошибки страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая инструкции из модулей процесса и системных библиотек.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **рабочий набор пик** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должна ли операционная система временно увеличить приоритет связанного процесса, когда основное окно процесса получит фокус.</summary>
        <value>Значение <see langword="true" />, если требуется динамическое увеличение приоритета процесса, когда процесс выходит из состояния ожидания; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если поток выполняется в процессе, для которого класс приоритета имеет одно из значений перечисления динамического приоритета (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, или <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), система временно увеличивает приоритет потока, когда он извлекается из состояния ожидания. Это действие предотвращает прерывание обработки текущего потока другими процессами. <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Влияет на все существующие потоки и все потоки, созданные в процессе впоследствии. Чтобы восстановить нормальное поведение, задайте <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> свойства `false`.  
  
> [!NOTE]
>  Бустинг слишком высокого приоритета может привести к утечке ресурсов операционную систему и сетевые функции, вызывающих проблемы с другими задачами операционной системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается получить информацию о повышении приоритета от связанного ресурса процесса.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.  
  
-или- 
Идентификатор процесса или дескриптор процесса равен нулю. (Процесс не был запущен.)</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает общую категорию приоритета для процесса.</summary>
        <value>Категория приоритета для связанного процесса, из которой вычисляется свойство <see cref="P:System.Diagnostics.Process.BasePriority" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс приоритета процесса включает диапазон уровней приоритета потоков. Потоки с различными приоритетами, которые выполняются в процессе выполнения по отношению к классу приоритета процесса. Win32 использует четыре класса приоритета 7 уровней базовый приоритет каждого класса. Эти классы приоритета процесса, будут записываться в <xref:System.Diagnostics.ProcessPriorityClass> перечисления, который позволяет присвоить приоритет процесса <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, или <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. На основе времени, затраченного или других показателях, базовый уровень приоритета может быть изменен в операционной системе, когда процесс необходимо поставить перед другим пользователям для доступа к процессору. Кроме того, можно задать <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> временно повысить уровень приоритета потоков, которые были взяты из состояния ожидания. Приоритет сбрасывается при возвращении процесса в состояние ожидания.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> Свойство позволяет просмотреть начальный приоритет, назначенный к процессу. Тем не менее, так как документ доступен только для чтения, нельзя использовать <xref:System.Diagnostics.Process.BasePriority%2A> свойство для задания приоритета процесса. Чтобы изменить приоритет, используйте <xref:System.Diagnostics.Process.PriorityClass%2A> свойство, которое получает или задает общую категорию приоритета для процесса.  
  
 Класс приоритета нельзя просмотреть с помощью системного монитора. В следующей таблице показаны связи между <xref:System.Diagnostics.Process.BasePriority%2A> и <xref:System.Diagnostics.Process.PriorityClass%2A> значения.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается задать или получить сведения о приоритете процесса от связанного ресурса процесса.  
  
-или- 
Идентификатор процесса или дескриптор процесса равен нулю. (Процесс не был запущен.)</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.PriorityClass" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Вы задали для класса <see cref="P:System.Diagnostics.Process.PriorityClass" /> значение <see langword="AboveNormal" /> или <see langword="BelowNormal" /> при использовании Windows 98 или Windows Millennium Edition (Windows Me). Эти платформы не поддерживают такие значения для класса приоритета.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Невозможно задать класс приоритета, поскольку он не использует допустимое значение, как определено в перечислении <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объем закрытой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Число байтов, выделенных связанным процессом, которые не могут быть доступны другим процессам.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объем закрытой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенное для связанного процесса, которое не может быть доступно другим процессам.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством представляет текущий объем памяти, используемой процессом, в байтах, которые нельзя использовать совместно с другими процессами.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **байт исключительного пользования** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает права доступа на время процессора для этого процесса.</summary>
        <value>Класс <see cref="T:System.TimeSpan" />, показывающий количество времени, которое процесс потратил на выполнение кода внутри ядра операционной системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя процесса.</summary>
        <value>Имя, которое использует система для идентификации процесса для пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A> Свойство содержит имя исполняемого файла, например Outlook, который не поддерживает расширения .exe или путь. Это полезно для получения и обработки всех процессов, которые связаны с тот же исполняемый файл.  
  
> [!NOTE]
>  На [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] операционных систем, <xref:System.Diagnostics.Process.ProcessName%2A> свойство может быть усечена до 15 символов, если не удается получить сведения о процессе модуля.  
  
 Можно вызвать <xref:System.Diagnostics.Process.GetProcessesByName%2A>, передавая ему имя исполняемого файла, чтобы получить массив, содержащий каждого запущенного экземпляра на указанном компьютере. Этот массив, например, можно использовать для завершения работы всех выполняющихся экземпляров исполняемого файла.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не имеет идентификатора, или нет процесса, связанного с <see cref="T:System.Diagnostics.Process" />.  
  
-или- 
Связанный процесс завершился.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">Процесс отсутствует на этом компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает процессоры, на которых может быть запланировано выполнение потоков данного процесса.</summary>
        <value>Битовая маска, представляющая процессоры, на которых могут выполняться потоки связанного процесса. По умолчанию маска зависит от числа процессоров в компьютере. Значение по умолчанию — 2 <sup>n</sup> -1, где n — число процессоров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В Windows 2000 и более поздних версиях поток в процессе можно перенести из процессора на процессор, с помощью каждую операцию миграции обновление кэша процессора. При больших системных нагрузках указав какой процессор должен выполняться в определенном потоке может повысить производительность за счет сокращения числа перезагрузок кэша процессора. Связь между процессор и поток называется соответствием процессоров.  
  
 Каждый процессор представляется как битовое. Бит 0 — это первый процессор, 1-й бит — второй процессор и т. д. Если задать бита значение 1, соответствующий процессор будет выбрана для назначения потоков. При задании <xref:System.Diagnostics.Process.ProcessorAffinity%2A> значение, равное нулю, операционной системы планирование алгоритмов набора сходство потоков. Когда <xref:System.Diagnostics.Process.ProcessorAffinity%2A> значение задано любое ненулевое значение, значение интерпретируется как битовую маску, определяющую процессоры, годные для выбора.  
  
 В следующей таблице показаны подборку <xref:System.Diagnostics.Process.ProcessorAffinity%2A> значения для восьмипроцессорной системы.  
  
|Битовая маска|Двоичное значение|Подходящие процессоры|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 и 2|  
|0x0007|00000000 00000111|1, 2 и 3|  
|0x0009|00000000 00001001|1 и 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 и 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается задать или получить сведения о <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> от связанного ресурса процесса.  
  
-или- 
Идентификатор процесса или дескриптор процесса равен нулю. (Процесс не был запущен.)</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.  
  
-или- 
Процесс завершен.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет любые кэшированные внутри компонента процесса сведения о связанном процессе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После <xref:System.Diagnostics.Process.Refresh%2A> вызывается, первый запрос для сведения о каждом свойстве компонент процесса получает новое значение из связанного процесса.  
  
 Когда <xref:System.Diagnostics.Process> компонент связан с ресурсом процесса, значения свойств <xref:System.Diagnostics.Process> немедленно заполняются в соответствии с состояние связанного процесса. Если сведения о связанном процессе впоследствии изменяется, эти изменения не отражаются в <xref:System.Diagnostics.Process> компонента кэшированных значений. <xref:System.Diagnostics.Process> Компонент является моментальным снимком ресурса процесса на момент они связаны. Чтобы просмотреть текущие значения для связанного процесса, вызовите <xref:System.Diagnostics.Process.Refresh%2A> метод.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем он получает использование физической памяти связанного процесса с 2-секундным интервалом не более 10 секунд. В данном примере отслеживается ли процесс завершается до истечения 10 секунд. Пример закрывает процесс, если оно по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, отвечает или нет пользовательский интерфейс.</summary>
        <value>Значение <see langword="true" />, если пользовательский интерфейс связанного процесса отвечает системе; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если процесс имеет пользовательский интерфейс, <xref:System.Diagnostics.Process.Responding%2A> связывается пользовательский интерфейс, чтобы определить, отвечает ли процесс на ввод данных пользователем. Если интерфейс не отвечает немедленно, <xref:System.Diagnostics.Process.Responding%2A> возвращает `false`. Используйте это свойство, чтобы определить, является ли интерфейс связанного процесса перестал отвечать.  
  
 Если процесс не имеет <xref:System.Diagnostics.Process.MainWindowHandle%2A>, это свойство возвращает `true`.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.Responding" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает собственный дескриптор процесса.</summary>
        <value>Собственный дескриптор процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дескриптор доступен только в том случае, если вызывающий компонент запущен процесс.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор сеанса служб терминалов для связанного процесса.</summary>
        <value>Идентификатор сеанса служба терминалов для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A> Свойство идентифицирует сеанс, в котором выполняется приложение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">С этим процессом никакие сеансы не связаны.</exception>
        <exception cref="T:System.InvalidOperationException">С этим идентификатором сеанса не связаны никакие процессы.  
  
-или- 
На этом компьютере нет связанного процесса.</exception>
        <exception cref="T:System.PlatformNotSupportedException">В Windows 98 свойство <see cref="P:System.Diagnostics.Process.SessionId" /> не поддерживается.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает поток, используемый для чтения вывода ошибок приложения.</summary>
        <value>Объект <see cref="T:System.IO.StreamReader" />, используемый для чтения стандартного потока ошибок приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.Process> записывает текст в его стандартный поток ошибок, что текст обычно отображается в консоли. Перенаправляя <xref:System.Diagnostics.Process.StandardError%2A> потока, можно подавить вывод ошибок, процесса или управления ею. Например можно фильтровать текст, отформатируйте его по-разному или записывать выходные данные консоли и назначенный файл журнала.  
  
> [!NOTE]
>  Чтобы использовать <xref:System.Diagnostics.Process.StandardError%2A>, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> для `false`, и необходимо указать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> для `true`. В противном случае считывание <xref:System.Diagnostics.Process.StandardError%2A> поток вызывает исключение.  
  
 Перенаправленного <xref:System.Diagnostics.Process.StandardError%2A> возможность чтения потока, синхронно или асинхронно. Методы, такие как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> выполнять синхронные операции чтения в потоке вывода ошибок процесса. Эти синхронные чтение операции не завершаются до связанного <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardError%2A> потоковой передачи или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A> потока. Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращает вызывающему объекту, который может выполнять другую работу, пока выходной поток направляется обработчику событий.  
  
 Синхронное чтение операций вводит зависимость между считыванием из вызывающего <xref:System.Diagnostics.Process.StandardError%2A> потока и дочерний процесс записи в поток. Эти зависимости можно привести в состоянии взаимоблокировки. Когда вызывающий объект считывает из перенаправленного потока дочернего процесса, он зависит от дочернего. Вызывающий объект ожидает операции считывания дочерние записывает в поток или закрывает поток. Когда дочерний процесс записывает достаточно данных для заполнения своего перенаправленного потока, он зависит от родительского. Дочерний процесс ожидает следующей операции записи до родительского считывает из полного потока или закрывает поток. Взаимоблокировка возникает, когда вызывающий объект и дочерний процесс ждут друг от друга, для завершения операции и не может продолжить работу. Взаимоблокировок можно избежать, оценивая зависимости между вызывающим и дочерний процесс.  

В последних двух примерах этого раздела используется <xref:System.Diagnostics.Process.Start%2A> метод для запуска исполняемого файла с именем *Write500Lines.exe*. Следующий пример содержит его исходный код.

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

Приведенный ниже показано, как читать из потока перенаправленный ошибки и дождитесь завершения дочернего процесса. Это позволяет избежать взаимоблокировки, вызвав `p.StandardError.ReadToEnd` перед `p.WaitForExit`. Если родительский обработки вызовов может привести к взаимоблокировки `p.WaitForExit` перед `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса. Дочерний процесс будет ожидать неопределенно долго родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A> потока.   

[!code-csharp[Reading from the error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standarderror/stderror-sync.cs)]
[!code-vb[Reading from the error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standarderror/stderror-sync.vb)]  

Есть аналогичная проблема возникает при считывании весь текст из стандартного вывода и потоков стандартной ошибки. В следующем примере выполняется операция считывания в обоих потоках. Это позволяет избежать взаимоблокировки, выполняя асинхронные операции чтения на <xref:System.Diagnostics.Process.StandardError%2A> потока. Взаимоблокировка возникает, если родительский обрабатывать вызовы `p.StandardOutput.ReadToEnd` следуют `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения его поток сообщений об ошибках. Родительский процесс будет ожидать неопределенно долго дочерний процесс закрыть его <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Дочерний процесс будет ожидать неопределенно долго родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A> потока.  
[!code-csharp[Reading from both streams](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]
[!code-vb[Reading from both streams](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]  

Чтобы избежать этих зависимостей и возможных взаимоблокировок можно использовать асинхронных операций чтения. Кроме того можно избежать этого состояния взаимоблокировки путем создания двух потоков и чтении выходных данных каждого потока в отдельном потоке.  
  
> [!NOTE]
>  Нельзя смешивать асинхронные и синхронные операции чтения в перенаправленном потоке. Один раз перенаправленного потока <xref:System.Diagnostics.Process> открыт в режиме асинхронной или синхронной, все дополнительные чтения операции в этом потоке должен быть в одном режиме. Например, не выполняйте <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> вызовом <xref:System.IO.StreamReader.ReadLine%2A> на <xref:System.Diagnostics.Process.StandardError%2A> потока, или наоборот. Тем не менее вы найдете в двух разных потоках в разных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , а затем вызвать <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
   
  
## Examples  
 В следующем примере используется `net use` команду с пользователя указан аргумент для сопоставления сетевому ресурсу. Затем считывается в стандартный поток ошибок сетевой команды и записывается в консоль.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток <see cref="P:System.Diagnostics.Process.StandardError" /> не был определен для переадресации. Убедитесь, что для <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> задано <see langword="true" />, а для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> — <see langword="false" />.  
  
-или- 
Поток <see cref="P:System.Diagnostics.Process.StandardError" /> был открыт для асинхронных операций чтения с <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает поток, используемый для записи ввода приложения.</summary>
        <value>Объект <see cref="T:System.IO.StreamWriter" />, используемый для записи стандартного входного потока приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Diagnostics.Process> может считывать входной текст из его стандартного входного потока, обычно клавиатуры. Перенаправляя <xref:System.Diagnostics.Process.StandardInput%2A> потока, можно программно задать входные данные. Например вместо ввода с клавиатуры, можно предоставить текст из содержимого указанного файла или выходные данные из другого приложения.  
  
> [!NOTE]
>  Чтобы использовать <xref:System.Diagnostics.Process.StandardInput%2A>, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> для `false`, и необходимо указать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> для `true`. В противном случае запись <xref:System.Diagnostics.Process.StandardInput%2A> поток вызывает исключение.  
  
   
  
## Examples  
 Следующий пример иллюстрирует способ перенаправления <xref:System.Diagnostics.Process.StandardInput%2A> потока процесса. В примере запускается `sort` с перенаправленным вводом. Затем он запрашивает у пользователя текст и передает его `sort` процесса с помощью перенаправленного <xref:System.Diagnostics.Process.StandardInput%2A> потока. `sort` Результаты отображаются пользователю на консоль.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardInput" /> Поток не был определен, так как для <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> установлено значение <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает поток, используемый для чтения текстовых выходных данных приложения.</summary>
        <value>Объект <see cref="T:System.IO.StreamReader" />, используемый для чтения стандартного потока вывода приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.Process> записывает текст в свой стандартный поток, что текст обычно отображается в консоли. Перенаправляя <xref:System.Diagnostics.Process.StandardOutput%2A> stream, вы можете управлять или подавлять вывод процесса. Например можно фильтровать текст, отформатируйте его по-разному или записывать выходные данные консоли и назначенный файл журнала.  
  
> [!NOTE]
>  Чтобы использовать <xref:System.Diagnostics.Process.StandardOutput%2A>, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> для `false`, и необходимо указать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> для `true`. В противном случае считывание <xref:System.Diagnostics.Process.StandardOutput%2A> поток вызывает исключение.  
  
 Перенаправленного <xref:System.Diagnostics.Process.StandardOutput%2A> возможность чтения потока, синхронно или асинхронно. Методы, такие как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> выполнять синхронные операции чтения в выходной поток процесса. Эти синхронные чтение операции не завершаются до связанного <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardOutput%2A> потоковой передачи или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращает вызывающему объекту, который может выполнять другую работу, пока выходной поток направляется обработчику событий.  
  
 Синхронное чтение операций вводит зависимость между считыванием из вызывающего <xref:System.Diagnostics.Process.StandardOutput%2A> потока и дочерний процесс записи в поток. Эти зависимости можно привести в состоянии взаимоблокировки. Когда вызывающий объект считывает из перенаправленного потока дочернего процесса, он зависит от дочернего. Вызывающий объект ожидает операции считывания дочерние записывает в поток или закрывает поток. Когда дочерний процесс записывает достаточно данных для заполнения своего перенаправленного потока, он зависит от родительского. Дочерний процесс ожидает следующей операции записи до родительского считывает из полного потока или закрывает поток. Взаимоблокировка возникает, когда вызывающий объект и дочерний процесс ждут друг от друга, для завершения операции и не может продолжить работу. Взаимоблокировок можно избежать, оценивая зависимости между вызывающим и дочерний процесс.  

В последних двух примерах этого раздела используется <xref:System.Diagnostics.Process.Start%2A> метод для запуска исполняемого файла с именем *Write500Lines.exe*. Следующий пример содержит его исходный код.

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

В следующем примере показано, как считывание из перенаправленного потока и ожидание завершения дочернего процесса. Пример позволяет избежать взаимоблокировки, вызвав `p.StandardOutput.ReadToEnd` перед `p.WaitForExit`. Если родительский обработки вызовов может привести к взаимоблокировки `p.WaitForExit` перед `p.StandardOutput.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса. Дочерний процесс будет ожидать неопределенно долго родительским для чтения из полной <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  

[!code-csharp[Reading synchronously from a redirected output stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-sync.cs)]  
[!code-vb[Reading synchronously from a redirected output stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-sync.vb)]  

Есть аналогичная проблема возникает при считывании весь текст из стандартного вывода и потоков стандартной ошибки. В следующем примере выполняется операция считывания в обоих потоках. Это позволяет избежать взаимоблокировки, выполняя асинхронные операции чтения на <xref:System.Diagnostics.Process.StandardError%2A> потока. Взаимоблокировка возникает, если родительский обрабатывать вызовы `p.StandardOutput.ReadToEnd` следуют `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения его поток сообщений об ошибках. Родительский процесс будет ожидать неопределенно долго дочерний процесс закрыть его <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Дочерний процесс будет ожидать неопределенно долго родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A> потока.   
[!code-csharp[Reading from a redirected output and error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]  
[!code-vb[Reading from a redirected output and error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]    
  
 Чтобы избежать этих зависимостей и возможных взаимоблокировок можно использовать асинхронных операций чтения. Кроме того можно избежать этого состояния взаимоблокировки путем создания двух потоков и чтении выходных данных каждого потока в отдельном потоке.  
  
> [!NOTE]
>  Нельзя смешивать асинхронные и синхронные операции чтения в перенаправленном потоке. Один раз перенаправленного потока <xref:System.Diagnostics.Process> открыт в режиме асинхронной или синхронной, все дополнительные чтения операции в этом потоке должен быть в одном режиме. Например, не выполняйте <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> вызовом <xref:System.IO.StreamReader.ReadLine%2A> на <xref:System.Diagnostics.Process.StandardOutput%2A> потока, или наоборот. Тем не менее вы найдете в двух разных потоках в разных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , а затем вызвать <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
   
  
## Examples  
 В следующем примере выполняется команда ipconfig.exe и перенаправляет его стандартные выходные данные в окно консоли для данного примера.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток <see cref="P:System.Diagnostics.Process.StandardOutput" /> не был определен для переадресации. Убедитесь, что для <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> задано <see langword="true" />, а для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> — <see langword="false" />.  
  
-или- 
Поток <see cref="P:System.Diagnostics.Process.StandardOutput" /> был открыт для асинхронных операций чтения с <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Запускает ресурс процесса и связывает его с компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает (или повторно использует) ресурс процесса, определенный свойством <see cref="P:System.Diagnostics.Process.StartInfo" /> этого компонента <see cref="T:System.Diagnostics.Process" />, и связывает его с компонентом.</summary>
        <returns>Значение <see langword="true" />, если ресурс процесса запущен; значение <see langword="false" />, если новый ресурс процесса не был запущен (например, при повторном использовании существующего процесса).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для запуска ресурса процесса и связывания его с текущим <xref:System.Diagnostics.Process> компонента. Возвращаемое значение `true` указывает, что новый ресурс процесса запущен. Если ресурс процесса, указанный свойством <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> членом <xref:System.Diagnostics.Process.StartInfo%2A> свойство уже выполняется на компьютере, ресурса не дополнительный процесс был запущен. Вместо этого выполняющийся процесс ресурсов используется повторно и `false` возвращается.  
  
 Можно запустить приложение ClickOnce, указав расположение (например, веб-адрес), из которого изначально устанавливалось приложение. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
> [!NOTE]
>  Если вы используете Visual Studio, эта перегрузка <xref:System.Diagnostics.Process.Start%2A> метод является тот, который можно вставить в код после перетаскивания <xref:System.Diagnostics.Process> компонента в конструктор. Используйте `Properties` окна, чтобы развернуть `StartInfo` категории и записи соответствующего значения в `FileName` свойство. Внесенные изменения будут отображены в форме `InitializeComponent` процедуры.  
  
 Эта перегрузка <xref:System.Diagnostics.Process.Start%2A> не `static` метод. Необходимо вызвать его из экземпляра <xref:System.Diagnostics.Process> класса. Перед вызовом <xref:System.Diagnostics.Process.Start%2A>, прежде всего необходимо указать <xref:System.Diagnostics.Process.StartInfo%2A> сведения о свойстве для данного <xref:System.Diagnostics.Process> экземпляра, так как эта информация используется для определения ресурса процесса для запуска.  
  
 Другие перегрузки <xref:System.Diagnostics.Process.Start%2A> метод `static` членов. Необходимо создать экземпляр <xref:System.Diagnostics.Process> компонента перед вызовом этих перегрузок метода. Вместо этого можно вызвать <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> класса б, а новый <xref:System.Diagnostics.Process> компонент создается в том случае, если процесс был запущен. Или, `null` возвращается, если процесс был использован заново. Ресурс процесса автоматически связывается с новым <xref:System.Diagnostics.Process> компонент, который возвращается методом <xref:System.Diagnostics.Process.Start%2A> метод.  
  
 <xref:System.Diagnostics.Process.StartInfo%2A> Члены могут использоваться для дублируют функциональность `Run` диалоговое окно Windows `Start` меню. Все, что можно ввести в командной строке можно запустить, задав соответствующие значения <xref:System.Diagnostics.Process.StartInfo%2A> свойство. Единственным <xref:System.Diagnostics.Process.StartInfo%2A> является свойством, которое необходимо задать <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойства. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Свойство не нужно быть исполняемым файлом. Он может быть любой тип файла, для которого была связана с приложением, установленные в системе расширения. Например <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или он может иметь расширение .doc, при наличии файлов с помощью средства обработки текста, таких как Microsoft Word.  
  
 В командной строке можно указать действия для обработки определенных типов файлов. Например можно распечатать документы или редактирования текстовых файлов. Укажите эти действия с помощью <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> членом <xref:System.Diagnostics.Process.StartInfo%2A> свойство. Для других типов файлов, можно указать аргументы командной строки при запуске файла из `Run` диалоговое окно. Например, можно передать URL-адрес в качестве аргумента, если задать обозреватель в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Эти аргументы могут быть заданы в <xref:System.Diagnostics.Process.StartInfo%2A> свойства <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> член.  
  
 Если у вас есть путь к переменной, объявленной в вашей системе, с помощью кавычки, необходимо полностью указать этот путь при запуске любого процесса, в этом расположении. В противном случае система не найдет путь. Например если `c:\mypath` не находится в системном пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо полностью указать любой процесс в `c:\mypath` при запуске.  
  
> [!NOTE]
>  Код элемента управления страницы и сервера веб-ASP.NET выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  Если вы используете <xref:System.Diagnostics.Process.Start%2A> выполнения нового процесса метода в веб-страницы ASP.NET или серверный элемент управления, на веб-сервере с ограниченными разрешениями. Процесс не запускается в контексте клиентского браузера и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его, или существует риск потери системных ресурсов. Закрыть процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A> свойство.  
  
 Примечание о состояния подразделения в управляемых потоках здесь не требуется. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` на компонент обработки <xref:System.Diagnostics.Process.StartInfo%2A> свойство, убедитесь, что установки потоковой модели приложения, задав атрибуту `[STAThread]` на `main()` метод. В противном случае может быть управляемый поток в `unknown` состояние или поместить в `MTA` state, последний который конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> , `true`. Некоторые методы требуют состояние подразделения не `unknown`. Если состояние не задано явно, когда приложение обнаруживает такой метод, по умолчанию `MTA`, а затем состояние подразделения не может быть изменено. Тем не менее `MTA` приводит к возникновению исключения, исключение, когда оболочке операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере используется экземпляр <xref:System.Diagnostics.Process> класса для запуска процесса.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Имя файла не было указано в свойстве <see cref="P:System.Diagnostics.Process.StartInfo" /> компонента <see cref="T:System.Diagnostics.Process" />.
- или- Член <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> свойства <see cref="P:System.Diagnostics.Process.StartInfo" /> имеет значение <see langword="true" />, тогда как <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> или <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> имеет значение <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при открытии связанного файла.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Метод не поддерживается в операционных системах без поддержки оболочки, таких как Nano Server (только в .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">Объект <see cref="T:System.Diagnostics.ProcessStartInfo" />, который содержит информацию, использующуюся для запуска процесса, включая имя файла и все аргументы командной строки.</param>
        <summary>Запускает ресурс процесса, определенный параметром, содержащим стартовую информацию процесса (например, имя файла запускаемого процесса), и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, чтобы запустить ресурс процесса путем указания <xref:System.Diagnostics.ProcessStartInfo> экземпляра. Перегрузка связывает ресурс с новым <xref:System.Diagnostics.Process> объекта.  
  
> [!NOTE]
>  Если URL-адрес назначен адрес для запуска исполняемого файла, процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Использование этой перегрузки с <xref:System.Diagnostics.ProcessStartInfo> параметр можно использовать вместо явного действия по созданию нового <xref:System.Diagnostics.Process> экземпляра, установка его <xref:System.Diagnostics.Process.StartInfo%2A> свойств и вызова <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 С помощью <xref:System.Diagnostics.ProcessStartInfo> экземпляра как параметр дает возможность вызывать <xref:System.Diagnostics.Process.Start%2A> с полностью управлять содержимым, передаваемым в вызов для запуска процесса. Если вам нужно передать только имя файла или имя файла с аргументами, нет необходимости создавать новый <xref:System.Diagnostics.ProcessStartInfo> экземпляра, несмотря на то, что это возможно. Единственным <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> является свойством, которое необходимо задать <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойства. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Свойство не нужно предоставлять исполняемый файл. Он может быть любой тип файла, для которого была связана с приложением, установленные в системе расширения. Например <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или он может иметь расширение .doc, при наличии файлов с помощью средства обработки текста, таких как Microsoft Word.  
  
 Можно запустить приложение ClickOnce, указав расположение (например, веб-адрес), из которого изначально устанавливалось приложение. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
 Если <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> и <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> свойства <xref:System.Diagnostics.Process.StartInfo%2A> экземпляр заданы, неуправляемой `CreateProcessWithLogonW` вызывается функция, которая запускает процесс в новый даже если окно <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> свойство имеет значение `true` или <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> свойство имеет значение <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Если <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> свойство `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> свойство должно быть в формате имени участника-пользователя, *пользователя*@*DNS_domain_name*.   
  
 В отличие от других перегрузок, перегрузка <xref:System.Diagnostics.Process.Start%2A> , не имеющего параметров не `static` член. Использовать полученный перегружать, если вы уже создали <xref:System.Diagnostics.Process> экземпляра указанной начальной сведения (включая имя файла) и нужно запустить ресурс процесса и связать его с существующим <xref:System.Diagnostics.Process> экземпляра. Используйте один из `static` перегрузок, если вы хотите создать новый <xref:System.Diagnostics.Process> компонента, а не запустить процесс для существующего компонента. Эта перегрузка и перегрузку, которая не имеет параметров позволяют пользователю указать сведения о запуске для ресурса процесса с помощью <xref:System.Diagnostics.ProcessStartInfo> экземпляра.  
  
 Если у вас есть путь к переменной, объявленной в вашей системе, с помощью кавычки, необходимо полностью указать этот путь при запуске любого процесса, в этом расположении. В противном случае система не найдет путь. Например если `c:\mypath` не находится в системном пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо полностью указать любой процесс в `c:\mypath` при запуске.  
  
> [!NOTE]
>  Код элемента управления страницы и сервера веб-ASP.NET выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  Если вы используете <xref:System.Diagnostics.Process.Start%2A> выполнения нового процесса метода в веб-страницы ASP.NET или серверный элемент управления, на веб-сервере с ограниченными разрешениями. Процесс не запускается в контексте клиентского браузера и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его, или существует риск потери системных ресурсов. Закрыть процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A> свойство.  
  
 Примечание о состояния подразделения в управляемых потоках здесь не требуется. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` на `startInfo` параметр, убедитесь, что установки потоковой модели приложения, задав атрибуту `[STAThread]` на `main()` метод. В противном случае может быть управляемый поток в `unknown` состояние или поместить в `MTA` state, последний который конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> , `true`. Некоторые методы требуют состояние подразделения не `unknown`. Если состояние не задано явно, когда приложение обнаруживает такой метод, по умолчанию `MTA`, а затем состояние подразделения не может быть изменено. Тем не менее `MTA` приводит к возникновению исключения, исключение, когда оболочке операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере сначала создается экземпляр Internet Explorer и отображает содержимое папки "Избранное" в браузере. Затем запускаются несколько других экземпляров Internet Explorer и отображает несколько определенных страниц или сайтов. И наконец Internet Explorer запускается с окном, минимизируется при переходе на указанном сайте.  
  
 Дополнительные примеры других применений этого метода см. отдельные свойства <xref:System.Diagnostics.ProcessStartInfo> класса.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Имя файла не было указано в свойстве <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> параметра <paramref name="startInfo" />.  
  
-или- 
Свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> параметра<paramref name="startInfo" /> имеет значение <see langword="true" /> и <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> или свойство <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> также имеет значение <see langword="true" />.  
  
-или- 
Свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> параметра <paramref name="startInfo" /> имеет значение <see langword="true" />, и свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> не равно <see langword="null" /> или не является пустым или свойство <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> не равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="startInfo" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл, указанный в свойстве <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> параметра <paramref name="startInfo" />, не найден.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла ошибка при открытии связанного файла.  
  
-или- 
Сумма длины аргументов и длины полного пути к процессу превышает 2080. Сообщение об ошибке, связанной с этим исключением, может иметь следующую формулировку: "Область данных, переданная системному вызову, слишком мала". или "Отказано в доступе".</exception>
        <exception cref="T:System.PlatformNotSupportedException">Метод не поддерживается в операционных системах без поддержки оболочки, таких как Nano Server (только в .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя документа или файла приложения для запуска в процессе.</param>
        <summary>Запускает ресурс процесса путем указания имени документа или файла приложения и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, чтобы запустить ресурс процесса путем указания имени файла. Перегрузка связывает ресурс с новым <xref:System.Diagnostics.Process> объекта.  
  
> [!NOTE]
>  Если URL-адрес назначен адрес для запуска исполняемого файла, процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явного действия по созданию нового <xref:System.Diagnostics.Process> экземпляра, установка <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> членом <xref:System.Diagnostics.Process.StartInfo%2A> и вызова <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 Можно запустить приложение ClickOnce, задав `fileName` параметр в папку (например, веб-адрес), из которого изначально установлены приложения. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
 Запуск процесса путем указания имени файла похож на запуск с `Run` диалоговое окно Windows `Start` меню. Таким образом имя файла не нужно предоставлять исполняемый файл. Он может быть любой тип файла, для которого модуль был связан с приложением, установленные в системе. Например имя файла может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или он может иметь расширение .doc, при наличии файлов с помощью средства обработки текста, таких как Microsoft Word. Аналогичным образом, в том же образом, как `Run` диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширение .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот».  
  
 Эта перегрузка не поддерживает аргументы командной строки для процесса. Если необходимо указать один или несколько аргументов командной строки для процесса, используйте <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> или <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> перегрузки.  
  
 В отличие от других перегрузок, перегрузка <xref:System.Diagnostics.Process.Start%2A> , не имеющего параметров не `static` член. Использовать полученный перегружать, если вы уже создали <xref:System.Diagnostics.Process> экземпляра указанной начальной сведения (включая имя файла) и нужно запустить ресурс процесса и связать его с существующим <xref:System.Diagnostics.Process> экземпляра. Используйте один из `static` перегрузок, если вы хотите создать новый <xref:System.Diagnostics.Process> компонента, а не запустить процесс для существующего компонента. Эта перегрузка и перегрузку, которая не имеет параметров позволяют пользователю указать имя файла ресурса процесса для запуска.  
  
 Если у вас есть путь к переменной, объявленной в вашей системе, с помощью кавычки, необходимо полностью указать этот путь при запуске любого процесса, в этом расположении. В противном случае система не найдет путь. Например если `c:\mypath` не находится в системном пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо полностью указать любой процесс в `c:\mypath` при запуске.  
  
> [!NOTE]
>  Код элемента управления страницы и сервера веб-ASP.NET выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  Если вы используете <xref:System.Diagnostics.Process.Start%2A> выполнения нового процесса метода в веб-страницы ASP.NET или серверный элемент управления, на веб-сервере с ограниченными разрешениями. Процесс не запускается в контексте клиентского браузера и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его, или существует риск потери системных ресурсов. Закрыть процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A> свойство.  
  
 Примечание о состояния подразделения в управляемых потоках здесь не требуется. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` на компонент обработки <xref:System.Diagnostics.Process.StartInfo%2A> свойство, убедитесь, что установки потоковой модели приложения, задав атрибуту `[STAThread]` на `main()` метод. В противном случае может быть управляемый поток в `unknown` состояние или поместить в `MTA` state, последний который конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> , `true`. Некоторые методы требуют состояние подразделения не `unknown`. Если состояние не задано явно, когда приложение обнаруживает такой метод, по умолчанию `MTA`, а затем состояние подразделения не может быть изменено. Тем не менее `MTA` приводит к возникновению исключения, исключение, когда оболочке операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере сначала создается экземпляр Internet Explorer и отображает содержимое папки "Избранное" в браузере. Затем запускаются несколько других экземпляров Internet Explorer и отображает несколько определенных страниц или сайтов. И наконец Internet Explorer запускается с окном, минимизируется при переходе на указанном сайте.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла ошибка при открытии связанного файла.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Переменная среды PATH содержит строку с кавычками.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла приложения для запуска в процессе.</param>
        <param name="arguments">Аргументы командной строки для передачи при запуске процесса.</param>
        <summary>Запускает ресурс процесса путем указания имени приложения и набора аргументов командной строки и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, чтобы запустить ресурс процесса путем указания имени файла и аргументы командной строки. Перегрузка связывает ресурс с новым <xref:System.Diagnostics.Process> объекта.  
  
> [!NOTE]
>  Если URL-адрес назначен адрес для запуска исполняемого файла, процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явного действия по созданию нового <xref:System.Diagnostics.Process> экземпляра, установка <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> и <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> членами <xref:System.Diagnostics.Process.StartInfo%2A> и вызова <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 Запуск процесса путем указания имени файла и аргументы похож на ввод имени файла и аргументы командной строки в `Run` диалоговое окно Windows `Start` меню. Таким образом имя файла не нужно предоставлять исполняемый файл. Он может быть любой тип файла, для которого модуль был связан с приложением, установленные в системе. Например имя файла может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или он может иметь расширение .doc, при наличии файлов с помощью средства обработки текста, таких как Microsoft Word. Аналогичным образом, в том же образом, как `Run` диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширение .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот». Если `fileName` параметр представляет собой исполняемый файл, `arguments` параметр может представлять действия, такие как текстовый файл в файл `Notepad.exe myfile.txt`. Если `fileName` параметр представляет командный (cmd) файл, `arguments` необходимо включить параметр "`/c`«или»`/k`" аргумент, чтобы указать ли командное окно завершает работу или остается после завершения.  
  
 В отличие от других перегрузок, перегрузка <xref:System.Diagnostics.Process.Start%2A> , не имеющего параметров не `static` член. Использовать полученный перегружать, если вы уже создали <xref:System.Diagnostics.Process> экземпляра указанной начальной сведения (включая имя файла) и нужно запустить ресурс процесса и связать его с существующим <xref:System.Diagnostics.Process> экземпляра. Используйте один из `static` перегрузок, если вы хотите создать новый <xref:System.Diagnostics.Process> компонента, а не запустить процесс для существующего компонента. Эта перегрузка и перегрузку, которая не имеет параметров позволяют пользователю указать имя файла ресурса процесса для запуска и аргументы командной строки для передачи.  
  
 Если у вас есть путь к переменной, объявленной в вашей системе, с помощью кавычки, необходимо полностью указать этот путь при запуске любого процесса, в этом расположении. В противном случае система не найдет путь. Например если `c:\mypath` не находится в системном пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо полностью указать любой процесс в `c:\mypath` при запуске.  
  
> [!NOTE]
>  Код элемента управления страницы и сервера веб-ASP.NET выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  Если вы используете <xref:System.Diagnostics.Process.Start%2A> выполнения нового процесса метода в веб-страницы ASP.NET или серверный элемент управления, на веб-сервере с ограниченными разрешениями. Процесс не запускается в контексте клиентского браузера и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его, или существует риск потери системных ресурсов. Закрыть процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A> свойство. 
  
 Примечание о состояния подразделения в управляемых потоках здесь не требуется. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` на компонент обработки <xref:System.Diagnostics.Process.StartInfo%2A> свойство, убедитесь, что установки потоковой модели приложения, задав атрибуту `[STAThread]` на `main()` метод. В противном случае может быть управляемый поток в `unknown` состояние или поместить в `MTA` state, последний который конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> , `true`. Некоторые методы требуют состояние подразделения не `unknown`. Если состояние не задано явно, когда приложение обнаруживает такой метод, по умолчанию `MTA`, а затем состояние подразделения не может быть изменено. Тем не менее `MTA` приводит к возникновению исключения, исключение, когда оболочке операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере сначала создается экземпляр Internet Explorer и отображает содержимое папки "Избранное" в браузере. Затем запускаются несколько других экземпляров Internet Explorer и отображает несколько определенных страниц или сайтов. И наконец Internet Explorer запускается с окном, минимизируется при переходе на указанном сайте.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение параметра <paramref name="fileName" /> или параметра <paramref name="arguments" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла ошибка при открытии связанного файла.  
  
-или- 
Сумма длины аргументов и длины полного пути к процессу превышает 2080. Сообщение об ошибке, связанной с этим исключением, может иметь следующую формулировку: "Область данных, переданная системному вызову, слишком мала". или "Отказано в доступе".</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Переменная среды PATH содержит строку с кавычками.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="domain" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла приложения для запуска в процессе.</param>
        <param name="userName">Имя пользователя, используемое при запуске процесса.</param>
        <param name="password">Объект <see cref="T:System.Security.SecureString" />, содержащий пароль для использования при запуске процесса.</param>
        <param name="domain">Домен, используемый при запуске процесса.</param>
        <summary>Запускает ресурс процесса путем указания имени приложения, имени пользователя, пароля и домена и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для создания нового процесса и основной поток, указав его имя файла, имя пользователя, пароль и домен. Указанный исполняемый файл запустит новый процесс в контексте безопасности указанные учетные данные (пользователя, домен и пароль).  
  
> [!NOTE]
>  Если исполняемый файл, находится на удаленном диске, необходимо определить общий сетевой ресурс, используя универсальный код ресурса (URI), не связанный с буквой диска.  
  
> [!NOTE]
>  Если URL-адрес назначен адрес для запуска исполняемого файла, процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явного действия по созданию нового <xref:System.Diagnostics.Process> экземпляра, установка <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, и <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> свойства <xref:System.Diagnostics.Process.StartInfo%2A> и вызова <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 Аналогичным образом, в том же образом, как **запуска** диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширение .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот». Если `fileName` параметр представляет собой исполняемый файл, `arguments` параметр может представлять действия, такие как текстовый файл в файл `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Имя файла должно предоставлять исполняемый файл в <xref:System.Diagnostics.Process.Start%2A> перегрузок, имеющих `userName`, `password`, и `domain` параметров.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его, или существует риск потери системных ресурсов. Закрыть процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A> свойство. 
  
   
  
## Examples  
 В следующем примере кода показано, как использовать эту перегрузку, чтобы запустить исполняемый файл, а также демонстрируется возникновение <xref:System.ComponentModel.Win32Exception> при попытке запуска приложения, связанного с файлом неисполняемые.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Не указано имя файла.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при открытии связанного файла.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Метод не поддерживается в Linux или macOS (только в .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="domain" Type="System.String" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла приложения для запуска в процессе.</param>
        <param name="arguments">Аргументы командной строки для передачи при запуске процесса.</param>
        <param name="userName">Имя пользователя, используемое при запуске процесса.</param>
        <param name="password">Объект <see cref="T:System.Security.SecureString" />, содержащий пароль для использования при запуске процесса.</param>
        <param name="domain">Домен, используемый при запуске процесса.</param>
        <summary>Запускает ресурс процесса путем указания имени приложения, набора аргументов командной строки, имени пользователя, пароля и домена и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для создания нового процесса и основной поток, указав имя файла, аргументы командной строки, имя пользователя, пароль и домен. Указанный исполняемый файл запустит новый процесс в контексте безопасности указанные учетные данные (пользователя, домен и пароль).  
  
> [!NOTE]
>  Если исполняемый файл, находится на удаленном диске, необходимо определить общий сетевой ресурс, используя универсальный код ресурса (URI), не связанный с буквой диска.  
  
> [!NOTE]
>  Если URL-адрес назначен адрес для запуска исполняемого файла, процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явного действия по созданию нового <xref:System.Diagnostics.Process> экземпляра, установка <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, и <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> свойства <xref:System.Diagnostics.Process.StartInfo%2A> и вызова <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 Аналогичным образом, в том же образом, как **запуска** диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширение .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот». Если `fileName` параметр представляет собой исполняемый файл, `arguments` параметр может представлять действия, такие как текстовый файл в файл `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Имя файла должно предоставлять исполняемый файл в <xref:System.Diagnostics.Process.Start%2A> перегрузок, имеющих `userName`, `password`, и `domain` параметров.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его, или существует риск потери системных ресурсов. Закрыть процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A> свойство. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Не указано имя файла.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла ошибка при открытии связанного файла.  
  
-или- 
Сумма длины аргументов и длины полного пути к соответствующему файлу превышает 2080. Сообщение об ошибке, связанной с этим исключением, может иметь следующую формулировку: "Область данных, переданная системному вызову, слишком мала". или "Отказано в доступе".</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Метод не поддерживается в Linux или macOS (только в .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает свойства для передачи их методу <see cref="M:System.Diagnostics.Process.Start" /> объекта <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>Класс <see cref="T:System.Diagnostics.ProcessStartInfo" />, который представляет данные для запуска процесса. Эти аргументы включают имя исполняемого файла или документа, использованного для запуска процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> Представляет набор параметров, используемые для запуска процесса. Когда <xref:System.Diagnostics.Process.Start%2A> вызове <xref:System.Diagnostics.Process.StartInfo%2A> используется для указания процесса для запуска. Только необходимые <xref:System.Diagnostics.Process.StartInfo%2A> — члена <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство. Запуск процесса путем указания <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство похоже на запуск в **запуска** диалоговое окно Windows **запустить** меню. Таким образом <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство не нужно предоставлять исполняемый файл. Он может быть любой тип файла, для которого модуль был связан с приложением, установленные в системе. Например <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или он может иметь расширение .doc, при наличии файлов с помощью средства обработки текста, таких как Microsoft Word. Аналогичным образом, в том же образом, как **запуска** диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширение .exe является необязательным в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> член. Например, можно задать <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство «Notepad.exe» или «Блокнот».  
  
 Можно запустить приложение ClickOnce, задав <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство в папку (например, веб-адрес), из которого изначально установлены приложения. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
 Если имя файла включает в себя неисполняемые файла, например DOC-файл, можно включить команду, задающую какое действие следует предпринять для файла. Например, можно задать <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> «Print» для файла, расширение .doc. Имя файла, указанное в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство не указано расширение, если вы вручную вводите значение для <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> свойство. Тем не менее если вы используете <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> свойство, чтобы определить, какие команды доступны, необходимо включить расширение.  
  
 Можно изменить параметры, заданные в <xref:System.Diagnostics.Process.StartInfo%2A> свойство вплоть до времени, который вы вызываете <xref:System.Diagnostics.Process.Start%2A> метод на процесс. После запуска процесса, изменив <xref:System.Diagnostics.Process.StartInfo%2A> значения не влияет на и перезапуска процесса. При вызове метода <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> метод с <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> и <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> набором свойств, неуправляемой `CreateProcessWithLogonW` вызывается функция, которая запускает процесс в новый даже если окно <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> свойство имеет значение `true` или <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> свойство имеет значение <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Если вы не использовали <xref:System.Diagnostics.Process.Start%2A> метод для запуска процесса, <xref:System.Diagnostics.Process.StartInfo%2A> свойство не отражает параметров, используемых для запуска процесса. Например, если вы используете <xref:System.Diagnostics.Process.GetProcesses%2A> для получения массива процессов, запущенных на компьютере, <xref:System.Diagnostics.Process.StartInfo%2A> каждого элемента <xref:System.Diagnostics.Process> не содержит имя исходного файла и аргументы, используемые для запуска процесса.  
  
 Когда запускается процесс, имя файла — файл, который заполняет (только для чтения) <xref:System.Diagnostics.Process.MainModule%2A> свойство. Если вы хотите получить исполняемый файл, связанный с процессом после запуска процесса, используйте <xref:System.Diagnostics.Process.MainModule%2A> свойство. Если вы хотите задать исполняемый файл <xref:System.Diagnostics.Process> экземпляра, для которого связанного процесса не был запущен, используйте <xref:System.Diagnostics.Process.StartInfo%2A> свойства <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> член. Так как члены <xref:System.Diagnostics.Process.StartInfo%2A> свойства, аргументы, передаваемые <xref:System.Diagnostics.Process.Start%2A> метод процесса, изменив <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство после начала процесса не приведет к сбросу <xref:System.Diagnostics.Process.MainModule%2A> свойство. Эти свойства используются только для инициализации процесса.  
  
   
  
## Examples  
 В следующем примере <xref:System.Diagnostics.Process.StartInfo%2A> с выполняемого файла, действием над ней и должен ли отображаться пользовательский интерфейс. Дополнительные примеры см. на страницах справочника для свойства <xref:System.Diagnostics.ProcessStartInfo> класса.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, указывающее <see cref="P:System.Diagnostics.Process.StartInfo" />, равняется <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время запуска связанного процесса.</summary>
        <value>Объект, показывающий время запуска процесса. Если процесс не выполняется, возникает исключение.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.StartTime" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс завершен.  
  
-или- 
Процесс не был запущен.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">В вызове функции Windows произошла ошибка.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект, используемый для маршалинга вызовов обработчика событий, происходящих в результате события завершения процесса.</summary>
        <value>Объект <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, используемый для маршалинга вызовов обработчика событий, возникающих в результате события <see cref="E:System.Diagnostics.Process.Exited" /> в процессе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> — `null`, методы, обрабатывающие <xref:System.Diagnostics.Process.Exited> событие, называются в поток из системного пула потоков. Дополнительные сведения о системе пулов потоков, см. в разделе <xref:System.Threading.ThreadPool>.  
  
 Когда <xref:System.Diagnostics.Process.Exited> событие обрабатывается с помощью визуального компонента Windows Forms, такие как <xref:System.Windows.Forms.Button>, обращение к компоненту через пул потоков системы могут работать неправильно, или может привести к исключению. Избежать этого, задав <xref:System.Diagnostics.Process.SynchronizingObject%2A> в компонент Windows Forms, который вызывает методы, обрабатывающие <xref:System.Diagnostics.Process.Exited> событий, вызываемый в том же потоке, в котором был создан компонент.  
  
 Если <xref:System.Diagnostics.Process> используется внутри [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] в конструкторе Windows Forms, <xref:System.Diagnostics.Process.SynchronizingObject%2A> автоматически устанавливается в элемент управления, содержащий <xref:System.Diagnostics.Process>. Например, если вы поместите <xref:System.Diagnostics.Process> конструктору `Form1` (который наследуется от <xref:System.Windows.Forms.Form>) <xref:System.Diagnostics.Process.SynchronizingObject%2A> свойство <xref:System.Diagnostics.Process> присваивается экземпляр `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 Как правило это свойство задается при компонент размещается внутри элемента управления или формы, так как эти компоненты привязаны к определенному потоку.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает множество потоков, выполняющихся в связанном процессе.</summary>
        <value>Массив объектов типа <see cref="T:System.Diagnostics.ProcessThread" />, представляющий потоки операционной системы, которые в настоящий момент выполняются в связанном процессе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток выполняет код в процессе. Каждый процесс запускается с одним потоком, основной поток. Любой поток может создавать дополнительные потоки. Потоки процесса разделяют адресное пространство процесса.  
  
 Используйте <xref:System.Diagnostics.ProcessThread> можно получить все потоки, связанные с текущим процессом. Основной поток в данный момент не обязательно с нулевым индексом в массиве.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Процесс не имеет <see cref="P:System.Diagnostics.Process.Id" />, или нет процесса, связанного с экземпляром <see cref="T:System.Diagnostics.Process" />.  
  
-или- 
Связанный процесс завершился.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразует имя процесса в строку, объединенную с родительским типом компонента, если это применимо.</summary>
        <returns>Свойство <see cref="P:System.Diagnostics.Process.ProcessName" />, объединенное с возвращаемым значением метода <see cref="M:System.Object.ToString" /> базового компонента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="M:System.Diagnostics.Process.ToString" /> не поддерживается в Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает полное время процессора для этого процесса.</summary>
        <value>Объект <see cref="T:System.TimeSpan" />, указывающий количество времени, потраченного процессом на загрузку ЦП. Это значение является суммой значений свойств <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> и <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает пользовательское время процессора для этого процесса.</summary>
        <value>Класс <see cref="T:System.TimeSpan" />, показывающий количество времени, которое связанный процесс потратил на выполнение кода внутри приложения (не внутри ядра операционной системы).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает размер виртуальной памяти процесса (в байтах).</summary>
        <value>Объем виртуальной памяти в байтах, запрошенной связанным процессом.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем виртуальной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Возвращает количество виртуальной памяти в байтах, выделенной для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер виртуальной памяти, используемой процессом, в байтах. Операционная система сопоставляет виртуального адресного пространства для каждого процесса, либо на страницы загрузки в физической памяти, или на страницы хранятся в файле подкачки виртуальной памяти на диске.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **байт виртуальной памяти** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает период времени для ожидания завершения связанного процесса и блокирует текущий поток выполнения до того, как пройдет это время или процесс завершится. Чтобы избежать блокировки текущего потока, используйте событие <see cref="E:System.Diagnostics.Process.Exited" />.  
  
Примеры кода см. на следующих страницах справочника по свойствам <see cref="P:System.Diagnostics.Process.StandardError" /> и <see cref="P:System.Diagnostics.Process.ExitCode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать завершения связанного процесса в течение неограниченного времени.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> делает текущий поток ждал до завершения связанного процесса.  Его следует вызывать после вызова всех остальных методов для процесса. Чтобы избежать блокировки текущего потока, используйте событие <xref:System.Diagnostics.Process.Exited>.  
  
 Указывает, что этот метод <xref:System.Diagnostics.Process> ожидания неограниченного количества времени для процесса и обработчики событий для выхода. Это может вызвать приложение перестает отвечать на запросы. Например, если вы вызываете <xref:System.Diagnostics.Process.CloseMainWindow%2A> для процесса, который имеет пользовательский интерфейс, запрос к операционной системе на завершение процесса может быть не обработан, если запись процесса не нужно вводить его цикл обработки сообщений.  
  
> [!NOTE]
>  В [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] и более ранних версий <xref:System.Diagnostics.Process.WaitForExit> ожидание перегрузки <xref:System.Int32.MaxValue> миллисекунд (приблизительно 24 дней), не бесконечно. Кроме того, предыдущие версии были ожидает обработчики событий выход в случае полной <xref:System.Int32.MaxValue> достигнуто время.  
  
 Эта перегрузка гарантирует, что вся обработка завершения, включая обработку асинхронных событий для перенаправленного стандартного вывода. Эту перегрузку следует использовать после вызова <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> перегрузки, когда был перенаправлен стандартный поток вывода для асинхронных обработчиков событий.  
  
 При завершении связанного процесса (то есть, когда его работа была завершена функцией операционной системы через нормальное или аварийное завершение), система сохраняет административную информацию о процессе и возвращает к компоненту, вызвавшему метод <xref:System.Diagnostics.Process.WaitForExit>. <xref:System.Diagnostics.Process> Может получить доступ к сведения, а также <xref:System.Diagnostics.Process.ExitTime%2A>, с помощью <xref:System.Diagnostics.Process.Handle%2A> завершенных процессов.  
  
 Так как связанный процесс завершился, <xref:System.Diagnostics.Process.Handle%2A> свойства компонента больше не указывает на существующий ресурс процесса. Вместо этого дескриптор может использоваться только для доступа к операционной системы сведения о ресурсе процесса. Система известно о дескрипторах завершенных процессов, которые не были освобождены <xref:System.Diagnostics.Process> компонентов, поэтому она хранит <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.Handle%2A> информацию в памяти до <xref:System.Diagnostics.Process> компонента, в частности, освобождает ресурсы. По этой причине при каждом вызове <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра, вызовите <xref:System.Diagnostics.Process.Close%2A> при связанный процесс был завершен, и больше не нужны административной информации о нем. <xref:System.Diagnostics.Process.Close%2A> Освобождает память, выделенную завершенных процессов.  
  
   
  
## Examples  
 См. в разделе "Примечания" <xref:System.Diagnostics.Process.StandardError%2A> справочной странице.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Нет доступа к параметру ожидания.</exception>
        <exception cref="T:System.SystemException">Не задан <see cref="P:System.Diagnostics.Process.Id" /> процесса, и <see cref="P:System.Diagnostics.Process.Handle" />, из которого можно определить свойство <see cref="P:System.Diagnostics.Process.Id" />, не существует.  
  
-или- 
С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.  
  
-или- 
Вы пытаетесь вызвать метод <see cref="M:System.Diagnostics.Process.WaitForExit" /> для процесса, выполняющегося на удаленном компьютере. Этот метод доступен только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Количество времени в миллисекундах для ожидания завершения связанного процесса. Максимальным является наибольшее возможное 32-битное целое число, которое представляет для операционной системы бесконечность.</param>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать завершения связанного процесса в течение указанного времени в миллисекундах.</summary>
        <returns>Значение <see langword="true" />, если связанный процесс завершился; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> делает текущий поток ждал до завершения связанного процесса. Его следует вызывать после вызова всех остальных методов для процесса. Чтобы избежать блокировки текущего потока, используйте событие <xref:System.Diagnostics.Process.Exited>.  
  
 Указывает, что этот метод <xref:System.Diagnostics.Process> ожидания конечное количество времени для завершения процесса. Если связанный процесс не завершится по истечении интервала из-за отказа в запросе на завершение `false` возвращается вызвавшей процедуре. Можно указать <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> для `milliseconds`, и <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> будет вести себя так же, как <xref:System.Diagnostics.Process.WaitForExit> перегрузки. Если методу передается 0 (ноль), он возвращает `true` только в том случае, если процесс уже завершился; в противном случае он немедленно возвращает `false`.  
  
> [!NOTE]
>  В [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] и более ранних версий, если `milliseconds` -1, <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> ожидание перегрузки <xref:System.Int32.MaxValue> миллисекунд (приблизительно 24 дней), не бесконечно.  
  
 Когда стандартный вывод был перенаправлен к асинхронных обработчиков событий, вполне возможно, что обработка вывода не будет завершена при возвращении данного метода. Чтобы гарантировать завершение асинхронной обработки событий, вызвать <xref:System.Diagnostics.Process.WaitForExit> перегрузку, принимающую параметр не после получения `true` из этой перегрузки. Чтобы обеспечить <xref:System.Diagnostics.Process.Exited> правильную обработку событий в приложениях Windows Forms, задайте <xref:System.Diagnostics.Process.SynchronizingObject%2A> свойство.  
  
 При завершении связанного процесса (завершает работу операционной системой через обычный или аварийное завершение), система сохраняет административную информацию о процессе и возвращает к компоненту, вызвавшему метод <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. <xref:System.Diagnostics.Process> Может получить доступ к сведения, а также <xref:System.Diagnostics.Process.ExitTime%2A>, с помощью <xref:System.Diagnostics.Process.Handle%2A> завершенных процессов.  
  
 Так как связанный процесс завершился, <xref:System.Diagnostics.Process.Handle%2A> свойства компонента больше не указывает на существующий ресурс процесса. Вместо этого дескриптор может использоваться только для доступа к операционной системы сведения о ресурсе процесса. Система известно о дескрипторах завершенных процессов, которые не были освобождены <xref:System.Diagnostics.Process> компонентов, поэтому она хранит <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.Handle%2A> информацию в памяти до <xref:System.Diagnostics.Process> компонента, в частности, освобождает ресурсы. По этой причине при каждом вызове <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра, вызовите <xref:System.Diagnostics.Process.Close%2A> при связанный процесс был завершен, и больше не нужны административной информации о нем. <xref:System.Diagnostics.Process.Close%2A> Освобождает память, выделенную завершенных процессов.  
  
   
  
## Examples  
 См. в примере кода <xref:System.Diagnostics.Process.ExitCode%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Нет доступа к параметру ожидания.</exception>
        <exception cref="T:System.SystemException">Не задан <see cref="P:System.Diagnostics.Process.Id" /> процесса, и <see cref="P:System.Diagnostics.Process.Handle" />, из которого можно определить свойство <see cref="P:System.Diagnostics.Process.Id" />, не существует.  
  
-или- 
С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.  
  
-или- 
Вы пытаетесь вызвать метод <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> для процесса, выполняющегося на удаленном компьютере. Этот метод доступен только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="milliseconds" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать входа связанного процесса в состояние простоя.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать перехода связанного процесса в состояние простоя в течение неограниченного времени. Эта перегрузка применяется только к процессам с пользовательским интерфейсом и, следовательно, с циклом сообщений.</summary>
        <returns>Значение <see langword="true" />, если связанный процесс достиг состояния простоя.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.Process.WaitForInputIdle> включить обработку приложения, чтобы подождать, пока цикл обработки сообщений вернулась в состояние бездействия. При выполнении процесса с пользовательским интерфейсом, цикл сообщений выполняется каждый раз, отправляется сообщение Windows для процесса операционной системой. Затем процесс возвращается в цикл обработки сообщений. Это процесс называется быть в состоянии простоя, когда он ожидает сообщений внутри цикла обработки сообщений. Это состояние, полезно, например, когда приложение должно ожидать запуска процесса завершить создание основного окна, прежде чем приложение взаимодействует с этим окном.  
  
 Если процесс не содержит цикл обработки сообщений, <xref:System.Diagnostics.Process.WaitForInputIdle> вызывает <xref:System.InvalidOperationException>.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle> Перегрузка указывает, что <xref:System.Diagnostics.Process> компонента для неограниченного времени ожидания для процесса в состояние бездействия в цикл обработки сообщений. Эта инструкция может вызвать приложение перестает отвечать на запросы. Например, если процесс написан так, чтобы всегда выйти из цикла сообщений сразу же, как показано в фрагменте кода `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не имеет графического интерфейса.  
  
-или- 
Произошла неизвестная ошибка. Процессу не удалось перейти в состояние бездействия.  
  
-или- 
Этот процесс уже завершился.  
  
-или- 
Нет процессов, связанных с этим объектом <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Значение от 1 до <see cref="F:System.Int32.MaxValue" />, определяющее количество времени в миллисекундах, в течение которого ожидается переход связанного процесса в состояние простоя. Значение "0" указывает немедленный возврат, а значение "-1" указывает неопределенно долгое ожидание.</param>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать входа связанного процесса в состояние простоя в течение указанного времени в миллисекундах. Эта перегрузка применяется только к процессам с пользовательским интерфейсом и, следовательно, с циклом сообщений.</summary>
        <returns>Значение <see langword="true" />, если связанный процесс достиг состояния простоя; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> включить обработку приложения, чтобы подождать, пока цикл обработки сообщений вернулась в состояние бездействия. При выполнении процесса с пользовательским интерфейсом, цикл сообщений выполняется каждый раз, отправляется сообщение Windows для процесса операционной системой. Затем процесс возвращается в цикл обработки сообщений. Это процесс называется быть в состоянии простоя, когда он ожидает сообщений внутри цикла обработки сообщений. Это состояние, полезно, например, когда приложение должно ожидать запуска процесса завершить создание основного окна, прежде чем приложение взаимодействует с этим окном.  
  
 Если процесс не содержит цикл обработки сообщений, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> вызывает <xref:System.InvalidOperationException>.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> Перегрузка указывает, что <xref:System.Diagnostics.Process> ожидания конечное количество времени для процесса в состояние бездействия в цикл обработки сообщений. Если связанный процесс не стало простаивающим в конце интервала, так как цикл обработки сообщений, `false` возвращается вызвавшей процедуре.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не имеет графического интерфейса.  
  
-или- 
Произошла неизвестная ошибка. Процессу не удалось перейти в состояние бездействия.  
  
-или- 
Этот процесс уже завершился.  
  
-или- 
Нет процессов, связанных с этим объектом <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает использование физической памяти связанного процесса (в байтах).</summary>
        <value>Полное количество физической памяти в байтах, которое использует связанный процесс.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством представляет текущий размер рабочего набора памяти, используемой процессом, в байтах. Рабочий набор процесса — это набор страниц памяти, видимой в данный момент к процессу в физической памяти ОЗУ. Эти страницы являются резидентными и доступны для приложения для использования без создания ошибки страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая модули процессов и системных библиотек.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объем физической памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем физической памяти в байтах, выделенной для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством представляет текущий размер рабочего набора памяти, используемой процессом, в байтах. Рабочий набор процесса — это набор страниц памяти, видимой в данный момент к процессу в физической памяти ОЗУ. Эти страницы являются резидентными и доступны для приложения для использования без создания ошибки страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая инструкции в модули процессов и системных библиотек.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с 32-разрядных процессорах и 64-разрядных процессоров. Это значение эквивалентно **рабочий набор** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускает экземпляр программы Блокнот. Затем извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>