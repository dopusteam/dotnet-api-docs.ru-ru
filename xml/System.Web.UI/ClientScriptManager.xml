<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="362838f0721b50d4f9941389c889e4c552a1bbc0" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53395985" /></Metadata><TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <TypeSignature Language="F#" Value="type ClientScriptManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Определяет методы для управления клиентскими скриптами в веб-приложениях.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager> Класс используется для управления клиентских скриптов и добавить их в веб-приложений. Можно получить ссылку на <xref:System.Web.UI.ClientScriptManager> класса из <xref:System.Web.UI.Page.ClientScript%2A> свойство <xref:System.Web.UI.Page> объекта.  
  
 Можно добавить клиентский скрипт на веб-страницу декларативно, включив его в разметке HTML страницы. Тем не менее существуют ситуации, когда необходимо динамически добавить клиентского скрипта. Чтобы добавить сценарий динамически, используйте <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод, <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метод, <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод, или <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метод, в зависимости от того, как и когда вы хотите добавить скрипт. Дополнительные сведения см. в разделе [Как Динамическое добавление клиентского сценария на веб-страницы ASP.NET](https://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666).  
  
 <xref:System.Web.UI.ClientScriptManager> Класс однозначно определяет сценарии по ключу <xref:System.String> и <xref:System.Type>. Сценарии с один и тот же ключ и тип считаются повторяющимися. Использование типа скрипта помогает избежать путаницы с похожими сценариями разным пользовательским элементам управления, которые могут использоваться на странице.  
  
 <xref:System.Web.UI.ClientScriptManager> Класс может использоваться для обратных вызовов клиентов в ситуациях, когда желательно запустить серверный код из клиента без выполнения обратной передачи. Это называется выполнением обратного вызова каналу на сервер. В функции обратного вызова клиента функция клиентского скрипта отправляет асинхронный запрос веб-страницу ASP.NET. Веб-страницы запускает измененную версию обычного жизненного цикла для обработки обратного вызова. Используйте <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод, чтобы получить ссылку на клиентскую функцию, которая, при вызове инициализирует обратный вызов клиента к событию сервера. Дополнительные сведения см. в разделе [реализация клиента обратные вызовы без обратной передачи](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Обратные вызовы из сценария не будет работать в старых браузерах, которые не поддерживают объектной модели документа (DOM), и они требуют, что ECMAScript включено на стороне клиента. Чтобы проверить, если браузер поддерживает обратные вызовы, используйте <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> свойство, которое можно получить с помощью <xref:System.Web.HttpRequest.Browser%2A> свойства встроенных ASP.NET <xref:System.Web.HttpContext.Request%2A> объекта.  
  
 Используйте <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод и <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> метод для определения события обратной передачи клиента. Эти методы позволяют функций клиентского скрипта, при вызове, чтобы заставить сервер для обратной передачи страницы. События обратной передачи клиента отличается от обратного вызова клиента в том, что веб-страницы завершается нормальный жизненный цикл для обработки событий обратной передачи клиента.  
  
> [!NOTE]
>  Если вы используете <xref:System.Web.UI.WebControls.Button> управления и <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство имеет значение `false`, можно использовать <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод, чтобы снова получить возможность управления обратной передачи событий для <xref:System.Web.UI.WebControls.Button> элемента управления.  
  
 <xref:System.Web.UI.WebControls.Button.OnClientClick%2A> Свойство <xref:System.Web.UI.WebControls.Button> управления <xref:System.Web.UI.WebControls.ImageButton> элемента управления, и <xref:System.Web.UI.WebControls.LinkButton> элемент управления можно использовать для запуска клиентского скрипта.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод <xref:System.Web.UI.ClientScriptManager> класса. Два клиентских скриптов определены на странице: `PopupScript`, который отображает предупреждение при загрузке страницы, и `ButtonClickScript`, определяющий клиентский обработчик для кнопка HTML `onClick` событий.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
    <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">Клиентский скрипт на веб-страницах ASP.NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событию сервера.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Сервер <see cref="T:System.Web.UI.Control" />, обрабатывающий обратные вызовы клиента. Элемент управления должен реализовать интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" /> и предоставить метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Аргумент, передаваемый от клиентского скрипта серверу. 
 Метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Имя клиентского обработчика событий, который принимает результаты успешно выполненного события сервера.</param>
        <param name="context">Клиентский скрипт, оцениваемый на стороне клиента до инициализации обратного вызова. Результат скрипта отправляется обратно клиентскому обработчику событий.</param>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событию сервера. Клиентская функция для перегруженного метода включает указанный элемент управления, аргумент, клиентский скрипт и контекст.</summary>
        <returns>Имя клиентской функции, осуществляющей обратный вызов клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Метод выполняет обратный вызов из внешнего сервера, являющегося модификацией обычного жизненного цикла страницы. Дополнительные сведения см. в разделе [реализация клиента обратные вызовы без обратной передачи](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  При использовании обозревателя Microsoft Internet Explorer (версии 5.0 или более поздней версии), механизм обратного вызова сценарий реализуется с помощью Microsoft.XmlHttp COM-объекта и требуется браузер, чтобы задать выполнение элементов управления ActiveX. Для других браузеров используется запрос XMLHttpRequest, с помощью браузера локального объекта модели (DOM). Чтобы проверить, поддерживает ли браузер обратные вызовы клиента, используйте <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> свойство. Чтобы проверить, поддерживает ли браузер XML по протоколу HTTP, используйте <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> свойство. Оба свойства, доступны через <xref:System.Web.HttpRequest.Browser%2A> свойства встроенных ASP.NET <xref:System.Web.HttpContext.Request%2A> объекта.  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод выполняет обратный вызов синхронно с помощью XML по протоколу HTTP. При отправке данных синхронно в сценарии обратного вызова, синхронные обратные вызовы немедленно возвращаются и не блокируют браузер. В то же время, в браузере может выполняться не два синхронных обратных вызова. Если второй синхронный обратный вызов инициируется в том случае, пока он находится в состоянии ожидания, второй синхронный обратный вызов отменяет первый, и вернет только второй обратного вызова.  
  
 Для асинхронной передачи данных, используйте одну из перегрузок, принимающих `useAsync` параметр, который возвращается логическое значение, определяющее, это поведение. В асинхронном сценарии может иметь несколько ждущих ответных вызовов; Тем не менее порядок, в котором они возвращаются в соответствии с порядком, в котором они были инициированы не гарантируется.  
  
 Кроме того, эта перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод задает не клиентская функция для обработки случая, условий возникновения ошибки, создаваемые <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метод. Чтобы указать обработчик обратного вызова клиента ошибки, используйте одну из перегрузок, принимающих `clientErrorCallback` параметра.  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Метод принимает необязательную строку `argument` параметр и возвращает строку. Для передачи или получить несколько значений, производящие объединение значений во входных данных или возвращают строку, соответственно.  
  
> [!NOTE]
>  Избегайте использования состояния представления при реализации свойств страницы или элемента управления, которые необходимо обновлять во время операций обратного вызова сценария. Если свойства должен быть устойчив запросов страниц, можно использовать состояние сеанса.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование двух перегрузок <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод в сценарии обратного вызова клиента, который увеличивает целых чисел.  
  
 Отображаются два механизма обратного вызова; различие между ними является использование `context` параметра. Объект `ReceiveServerData1` функцию обратного вызова клиента обеспечивается с помощью `context` параметра. Напротив `ReceiveServerData2` функцию обратного вызова клиента определяется в `<script>` блок на странице. Объект <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метод является обработчиком сервера, на которое увеличивается значение, которое передается в него и <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> метод возвращает увеличенное значение как строка. Если <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метод возвращает ошибку, а затем `ProcessCallBackError` вызове функции клиента.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный элемент управления <see cref="T:System.Web.UI.Control" /> не реализует интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Сервер <see cref="T:System.Web.UI.Control" />, обрабатывающий обратные вызовы клиента. Элемент управления должен реализовать интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" /> и предоставить метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Аргумент, передаваемый от клиентского скрипта серверу. 
 Метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Имя клиентского обработчика событий, который принимает результаты успешно выполненного события сервера.</param>
        <param name="context">Клиентский скрипт, оцениваемый на стороне клиента до инициализации обратного вызова. Результат скрипта отправляется обратно клиентскому обработчику событий.</param>
        <param name="useAsync"><see langword="true" /> для выполнения обратного вызова асинхронно; <see langword="false" /> для выполнения обратного вызова синхронно.</param>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событиям сервера. Клиентская функция для перегруженного метода включает указанный элемент управления, аргумент, клиентский скрипт, контекст и логическое значение.</summary>
        <returns>Имя клиентской функции, осуществляющей обратный вызов клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод требует `useAsync` параметр, который позволяет асинхронно выполнять обратный вызов клиента, задав значение `true`. Версии перегрузки этого метода, не требующие `useAsync` параметру присвоить значение `false` по умолчанию.  
  
 Дополнительные сведения об этом методе см. в разделе "Примечания" для перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный элемент управления <see cref="T:System.Web.UI.Control" /> не реализует интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : string * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (target, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">Имя сервера <see cref="T:System.Web.UI.Control" />, обрабатывающего обратный вызов клиента. Элемент управления должен реализовать интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" /> и предоставить метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Аргумент, передаваемый от клиентского скрипта серверу. 
 Метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Имя клиентского обработчика событий, который принимает результаты успешно выполненного события сервера.</param>
        <param name="context">Клиентский скрипт, оцениваемый на стороне клиента до инициализации обратного вызова. Результат скрипта отправляется обратно клиентскому обработчику событий.</param>
        <param name="clientErrorCallback">Имя клиентского обработчика событий, принимающего результат, когда в обработчике событий сервера возникает ошибка.</param>
        <param name="useAsync"><see langword="true" /> для выполнения обратного вызова асинхронно; <see langword="false" /> для выполнения обратного вызова синхронно.</param>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событиям сервера. Клиентская функция для перегруженного метода включает указанную цель, аргумент, клиентский скрипт, контекст, обработчик ошибок и логическое значение.</summary>
        <returns>Имя клиентской функции, осуществляющей обратный вызов клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> альбома `target` строковый параметр, а не <xref:System.Web.UI.Control> параметра. Используйте этот перегруженный метод, при необходимости обратного вызова, чтобы вернуться назад, отличный от строка, содержащая <xref:System.Web.UI.Control.UniqueID%2A> элемента управления.  
  
 Кроме того, эта перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод требует `useAsync` и `clientErrorCallback` параметр. `useAsync` Служит для выполнения обратного вызова клиента в асинхронном режиме, задав значение `true`. Версии перегрузки этого метода, не требующие `useAsync` параметру присвоить значение `false` по умолчанию. `clientErrorCallback` Параметра можно задать имя клиентская функция, которая вызывается, если обработчик сервера <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метода, возвращает сообщение об ошибке. Версии перегрузки этого метода, не требующие `clientErrorCallback` параметру присвоить значение null.  
  
 Дополнительные сведения об этом методе см. в разделе "Примечания" для перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование двух перегрузок <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод в сценарии обратного вызова клиента, который увеличивает целых чисел.  
  
 Отображаются два механизма обратного вызова; различие между ними является использование `context` параметра. Объект `ReceiveServerData1` функцию обратного вызова клиента обеспечивается с помощью `context` параметра. Напротив `ReceiveServerData2` функцию обратного вызова клиента определяется в `<script>` блок на странице. Объект <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метод является обработчиком сервера, на которое увеличивается значение, которое передается в него и <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> метод возвращает увеличенное значение как строка. Если <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метод возвращает ошибку, то клиентская функция `ProcessCallBackError` вызывается.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Сервер <see cref="T:System.Web.UI.Control" />, обрабатывающий обратные вызовы клиента. Элемент управления должен реализовать интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" /> и предоставить метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Аргумент, передаваемый от клиентского скрипта методу <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> сервера.</param>
        <param name="clientCallback">Имя клиентского обработчика событий, который принимает результаты успешно выполненного события сервера.</param>
        <param name="context">Клиентский скрипт, оцениваемый на стороне клиента до инициализации обратного вызова. Результат скрипта отправляется обратно клиентскому обработчику событий.</param>
        <param name="clientErrorCallback">Имя клиентского обработчика событий, принимающего результат, когда в обработчике событий сервера возникает ошибка.</param>
        <param name="useAsync"><see langword="true" /> для выполнения обратного вызова асинхронно; <see langword="false" /> для выполнения обратного вызова синхронно.</param>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событиям сервера. Клиентская функция для перегруженного метода включает указанный элемент управления, аргумент, клиентский скрипт, контекст, обработчик ошибок и логическое значение.</summary>
        <returns>Имя клиентской функции, осуществляющей обратный вызов клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод требует `useAsync` и `clientErrorCallback` параметр. `useAsync` Служит для выполнения обратного вызова клиента в асинхронном режиме, задав значение `true`. Версии перегрузки этого метода, не требующие `useAsync` параметру присвоить значение `false` по умолчанию. `clientErrorCallback` Параметра можно задать имя клиентская функция, которая вызывается, если обработчик сервера ( <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> метод) возвращает сообщение об ошибке. Версии перегрузки этого метода, не требующие `clientErrorCallback` параметру присвоить значение null.  
  
 Дополнительные сведения об этом методе см. в разделе "Примечания" для перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный элемент управления <see cref="T:System.Web.UI.Control" /> не реализует интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает ссылку с добавленным <see langword="javascript:" /> в начале, которую можно использовать в клиентском событии для обратной передачи серверу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, обрабатывающий обратную передачу.</param>
        <param name="argument">Параметр, передаваемый серверному элементу управления.</param>
        <summary>Возвращает ссылку, с <see langword="javascript:" /> в начале, которую можно использовать в клиентском событии для обратной передачи серверу указанного элемента управления с указанными аргументами события.</summary>
        <returns>Строка, представляющая вызов JavaScript функции обратной передачи, включающей идентификатор целевого элемента управления и аргументы события.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод требует элемент управления, обрабатывающий обратную передачу для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс. Для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс для <xref:System.Web.UI.Page>, используйте директиву.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> метод. Пользовательский элемент управления, `MyControl`, реализует <xref:System.Web.UI.IPostBackEventHandler> интерфейс. При щелчке элемент привязки HTML на странице, <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> вызывается метод пользовательского элемента управления.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 В следующем примере кода имеет ту же функциональность, что и предыдущий, но вместо пользовательского элемента управления, <xref:System.Web.UI.Page> класс реализует <xref:System.Web.UI.IPostBackEventHandler> интерфейс.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, обрабатывающий обратную передачу.</param>
        <param name="argument">Параметр, передаваемый серверному элементу управления.</param>
        <param name="registerForEventValidation"><see langword="true" />, чтобы регистрировать событие обратной передачи для проверки; <see langword="false" />, чтобы не регистрировать событие обратной передачи для проверки.</param>
        <summary>Возвращает ссылку с добавленным <see langword="javascript:" /> в начале, которую можно использовать в клиентском событии для обратной передачи серверу для указанного элемента управления с указанными аргументами события и логическим обозначением, следует ли регистрировать обратную передачу для проверки события.</summary>
        <returns>Строка, представляющая вызов JavaScript функции обратной передачи, включающей идентификатор целевого элемента управления и аргументы события.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод требует элемент управления, обрабатывающий обратную передачу для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс. Для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс для <xref:System.Web.UI.Page>, используйте директиву.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions -&gt; string" Usage="clientScriptManager.GetPostBackEventReference options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options"><see cref="T:System.Web.UI.PostBackOptions" />, определяющий обратную передачу.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным экземпляром <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <returns>Строка, инициирующая клиентскую обратную передачу (при рассмотрении строки в качестве клиентского скрипта).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс для <xref:System.Web.UI.Page>, используйте директиву.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Метод может использоваться с <xref:System.Web.UI.WebControls.Button> управления <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство `false`. В этом случае <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> возвращает клиентскую обратную передачу событий для <xref:System.Web.UI.WebControls.Button> элемента управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="T:System.Web.UI.PostBackOptions" /> равно <see langword="null" /></exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления <see cref="T:System.Web.UI.Control" />, обрабатывающий обратную передачу на сервер.</param>
        <param name="argument">Строка необязательных аргументов для передачи элементу управления, обрабатывающему обратную передачу.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным элементом управления, обрабатывающим обратную передачу, и строчным аргументом с дополнительной информацией о событии.</summary>
        <returns>Строка, инициирующая — при рассмотрении ее в качестве скрипта на стороне клиента — обратную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс для <xref:System.Web.UI.Page>, используйте директиву.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Метод может использоваться с <xref:System.Web.UI.WebControls.Button> управления <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство `false`. В этом случае <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> возвращает клиентскую обратную передачу событий для <xref:System.Web.UI.WebControls.Button> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод. Пользовательский элемент управления, `MyControl`, реализует <xref:System.Web.UI.IPostBackEventHandler> интерфейс. При нажатии кнопки на странице <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> вызывается метод пользовательского элемента управления.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 В следующем примере кода имеет ту же функциональность, что и предыдущий, но вместо пользовательского элемента управления, <xref:System.Web.UI.Page> класс реализует <xref:System.Web.UI.IPostBackEventHandler> интерфейс.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (options, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options"><see cref="T:System.Web.UI.PostBackOptions" />, определяющий обратную передачу.</param>
        <param name="registerForEventValidation"><see langword="true" /> для регистрации ссылки на событие для проверки; в противном случае — <see langword="false" />.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным объектом <see cref="T:System.Web.UI.PostBackOptions" />. По выбору регистрирует ссылку на событие для проверки.</summary>
        <returns>Строка, инициирующая клиентскую обратную передачу (при рассмотрении строки в качестве клиентского скрипта).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс для <xref:System.Web.UI.Page> , используйте директиву.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Метод может использоваться с <xref:System.Web.UI.WebControls.Button> управления <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство `false`. В этом случае <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> возвращает клиентскую обратную передачу событий для <xref:System.Web.UI.WebControls.Button> элемента управления.  
  
 Если `registerForEventValidation` — `true`, <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> вызовы методов <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> метод, чтобы зарегистрировать ссылку на событие для проверки с уникальным ИД элемента управления, представляющий клиентский элемент управления, который создает событие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="T:System.Web.UI.PostBackOptions" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления <see cref="T:System.Web.UI.Control" />, обрабатывающий обратную передачу на сервер.</param>
        <param name="argument">Строка необязательных аргументов для передачи элементу управления <paramref name="control" />.</param>
        <param name="registerForEventValidation"><see langword="true" /> для регистрации ссылки на событие для проверки; в противном случае — <see langword="false" />.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным элементом управления, обрабатывающим обратную передачу, и строчным аргументом с дополнительной информацией о событии. По выбору регистрирует ссылку на событие для проверки.</summary>
        <returns>Строка, инициирующая — при рассмотрении ее в качестве скрипта на стороне клиента — обратную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для реализации <xref:System.Web.UI.IPostBackEventHandler> интерфейс для <xref:System.Web.UI.Page>, используйте директиву.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Метод может использоваться с <xref:System.Web.UI.WebControls.Button> управления <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство `false`. В этом случае <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> возвращает клиентскую обратную передачу событий для <xref:System.Web.UI.WebControls.Button> элемента управления.  
  
 Если `registerForEventValidation` имеет значение true, <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> вызовы методов <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> метод, чтобы зарегистрировать ссылку на событие для проверки с уникальным ИД элемента управления, представляющий клиентский элемент управления, который создает событие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.GetWebResourceUrl : Type * string -&gt; string" Usage="clientScriptManager.GetWebResourceUrl (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип ресурса.</param>
        <param name="resourceName">Полное имя ресурса в сборке.</param>
        <summary>Возвращает ссылку URL-адреса на ресурс в сборке.</summary>
        <returns>Ссылка URL-адреса на ресурс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Метод возвращает ссылку URL-адреса ресурсов, внедренных в сборку. Возвращаемая ссылка не является URL-кодированием. Ресурсы можно файлы скриптов, изображений или статическим. Указывается тип, на основе объекта, который будет осуществлять доступ к ресурсу.  
  
 Зарегистрирован на странице веб-ресурс однозначно идентифицируется его имя и тип. Страницы может быть зарегистрирован только один ресурс с заданным типом и пару "имя". При попытке регистрации ресурса, который уже зарегистрирован создается дубликат зарегистрированного ресурса.  
  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Метод используется в сочетании с <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> метод для доступа к ресурсам, внедренным в сборки. Дополнительные сведения об использовании ресурсов в приложениях, см. в разделе [ASP.NET Web Page Resources Overview](https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> метод. *Типа* параметра в этом примере присваивается тип класса в сборке, содержащей ресурс. `resourceName` Параметр указан с полный путь к ресурсу, который включает в себя пространство имен по умолчанию.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 В следующем примере кода показано, как программно применять <xref:System.Web.UI.WebResourceAttribute> атрибут метаданных, чтобы пометить сборку для ресурсов, которые будут обслуживаться. Скомпилируйте следующий класс в библиотеке классов пространства имен по умолчанию, равным `Samples.AspNet.CS.Controls` или `Samples.AspNet.VB.Controls`в зависимости от языка вы используете.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 В этом примере требуется файл JavaScript с именем `Script_include.js`. JS-файла является внедренного ресурса в сборку, содержащую `ClientScriptResourceLabel` объекта. Если вы используете Visual Studio в окне свойств проекта библиотеки классов, задайте **действие при построении** для **внедренный ресурс** при выборе файла скрипта. При компиляции библиотеки из командной строки, служит для внедрения ресурса.  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип веб-ресурса — <see langword="null" />.

-или-

Имя веб-ресурса — <see langword="null" />.  
  
-или- 
Длина имени веб-ресурса равна 0.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <related type="Article" href="https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd">Общие сведения о ресурсах веб-страницы ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5212666e-98ab-47e4-a497-b5545ab15c7f">/ Resource (внедрить файл ресурсов в выходной файл) (параметры компилятора C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eee2f227-91f2-4f2b-a9d6-1c51c5320858">/resource (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, зарегистрирован ли блок клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ блока клиентского скрипта, используемый для поиска.</param>
        <summary>Определяет, зарегистрирован ли блок клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя указанный ключ.</summary>
        <returns><see langword="true" />, если блок клиентского скрипта зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод, чтобы избежать повторяющихся сценариев регистрации. Это особенно важно в том случае, если сценарий требует большой объем серверных ресурсов.  
  
 Клиентский скрипт однозначно идентифицируется ключом и его тип. Сценарии с один и тот же ключ и тип считаются повторяющимися.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метод вызывает перегрузку, принимающую оба `key` и `type` параметр с типом в качестве <xref:System.Web.UI.Page> объекта  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип блока клиентского скрипта, используемый для поиска.</param>
        <param name="key">Ключ блока клиентского скрипта, используемый для поиска.</param>
        <summary>Определяет, зарегистрирован ли блок клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя ключ и тип.</summary>
        <returns><see langword="true" />, если блок клиентского скрипта зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод, чтобы избежать повторяющихся сценариев регистрации. Это особенно важно в том случае, если сценарий требует большой объем серверных ресурсов.  
  
 Клиентский скрипт однозначно идентифицируется ключом и его тип. Сценарии с один и тот же ключ и тип считаются повторяющимися. Указывается тип, на основе объекта, который будет осуществлять доступ к ресурсу. Например при использовании `Page` экземпляр для доступа к ресурсу, можно указать `Page` типа.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метод. Обратите внимание, что, если были удалены, логика для проверки существующего блок клиентского скрипта, будет не два повторяющихся клиентских скриптов в исходном коде HTML, отображаемой страницы поскольку <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод проверяет наличие дубликатов. Преимущество проверки заключается в сокращении ненужных вычислений.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип клиентского скрипта — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, зарегистрировано ли включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ включения клиентского скрипта, используемый для поиска.</param>
        <summary>Определяет, зарегистрировано ли включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя указанный ключ.</summary>
        <returns><see langword="true" />, если включение клиентского скрипта зарегистрировано; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метод, чтобы избежать повторяющихся сценариев регистрации. Это особенно важно в том случае, если сценарий требует большой объем серверных ресурсов.  
  
 Включение клиентского скрипта однозначно идентифицируется ключом и его тип. Сценарии с один и тот же ключ и тип считаются повторяющимися.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метод вызывает перегрузку, принимающую оба `key` и `type` параметр с типом в качестве <xref:System.Web.UI.Page> объекта.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип включения клиентского скрипта, используемый для поиска.</param>
        <param name="key">Ключ включения клиентского скрипта, используемый для поиска.</param>
        <summary>Определяет, зарегистрировано ли включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя ключ и тип.</summary>
        <returns><see langword="true" />, если включение клиентского скрипта зарегистрировано; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> включает метод, чтобы исключить регистрацию повторяющиеся клиентского скрипта. Это особенно важно в том случае, если сценарий требует большой объем серверных ресурсов.  
  
 Включение клиентского скрипта однозначно идентифицируется ключом и его тип. Сценарии с один и тот же ключ и тип считаются повторяющимися. Указывается тип, на основе объекта, который будет осуществлять доступ к ресурсу. Например, при использовании экземпляра Page для доступа к ресурсу, указывается `Page` типа.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> метод. Обратите внимание, что, если логика для проверки для существующего клиентского скрипта включают были удалены, будет не два повторяющихся клиентских скриптов в исходном коде HTML, отображаемой страницы поскольку <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метод проверяет наличие дубликатов. Преимущество проверки заключается в сокращении ненужных вычислений.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 В этом примере требуется файл JavaScript с именем `Script_include.js`, со следующим содержимым:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип включения клиентского скрипта — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, зарегистрирован ли оператор OnSubmit с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ оператора OnSubmit, используемый для поиска.</param>
        <summary>Определяет, зарегистрирован ли оператор OnSubmit с объектом <see cref="T:System.Web.UI.Page" />, используя указанный ключ.</summary>
        <returns><see langword="true" />, если оператор OnSubmit зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метод, чтобы избежать повторяющихся инструкций OnSubmit регистрации. Это особенно важно в том случае, если оператор требует большой объем серверных ресурсов.  
  
 Оператор однозначно идентифицируется ключом и его тип. Инструкции с один и тот же ключ и тип считаются повторяющимися.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> метод вызывает перегрузку, принимающую оба `key` и `type` параметр с типом в качестве <xref:System.Web.UI.Page> объекта  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип оператора OnSubmit, используемый для поиска.</param>
        <param name="key">Ключ оператора OnSubmit, используемый для поиска.</param>
        <summary>Определяет, зарегистрирован ли оператор OnSubmit с объектом <see cref="T:System.Web.UI.Page" />, используя указанные ключ и тип.</summary>
        <returns><see langword="true" />, если оператор OnSubmit зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метод, чтобы исключить регистрацию повторяющихся инструкций. Это особенно важно в том случае, если оператор требует большой объем серверных ресурсов.  
  
 Оператор однозначно идентифицируется ключом и его тип. Инструкции с один и тот же ключ и тип считаются повторяющимися. Указывается тип, на основе объекта, который будет осуществлять доступ к ресурсу. Например при использовании `Page` экземпляр для доступа к ресурсу, можно указать `Page` типа.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> метод. Сценарий с именем `OnSubmitScript` зарегистрирован <xref:System.Web.UI.Page> таким образом, когда страницы отправки формы вызывается скрипт.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип оператора OnSubmit — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, зарегистрирован ли скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ скрипта, активизируемого при запуске, для поиска.</param>
        <summary>Определяет, зарегистрирован ли скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />, используя указанный ключ.</summary>
        <returns><see langword="true" />, если скрипт, активизируемый при запуске, зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод, чтобы избежать повторяющихся сценариев регистрации. Это особенно важно в том случае, если сценарий требует большой объем серверных ресурсов.  
  
 Сценарий запуска однозначно идентифицируется ключом и его тип. Сценарии с один и тот же ключ и тип считаются повторяющимися.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метод вызывает перегрузку, которая принимает строку, оба `key` и `type` параметр с типом в качестве <xref:System.Web.UI.Page> объекта  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип скрипта запуска, используемый при поиске.</param>
        <param name="key">Ключ скрипта, активизируемого при запуске, для поиска.</param>
        <summary>Определяет, зарегистрирован ли скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />, используя указанные ключ и тип.</summary>
        <returns><see langword="true" />, если скрипт, активизируемый при запуске, зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод, чтобы избежать повторяющихся сценариев регистрации. Это особенно важно в том случае, если сценарий требует большой объем серверных ресурсов.  
  
 Сценарий запуска клиента однозначно идентифицируется ключом и его тип. Сценарии с один и тот же ключ и тип считаются повторяющимися.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метод. Обратите внимание, что, если были удалены, логика для проверки существующего стартовый блок скрипта, будет не двух повторяющихся сценариев в исходном коде HTML, отображаемой страницы поскольку <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод проверяет наличие дубликатов. Преимущество проверки заключается в сокращении ненужных вычислений.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип скрипта, активизируемого при запуске, — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="clientScriptManager.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Имя массива для регистрации.</param>
        <param name="arrayValue">Значение или значения массива для регистрации.</param>
        <summary>Регистрирует объявление массива JavaScript с объектом <see cref="T:System.Web.UI.Page" />, используя имя массива и значение массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> Проверяет, существует ли зарегистрированный массив с тем же именем, как имя, указанное в `arrayName` параметр и, если да, добавляет значения, указанные в `arrayValue` параметра. Так как базовый механизм хранения основана на <xref:System.Collections.ArrayList>, дубликаты разрешены. Если зарегистрированный массив с тем же именем, что `arrayName` параметр не существует, оно создается и значения в `arrayValue` параметр, добавленный к нему.  
  
 Если требуется, чтобы строковые литералы в результирующий массив JavaScript, используйте одиночные кавычки (') или экранировать двойные кавычки (\\«) в `arrayValue` параметра. Значение `arrayValue` параметр должен быть один элемент. Если более одного значения должен быть добавлен в массив, несколько вызовов с помощью <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> и <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> методы. В примере регистрируется массив и скрытое значение, а также определяет `OnClick` событие `<input>` кнопку, чтобы вычислить сумму двух значений массива и скрытое значение.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="arrayName" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого клиентского скрипта.</param>
        <param name="key">Ключ регистрируемого клиентского скрипта.</param>
        <param name="script">Константа регистрируемого клиентского скрипта.</param>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ и константу скрипта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентский скрипт однозначно идентифицируется ключом и его тип. Сценарии с один и тот же ключ и тип считаются повторяющимися. Страницы может быть зарегистрирован только один скрипт с заданным типом и пару ключей. Попытка зарегистрировать скрипт, который уже зарегистрирован создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метод, чтобы определить ли клиентский скрипт с заданной парой ключ и тип зарегистрирован и избежать ненужной попытки добавления скрипта.  
  
 В этой перегрузке <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод, убедитесь, что он предоставлен в `script` параметра упаковывается в `<script>` элемент блока.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Метод добавляет блок скрипта в начало отображаемой страницы. Блоки скриптов не обязательно будут выводиться в порядке, в котором они зарегистрированы. Если важен порядок блоков сценария, используйте <xref:System.Text.StringBuilder> для сбора скриптов вместе в одной строке, а затем зарегистрировать их все в один блок клиентского скрипта.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого клиентского скрипта.</param>
        <param name="key">Ключ регистрируемого клиентского скрипта.</param>
        <param name="script">Константа регистрируемого клиентского скрипта.</param>
        <param name="addScriptTags">Логическое значение, указывающее, требуется ли добавление тегов скрипта.</param>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ, константу скрипта и логическое значение, указывающее следует ли добавление тегов скрипта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентский скрипт однозначно идентифицируется ключом и его тип. Сценарии с один и тот же ключ и тип считаются повторяющимися. Страницы может быть зарегистрирован только один скрипт с заданным типом и пару ключей. Попытка зарегистрировать скрипт, который уже зарегистрирован создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метод, чтобы определить, зарегистрирован ли клиентский скрипт с заданной парой ключ и тип. Это позволяет избежать ненужной попытки добавления скрипта.  
  
 В этой перегрузке <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод, вы можете указывает, что скрипт в `script` параметр заключается в оболочку с `<script>` блока элементов с помощью `addScriptTags` параметра. Установка `addScriptTags` для `true` указывает, что теги сценариев будут добавляться автоматически.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Метод добавляет блок скрипта в начало отображаемой страницы. Блоки скриптов не обязательно будут выводиться в порядке, в котором они зарегистрированы. Если важен порядок блоков сценария, используйте <xref:System.Text.StringBuilder> для сбора скриптов вместе в одной строке, а затем зарегистрировать их все в один блок клиентского скрипта.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод. Обратите внимание, что `addScriptTags` параметр имеет значение `true` , начальный и закрывающий теги сценариев не включаются `script` параметра.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип блока клиентского скрипта — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ регистрируемого включения клиентского скрипта.</param>
        <param name="url">URL-адрес регистрируемого включения клиентского скрипта.</param>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />, используя ключ и URL-адрес, который позволяет вызывать скрипт из клиента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Включение клиентского скрипта однозначно идентифицируется ключом и его тип. Сценарии с один и тот же ключ и тип считаются повторяющимися. Страницы может быть зарегистрирован только один скрипт с заданным типом и пару ключей. Попытка зарегистрировать скрипт, который уже зарегистрирован создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> метод, чтобы определить ли включение клиентского скрипта с данным ключом и пара типа уже зарегистрирован и избежать ненужной попытки добавления скрипта.  
  
> [!NOTE]
>  Чтобы разрешить URL-адрес клиента, используйте <xref:System.Web.UI.Control.ResolveClientUrl%2A> метод. Этот метод использует контекст URL-адрес, на котором он вызывается для разрешения пути.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метод вызывает перегрузку, принимающую `key`, `URL`и `type` параметра.  
  
 Метод добавляет блок скрипта в верхней части отображаемой страницы.  
  
   
  
## Examples  
 Дополнительные сведения, включая синтаксис, использование и пример, см. в разделе <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого включения клиентского скрипта.</param>
        <param name="key">Ключ регистрируемого включения клиентского скрипта.</param>
        <param name="url">URL-адрес регистрируемого включения клиентского скрипта.</param>
        <summary>Регистрирует включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ и URL-адрес.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> альбома *ключ* и *URL-адрес* параметры для определения скрипта на, а также `type` включать параметр, чтобы указать идентификатор клиентского скрипта. Указывается тип, на основе объекта, который будет осуществлять доступ к ресурсу. Например при использовании `Page` экземпляр для доступа к ресурсу, можно указать `Page` типа.  
  
> [!NOTE]
>  Чтобы разрешить URL-адрес клиента, используйте <xref:System.Web.UI.Control.ResolveClientUrl%2A> метод. Этот метод использует контекст URL-адрес, на котором он вызывается для разрешения пути.  
  
 Этот метод добавляет блок скрипта в верхней части отображаемой страницы.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метод. Обратите внимание, что если логику для проверки для существующего клиентского скрипта включают были удалены, будет по-прежнему не повторяющиеся клиентских скриптов в отображаемой странице поскольку <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метод проверяет наличие дубликатов. Преимущество проверки заключается в сокращении ненужных вычислений.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 В этом примере требуется файл JavaScript с именем и со следующим содержимым:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип включения клиентского скрипта — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">URL-адрес имеет значение <see langword="null" />.  
  
- или - 
URL пуст.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptResource : Type * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptResource (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого ресурса клиентского скрипта.</param>
        <param name="resourceName">Имя регистрируемого ресурса клиентского скрипта.</param>
        <summary>Регистрирует ресурс клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя тип и имя ресурса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Метод используется, если доступ к ресурсам скомпилированный из сборки через обработчик WebResource.axd HTTP. <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Метод регистрирует скрипт с <xref:System.Web.UI.Page> объекта и запрещает повторяющиеся сценариев. Этот метод создает оболочку содержимое URL-адрес ресурса с `<script>` элемент блока.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> метод.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 В следующем примере кода показано, как программно применять <xref:System.Web.UI.WebResourceAttribute> атрибут метаданных, чтобы пометить сборку для ресурсов, которые будут обслуживаться.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 В этом примере требуется файл JavaScript с именем `Script_include.js`, со следующим содержимым:  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 Скомпилируйте `Script_include.js` файл как ресурс в `Samples.AspNet.CS.Controls` сборку, содержащую `ClientScriptResourceLabel` класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип клиентского ресурса — <see langword="null" />.

-или-

Имя клиентского ресурса — <see langword="null" />.  
  
- или - 
Длина имени клиентского ресурса равна 0.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует пару "имя-значение" как пользовательский (expando) атрибут указанного элемента управления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">Элемент управления <see cref="T:System.Web.UI.Control" /> на странице, содержащей пользовательский атрибут.</param>
        <param name="attributeName">Имя регистрируемого пользовательского атрибута.</param>
        <param name="attributeValue">Значение пользовательского атрибута.</param>
        <summary>Регистрирует пару "имя-значение" как пользовательский (expando) атрибут указанного элемента управления с указанными идентификатором, именем атрибута и значением атрибута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Метод регистрирует пару имя значение как пользовательский (expando) атрибут на указанном <xref:System.Web.UI.Control>. Атрибут expando устанавливается динамически из кода JavaScript для сохранения совместимости разметки отображаемых элементов управления XHTML. Кавычки и обратные косые черты в пользовательский (expando) атрибут значения экранируются. Если вы не хотите escape-кавычки и обратные косые черты, вызвать <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> перегрузки метода и задайте `encode` параметр `false`.  
  
 Если атрибут expando не найден или не найден элемент управления для добавления атрибута expando, клиентский скрипт по-прежнему создается, но не влияет на элемент управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">Элемент управления <see cref="T:System.Web.UI.Control" /> на странице, содержащей пользовательский атрибут.</param>
        <param name="attributeName">Имя регистрируемого пользовательского атрибута.</param>
        <param name="attributeValue">Значение пользовательского атрибута.</param>
        <param name="encode">Логическое значение, указывающее будет ли кодироваться регистрируемый пользовательский атрибут.</param>
        <summary>Регистрирует пару "имя-значение" как пользовательский (expando) атрибут указанного элемента управления с указанными идентификатором, именем атрибута, значением атрибута и логическим значением, определяющим, будет ли кодироваться значение атрибута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Метод регистрирует пару имя значение как пользовательский (expando) атрибут на указанном <xref:System.Web.UI.Control>. Атрибут expando устанавливается динамически из кода JavaScript для сохранения совместимости разметки отображаемых элементов управления XHTML. Задайте `encode` параметр `true` Если необходимо экранировать кавычки и обратные косые черты в значении атрибута expando.  
  
 Если атрибут expando не найден или не найден элемент управления для добавления атрибута expando, клиентский скрипт по-прежнему создается, но не влияет на элемент управления.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> метод <xref:System.Web.UI.ClientScriptManager> класса. Клиентский скрипт в отображаемой странице наборах `title` атрибут `<span>` элемента.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует ссылку на событие для проверки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Уникальный ИД, представляющий клиентский элемент управления, генерирующий событие.</param>
        <summary>Регистрирует ссылку на событие для проверки с уникальным ИД элемента управления, представляющим клиентский элемент управления, генерирующий событие.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения и примеры см. в разделе <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод и <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> метод, чтобы зарегистрировать обратный вызов для проверки, а также способы проверки, что обратный вызов поступил со страницы.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : System.Web.UI.PostBackOptions -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">Объект <see cref="T:System.Web.UI.PostBackOptions" />, определяющий, как создается клиентский скрипт JavaScript для инициации обратной передачи.</param>
        <summary>Регистрирует ссылку на событие для проверки с <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения и примеры см. в разделе <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string * string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Уникальный ИД, представляющий клиентский элемент управления, генерирующий событие.</param>
        <param name="argument">Аргументы события, переданные вместе с клиентским событием.</param>
        <summary>Регистрирует ссылку на событие для проверки с уникальным ИД элемента управления, представляющим клиентский элемент управления, генерирующий событие, и аргументами события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод и <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> метод, чтобы зарегистрировать обратный вызов для проверки и проверить, что обратный вызов поступил со страницы. Для улучшения проверки, показано в примере, можно изменить проверки `argument` параметр, содержащий сведения, относящиеся к пользователю, например удостоверение или роль.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод, чтобы зарегистрировать обратный вызов для проверки.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод вызывается до метода <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/18fc94c9-56fc-46c3-9f29-7358f18667df">Обратный вызов клиента с примером реализации проверки</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterHiddenField : string * string -&gt; unit" Usage="clientScriptManager.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Имя регистрируемого скрытого поля.</param>
        <param name="hiddenFieldInitialValue">Начальное значение регистрируемого поля.</param>
        <summary>Регистрирует скрытое значение с объектом <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> Метод создает скрытый `<input>` элементов на подготовленной странице HTML.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> и <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> методы. В примере регистрируется массив и скрытое значение, а также определяет `OnClick` событие `<input>` кнопку, чтобы вычислить сумму двух значений массива и скрытое значение.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="hiddenFieldName" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterOnSubmitStatement (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого оператора OnSubmit.</param>
        <param name="key">Ключ регистрируемого оператора OnSubmit.</param>
        <param name="script">Константа скрипта регистрируемого оператора OnSubmit.</param>
        <summary>Регистрирует оператор OnSubmit с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ и константу скрипта. Оператор выполняется, если <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> представляется на рассмотрение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Оператор OnSubmit однозначно идентифицируется ключом и его тип. Инструкции с один и тот же ключ и тип считаются повторяющимися. Можно зарегистрировать только одну инструкцию с заданным типом и пара ключей со страницей. При попытке регистрации инструкцию, которая уже зарегистрирована не создает копию выбранной инструкции.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> метод, чтобы определить, зарегистрирован ли оператор OnSubmit с заданной парой ключ и тип и избежать ненужной попытки добавления скрипта.  
  
 `script` Параметр <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метод может содержать нескольких команд сценария, поскольку они правильно разделенные точкой с запятой (;).  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> Добавляет скрипт, который выполняется перед отправкой страницы и дает возможность отменить отправку.  
  
 Дополнительные сведения о HTML-формы и `OnSubmit` атрибут, см. в разделе [World Wide Web Consortium (W3C) веб-сайт](https://go.microsoft.com/fwlink/?linkid=37125).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метод.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="key">Ключ регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="script">Константа регистрируемого скрипта, активизируемого при запуске.</param>
        <summary>Регистрирует скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ и константу скрипта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентский скрипт однозначно идентифицируется ключом и его тип. Сценарии с один и тот же ключ и тип считаются повторяющимися. Страницы может быть зарегистрирован только один скрипт с заданным типом и пару ключей. Попытка зарегистрировать скрипт, который уже зарегистрирован создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метод, чтобы определить ли сценарий запуска с заданной парой ключ и тип зарегистрирован и избежать ненужной попытки добавления скрипта.  
  
 В этой перегрузке <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод, убедитесь, что он предоставлен в `script` параметр заключается в оболочку с `<script>` элемент блока.  
  
 Блок скрипта, добавленные <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> выполняется метод, когда страница уже загружена, но перед <xref:System.Web.UI.Control.OnLoad%2A> события. Блоки скриптов не обязательно будут выводиться в порядке, в котором они зарегистрированы. Если важен порядок блоков сценария, используйте <xref:System.Text.StringBuilder> для сбора скриптов вместе в одной строке, а затем зарегистрировать их все в один блок клиентского скрипта.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод. Обратите внимание, что начальный и закрывающий теги сценариев, включаются в `script` параметра. Для скрипта, теги, добавляемые на основе параметра дополнительный параметр, см. в разделе <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="key">Ключ регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="script">Константа регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="addScriptTags">Логическое значение, указывающее, требуется ли добавление тегов скрипта.</param>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ, константу скрипта и логическое значение, указывающее следует ли добавлять теги скрипта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сценарий запуска однозначно идентифицируется ключом и его тип. Сценарии с один и тот же ключ и тип считаются повторяющимися. Страницы может быть зарегистрирован только один скрипт с заданным типом и пару ключей. Попытка зарегистрировать скрипт, который уже зарегистрирован создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метод, чтобы определить ли сценарий запуска с заданной парой ключ и тип зарегистрирован и избежать ненужной попытки добавления скрипта.  
  
 В этой перегрузке <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод, вы можете указывает, что скрипт в `script` параметр заключается в оболочку с `<script>` блока элементов с помощью `addScriptTags` параметра. Установка `addScriptTags` для `true` указывает, что теги сценариев будут добавляться автоматически.  
  
 Блок скрипта, добавленные <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> выполняется метод, когда страница уже загружена, но перед <xref:System.Web.UI.Control.OnLoad%2A> события. Блоки скриптов не обязательно будут выводиться в порядке, в котором они зарегистрированы. Если важен порядок блоков сценария, используйте <xref:System.Text.StringBuilder> для сбора скриптов вместе в одной строке, а затем зарегистрировать их все в один блок клиентского скрипта.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод. Обратите внимание, что `addScriptTags` параметр имеет значение `false` , начальный и закрывающий теги сценариев входят в состав `script` параметра.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Проверяет клиентское событие.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string -&gt; unit" Usage="clientScriptManager.ValidateEvent uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Уникальный ИД, представляющий клиентский элемент управления, генерирующий событие.</param>
        <summary>Проверяет клиентское событие, зарегистрированное для проверки, используя метод <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string * string -&gt; unit" Usage="clientScriptManager.ValidateEvent (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Уникальный ИД, представляющий клиентский элемент управления, генерирующий событие.</param>
        <param name="argument">Аргументы события, переданные вместе с клиентским событием.</param>
        <summary>Проверяет клиентское событие, зарегистрированное для проверки, используя метод <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод и <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> метод, чтобы зарегистрировать обратный вызов для проверки и проверить, что обратный вызов поступил со страницы. Для улучшения проверки, показано ниже, можно изменить проверки `argument` параметр, содержащий сведения, относящиеся к пользователю, например удостоверение или роль.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="uniqueId" /> имеет значение <see langword="null" /> или равен пустой строке ("").</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>