<Type Name="Page" FullName="System.Web.UI.Page">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cf51102aae3b27310c7d443e064bf5dca24e5b0f" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58461440" /></Metadata><TypeSignature Language="C#" Value="public class Page : System.Web.UI.TemplateControl, System.Web.IHttpHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Web.UI.TemplateControl implements class System.Web.IHttpHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits TemplateControl&#xA;Implements IHttpHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Web::UI::TemplateControl, System::Web::IHttpHandler" />
  <TypeSignature Language="F#" Value="type Page = class&#xA;    inherit TemplateControl&#xA;    interface IHttpHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.TemplateControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.IHttpHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.WebFormCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.TypeCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Web.WebForms.WebFormDesigner, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("ASPXCodeBehind")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Design.Serialization.RootDesignerSerializer("Microsoft.VSDesigner.WebForms.RootCodeDomSerializer, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.WebForms.WebFormDesigner, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.WebFormCodeDomSerializer, Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.TypeCodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Web.WebForms.WebFormDesigner, Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет файл ASPX, называемый также страницей веб-формы, запрашиваемый с сервера, где выполняется веб-приложение ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page> Класс связывается с файлами, имеющими расширение .aspx. Эти файлы компилируются во время выполнения как <xref:System.Web.UI.Page> объектов и кэшируются в памяти сервера.  
  
 Если вы хотите создать страницу веб-форм, используя метод фонового кода, являются производными от этого класса. Конструкторы быстрой разработки (RAD), таких как Microsoft Visual Studio, автоматически использовать эту модель для создания страниц веб-форм.  
  
 <xref:System.Web.UI.Page> Объект играет роль контейнера именования для всех серверных элементов управления на странице, за исключением тех, которые реализуют <xref:System.Web.UI.INamingContainer> интерфейс или дочерние элементы элементов управления, реализующих этот интерфейс.  
  
 <xref:System.Web.UI.Page> Элемент управления, который выступает в качестве пользовательского интерфейса для веб-приложения и таким образом следует проверять на вносить конечно рекомендации за написание безопасного кода и защите приложений. Общие сведения об этих темах см. в разделе [Общие сведения о безопасности приложения Web угрозы](https://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a), [NIB: Рекомендации по обеспечению безопасности политики](https://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), и [основные понятия безопасности](~/docs/standard/security/key-security-concepts.md). Дополнительные сведения см. в разделе [защита стандартных элементов управления](https://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [как: Отображать безопасные сообщения об ошибках](https://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [как: Защищает от использования сценариев в веб-приложения, применяя, HTML-кодирования в строки](https://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), и [введение проверяющие элементы управления](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.0/2e4hd649(v=vs.85)).  
  
   
  
## Examples  
 Проект Visual Studio Web сайта с исходным кодом доступен на следующей странице в этом разделе: [Скачайте](https://go.microsoft.com/fwlink/?LinkId=192425).  
  
 В следующем примере кода показано, как <xref:System.Web.UI.Page> класс используется в модель страницы с выделенным кодом. Обратите внимание, что в файле исходного кода объявляется разделяемый класс, наследуемый от базового класса страницы. Базовый класс страницы может быть <xref:System.Web.UI.Page>, или это может быть другой класс, производный от <xref:System.Web.UI.Page>. Кроме того Обратите внимание, что разделяемый класс разрешает файл с выделенным кодом для использования элементов управления, определенных на странице без необходимости определять их как элементы поля.  
  
 [!code-csharp[System.Web.UI.Page_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx.cs#2)]
 [!code-vb[System.Web.UI.Page_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx.vb#2)]  
  
 В следующем примере кода показан файл .aspx, соответствующий предыдущий файл исходного кода.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx#1)]  
  
 Необходимо использовать директиву и использовать `Inherits` и `CodeFile` атрибуты, чтобы связать файл с выделенным кодом для ASPX-файла. В этом примере `Inherits` атрибут указывает `MyCodeBehind` класс и `CodeFile` атрибут указывает путь к файлу определенного языка, который содержит класс.  
  
 В следующем примере кода показано, однофайловая страница модели и как получить доступ к <xref:System.Web.UI.Page.IsPostBack%2A> свойство и <xref:System.Web.UI.Page.Response%2A> свойство <xref:System.Web.UI.Page>.  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/vb/pageexample.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Control" />
    <related type="Article" href="https://msdn.microsoft.com/library/01e87387-33f4-45b5-91ec-6c540afe7ee0">Общие сведения о классе страницы ASP.NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/81b13e7a-b95b-4285-906f-d2dd77411417">Модель веб-ASP.NET код страницы</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор по умолчанию инициализирует все поля к значениям по умолчанию.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddContentTemplate">
      <MemberSignature Language="C#" Value="protected internal void AddContentTemplate (string templateName, System.Web.UI.ITemplate template);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddContentTemplate(string templateName, class System.Web.UI.ITemplate template) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddContentTemplate(System.String,System.Web.UI.ITemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddContentTemplate (templateName As String, template As ITemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddContentTemplate(System::String ^ templateName, System::Web::UI::ITemplate ^ template);" />
      <MemberSignature Language="F#" Value="member this.AddContentTemplate : string * System.Web.UI.ITemplate -&gt; unit" Usage="page.AddContentTemplate (templateName, template)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templateName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="template" Type="System.Web.UI.ITemplate" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="templateName">Имя добавляемого шаблона содержимого.</param>
        <param name="template">Шаблон содержимого.</param>
        <summary>Вызывается во время инициализации страницы для создания коллекции содержимого (из элементов управления содержимым), передаваемого эталонной странице, если текущая страница или эталонная страница ссылаются на эталонную страницу.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Шаблон содержимого с этим именем уже существует.</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
        <related type="Article" href="https://msdn.microsoft.com/library/4e53eedf-8304-4e7a-aed1-691a2623b28b">Обзор ASP.NET главных страниц</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOnPreRenderCompleteAsync">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует делегаты обработчика начального и конечного событий для асинхронной страницы.</summary>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
        <related type="Article" href="https://msdn.microsoft.com/library/4e53eedf-8304-4e7a-aed1-691a2623b28b">Обзор ASP.NET главных страниц</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOnPreRenderCompleteAsync (beginHandler As BeginEventHandler, endHandler As EndEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOnPreRenderCompleteAsync(System::Web::BeginEventHandler ^ beginHandler, System::Web::EndEventHandler ^ endHandler);" />
      <MemberSignature Language="F#" Value="member this.AddOnPreRenderCompleteAsync : System.Web.BeginEventHandler * System.Web.EndEventHandler -&gt; unit" Usage="page.AddOnPreRenderCompleteAsync (beginHandler, endHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="beginHandler">Делегат для метода <see cref="T:System.Web.BeginEventHandler" />.</param>
        <param name="endHandler">Делегат для метода <see cref="T:System.Web.EndEventHandler" />.</param>
        <summary>Регистрирует делегаты, не требующих информации о состоянии, обработчика начального и конечного событий для асинхронной страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> метод для добавления обработчиков асинхронных веб-странице.  
  
 Можно зарегистрировать несколько асинхронных обработчиков; Тем не менее одновременно выполняется только один обработчик. Если вы хотите одновременно обрабатывать несколько асинхронных методов, следует использовать один <xref:System.Web.BeginEventHandler> метод и запустить несколько асинхронных операций из этого обработчика.  
  
 Асинхронные обработчики вызываются между <xref:System.Web.UI.Control.PreRender> и <xref:System.Web.UI.Page.PreRenderComplete> события.  
  
 Во-первых, все <xref:System.Web.UI.Page> событий (через <xref:System.Web.UI.Control.PreRender> событий) выполнения, а затем каждый регистрируются <xref:System.Web.BeginEventHandler> вызывается метод. При завершении работы обработчика, соответствующий <xref:System.Web.EndEventHandler> вызывается метод. Следующий обработчик вызывается, если есть несколько асинхронных обработчиков.  
  
 После вызова зарегистрированные асинхронные обработчики событий вызываются остальная часть событий страницы, начиная с версии <xref:System.Web.UI.Page.PreRenderComplete> событий.  
  
   
  
## Examples  
 В следующем примере кода используется асинхронный запрос для отображения исходного кода HTML страницы по умолчанию на локальном веб-сервере в <xref:System.Web.UI.WebControls.TextBox> элемента управления.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Директива <see langword="&lt;async&gt;" /> страницы не установлена в <see langword="true" />.  
  
-или- 
Метод <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> вызывается после события <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> или <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
        <related type="Article" href="https://msdn.microsoft.com/library/4e53eedf-8304-4e7a-aed1-691a2623b28b">Обзор ASP.NET главных страниц</related>
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOnPreRenderCompleteAsync (beginHandler As BeginEventHandler, endHandler As EndEventHandler, state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOnPreRenderCompleteAsync(System::Web::BeginEventHandler ^ beginHandler, System::Web::EndEventHandler ^ endHandler, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddOnPreRenderCompleteAsync : System.Web.BeginEventHandler * System.Web.EndEventHandler * obj -&gt; unit" Usage="page.AddOnPreRenderCompleteAsync (beginHandler, endHandler, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="beginHandler">Делегат для метода <see cref="T:System.Web.BeginEventHandler" />.</param>
        <param name="endHandler">Делегат для метода <see cref="T:System.Web.EndEventHandler" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии обработчиков событий.</param>
        <summary>Регистрирует делегаты обработчика начального и конечного событий для асинхронной страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> метод для добавления обработчиков, которые требуются сведения о состоянии асинхронных веб-странице. Объект, передаваемый в `state` параметр может быть любой объект, который приложение требует передачи информации между делегатов обработчиков событий, указанного в `beginHandler` и `endHandler` параметров.  
  
 Можно зарегистрировать несколько асинхронных обработчиков; Тем не менее одновременно выполняется только один обработчик. Если вы хотите одновременно обрабатывать несколько асинхронных методов, следует использовать один <xref:System.Web.BeginEventHandler> метод и запустить несколько асинхронных операций из этого обработчика.  
  
 Асинхронные обработчики вызываются между <xref:System.Web.UI.Control.PreRender> и <xref:System.Web.UI.Page.PreRenderComplete> события.  
  
 Во-первых, все <xref:System.Web.UI.Page> событий (через <xref:System.Web.UI.Control.PreRender> событий) выполнения, а затем каждый регистрируются <xref:System.Web.BeginEventHandler> вызывается метод. При завершении работы обработчика, соответствующий <xref:System.Web.EndEventHandler> вызывается метод. Следующий обработчик вызывается, если есть несколько асинхронных обработчиков.  
  
 После вызова зарегистрированные асинхронные обработчики событий вызываются остальная часть событий страницы, начиная с версии <xref:System.Web.UI.Page.PreRenderComplete> событий.  
  
   
  
## Examples  
 В следующем примере кода используется асинхронный запрос для отображения исходного кода HTML страницы по умолчанию на локальном веб-сервере в <xref:System.Web.UI.WebControls.TextBox> элемента управления.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Директива <see langword="&lt;async&gt;" /> страницы не установлена в <see langword="true" />.  
  
-или- 
Метод <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> вызывается после события <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> или <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected internal void AddWrappedFileDependencies (object virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddWrappedFileDependencies(object virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddWrappedFileDependencies(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddWrappedFileDependencies (virtualFileDependencies As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddWrappedFileDependencies(System::Object ^ virtualFileDependencies);" />
      <MemberSignature Language="F#" Value="member this.AddWrappedFileDependencies : obj -&gt; unit" Usage="page.AddWrappedFileDependencies virtualFileDependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">Объект <see cref="T:System.Object" />, содержащий список имен файлов.</param>
        <summary>Добавляет список зависимых файлов, составляющих текущую страницу. Класс используется внутри платформы страницы ASP.NET и не предназначен для использования в коде.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.AddWrappedFileDependencies%2A> Метод добавляет список файлов, таких как файлы пользовательских элементов управления, составляющих текущую страницу. Если любой из этих страниц изменяется, вся страница компилируется следующий раз, когда он запрашивается. Этот метод поддерживает инфраструктуру .NET Framework и не предназначен для использования непосредственно из программного кода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.UI.Page.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.HttpApplicationState" /> для текущего веб-запроса.</summary>
        <value>Текущие данные в классе <see cref="T:System.Web.HttpApplicationState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page.Application_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Application_Sample1/CS/applicationcs.aspx#1)]
 [!code-vb[Page.Application_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Application_Sample1/VB/applicationvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpApplicationState" />
      </Docs>
    </Member>
    <Member MemberName="AspCompatBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AspCompatBeginProcessRequest (System.Web.HttpContext context, AsyncCallback cb, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AspCompatBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback cb, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function AspCompatBeginProcessRequest (context As HttpContext, cb As AsyncCallback, extraData As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ AspCompatBeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ cb, System::Object ^ extraData);" />
      <MemberSignature Language="F#" Value="member this.AspCompatBeginProcessRequest : System.Web.HttpContext * AsyncCallback * obj -&gt; IAsyncResult" Usage="page.AspCompatBeginProcessRequest (context, cb, extraData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="cb" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">Объект <see cref="T:System.Web.HttpContext" /> с информацией о текущем запросе.</param>
        <param name="cb">Метод обратного вызова.</param>
        <param name="extraData">Дополнительные данные, необходимые для обработки запроса таким же образом, как в ASP.</param>
        <summary>Инициирует запрос на ресурсы Active Server Page (ASP). Метод, предоставляется для совместимости с предыдущими приложениями ASP.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не следует вызывать.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AspCompatEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AspCompatEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatEndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AspCompatEndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AspCompatEndProcessRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.AspCompatEndProcessRequest : IAsyncResult -&gt; unit" Usage="page.AspCompatEndProcessRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Страница ASP, созданная по запросу.</param>
        <summary>Завершает запрос на ресурсы Active Server Page (ASP). Метод, предоставляется для совместимости с предыдущими приложениями ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не следует вызывать.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatMode">
      <MemberSignature Language="C#" Value="protected bool AspCompatMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AspCompatMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AspCompatMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property AspCompatMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AspCompatMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AspCompatMode : bool with get, set" Usage="System.Web.UI.Page.AspCompatMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает значение, указывающее, может ли страница выполняться в однопотоковом апартаменте.</summary>
        <value><see langword="true" />, если страница поддерживает код Active Server Pages (ASP); в противном случае ─ <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если задано значение `true`, это свойство позволяет странице выполняться в потоке однопотокового подразделения (STA). Это позволяет странице вызывать STA компонентов, таких как компоненты, разработанные с помощью Visual Basic 6.0. Этому свойству присвоить `true` также позволяет странице вызывать компоненты COM +, которым требуется доступ к неуправляемым встроенным объектам ASP. Они доступны через ВНУТРЕННИЙ `ObjectContext` объекта или `OnStartPage` метод.  
  
 В большинстве случаев это свойство не задано в коде. Задайте `aspcompat` атрибут `true` использование директивы в файле .aspx. При запросе страницы, динамически создаваемого класса задает свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncMode">
      <MemberSignature Language="C#" Value="protected bool AsyncMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property AsyncMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AsyncMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncMode : bool with get, set" Usage="System.Web.UI.Page.AsyncMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, как обрабатывается страница ─ синхронно или асинхронно.</summary>
        <value>Значение <see langword="true" />, если страница обрабатывается асинхронно; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.AsyncMode%2A> Свойство задается <xref:System.Web.UI.Page> средство синтаксического анализа, при создании кода для страницы. Используйте `Async` атрибут в директиву, чтобы задать это значение.  
  
 Асинхронные страницы не работают при `AspCompat` атрибуту присваивается `true` или `Transaction` атрибуту присваивается значение, отличное от `Disabled` в директиве.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AsyncPageBeginProcessRequest (System.Web.HttpContext context, AsyncCallback callback, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AsyncPageBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback callback, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function AsyncPageBeginProcessRequest (context As HttpContext, callback As AsyncCallback, extraData As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ AsyncPageBeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ callback, System::Object ^ extraData);" />
      <MemberSignature Language="F#" Value="member this.AsyncPageBeginProcessRequest : System.Web.HttpContext * AsyncCallback * obj -&gt; IAsyncResult" Usage="page.AsyncPageBeginProcessRequest (context, callback, extraData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="extraData" Type="System.Object" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="context">Информация <see cref="T:System.Web.HttpContext" /> для запроса.</param>
        <param name="callback">Метод обратного вызова для оповещении об окончании процесса.</param>
        <param name="extraData">Данные о состоянии для асинхронного метода.</param>
        <summary>Начинает обработку запроса асинхронной страницы.</summary>
        <returns>Класс <see cref="T:System.IAsyncResult" />, ссылающийся на асинхронный запрос.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AsyncPageEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AsyncPageEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageEndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AsyncPageEndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AsyncPageEndProcessRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.AsyncPageEndProcessRequest : IAsyncResult -&gt; unit" Usage="page.AsyncPageEndProcessRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="result">Класс <see cref="T:System.IAsyncResult" />, ссылающийся на отложенный асинхронный запрос.</param>
        <summary>Заканчивает обработку запроса асинхронной страницы.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan AsyncTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AsyncTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan AsyncTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncTimeout : TimeSpan with get, set" Usage="System.Web.UI.Page.AsyncTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее лимит времени при обработке асинхронных задач.</summary>
        <value>Объект <see cref="T:System.TimeSpan" />, содержащий разрешенный временной интервал для асинхронной задачи. Значение интервала по умолчанию составляет 45 секунд.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Время ожидания асинхронной страницы представляет время ожидания страницы для выполнения асинхронных задач. В большинстве случаев это свойство не задано в коде. Установка интервала времени ожидания асинхронной страницы с помощью файла конфигурации веб- или в директиве. Значения, заданные в разделе конфигурации страницы перезаписываются директиву страницы.  
  
 Определите на асинхронную задачу <xref:System.Web.UI.PageAsyncTask> класса и зарегистрировать начала, окончания и обработчик времени ожидания. Если асинхронная задача не завершается в течение указанного интервала времени, будет вызван обработчик времени ожидания.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.Page.AsyncTimeout%2A> свойство с <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> и <xref:System.Web.UI.Page.RegisterAsyncTask%2A> методы. Обратите внимание на использование обработчиков начала, окончания и время ожидания. В примере вводится искусственная задержка для демонстрации ситуации асинхронной задачи, превышающей отведенное время для задачи, как указано в <xref:System.Web.UI.Page.AsyncTimeout%2A> свойство. В реальной ситуации асинхронная задача может использоваться для выполнения вызовов базы данных или создание образов, например, и обработчик времени ожидания предоставляет постепенного ухудшения качества обслуживания, если задача не выполняется в течение указанного промежутка времени. Обратите внимание, что <xref:System.Web.UI.Page.AsyncTimeout%2A> свойству в директиве page.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойству присвоено отрицательное значение.</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="AutoPostBackControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control AutoPostBackControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control AutoPostBackControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AutoPostBackControl" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoPostBackControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ AutoPostBackControl { System::Web::UI::Control ^ get(); void set(System::Web::UI::Control ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AutoPostBackControl : System.Web.UI.Control with get, set" Usage="System.Web.UI.Page.AutoPostBackControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает страничный элемент управления, используемый для выполнения обратной передачи.</summary>
        <value>Элемент управления, используемый для выполнения обратной передачи.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.UI.Page.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, буферизуется ли вывод страницы.</summary>
        <value><see langword="true" />, если вывод страницы буферизован; в противном случае ─ <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задайте <xref:System.Web.UI.Page.Buffer%2A> атрибут `true` использование директивы в файле .aspx. При запросе страницы, динамически создаваемого класса задает свойство.  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.Buffer%2A> Свойство задает и получает <xref:System.Web.HttpResponse.BufferOutput%2A> свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.UI.Page.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.Caching.Cache" />, связанный приложением, в котором находится страница.</summary>
        <value>Объект <see cref="T:System.Web.Caching.Cache" />, связанный с содержащим страницу приложением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложения <xref:System.Web.Caching.Cache> объект позволяет сохранять и извлекать произвольные данные при последующих запросах. Кэш не связанный с страницы или пользовательского сеанса. Он используется в основном для повышения производительности приложения. Дополнительные сведения см. в разделе [кэширование данных приложения](https://msdn.microsoft.com/library/206f977d-7860-4d20-bdd5-c3b3d8479f3d(v=vs.100)). Дополнительные сведения о различиях между приложения кэширования и кэширования вывода страниц см. в разделе [Общие сведения о кэшировании ASP.NET](https://msdn.microsoft.com/library/5ec28012-4972-4dc3-b3e8-9d20401fe11d).  
  
   
  
## Examples  
 В следующем примере кода вставляет сумму двух целых чисел в <xref:System.Web.Caching.Cache?displayProperty=nameWithType> с помощью <xref:System.Web.UI.Page.Cache%2A?displayProperty=nameWithType> свойство. Затем извлекается значение с помощью <xref:System.Web.Caching.Cache.Get%2A?displayProperty=nameWithType> метода и записывает его в <xref:System.Web.UI.WebControls.Label> управления веб-сервера.  
  
 [!code-csharp[System.Web.Page.Cache_Replacement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/CS/pagecachecs.aspx#1)]
 [!code-vb[System.Web.Page.Cache_Replacement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/VB/pagecachevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Экземпляр объекта <see cref="T:System.Web.Caching.Cache" /> не создается.</exception>
        <altmember cref="T:System.Web.Caching.Cache" />
        <related type="Article" href="https://msdn.microsoft.com/library/206f977d-7860-4d20-bdd5-c3b3d8479f3d(v=vs.100)">Кэширование данных приложения</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5ec28012-4972-4dc3-b3e8-9d20401fe11d">Общие сведения о кэшировании в ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ClientQueryString">
      <MemberSignature Language="C#" Value="public string ClientQueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientQueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientQueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientQueryString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientQueryString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientQueryString : string" Usage="System.Web.UI.Page.ClientQueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает часть строки с запрошенным URL-адресом.</summary>
        <value>Возвращает часть строки с запрошенным URL-адресом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.ClientQueryString%2A> Свойство содержит часть строки запроса URL-адрес, браузер запрашивает. Например, если запрошенный URL-адрес "http://www.contoso.com/default.aspx?id=100«, <xref:System.Web.UI.Page.ClientQueryString%2A> свойство будет содержать «id = 100». <xref:System.Web.UI.Page.ClientQueryString%2A> Свойство кодируется; используйте <xref:System.Web.HttpServerUtility.UrlDecode%2A?displayProperty=nameWithType> метод Декодируемая строка запроса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.ClientScriptManager ClientScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ClientScriptManager ClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientScript As ClientScriptManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ClientScriptManager ^ ClientScript { System::Web::UI::ClientScriptManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientScript : System.Web.UI.ClientScriptManager" Usage="System.Web.UI.Page.ClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientScriptManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.UI.ClientScriptManager" />, используемый для управления, регистрации и добавления скрипта к странице.</summary>
        <value>Объект <see cref="T:System.Web.UI.ClientScriptManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.ClientScript%2A> свойство для получения <xref:System.Web.UI.ClientScriptManager> объект, который может использоваться для управления, регистрации и добавьте скрипт на веб-страницу. Дополнительные сведения см. в описании класса <xref:System.Web.UI.ClientScriptManager>.  
  
 <xref:System.Web.UI.ClientScriptManager> Класс впервые появился в [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] и заменяет <xref:System.Web.UI.Page> методы для управления сценариями, которые теперь отнесены к устаревшим класса.  
  
   
  
## Examples  
 Например, см. в разделе <xref:System.Web.UI.ClientScriptManager> класс обзорной статье.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="ClientTarget">
      <MemberSignature Language="C#" Value="public string ClientTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientTarget" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientTarget As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientTarget { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientTarget : string with get, set" Usage="System.Web.UI.Page.ClientTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, позволяющее переопределить автоматическое обнаружение характеристик браузера и задать способ отображения страницы для конкретного браузера клиента.</summary>
        <value>Значение <see cref="T:System.String" />, задающее переопределяемые характеристики браузера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не установите <xref:System.Web.UI.Page.ClientTarget%2A> свойство, <xref:System.Web.HttpBrowserCapabilities> объект, связанный с <xref:System.Web.UI.Page.Request%2A?displayProperty=nameWithType> свойство отражает возможности клиентского браузера. Если это свойство задано, определение обозревателя клиента отключена, и страницы будут использовать возможности браузера, связанные со значением (псевдоним), введенного.  
  
 Корневой файл конфигурации Web.config на компьютере веб-сервера определяет следующие псевдонимы по умолчанию, которые можно использовать как сокращенную запись для часто используемых строк агента пользователя:  
  
-   `uplevel`, указывающий возможности браузера Internet Explorer 6.0.  
  
-   `downlevel`, который определяет возможности браузера эквивалентно старых браузерах, которые не поддерживают клиентского скрипта. Этот псевдоним можно использовать для определения того, как будет работать веб-страниц в браузере, который отключен клиентский скрипт.  
  
 Можно задать псевдоним, программно с помощью этого свойства, или можно задать декларативно, используя `ClientTarget` атрибута директивы.  
  
 Вы можете определить Дополнительные псевдонимы в `clientTarget` раздел файла Web.config уровня приложения. Дополнительные сведения см. в разделе [clientTarget (схема параметров ASP.NET) элемент](https://msdn.microsoft.com/library/17a0fa6e-a065-49cc-b900-ef73eda6a922).  
  
   
  
## Examples  
 В следующем примере кода определяется `ie302` псевдоним и включает в себя разделы, необходимые для настройки приложения в файле Web.config. С помощью псевдонима, можно задать <xref:System.Web.UI.Page.ClientTarget%2A> свойства `ie302` и настройка страниц специально для браузеров Internet Explorer 3.02.  
  
```  
<configuration>  
  <system.web>  
   <clientTarget>  
    <add alias="ie302" useragent="Mozilla/2.0 (compatible; MSIE 3.02; Windows NT 3.5)" />  
   </clientTarget>  
  </system.web>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">Серверные элементы управления ASP.NET и возможностей браузера</related>
        <related type="Article" href="https://msdn.microsoft.com/library/01505090-9114-41a7-93ca-068e2283ed3d">Файлы конфигурации ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public int CodePage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CodePage { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int with get, set" Usage="System.Web.UI.Page.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает идентификатор кодовой страницы для текущего объекта <see cref="T:System.Web.UI.Page" />.</summary>
        <value>Целое значение, представляющее идентификатора страницы кода для текущего объекта <see cref="T:System.Web.UI.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задайте `CodePage` равным значению, используя директиву в файле .aspx. При запросе страницы, динамически создаваемого класса задает свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.UI.Page.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает тип MIME HTTP для объекта <see cref="T:System.Web.HttpResponse" />, связанного со страницей.</summary>
        <value>Тип MIME HTTP, связанный с текущей страницей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задайте `ContentType` атрибута с помощью директивы в файле .aspx. При запросе страницы, динамически создаваемого класса задает свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal override System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Web.HttpContext" Usage="System.Web.UI.Page.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.HttpContext" />, связанный со страницей.</summary>
        <value>Объект <see cref="T:System.Web.HttpContext" />, содержащий связанные с текущей страницей сведения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство обеспечивает программный доступ к контексту выполнения страницы, включая сведения о запросе, ответе, сеанса и приложения.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.UI.Page.Context%2A> свойство для доступа к <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> и <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> методы и <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> свойство. В примере создается три пользовательских исключений с помощью <xref:System.Web.HttpContext.AddError%2A> и использует <xref:System.Web.HttpContext.AllErrors%2A> свойства для загрузки этих исключений в массив. Затем он записывает массив в страницу и использует <xref:System.Web.HttpContext.ClearError%2A> метод, чтобы удалить все ошибки <xref:System.Web.UI.Page.Context%2A> свойство.  
  
 [!code-csharp[System.Web.UI.Page.Context#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Context/CS/pagecontextcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Context#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Context/VB/pagecontextvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriter">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.UI.HtmlTextWriter CreateHtmlTextWriter (System.IO.TextWriter tw);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Web.UI.HtmlTextWriter CreateHtmlTextWriter(class System.IO.TextWriter tw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateHtmlTextWriter (tw As TextWriter) As HtmlTextWriter" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Web::UI::HtmlTextWriter ^ CreateHtmlTextWriter(System::IO::TextWriter ^ tw);" />
      <MemberSignature Language="F#" Value="abstract member CreateHtmlTextWriter : System.IO.TextWriter -&gt; System.Web.UI.HtmlTextWriter&#xA;override this.CreateHtmlTextWriter : System.IO.TextWriter -&gt; System.Web.UI.HtmlTextWriter" Usage="page.CreateHtmlTextWriter tw" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="tw">Экземпляр класса <see cref="T:System.IO.TextWriter" />, используемый для создания <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <summary>Создает объект <see cref="T:System.Web.UI.HtmlTextWriter" /> для отображения содержимого страницы.</summary>
        <returns><see cref="T:System.Web.UI.HtmlTextWriter" /> или <see cref="T:System.Web.UI.Html32TextWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> Метод создает <xref:System.IO.TextWriter> через <xref:System.Web.HttpRequest.Browser%2A> свойство <xref:System.Web.HttpContext.Request%2A> объект, связанный с запроса страницы. Можно добавить ссылку на <xref:System.Web.UI.HtmlTextWriter> в `browserCaps` раздел конфигурации. Переопределить <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> метод для выполнения пользовательского поиска.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> метод для создания экземпляра настраиваемого <xref:System.Web.UI.HtmlTextWriter> объект с именем `MyHtmlTextWriter`. <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> Метод переопределен в `MyPage` класс, который является производным от <xref:System.Web.UI.Page>, так что `MyHtmlTextWriter` отображает серверных элементов управления ASP.NET при запросе страницы. Обратите внимание, что в этом примере не позволит адаптера <xref:System.IO.TextWriter> поведение.  
  
 [!code-csharp[Page_CreateHtmlTextWriter#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/CS/page_createhtmltextwriter.cs#2)]
 [!code-vb[Page_CreateHtmlTextWriter#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/VB/page_createhtmltextwriter.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Html32TextWriter" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriterFromType">
      <MemberSignature Language="C#" Value="public static System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType (System.IO.TextWriter tw, Type writerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType(class System.IO.TextWriter tw, class System.Type writerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateHtmlTextWriterFromType (tw As TextWriter, writerType As Type) As HtmlTextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::HtmlTextWriter ^ CreateHtmlTextWriterFromType(System::IO::TextWriter ^ tw, Type ^ writerType);" />
      <MemberSignature Language="F#" Value="static member CreateHtmlTextWriterFromType : System.IO.TextWriter * Type -&gt; System.Web.UI.HtmlTextWriter" Usage="System.Web.UI.Page.CreateHtmlTextWriterFromType (tw, writerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writerType" Type="System.Type" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="tw">Экземпляр класса <see cref="T:System.IO.TextWriter" />, используемый для создания <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <param name="writerType">Тип создаваемого компонента для записи текста.</param>
        <summary>Создает указанный объект <see cref="T:System.Web.UI.HtmlTextWriter" /> для отображения содержимого страницы.</summary>
        <returns>Объект <see cref="T:System.Web.UI.HtmlTextWriter" />, отображающий содержимое страницы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется внутренне в адаптерах страниц.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Параметр <paramref name="writerType" /> установлен в недействительный тип.</exception>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public string Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Culture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Culture { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : string with get, set" Usage="System.Web.UI.Page.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает идентификатор языка и региональных параметров объекта <see cref="T:System.Threading.Thread" />, связанного со страницей.</summary>
        <value>Идентификатор языка и региональных параметров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задайте `Culture` атрибут директивы в файле .aspx. При запросе страницы, динамически создаваемого класса значение этого свойства. Кроме того, можно также явно задать значение <xref:System.Web.UI.Page.Culture%2A> свойства программно или в элементе файла Web.config файла.  
  
 <xref:System.Web.UI.Page.Culture%2A> Свойство используется для локализации содержимого страницы. Можно задать идентификатор любой допустимый язык и региональные параметры. Например `en-us` устанавливает идентификатор языка и региональных параметров страницы американского английского языка, while `fr` устанавливает идентификатор языка и региональных параметров страницы французский. Можно также присвоить значение `auto` которого будет выполнять автоматическое обнаружение браузера предпочтительный язык и задайте для него. Автоматическое обнаружение языка может быть задано со значением по умолчанию, например `auto:en-us`.  
  
 Дополнительные сведения см. в разделе <xref:System.Globalization.CultureInfo> Общие сведения о классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
      </Docs>
    </Member>
    <Member MemberName="DesignerInitialize">
      <MemberSignature Language="C#" Value="public void DesignerInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DesignerInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DesignerInitialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub DesignerInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DesignerInitialize();" />
      <MemberSignature Language="F#" Value="member this.DesignerInitialize : unit -&gt; unit" Usage="page.DesignerInitialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Производит инициализацию экземпляра класса <see cref="T:System.Web.UI.Page" />, необходимую для конструкторов RAD. Этот метод используется только во время разработки.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.UserControl.DesignerInitialize" />
        <related type="Article" href="https://msdn.microsoft.com/library/4881917b-628f-4689-b872-472e4f8a4e3a">Архитектура времени разработки</related>
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackMode">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.Specialized.NameValueCollection DeterminePostBackMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function DeterminePostBackMode () As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Collections::Specialized::NameValueCollection ^ DeterminePostBackMode();" />
      <MemberSignature Language="F#" Value="abstract member DeterminePostBackMode : unit -&gt; System.Collections.Specialized.NameValueCollection&#xA;override this.DeterminePostBackMode : unit -&gt; System.Collections.Specialized.NameValueCollection" Usage="page.DeterminePostBackMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию <see cref="T:System.Collections.Specialized.NameValueCollection" /> данных, переданных обратно странице, используя команду POST или GET.</summary>
        <returns>Объект <see cref="T:System.Collections.Specialized.NameValueCollection" />, содержащий данные формы. Если обратная передача использовала команду POST, информация о форме возвращается из объекта <see cref="P:System.Web.UI.Page.Context" />. Если обратная передача использовала команду GET, возвращается информация из строки запроса. Если страница запрашивается в первый раз, возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.DeterminePostBackMode%2A> Возвращает метод <xref:System.Collections.Specialized.NameValueCollection> объект, содержащий данные обратной передачи страницы. Наличие страницы скрытые поля, VIEWSTATE и EVENTTARGET используется для определения, произошла ли событие обратной передачи. <xref:System.Web.UI.Page.IsPostBack%2A> Свойство задается при <xref:System.Web.UI.Page.DeterminePostBackMode%2A> вызывается метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackModeUnvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackModeUnvalidated" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function DeterminePostBackModeUnvalidated () As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Collections::Specialized::NameValueCollection ^ DeterminePostBackModeUnvalidated();" />
      <MemberSignature Language="F#" Value="abstract member DeterminePostBackModeUnvalidated : unit -&gt; System.Collections.Specialized.NameValueCollection&#xA;override this.DeterminePostBackModeUnvalidated : unit -&gt; System.Collections.Specialized.NameValueCollection" Usage="page.DeterminePostBackModeUnvalidated " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию данных имя-значение, отправленную на страницу с помощью команды GET или POST, и без выполнения проверки запросов ASP.NET в запросе.</summary>
        <returns>Объект, содержащий непроверенные данные формы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в описании класса <xref:System.Web.UnvalidatedRequestValues>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableEventValidation">
      <MemberSignature Language="C#" Value="public virtual bool EnableEventValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableEventValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableEventValidation" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableEventValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableEventValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableEventValidation : bool with get, set" Usage="System.Web.UI.Page.EnableEventValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, проверяет ли страница события обратной передачи и обратного вызова.</summary>
        <value>Значения <see langword="true" />, если страница проверяет события обратной передачи и обратного вызова; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Web.UI.Page.EnableEventValidation%2A> свойству `true`, ASP.NET проверяет, что событие элемента управления, поступил из пользовательского интерфейса, который был преобразовываемый для просмотра этого элемента управления. Элемент управления регистрирует события во время отрисовки и затем проверяет при обратной передаче или обратных вызовов. Например если элемент управления списка включает параметры нумеруются с 1, 2 или 3, при отображении страницы, и в том случае, если поступает запрос обратной передачи, указав параметр номер 4, ASP.NET вызывает исключение. Все элементы управления на основе событий в ASP.NET использовать эту функцию по умолчанию.  
  
 При написании клиентского скрипта, который изменяет элемент управления в клиенте во время выполнения, может потребоваться использовать <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод, чтобы избежать ошибок проверки false событий.  
  
> [!IMPORTANT]
>  Эта функция снижает риск несанкционированного или злонамеренного обратных запросов и обратных вызовов. Настоятельно рекомендуется не отключать проверку событий.  
  
 Можно задать <xref:System.Web.UI.Page.EnableEventValidation%2A> свойство, задав `enableEventValidation` атрибута директивы или `enableEventValidation` атрибута элемента в файле Web.config. Если это свойство задано в коде, необходимо задать до инициализации страницы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Web.UI.Page.EnableEventValidation" /> было установлено после инициализации страницы.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
        <altmember cref="T:System.Web.UI.SupportsEventValidationAttribute" />
        <related type="Article" href="https://msdn.microsoft.com/library/fa2aa14d-a461-492e-9a79-c990904613ef">Проверяющие элементы управления ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public override bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewState : bool with get, set" Usage="System.Web.UI.Page.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, поддерживает ли страница свое состояние отображения и состояние отображения всех содержащихся в ней серверных элементов управления по окончании текущего запроса страницы.</summary>
        <value><see langword="true" />, если страница поддерживает состояние представления; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы узнать, почему может потребоваться отключить состояние представления, см. в разделе <xref:System.Web.UI.Control.EnableViewState%2A?displayProperty=nameWithType>.  
  
 Даже если <xref:System.Web.UI.Page.EnableViewState%2A> является `false`, страница может содержать скрытом поле состояния представления, используемого ASP.NET для обнаружения обратную передачу.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Web.UI.Page.EnableViewState%2A> свойства `false` при загрузке страницы. Отключить состояние представления для <xref:System.Web.UI.Page> объекта, это означает, что сохраняются ни сведений о состоянии просмотра страницы, ни любые элементы управления, содержащихся на странице.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/CS/page_enableviewstate.cs#1)]
 [!code-vb[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/VB/page_enableviewstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewStateMac" />
        <related type="Article" href="https://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818">Общие сведения о состоянии представления ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EnableViewStateMac">
      <MemberSignature Language="C#" Value="public bool EnableViewStateMac { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewStateMac" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewStateMac" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableViewStateMac As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableViewStateMac { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewStateMac : bool with get, set" Usage="System.Web.UI.Page.EnableViewStateMac" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должна ли платформа ASP.NET проверять коды проверки подлинности сообщений (MAC) в состоянии просмотра страницы, когда страница передается обратно от клиента.</summary>
        <value>Значение <see langword="true" />, если состояние представления должно проходить контроль подлинности сообщения и шифроваться; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Состояния представления MAC является зашифрованной версией скрытой переменной, в которой сохраняется состояние представления страницы для при отправке страницы в браузер. Если присвоить этому свойству `true`, зашифрованное представление состояния проверяется, чтобы проверить, что он имеет не были изменены на клиентском компьютере.  
  
 Это свойство не задано в коде. Задайте `EnableViewStateMac` атрибута с помощью директивы в файле .aspx. При запросе страницы, динамически создаваемого класса задает свойство.  
  
> [!IMPORTANT]
>  Этот атрибут никогда не должно быть присвоено `false` в рабочей среде веб-сайта, даже если приложения или страницы не использует состояние просмотра. Состояние представления MAC помогает обеспечить безопасность других функций ASP.NET в дополнение к состояние представления.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewState" />
      </Docs>
    </Member>
    <Member MemberName="ErrorPage">
      <MemberSignature Language="C#" Value="public string ErrorPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ErrorPage" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorPage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ErrorPage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ErrorPage : string with get, set" Usage="System.Web.UI.Page.ErrorPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает страницу ошибок, на которую переадресуется запрашивающий браузер в случае возникновения необработанного исключения страницы.</summary>
        <value>Страница ошибок, на которую переадресуется браузер.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page_ErrorPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_ErrorPage/CS/page_errorpage.cs.aspx#1)]
 [!code-vb[Page_ErrorPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_ErrorPage/VB/page_errorpage.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/428ce264-b57e-4f18-94e4-635800bdc091">Обработка ошибок в страницах ASP.NET и приложений</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteRegisteredAsyncTasks">
      <MemberSignature Language="C#" Value="public void ExecuteRegisteredAsyncTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecuteRegisteredAsyncTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecuteRegisteredAsyncTasks ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecuteRegisteredAsyncTasks();" />
      <MemberSignature Language="F#" Value="member this.ExecuteRegisteredAsyncTasks : unit -&gt; unit" Usage="page.ExecuteRegisteredAsyncTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает выполнение асинхронной задачи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Определение асинхронную задачу с помощью <xref:System.Web.UI.PageAsyncTask> класса. После задачи определяется и зарегистрирован в странице с помощью <xref:System.Web.UI.Page.RegisterAsyncTask%2A> метод, <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> метод может вызываться для начала асинхронной задачи.  
  
 <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> Метод автоматически вызывается во время обработки страницы, когда все зарегистрированные асинхронные задачи, если они существуют, вызываются для отличных от асинхронной страницы. Автоматический вызов <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> происходит непосредственно перед <xref:System.Web.UI.Page.PreRenderComplete> событий. Вызовите <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> метод для задачи требуется вызывать в некоторых случаях кроме автоматического вызова этого метода. Обратите внимание, что асинхронные задачи будут выполняться только один раз, даже если <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> может вызываться несколько раз.  
  
 <xref:System.Web.UI.Page.AsyncTimeout%2A> Свойство сбрасывается при каждом вызове <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> метод. Последнее значение <xref:System.Web.UI.Page.AsyncTimeout%2A> до вызова <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> метод имеет более высокий приоритет. Если асинхронная задача принимает больше, чем <xref:System.Web.UI.Page.AsyncTimeout%2A>, последующие задачи вызывается в процессе, <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> немедленно истекло вызова.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.Page.AsyncTimeout%2A> свойство с <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> и <xref:System.Web.UI.Page.RegisterAsyncTask%2A> методы. Обратите внимание на использование обработчиков начала, окончания и время ожидания. В примере вводится искусственная задержка для демонстрации ситуации асинхронной задачи, превышающей отведенное время для задачи, как указано в <xref:System.Web.UI.Page.AsyncTimeout%2A> свойство. В реальной ситуации асинхронная задача может использоваться для выполнения вызовов базы данных или создание образов, например, и обработчик времени ожидания предоставляет постепенного ухудшения качества обслуживания, если задача не выполняется в течение указанного промежутка времени.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Возникло исключение в асинхронной задаче:</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="FileDependencies">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList FileDependencies { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList FileDependencies" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.FileDependencies" />
      <MemberSignature Language="VB.NET" Value="Protected Property FileDependencies As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::ArrayList ^ FileDependencies {  void set(System::Collections::ArrayList ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FileDependencies : System.Collections.ArrayList" Usage="System.Web.UI.Page.FileDependencies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is HttpResponse.AddFileDependencies. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает массив файлов, от которых зависит объект <see cref="T:System.Web.HttpResponse" />.</summary>
        <value>Массив файлов, от которых зависит объект <see cref="T:System.Web.HttpResponse" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство использовать не рекомендуется. Используйте <xref:System.Web.HttpResponse.AddFileDependencies%2A> метод или <xref:System.Web.HttpResponse.AddFileDependency%2A> метод <xref:System.Web.HttpResponse> вместо этого класса.  
  
 В большинстве случаев это свойство не задано в коде. Задайте `FileDependencies` атрибут `true` использование директивы в файле .aspx. При запросе страницы, динамически создаваемого класса задает свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public override System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberSignature Language="F#" Value="override this.FindControl : string -&gt; System.Web.UI.Control" Usage="page.FindControl id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="id">Идентификатор искомого элемента управления.</param>
        <summary>Ищет контейнер именования страниц для указанного серверного элемента управления с указанным идентификатором.</summary>
        <returns>Указанный элемент управления или <see langword="null" />, если указанный элемент управления не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.FindControl%2A> Метод может использоваться для доступ к элементу управления, <xref:System.Web.UI.Control.ID%2A> недоступен во время разработки. Метод выполняет поиск только страницы немедленно или верхнего уровня, контейнер; Это делается не рекурсивного поиска для элементов управления в контейнерах именования, содержащихся на странице. Чтобы получить доступ к элементам управления в контейнере именования, подчиненных, вызовите `FindControl` метод этого контейнера.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.Page.FindControl%2A> метод для поиска элементов управления внутри шаблонов. В этом примере два <xref:System.Web.UI.WebControls.Repeater> определенные элементы управления; каждый показан другой способ catch <xref:System.Web.UI.WebControls.LinkButton.Click> событие <xref:System.Web.UI.WebControls.LinkButton> внутри шаблона элемента управления repeater.  
  
 [!code-aspx-csharp[System.Web.UI.Page_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/cs/pagefindcontrolcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/vb/pagefindcontrolvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlForm Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlForm Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As HtmlForm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::HtmlControls::HtmlForm ^ Form { System::Web::UI::HtmlControls::HtmlForm ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Web.UI.HtmlControls.HtmlForm" Usage="System.Web.UI.Page.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlForm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает форму HTML для страницы.</summary>
        <value>Объект <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />, связанный со страницей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.Form%2A> свойство для доступа к методам и свойствам <xref:System.Web.UI.HtmlControls.HtmlForm> объект, который является базовым иерархию элементов управления на странице.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
      </Docs>
    </Member>
    <Member MemberName="FrameworkInitialize">
      <MemberSignature Language="C#" Value="protected override void FrameworkInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FrameworkInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FrameworkInitialize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub FrameworkInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void FrameworkInitialize();" />
      <MemberSignature Language="F#" Value="override this.FrameworkInitialize : unit -&gt; unit" Usage="page.FrameworkInitialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует дерево элементов управления во время генерации страницы, на основе декларативной природы страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.FrameworkInitialize%2A> Метод инициализирует <xref:System.Web.UI.Page> и создает дерево элементов управления, в зависимости от декларативной природы страницы. <xref:System.Web.UI.Page.FrameworkInitialize%2A> Метод переопределяется страницы синтаксического анализа и создания кода для <xref:System.Web.UI.Page> класса для декларативной страницы. Как правило следует не при необходимости переопределить этот метод. Если переопределение, не забудьте вызвать базовый класс <xref:System.Web.UI.Page.FrameworkInitialize%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="GetDataItem">
      <MemberSignature Language="C#" Value="public object GetDataItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetDataItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetDataItem" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDataItem () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetDataItem();" />
      <MemberSignature Language="F#" Value="member this.GetDataItem : unit -&gt; obj" Usage="page.GetDataItem " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает элемент данных на верху стека контекста привязки данных.</summary>
        <returns>Объект на верху стека контекста привязки данных.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Контекст привязки для страницы отсутствует.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientEvent">
      <MemberSignature Language="C#" Value="public string GetPostBackClientEvent (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientEvent(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientEvent(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientEvent(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientEvent : System.Web.UI.Control * string -&gt; string" Usage="page.GetPostBackClientEvent (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, который получает события обратной передачи клиента.</param>
        <param name="argument"><see cref="T:System.String" /> — передается в <see cref="M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)" />.</param>
        <summary>Возвращает ссылку, которая может использоваться в клиентском событии при обратной передаче на сервер для указанного элемента управления с указанными аргументами события.</summary>
        <returns>Строка, которая представляет событие клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 См. в разделе <xref:System.Web.UI.ClientScriptManager> класс альтернативные варианты этот устаревший элемент.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.Button.OnClientClick" />
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="page.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackClientHyperlink. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, обрабатывающий обратную передачу.</param>
        <param name="argument">Параметр, передаваемый серверному элементу управления.</param>
        <summary>Возвращает ссылку, с <see langword="javascript:" /> в начале, которую можно использовать в клиентском событии для обратной передачи серверу указанного элемента управления с указанными аргументами события.</summary>
        <returns>Строка, представляющая вызов JavaScript функции обратной передачи, включающей идентификатор целевого элемента управления и аргументы события.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 См. в разделе <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> метод альтернативный способ этот устаревший элемент.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Этот метод использовать не рекомендуется. Вместо него следует использовать метод <see cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" /> класса <see cref="T:System.Web.UI.ClientScriptManager" />.</summary>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control -&gt; string" Usage="page.GetPostBackEventReference control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, обрабатывающий обратную передачу на сервере.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным объектом <see cref="T:System.Web.UI.Control" />.</summary>
        <returns>Строка, инициирующая — при рассмотрении ее в качестве скрипта на стороне клиента — обратную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использовать не рекомендуется. Вместо него следует использовать метод <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> класса <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#2)]
 [!code-vb[Page_GetPostBackEventReference#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="page.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, обрабатывающий обратную передачу.</param>
        <param name="argument">Параметр, передаваемый серверному элементу управления.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным элементом управления, обрабатывающим обратную передачу, и строчным аргументом с дополнительной информацией о событии.</summary>
        <returns>Строка, инициирующая — при рассмотрении ее в качестве скрипта на стороне клиента — обратную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использовать не рекомендуется. Вместо него следует использовать метод <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> класса <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#1)]
 [!code-vb[Page_GetPostBackEventReference#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetTypeHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetTypeHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetTypeHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetTypeHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeHashCode : unit -&gt; int&#xA;override this.GetTypeHashCode : unit -&gt; int" Usage="page.GetTypeHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает хэш-код, создаваемый объектами <see cref="T:System.Web.UI.Page" />, порождаемыми во время выполнения. Этот хэш-код уникален для иерархии элементов управления объекта <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Хэш-код, создаваемый во время выполнения. Значение по умолчанию — 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует переопределять этот метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValidators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection GetValidators (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.ValidatorCollection GetValidators(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetValidators(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValidators (validationGroup As String) As ValidatorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::ValidatorCollection ^ GetValidators(System::String ^ validationGroup);" />
      <MemberSignature Language="F#" Value="member this.GetValidators : string -&gt; System.Web.UI.ValidatorCollection" Usage="page.GetValidators validationGroup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="validationGroup">Возвращаемая группа проверки или <see langword="null" /> для возврата группы проверки по умолчанию.</param>
        <summary>Возвращает коллекцию проверяющих элементов управления для указанной группы проверки.</summary>
        <returns>Коллекция <see cref="T:System.Web.UI.ValidatorCollection" />, содержащая проверяющие элементы управления для указанной группы проверки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.GetValidators%2A> Метод возвращает все объекты проверки, связанные с группой проверки. Может возвращать группы проверки по умолчанию (все элементы управления проверки, связанные с элементами управления без `ValidationGroup` набор свойств), задав `validationGroup` параметр `null`.  
  
 Чтобы проверить элементы группы проверки, может осуществлять перечисление по коллекции и вызвать <xref:System.Web.UI.IValidator.Validate%2A> возвращается метод каждого проверяющего элемента управления.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.UI.Page.GetValidators%2A> метод для возврата группы проверки по умолчанию.  
  
 [!code-csharp[PageGetValidators#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageGetValidators/CS/pagegetvalidatorscs.aspx#1)]
 [!code-vb[PageGetValidators#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageGetValidators/VB/pagegetvalidatorsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.Validate(System.String)" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
      </Docs>
    </Member>
    <Member MemberName="GetWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected object GetWrappedFileDependencies (string[] virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetWrappedFileDependencies(string[] virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetWrappedFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetWrappedFileDependencies (virtualFileDependencies As String()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ GetWrappedFileDependencies(cli::array &lt;System::String ^&gt; ^ virtualFileDependencies);" />
      <MemberSignature Language="F#" Value="member this.GetWrappedFileDependencies : string[] -&gt; obj" Usage="page.GetWrappedFileDependencies virtualFileDependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.String[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">Строковый массив размещений виртуальных файлов.</param>
        <summary>Возвращает список имен физических файлов, соответствующих списку размещения виртуальных файлов.</summary>
        <returns>Объект, содержащий список размещения физических файлов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.GetWrappedFileDependencies%2A> Метод получает список файлов, таких как файлы пользовательских элементов управления, составляющих текущую страницу. При изменении каких-либо из этих страниц, вся страница компилируется в следующий раз, когда он запрашивается. Не следует переопределять этот метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Header">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlHead Header { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlHead Header" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Header" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Header As HtmlHead" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::HtmlControls::HtmlHead ^ Header { System::Web::UI::HtmlControls::HtmlHead ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Header : System.Web.UI.HtmlControls.HtmlHead" Usage="System.Web.UI.Page.Header" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlHead</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает заголовок документа страницы, если элемент <see langword="head" /> определен с <see langword="runat=server" /> в объявлении страницы.</summary>
        <value>Объект <see cref="T:System.Web.UI.HtmlControls.HtmlHead" />, содержащий заголовок страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Header%2A> Свойство получает ссылку на <xref:System.Web.UI.HtmlControls.HtmlHead> который можно использовать сведения заголовка документа для страницы. <xref:System.Web.UI.HtmlControls.HtmlHead> Позволяет добавлять сведения, такие как таблицы стилей, правила стилей, title и метаданных для `head` элемент.  
  
> [!NOTE]
>  Добавление стилей программно с помощью методов класса <xref:System.Web.UI.IStyleSheet> интерфейс во время асинхронных обратных вызовов не поддерживается. При добавлении функциональных возможностей AJAX на веб-страницу, асинхронные обратные передачи обновлять области страницы без обновления всей страницы. Дополнительные сведения см. в разделе [Обзор Microsoft Ajax](https://msdn.microsoft.com/library/be84d9b3-b7cd-47d7-8494-be4abfaad9cb).  
  
   
  
## Examples  
 В следующем примере кода показано, как получить доступ к <xref:System.Web.UI.HtmlControls.HtmlHead> управлять программно с помощью <xref:System.Web.UI.Page.Header%2A> свойство. Объект `title` элемент и `style` добавляются в элемент `head` элемента страницы.  
  
 [!code-aspx-csharp[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/CS/htmlheadclasscs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/VB/htmlheadclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlHead" />
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlLink" />
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public override string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ID : string with get, set" Usage="System.Web.UI.Page.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает идентификатор для конкретного экземпляра класса <see cref="T:System.Web.UI.Page" />.</summary>
        <value>Идентификатор экземпляра класса <see cref="T:System.Web.UI.Page" />. По умолчанию используется значение '_Page'.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="public virtual char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char IdSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.IdSeparator : char" Usage="System.Web.UI.Page.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает символ, используемый для разделения идентификаторов элемента управления при построении уникального идентификатора элемента управления на странице.</summary>
        <value>Символ, используемый для разделения идентификаторов элементов управления. Значение по умолчанию устанавливается экземпляром <see cref="T:System.Web.UI.Adapters.PageAdapter" />, отображающим страницу. Свойство <see cref="P:System.Web.UI.Page.IdSeparator" /> является полем на стороне сервера и не должно изменяться.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.ID" />
      </Docs>
    </Member>
    <Member MemberName="InitComplete">
      <MemberSignature Language="C#" Value="public event EventHandler InitComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InitComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.InitComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InitComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ InitComplete;" />
      <MemberSignature Language="F#" Value="member this.InitComplete : EventHandler " Usage="member this.InitComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при завершении инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.InitComplete> Событие вызывается в конце стадии инициализации страницы. На этом этапе жизненного цикла страницы все объявленные инициализируются элементы управления страницы, но еще не заполняется состояния страницы. Вы можете получить доступ к серверных элементов управления, но они еще не содержат сведений, полученных от пользователя.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Общие сведения о жизненном цикле страницы ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InitializeCulture">
      <MemberSignature Language="C#" Value="protected virtual void InitializeCulture ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeCulture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitializeCulture" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeCulture ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeCulture();" />
      <MemberSignature Language="F#" Value="abstract member InitializeCulture : unit -&gt; unit&#xA;override this.InitializeCulture : unit -&gt; unit" Usage="page.InitializeCulture " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Устанавливает свойства <see cref="P:System.Web.UI.Page.Culture" /> и <see cref="P:System.Web.UI.Page.UICulture" /> текущего потока страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.InitializeCulture%2A> Метод не содержит кода логики. Разработчики, расширения функциональных возможностей управления <xref:System.Web.UI.Page> класс может переопределить <xref:System.Web.UI.Page.InitializeCulture%2A> метод для инициализации <xref:System.Web.UI.Page.Culture%2A> и <xref:System.Web.UI.Page.UICulture%2A> сведения для страницы.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.Web.UI.Page.FrameworkInitialize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InitOutputCache">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует кэш выходных данных для текущего запроса страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не предназначен для непосредственного использования в коде. Для включения и управления кэшированием вывода для страницы, используйте один из следующих подходов:  
  
-   Задайте параметры декларативно с помощью директивы в файле .aspx.  
  
-   Использовать методы и свойства класса <xref:System.Web.HttpCachePolicy> класс, который предоставляется командлетом `Response.Cache` объект в коде страницы.  
  
 Дополнительные сведения см. в разделе [кэширования страницы ASP.NET](https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected internal virtual void InitOutputCache (System.Web.UI.OutputCacheParameters cacheSettings);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void InitOutputCache(class System.Web.UI.OutputCacheParameters cacheSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Web.UI.OutputCacheParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub InitOutputCache (cacheSettings As OutputCacheParameters)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void InitOutputCache(System::Web::UI::OutputCacheParameters ^ cacheSettings);" />
      <MemberSignature Language="F#" Value="abstract member InitOutputCache : System.Web.UI.OutputCacheParameters -&gt; unit&#xA;override this.InitOutputCache : System.Web.UI.OutputCacheParameters -&gt; unit" Usage="page.InitOutputCache cacheSettings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheSettings" Type="System.Web.UI.OutputCacheParameters" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="cacheSettings">Объект <see cref="T:System.Web.UI.OutputCacheParameters" />, содержащий параметры кэша.</param>
        <summary>Инициализирует кэш выходных данных для текущего запроса страницы на основе объекта <see cref="T:System.Web.UI.OutputCacheParameters" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует вызывать этот метод. Для включения и управления кэшированием вывода для страницы, используйте директиву в файле .aspx или методы и свойства <xref:System.Web.HttpCachePolicy> класса. Доступ через `Response.Cache` синтаксис в страницы кода блока или кода файл объявления. Дополнительные сведения см. в разделе [кэширования страницы ASP.NET](https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Профиль кэша не найден.  
  
-или- 
Пропущенная директива или атрибут профиля параметров конфигурации.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Задано неверное значение для расположения кэша выходных данных.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Кэширование страниц ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitOutputCache (duration As Integer, varyByHeader As String, varyByCustom As String, location As OutputCacheLocation, varyByParam As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitOutputCache(int duration, System::String ^ varyByHeader, System::String ^ varyByCustom, System::Web::UI::OutputCacheLocation location, System::String ^ varyByParam);" />
      <MemberSignature Language="F#" Value="abstract member InitOutputCache : int * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit&#xA;override this.InitOutputCache : int * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit" Usage="page.InitOutputCache (duration, varyByHeader, varyByCustom, location, varyByParam)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">Время, в течение которого объекты, сохраняемые в кэше выходных данных, верны.</param>
        <param name="varyByHeader">Список заголовков, разделенных точкой с запятой, по которым изменяется содержимое кэша выходных данных.</param>
        <param name="varyByCustom">НТТР-заголовок <see langword="Vary" />.</param>
        <param name="location">Одно из значений <see cref="T:System.Web.UI.OutputCacheLocation" />.</param>
        <param name="varyByParam">Список параметров, полученных методом GET или POST, разделенных точкой с запятой, по которым изменяется содержимое кэша выходных данных.</param>
        <summary>Инициализирует кэш выходных данных для текущего запроса страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует вызывать этот метод. Для включения и управления кэшированием вывода для страницы, используйте директиву в файле .aspx или методы и свойства <xref:System.Web.HttpCachePolicy> класса. Доступ через `Response.Cache` синтаксиса кода страницы. Дополнительные сведения см. в разделе [кэширования страницы ASP.NET](https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Задано недопустимое значение для <paramref name="location" />.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Кэширование страниц ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitOutputCache (duration As Integer, varyByContentEncoding As String, varyByHeader As String, varyByCustom As String, location As OutputCacheLocation, varyByParam As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitOutputCache(int duration, System::String ^ varyByContentEncoding, System::String ^ varyByHeader, System::String ^ varyByCustom, System::Web::UI::OutputCacheLocation location, System::String ^ varyByParam);" />
      <MemberSignature Language="F#" Value="abstract member InitOutputCache : int * string * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit&#xA;override this.InitOutputCache : int * string * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit" Usage="page.InitOutputCache (duration, varyByContentEncoding, varyByHeader, varyByCustom, location, varyByParam)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="varyByContentEncoding" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="varyByHeader" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="varyByCustom" Type="System.String" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="varyByParam" Type="System.String" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="duration">Время, в течение которого объекты, сохраняемые в кэше выходных данных, верны.</param>
        <param name="varyByContentEncoding">Список кодировок (кодирования содержимого), разделенных точкой с запятой, по которым изменяется содержимое кэша выходных данных.</param>
        <param name="varyByHeader">Список заголовков, разделенных точкой с запятой, по которым изменяется содержимое кэша выходных данных.</param>
        <param name="varyByCustom">НТТР-заголовок <see langword="Vary" />.</param>
        <param name="location">Одно из значений <see cref="T:System.Web.UI.OutputCacheLocation" />.</param>
        <param name="varyByParam">Список параметров, полученных методом GET или POST, разделенных точкой с запятой, по которым изменяется содержимое кэша выходных данных.</param>
        <summary>Инициализирует кэш выходных данных для текущего запроса страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует вызывать этот метод. Для включения и управления кэшированием вывода для страницы, используйте директиву в файле .aspx или методы и свойства <xref:System.Web.HttpCachePolicy> класса. Доступ через `Response.Cache` синтаксиса кода страницы. Дополнительные сведения см. в разделе [кэширования страницы ASP.NET](https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Задано недопустимое значение для <paramref name="location" />.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Кэширование страниц ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.Web.UI.Page.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, обрабатывается ли страница асинхронно.</summary>
        <value>Значение <see langword="true" />, если страница обрабатывается асинхронно; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.IsAsync%2A> свойства, чтобы определить, выполняется ли веб-страницы в асинхронном режиме. Эта информация полезна в том случае, если элементы управления или код на странице необходимо изменение их поведения в зависимости от асинхронной страницы. Дополнительные сведения об асинхронном программировании см. в разделе [асинхронных операций](~/docs/framework/data/adonet/sql/asynchronous-operations.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCallback">
      <MemberSignature Language="C#" Value="public bool IsCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCallback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCallback : bool" Usage="System.Web.UI.Page.IsCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли запрос страницы результатом обратного вызова.</summary>
        <value>Значение <see langword="true" />, если запрос страницы является результатом обратного вызова; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [реализация клиента обратные вызовы без обратной передачи](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/1d42ebea-8792-4279-acf8-5d497f3a41ea">Практическое руководство. Реализация обратных вызовов веб-страниц ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="page.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsClientScriptBlockRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Искомый строковый ключ клиентского скрипта.</param>
        <summary>Определяет, зарегистрирован ли со страницей блок скрипта с указанным ключом.</summary>
        <returns><see langword="true" />, если блок скрипта зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A?displayProperty=nameWithType> Чтобы избежать ненужного сборка клиентского скрипта. Это особенно важно в том случае, если сценарий требует большой объем серверных ресурсов.  
  
 Метод <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> не рекомендуется к использованию. Используйте <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метод в <xref:System.Web.UI.ClientScriptManager> класса.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> в сочетании с <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> метод. Если ECMAScript, записанных в блоке кода объявление не уже был зарегистрирован, что определяется <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, а затем <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> вызов.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsCrossPagePostBack">
      <MemberSignature Language="C#" Value="public bool IsCrossPagePostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCrossPagePostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCrossPagePostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCrossPagePostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCrossPagePostBack : bool" Usage="System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, вовлечена ли страница в межстраничные обратные передачи.</summary>
        <value><see langword="true" />, если страница участвует в межстраничных запросах; в противном случае ─ <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET предоставляет два механизма для передачи управления от одной страницы в другую. Можно использовать <xref:System.Web.HttpServerUtility.Transfer%2A> метод для передачи обработки между страницы, или сделать межстраничных запросах путем назначения URL-адрес страницы для <xref:System.Web.UI.WebControls.IButtonControl.PostBackUrl%2A> свойства элемента управления кнопки, реализующий <xref:System.Web.UI.WebControls.IButtonControl> интерфейс.  
  
 В любом случае <xref:System.Web.UI.Page.PreviousPage%2A> свойство страницы будет содержать объект, который представляет страницу предыдущих или инициатора. Если, например, путь A отправляет страницу B, A страницы <xref:System.Web.UI.Page.IsCrossPagePostBack%2A> свойство (доступный через <xref:System.Web.UI.Page.PreviousPage%2A> свойство) будет `true` и страницу B <xref:System.Web.UI.Page.PreviousPage%2A> свойство будет иметь имя страницы A.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.IButtonControl.PostBackUrl" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBack">
      <MemberSignature Language="C#" Value="public bool IsPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostBack : bool" Usage="System.Web.UI.Page.IsPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, отрисовывается ли страница в первый раз или же загружается в ответ на обратную передачу.</summary>
        <value><see langword="true" />, если страница загружается в ответ на обратный запрос клиента; иначе — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объяснение разницы между обратных вызовов и обратных вызовов, см. в разделе [реализация клиента обратные вызовы без обратной передачи](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
   
  
## Examples  
 В следующем примере показано, как для проверки значения <xref:System.Web.UI.Page.IsPostBack%2A> свойства при загрузке страницы, чтобы определить ли страница отображается в первый раз или отвечает на обратную передачу. Если страница отображается впервые, то вызывается <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> метод.  
  
 (Не показано) разметка страницы содержит <xref:System.Web.UI.WebControls.RequiredFieldValidator> элементы управления для отображения звездочки, если запись не выполняется для ввода обязательным полем. Вызов <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> вызывает звездочки для отображения сразу же при отображении страницы, а не ждать, пока пользователь нажимает кнопку «Отправить». После обратной передачи, нет необходимости вызывать <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>, так как этот метод вызывается как часть <xref:System.Web.UI.Page> жизненного цикла.  
  
 [!code-csharp[System.Web.UI.Page.Validate#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Validate#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.Page.IsCallback" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBackEventControlRegistered">
      <MemberSignature Language="C#" Value="public bool IsPostBackEventControlRegistered { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBackEventControlRegistered" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostBackEventControlRegistered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostBackEventControlRegistered { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostBackEventControlRegistered : bool" Usage="System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, зарегистрирован ли страничный элемент управления, выполняющий обратную передачу.</summary>
        <value>Значение <see langword="true" />, если элемент управления зарегистрирован; в противном случае — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReusable">
      <MemberSignature Language="C#" Value="public bool IsReusable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReusable" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsReusable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReusable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReusable : bool" Usage="System.Web.UI.Page.IsReusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.IHttpHandler.IsReusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, может ли объект <see cref="T:System.Web.UI.Page" /> быть повторно используемым.</summary>
        <value>Значение <see langword="false" /> во всех случаях.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.IHttpHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="page.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsStartupScriptRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Искомый строковый ключ скрипта запуска.</param>
        <summary>Определяет, зарегистрирован ли стартовый клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />.</summary>
        <returns><see langword="true" />, если скрипт, активизируемый при запуске, зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.Page.RegisterStartupScript%2A?displayProperty=nameWithType> Чтобы избежать ненужного сборка клиентского скрипта. Это особенно важно в том случае, если сценарий требует большой объем серверных ресурсов.  
  
 Метод <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> не рекомендуется к использованию. Используйте <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метод в <xref:System.Web.UI.ClientScriptManager> класса.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.Page.RegisterStartupScript%2A> в сочетании с <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> метод. Если ECMAScript, записанных в блоке кода объявление не уже был зарегистрирован, что определяется <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>, а затем <xref:System.Web.UI.Page.RegisterStartupScript%2A> вызов.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValid" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValid : bool" Usage="System.Web.UI.Page.IsValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, завершена ли проверка страницы успешно.</summary>
        <value><see langword="true" />, если проверка завершена успешно; иначе — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для этого свойства для возврата `true`, необходимо пройти все проверочные элементы управления в текущей группе проверки. Это свойство необходимо проверить только после вызова <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> метода или набора `CausesValidation` свойства `true` в `OnServerClick` обработчик событий для элемента управления сервера ASP.NET, инициирующего обработку формы. Эти серверные элементы управления включают <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.HtmlControls.HtmlButton>, <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, <xref:System.Web.UI.WebControls.ImageButton>, и <xref:System.Web.UI.WebControls.LinkButton> классы.  
  
 Если принудительная проверка группы проверки с помощью <xref:System.Web.UI.Page.Validate%2A> метод, то все элементы управления проверки в указанной группе проверки успешно проверены также.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.Page.IsValid%2A> свойство для задания условного оператора. Если свойство возвращает `true`, `Text` свойство `lblOutput` игнорируется «Страница предназначена!». В противном случае он становится равным «Некоторые обязательные поля пусты.»  
  
 [!code-csharp[System.Web.UI.Page.Validate#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Validate#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Свойство <see cref="P:System.Web.UI.Page.IsValid" /> вызывается до начала проверки.</exception>
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="M:System.Web.UI.Page.Validate" />
        <related type="Article" href="https://msdn.microsoft.com/library/fa2aa14d-a461-492e-9a79-c990904613ef">Проверяющие элементы управления ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.UI.Page.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает список объектов, хранящихся в контексте страницы.</summary>
        <value>Ссылка на объект <see cref="T:System.Collections.IDictionary" />, содержащий объекты, хранящиеся в контексте страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.Items%2A> свойство для хранения объектов с тем же временем жизни как запрос страницы. Это свойство доступно только для чтения; Тем не менее, можно добавлять объекты в <xref:System.Collections.IDictionary> объекта, он возвращает.  
  
 Объекты, добавленные <xref:System.Web.UI.Page.Items%2A> свойства доступны на протяжении всего жизненного цикла страницы, поэтому можно добавлять объекты <xref:System.Web.UI.Page.Items%2A> свойства в события на раннем этапе жизни страницы цикла, а также обращаться к этим объектам в более поздних событий.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public int LCID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.LCID" />
      <MemberSignature Language="VB.NET" Value="Public Property LCID As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LCID { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.LCID : int with get, set" Usage="System.Web.UI.Page.LCID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает идентификатор языкового стандарта объекта <see cref="T:System.Threading.Thread" />, связанного со страницей.</summary>
        <value>Идентификатор языкового стандарта, передаваемых объекту <see cref="T:System.Threading.Thread" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. `LCID` Атрибут можно задать в директиве ASPX-файла, однако является предпочтительным способом настройки локали помощи <xref:System.Web.UI.Page.Culture%2A> и <xref:System.Web.UI.Page.UICulture%2A> свойства.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
        <altmember cref="P:System.Web.UI.Page.UICulture" />
      </Docs>
    </Member>
    <Member MemberName="LoadComplete">
      <MemberSignature Language="C#" Value="public event EventHandler LoadComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LoadComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.LoadComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LoadComplete;" />
      <MemberSignature Language="F#" Value="member this.LoadComplete : EventHandler " Usage="member this.LoadComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит в конце стадии загрузки жизненного цикла страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.LoadComplete> Событие возникает после всех обратной передачи данных и загрузки данных состояния представления на странице и после <xref:System.Web.UI.Control.OnLoad%2A> для всех элементов управления на странице будет вызван метод.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Общие сведения о жизненном цикле страницы ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="LoadPageStateFromPersistenceMedium">
      <MemberSignature Language="C#" Value="protected internal virtual object LoadPageStateFromPersistenceMedium ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object LoadPageStateFromPersistenceMedium() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function LoadPageStateFromPersistenceMedium () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ LoadPageStateFromPersistenceMedium();" />
      <MemberSignature Language="F#" Value="abstract member LoadPageStateFromPersistenceMedium : unit -&gt; obj&#xA;override this.LoadPageStateFromPersistenceMedium : unit -&gt; obj" Usage="page.LoadPageStateFromPersistenceMedium " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Загружает сохраненные сведения о состоянии отображения в объект <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Сохраненное состояние представления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> Использует метод <xref:System.Web.UI.PageStatePersister.Load%2A> метод <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> объект, упоминаемый в <xref:System.Web.UI.Page.PageStatePersister%2A> свойство загружать все сохраненные сведения о состоянии представления для <xref:System.Web.UI.Page> объекта.  
  
 ASP.NET включает две подчиненные элементы <xref:System.Web.UI.PageStatePersister> класс, <xref:System.Web.UI.HiddenFieldPageStatePersister> класс, который сохраняет сведения о состоянии в скрытом поле включено в страницу ASP.NET, и <xref:System.Web.UI.SessionPageStatePersister> класс, который сохраняет состояние в <xref:System.Web.UI.Page.Session%2A> объект, связанный с запрос.  
  
 Для сохранения состояния в расположении по своему усмотрению, необходимо создать новый потомком <xref:System.Web.UI.PageStatePersister> класс, который сохраняет и загружает состояние на постоянном носителе по своему усмотрению. Пример создания нового <xref:System.Web.UI.PageStatePersister> объекта, см. в разделе <xref:System.Web.UI.PageStatePersister> класса.  
  
 Если вы используете .NET Framework версии 1.0 или 1.1, переопределите этот метод, если вы хотите загрузить <xref:System.Web.UI.Page> состояния, отличных от скрытое поле. Если вы решили сделать это, необходимо также переопределить <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="MaintainScrollPositionOnPostBack">
      <MemberSignature Language="C#" Value="public bool MaintainScrollPositionOnPostBack { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="VB.NET" Value="Public Property MaintainScrollPositionOnPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaintainScrollPositionOnPostBack { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MaintainScrollPositionOnPostBack : bool with get, set" Usage="System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, возвращается ли пользователь на прежнюю позицию в браузере после обратной передачи. Это свойство заменяет устаревшее свойство <see cref="P:System.Web.UI.Page.SmartNavigation" />.</summary>
        <value><see langword="true" />, если позиция клиента сохраняется; в противном случае ─ <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда веб-страницы учитываются на сервер, пользователь возвращается к верхней части страницы. Для длинных страниц это означает, что у пользователя есть к прокрутите страницу к последней позиции на странице.  
  
 Когда <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> свойству `true`, пользователь возвращается к последней позиции на странице.  
  
 Можно задать <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> свойство в [@ Page](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) директива.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="page.MapPath virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Значение типа <see cref="T:System.String" />, содержащее виртуальный путь.</param>
        <summary>Извлекает физический путь, к которому ведет виртуальный путь (абсолютный или относительный), или путь, на который отображается относительный путь приложения.</summary>
        <returns>Физический путь, связанный с виртуальным путем или относительным путем приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.UI.Page.MapPath%2A> Свойства могут содержать конфиденциальные сведения о среде размещения. Возвращаемое значение не должно отображаться для пользователей.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Web.UI.Page.MapPath%2A> метод, чтобы получить физический путь к вложенной папке. Затем он устанавливает имя файла, которая фактически считывается из <xref:System.Web.UI.WebControls.TextBox.Text%2A> свойство <xref:System.Web.UI.WebControls.TextBox> элемента управления. Результатом является абсолютный физический путь к этому файлу.  
  
 [!code-csharp[Page_MapPath_ResponseEncoding#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/CS/page_mappath_responseencoding.cs.aspx#1)]
 [!code-vb[Page_MapPath_ResponseEncoding#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/VB/page_mappath_responseencoding.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Master">
      <MemberSignature Language="C#" Value="public System.Web.UI.MasterPage Master { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.MasterPage Master" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Master" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Master As MasterPage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::MasterPage ^ Master { System::Web::UI::MasterPage ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Master : System.Web.UI.MasterPage" Usage="System.Web.UI.Page.Master" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.MasterPage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает эталонную страницу, определяющую общий вид таблицы.</summary>
        <value>Объект <see cref="T:System.Web.UI.MasterPage" />, связанный с этой страницей, если она существует; в противном случае ─ <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Master%2A> Возвращает <xref:System.Web.UI.MasterPage> объект, связанный с этой страницей. Это свойство доступно только для чтения; Тем не менее, можно задать свойства на <xref:System.Web.UI.MasterPage> объекта, он возвращает.  
  
 <xref:System.Web.UI.Page.Master%2A> Свойство поддерживается только на страницах, которые ссылаются на главную страницу в <xref:System.Web.UI.Page.MasterPageFile%2A> свойство. При доступе к <xref:System.Web.UI.Page.Master%2A> свойство на странице, которая не ссылается на главной странице, `null` возвращается. Содержимое главной страницы не действует только до после <xref:System.Web.UI.Page.PreInit> события.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.MasterPageFile" />
        <related type="Article" href="https://msdn.microsoft.com/library/4e53eedf-8304-4e7a-aed1-691a2623b28b">Основные сведения о главных страниц</related>
      </Docs>
    </Member>
    <Member MemberName="MasterPageFile">
      <MemberSignature Language="C#" Value="public virtual string MasterPageFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MasterPageFile" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MasterPageFile" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MasterPageFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ MasterPageFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MasterPageFile : string with get, set" Usage="System.Web.UI.Page.MasterPageFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает виртуальный путь эталонной страницы.</summary>
        <value>Виртуальный путь к эталонной странице.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.MasterPageFile%2A> Свойство — это виртуальный путь (от корневого каталога приложения), главной страницы файла, связанного с этой страницей. <xref:System.Web.UI.Page.MasterPageFile%2A> Свойство можно задать только в <xref:System.Web.UI.Page.PreInit> задание; попытка задать <xref:System.Web.UI.Page.MasterPageFile%2A> свойства после <xref:System.Web.UI.Page.PreInit> вызовет событие <xref:System.InvalidOperationException> исключение. Если <xref:System.Web.UI.Page.MasterPageFile%2A> свойство не является допустимым, исключение типа <xref:System.Web.HttpException> создается позже в жизненном цикле страницы, но исключение не вызывается в том случае, если свойство задается в <xref:System.Web.UI.Page.PreInit> событий.  
  
 Страниц, включающих <xref:System.Web.UI.Page.MasterPageFile%2A> набор свойств страниц содержимого и поэтому могут содержать только верхнего уровня элементов управления, являющихся <xref:System.Web.UI.WebControls.Content> элементов управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Web.UI.Page.MasterPageFile" /> устанавливается после завершения события <see cref="E:System.Web.UI.Page.PreInit" />.</exception>
        <exception cref="T:System.Web.HttpException">Файл, указанный в свойстве <see cref="P:System.Web.UI.Page.MasterPageFile" />, не существует.  
  
-или- 
Страница не имеет элемента управления <see cref="T:System.Web.UI.WebControls.Content" /> на верхнем уровне.</exception>
        <altmember cref="P:System.Web.UI.Page.Master" />
        <related type="Article" href="https://msdn.microsoft.com/library/4e53eedf-8304-4e7a-aed1-691a2623b28b">Основные сведения о главных страниц</related>
      </Docs>
    </Member>
    <Member MemberName="MaxPageStateFieldLength">
      <MemberSignature Language="C#" Value="public int MaxPageStateFieldLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPageStateFieldLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPageStateFieldLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPageStateFieldLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPageStateFieldLength : int with get, set" Usage="System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальную длину поля состояния страницы.</summary>
        <value>Максимальная длина, в байтах, поля состояния страницы. Значение по умолчанию — -1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> свойству присваивается значение положительное, состояние представления, отправляемых в браузер клиента разбивается на несколько скрытые поля и значение каждого поля меньше, чем размер, указанный в <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> свойство.  
  
 Параметр <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> свойство отрицательное целое число (по умолчанию) указывает, что поле состояния представления, не должны быть разделены на блоки. Параметр <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> небольшое число может привести к снижению производительности.  
  
 Установите для параметра <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> свойство в файле Web.config.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойство <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> не равно -1 или положительному числу.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> было установлено после инициализации страницы.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaDescription">
      <MemberSignature Language="C#" Value="public string MetaDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property MetaDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MetaDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MetaDescription : string with get, set" Usage="System.Web.UI.Page.MetaDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает содержимое элемента <see langword="meta" /> свойства "description".</summary>
        <value>Содержимое элемента <see langword="meta" /> свойства "description".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` элементы, которые могут использоваться для улучшения вхождений поисковой системы. «description» `meta` используется некоторые поисковые системы для улучшения предпросмотров.  
  
 Если отсутствует «описание» `meta` элемент в `head` элемент разметки страницы, `meta` при отображении страницы на страницу добавляется элемент. Если разметка страницы уже «description» `meta` элемент, это свойство Возвращает или задает `content` атрибут `meta` элемента.  
  
 Кроме того, это свойство можно задать в директиве.  
  
   
  
## Examples  
 Если задать <xref:System.Web.UI.Page.MetaDescription%2A> свойства страницы «Обзор ASP.NET» следующий элемент будет отображаться в формате HTML:  
  
 `<meta name="description" content="ASP.NET Overview" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">На странице нет элемента управления "заголовок" (элемент <see langword="head" /> с атрибутом <see langword="runat" /> со значением "server").</exception>
        <altmember cref="P:System.Web.UI.Page.MetaKeywords" />
      </Docs>
    </Member>
    <Member MemberName="MetaKeywords">
      <MemberSignature Language="C#" Value="public string MetaKeywords { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaKeywords" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaKeywords" />
      <MemberSignature Language="VB.NET" Value="Public Property MetaKeywords As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MetaKeywords { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MetaKeywords : string with get, set" Usage="System.Web.UI.Page.MetaKeywords" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает содержимое <see langword="meta" />-элемента "keywords".</summary>
        <value>Содержимое <see langword="meta" />-элемента "keywords".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` элементы, которые могут использоваться для улучшения вхождений поисковой системы. «keywords» `meta` элемент не используется вообще или задается вес практически все основные поисковые машины.  
  
 Если не «keywords» `meta` элемент в `head` элемент разметки страницы, `meta` при отображении страницы на страницу добавляется элемент. Если разметка страницы уже «keywords» `meta` элемент, это свойство Возвращает или задает `content` атрибут `meta` элемента.  
  
 Кроме того, это свойство можно задать в директиве.  
  
   
  
## Examples  
 Если задать <xref:System.Web.UI.Page.MetaKeywords%2A> свойства страницы «HTML, CSS, XML, JavaScript», следующий элемент будет отображаться в формате HTML:  
  
 `<meta name="keywords" content=" HTML,CSS,XML,JavaScript" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">На странице нет элемента управления "заголовок" (элемент <see langword="head" /> с атрибутом <see langword="runat" /> со значением "server").</exception>
        <altmember cref="P:System.Web.UI.Page.MetaDescription" />
      </Docs>
    </Member>
    <Member MemberName="ModelBindingExecutionContext">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModelBindingExecutionContext As ModelBindingExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ModelBinding::ModelBindingExecutionContext ^ ModelBindingExecutionContext { System::Web::ModelBinding::ModelBindingExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ModelBindingExecutionContext : System.Web.ModelBinding.ModelBindingExecutionContext" Usage="System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelBindingExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает контекст выполнения привязки модели.</summary>
        <value>Контекст выполнения привязки модели. Если контекст выполнения привязки модели — <see langword="null" />, создается и возвращается новый контекст.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModelState">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelStateDictionary ModelState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelStateDictionary ModelState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModelState As ModelStateDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ModelBinding::ModelStateDictionary ^ ModelState { System::Web::ModelBinding::ModelStateDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ModelState : System.Web.ModelBinding.ModelStateDictionary" Usage="System.Web.UI.Page.ModelState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelStateDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект словаря состояния модели, содержащий состояние модели и проверку привязки модели.</summary>
        <value>Объект словаря состояния модели.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Серии руководств по использованию привязки модели с веб-форм, см. в разделе [привязки модели и Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="page.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Web.UI.Control.Init" /> для инициализации страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnInit%2A> Метод выполняет действия инициализации и установки, необходимые для создания <xref:System.Web.UI.Page> экземпляра. На этом этапе жизненного цикла страницы объявленный серверных элементов управления на странице инициализируются состояние по умолчанию; Тем не менее состояние представления каждого элемента управления еще не заполнено. Элемент управления на странице не может получить доступ к других серверных элементов управления на странице во время `Page_Init` этап, независимо от других элементов управления дочерних или родительских элементов управления. Другие серверные элементы управления не обязательно быть создана и готова для доступа.  
  
 <xref:System.Web.UI.Page.OnInit%2A> Был вызван после <xref:System.Web.UI.Page.OnPreInit%2A> метода и перед <xref:System.Web.UI.Page.OnInitComplete%2A> метод.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnInit%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnInitComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInitComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitComplete : EventArgs -&gt; unit&#xA;override this.OnInitComplete : EventArgs -&gt; unit" Usage="page.OnInitComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Web.UI.Page.InitComplete" /> после инициализации страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnInitComplete%2A> Был вызван после завершения инициализации страницы. На этом этапе жизненного цикла страницы все объявленные элементы управления на странице инициализируются, но состояние представления страницы еще не заполняется. Вы можете получить доступ к серверных элементов управления, но они еще не содержат сведений, полученных от пользователя.  
  
 <xref:System.Web.UI.Page.OnInitComplete%2A> Метода происходит в конце <xref:System.Web.UI.Page> этап инициализации и до стадии загрузки.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnInitComplete%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLoadComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadComplete : EventArgs -&gt; unit&#xA;override this.OnLoadComplete : EventArgs -&gt; unit" Usage="page.OnLoadComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Web.UI.Page.LoadComplete" /> в конце стадии инициализации страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnLoadComplete%2A> Метод вызывается в конце стадии инициализации страницы. На этом этапе жизненного цикла страницы, все данные обратной передачи и данные состояния представления загружается в элементы управления страницы.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnLoadComplete%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPreInit">
      <MemberSignature Language="C#" Value="protected virtual void OnPreInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreInit : EventArgs -&gt; unit&#xA;override this.OnPreInit : EventArgs -&gt; unit" Usage="page.OnPreInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Web.UI.Page.PreInit" /> в начале инициализации страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreInit%2A> Метод вызывается в начале стадии инициализации страницы.  
  
 После <xref:System.Web.UI.Page.OnPreInit%2A> вызывается метод, загружаются сведения персонализации и темы страницы, если таковые имеются, инициализируется. Это также основной рабочей области для динамического определения <xref:System.Web.UI.PageTheme> или <xref:System.Web.UI.MasterPage> для страницы.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnPreInit%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPreLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnPreLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreLoad : EventArgs -&gt; unit&#xA;override this.OnPreLoad : EventArgs -&gt; unit" Usage="page.OnPreLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает <see cref="E:System.Web.UI.Page.PreLoad" /> событие после загрузки данных обратной передачи в серверные управляющие элементы страницы, но до события <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreLoad%2A> Метод вызывается в конце концов обратной передачи данных, возвращаемых от пользователя загружается. На этом этапе жизненного цикла страницы сведения о состоянии представления и данные обратной передачи для объявленные элементы управления и элементов управления, созданных на этапе инициализации загружаются в элементы управления страницы.  
  
 Элементы управления, созданные в <xref:System.Web.UI.Page.OnPreLoad%2A> метод также будут загружаться с данными состояния представления и обратного вызова.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnPreLoad%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPreRenderComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRenderComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreRenderComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreRenderComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreRenderComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRenderComplete : EventArgs -&gt; unit&#xA;override this.OnPreRenderComplete : EventArgs -&gt; unit" Usage="page.OnPreRenderComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Web.UI.Page.PreRenderComplete" /> после события <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> и до визуализации страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreRenderComplete%2A> Был вызван после завершения предварительной отрисовки этапа жизненного цикла страницы. На этом этапе жизненного цикла страницы все элементы управления создаются и страница готова для подготовки к просмотру выходные данные.  
  
 Это последнее событие, вызываемое перед сохранением состояния представления страницы.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnPreRenderComplete%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSaveStateComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSaveStateComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSaveStateComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSaveStateComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSaveStateComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSaveStateComplete : EventArgs -&gt; unit&#xA;override this.OnSaveStateComplete : EventArgs -&gt; unit" Usage="page.OnSaveStateComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные о событии.</param>
        <summary>Событие <see cref="E:System.Web.UI.Page.SaveStateComplete" /> возникает после того, как состояние страницы сохранено на постоянном носителе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnSaveStateComplete%2A> Метод вызывается, когда сведения о состоянии для элемента управления записано на постоянном носителе для страницы. Сведения о состоянии записываются на постоянном носителе, вызвав <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> метод.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Web.UI.Page.OnSaveStateComplete%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="public System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Page.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает адаптер, отображающий страницу для указанного запрашивающего браузера.</summary>
        <value>Объект <see cref="T:System.Web.UI.Adapters.PageAdapter" />, отображающий страницу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PageAdapter%2A> Свойство возвращает конкретный <xref:System.Web.UI.Adapters.PageAdapter> объект, который изменяет поведение <xref:System.Web.UI.Page> объект для запрашивающего браузера.  
  
 Конкретный <xref:System.Web.UI.Adapters.PageAdapter> объект определяется путем проверки характеристики входящего <xref:System.Web.UI.Page.Request%2A> объекта. Когда адаптер выбирается для выполнения запроса, событий жизненного цикла на <xref:System.Web.UI.Adapters.PageAdapter> объект переопределить соответствующие события на <xref:System.Web.UI.Page> объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageStatePersister">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.PageStatePersister PageStatePersister { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.PageStatePersister PageStatePersister" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageStatePersister" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property PageStatePersister As PageStatePersister" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::PageStatePersister ^ PageStatePersister { System::Web::UI::PageStatePersister ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageStatePersister : System.Web.UI.PageStatePersister" Usage="System.Web.UI.Page.PageStatePersister" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.PageStatePersister</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.UI.PageStatePersister" />, связанный со страницей.</summary>
        <value>Объект <see cref="T:System.Web.UI.PageStatePersister" />, связанный со страницей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запросы и ответы HTTP не учитывают состояние. Для поддержания состояния между HTTP-запросы, серверные страницы ASP.NET могут сохранять <xref:System.Web.UI.Page> состояния. Это состояние, называемое состоянием представления, состоит из страницы и параметры управления и данных, страницы и элементы управления отображаются, как будто они являются теми же самыми элементами, которые пользователь видел и взаимодействовал при их последнего цикла обработки страницы. Существует несколько механизмов для хранения состояния представления между последовательными запросами к той же странице. Абстрактный <xref:System.Web.UI.PageStatePersister> класс представляет базовый класс для этих механизмов хранения состояния.  
  
 Разработчики страниц будет обычно не требуется использовать <xref:System.Web.UI.Page.PageStatePersister%2A> свойство. <xref:System.Web.UI.Page.PageStatePersister%2A> Свойство используется преимущественно разработчиками элементов управления расширения функциональных возможностей <xref:System.Web.UI.Page> класса.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="postEventArgumentID">
      <MemberSignature Language="C#" Value="public const string postEventArgumentID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventArgumentID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventArgumentID" />
      <MemberSignature Language="VB.NET" Value="Public Const postEventArgumentID As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ postEventArgumentID;" />
      <MemberSignature Language="F#" Value="val mutable postEventArgumentID : string" Usage="System.Web.UI.Page.postEventArgumentID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Строка, определяющая скрытое поле EVENTARGUMENT в отображаемой странице.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventSourceID" />
      </Docs>
    </Member>
    <Member MemberName="postEventSourceID">
      <MemberSignature Language="C#" Value="public const string postEventSourceID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventSourceID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventSourceID" />
      <MemberSignature Language="VB.NET" Value="Public Const postEventSourceID As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ postEventSourceID;" />
      <MemberSignature Language="F#" Value="val mutable postEventSourceID : string" Usage="System.Web.UI.Page.postEventSourceID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Строка, определяющая скрытое поле EVENTTARGET в отображаемой странице.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventArgumentID" />
      </Docs>
    </Member>
    <Member MemberName="PreInit">
      <MemberSignature Language="C#" Value="public event EventHandler PreInit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreInit" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreInit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreInit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreInit;" />
      <MemberSignature Language="F#" Value="member this.PreInit : EventHandler " Usage="member this.PreInit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит до инициализации страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие позволяет проверять условия запроса страницы, например, загружается ли страница в ответ на обратный. Также можно проверить значения свойств профиля.  
  
 Это событие позволяет задать значения, которые используются позже в жизненном цикле страницы. Можно динамически задать главной страницы или темы для запрошенной страницы и создание динамических элементов управления.  
  
 Дополнительные сведения о том, как <xref:System.Web.UI.Page.PreInit> событий встраивается в жизненный цикл ASP.NET, см. в разделе [Общие сведения о жизненном цикле страницы ASP.NET](https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Общие сведения о жизненном цикле страницы ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="PreLoad">
      <MemberSignature Language="C#" Value="public event EventHandler PreLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreLoad" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreLoad As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreLoad;" />
      <MemberSignature Language="F#" Value="member this.PreLoad : EventHandler " Usage="member this.PreLoad : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит до события <see cref="E:System.Web.UI.Control.Load" /> страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PreLoad> События после всех обратной передачи обработки данных и перед <xref:System.Web.UI.Control.Load> событий. Вторая попытка загрузки данных обратной передачи перед <xref:System.Web.UI.Page.OnLoadComplete%2A> событий. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Общие сведения о жизненном цикле страницы ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="PreRenderComplete">
      <MemberSignature Language="C#" Value="public event EventHandler PreRenderComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRenderComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreRenderComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRenderComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRenderComplete;" />
      <MemberSignature Language="F#" Value="member this.PreRenderComplete : EventHandler " Usage="member this.PreRenderComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит до визуализации содержимого страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PreRenderComplete> Событие по завершении стадии предварительной визуализации жизненного цикла страницы. На этом этапе жизненного цикла страницы все элементы управления создаются, любые запрошенные разбиения на страницы завершена и страница готова для подготовки к просмотру в выходные данные.  
  
 Это последнее событие, возникающее перед сохранением состояния представления страницы.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Общие сведения о жизненном цикле страницы ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="PreviousPage">
      <MemberSignature Language="C#" Value="public System.Web.UI.Page PreviousPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page PreviousPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PreviousPage" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousPage As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Page ^ PreviousPage { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousPage : System.Web.UI.Page" Usage="System.Web.UI.Page.PreviousPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает страницу, передавшую управление текущей странице.</summary>
        <value>Объект <see cref="T:System.Web.UI.Page" />, представляющий страницу, передавшую управление текущей странице.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании <xref:System.Web.HttpServerUtility.Transfer%2A> метода или использования межстраничной записью передачу обработки с одной страницы ASP.NET, в другое, исходящей странице содержит запрашивать сведения, которые могут быть необходимы для страницы назначения. Можно использовать <xref:System.Web.UI.Page.PreviousPage%2A> свойство для доступа к информации.  
  
 Если текущая страница отображается в результате прямого запроса (не передачи или кросс post, с другой страницы), <xref:System.Web.UI.Page.PreviousPage%2A> свойство содержит `null`.  
  
   
  
## Examples  
 Следующий пример состоит из двух частей. Первый — страницы ASP.NET, использующего <xref:System.Web.HttpServerUtility.Transfer%2A> метода, представленные в модели страницы как `Server.Transfer("path")`. Вторая часть — целевой страницы, которая использует <xref:System.Web.UI.Page.PreviousPage%2A> свойство заголовок первой страницы.  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Main.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Main.aspx#1)]  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Notify.aspx#2)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Notify.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущему пользователю не разрешен доступ к предыдущей странице.  
  
-или- 
Используется маршрутизация ASP.NET, URL-адрес предыдущей страницы является перенаправленное маршрутизируемым URL-адресом. Когда ASP.NET проверяет разрешения на доступ, предполагается, что URL-адрес представляет собой фактический путь к файлу. Поскольку это не относится к случаю для маршрутизируемого URL-адреса, проверка завершится ошибкой.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRequest">
      <MemberSignature Language="C#" Value="public virtual void ProcessRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ProcessRequest (context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessRequest(System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ProcessRequest : System.Web.HttpContext -&gt; unit&#xA;override this.ProcessRequest : System.Web.HttpContext -&gt; unit" Usage="page.ProcessRequest context" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.IHttpHandler.ProcessRequest(System.Web.HttpContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context">Объект <see cref="T:System.Web.HttpContext" />, предоставляющий ссылки к внутренним серверным объектам (например, <see cref="P:System.Web.HttpContext.Request" />, <see cref="P:System.Web.HttpContext.Response" /> и <see cref="P:System.Web.HttpContext.Session" />), используемым для обслуживания запросов HTTP.</param>
        <summary>Задает встроенные серверные объекты, относящиеся к объекту <see cref="T:System.Web.UI.Page" />, такие как свойства <see cref="P:System.Web.UI.Page.Context" />, <see cref="P:System.Web.UI.Page.Request" />, <see cref="P:System.Web.UI.Page.Response" /> и <see cref="P:System.Web.UI.Page.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует вызывать этот метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Context" />
        <altmember cref="P:System.Web.UI.Page.Request" />
        <altmember cref="P:System.Web.UI.Page.Response" />
        <altmember cref="P:System.Web.UI.Page.Application" />
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(class System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RaisePostBackEvent(System.Web.UI.IPostBackEventHandler,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (sourceControl As IPostBackEventHandler, eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::Web::UI::IPostBackEventHandler ^ sourceControl, System::String ^ eventArgument);" />
      <MemberSignature Language="F#" Value="abstract member RaisePostBackEvent : System.Web.UI.IPostBackEventHandler * string -&gt; unit&#xA;override this.RaisePostBackEvent : System.Web.UI.IPostBackEventHandler * string -&gt; unit" Usage="page.RaisePostBackEvent (sourceControl, eventArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceControl" Type="System.Web.UI.IPostBackEventHandler" />
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceControl">Серверный элемент управления ASP.NET, вызвавший обратную передачу. Этот элемент управления должен реализовывать интерфейс <see cref="T:System.Web.UI.IPostBackEventHandler" />.</param>
        <param name="eventArgument">Аргумент обратного запроса.</param>
        <summary>Оповещает серверный элемент управления, вызвавший обратный запрос, о необходимости обработки входящего события обратной передачи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page> Вызывает <xref:System.Web.UI.Page.RaisePostBackEvent%2A> метод при обратной передаче. Этот вызов происходит в жизненном цикле страницы после уведомления о загрузке и изменении, но до подготовки к отображению.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Web.UI.Page.RaisePostBackEvent%2A> метод для уведомления ASP.NET о том, что события обратного возникает, когда пользовательский `userButton` нажатии элемента управления сервера.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Общие сведения о жизненном цикле страницы ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3">Модель события ASP.NET серверного элемента управления</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="page.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterArrayDeclaration(string arrayName, string arrayValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Имя массива для объявления значения.</param>
        <param name="arrayValue">Значение, помещаемое в массив.</param>
        <summary>Объявляет значение, определяемое как массив ECMAScript при отображении страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может использоваться элементами управления на основе сценария для объявления их в массиве, чтобы библиотека клиентских сценариев можно работать со всеми элементами того же типа.  
  
 Метод <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> не рекомендуется к использованию. Используйте <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> метод в <xref:System.Web.UI.ClientScriptManager> класса.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> метод, чтобы объявить массив, `myArray`, содержащий три объекта с именем `x`, `y`, и `z`. В примере определяется и регистрирует скрипт запуска с помощью <xref:System.Web.UI.Page.RegisterStartupScript%2A> метод. Когда ECMAScript `doClick` функция вызывается из страницы, содержащей этот код, инициализируются массива и его объектов.  
  
 [!code-csharp[Page_RegisterArrayDeclaration#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/CS/page_registerarraydeclaration.cs.aspx#1)]
 [!code-vb[Page_RegisterArrayDeclaration#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/VB/page_registerarraydeclaration.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncTask">
      <MemberSignature Language="C#" Value="public void RegisterAsyncTask (System.Web.UI.PageAsyncTask task);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterAsyncTask(class System.Web.UI.PageAsyncTask task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAsyncTask (task As PageAsyncTask)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAsyncTask(System::Web::UI::PageAsyncTask ^ task);" />
      <MemberSignature Language="F#" Value="member this.RegisterAsyncTask : System.Web.UI.PageAsyncTask -&gt; unit" Usage="page.RegisterAsyncTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Web.UI.PageAsyncTask" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="task">Объект <see cref="T:System.Web.UI.PageAsyncTask" />, определяющий асинхронную задачу.</param>
        <summary>Регистрирует новую асинхронную задачу со страницей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Определение асинхронную задачу с помощью <xref:System.Web.UI.PageAsyncTask> класса. При определении задачи, используйте <xref:System.Web.UI.Page.RegisterAsyncTask%2A> метод, чтобы зарегистрировать задачу со страницей. После регистрации задачи, вызвать <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> метод для начала асинхронной задачи.  
  
 <xref:System.Web.UI.Page.RegisterAsyncTask%2A> Метод может использоваться с синхронные и асинхронные страницы.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.Page.AsyncTimeout%2A> свойство с <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> и <xref:System.Web.UI.Page.RegisterAsyncTask%2A> методы. Обратите внимание на использование обработчиков начала, окончания и время ожидания. В примере вводится искусственная задержка для демонстрации ситуации асинхронной задачи, превышающей отведенное время для задачи, как указано в <xref:System.Web.UI.Page.AsyncTimeout%2A> свойство. В реальной ситуации асинхронная задача может использоваться для выполнения вызовов базы данных или создание образов, например, и обработчик времени ожидания предоставляет постепенного ухудшения качества обслуживания, если задача не выполняется в течение указанного промежутка времени.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Асинхронная задача равна <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public virtual void RegisterClientScriptBlock (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterClientScriptBlock(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterClientScriptBlock (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterClientScriptBlock(System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScriptBlock : string * string -&gt; unit&#xA;override this.RegisterClientScriptBlock : string * string -&gt; unit" Usage="page.RegisterClientScriptBlock (key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterClientScriptBlock(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный ключ, определяющий блок скрипта.</param>
        <param name="script">Содержимое скрипта, отправляемое клиенту.</param>
        <summary>Выпускает клиентские блоки скриптов в качестве ответа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентский скрипт создается сразу после открывающего тега <xref:System.Web.UI.Page> объекта `<form runat= server>` элемент. Не забудьте включить открывающий и закрывающий `<script>` элементы вокруг скрипт блокировки строки, указанной в `script` параметра.  
  
 Так как этот метод использует ключ для идентификации блока, блок скрипта не имеет для добавления в выходной поток каждый раз, когда он запрашивается экземпляр элемента управления другой сервер. Также с помощью ключа сокращается вероятность блоки скриптов различных элементов управления, которые конфликтуют друг с другом.  
  
 Любой скрипт блоки с тем же `key` считаются повторяющимися, значения параметров.  
  
> [!NOTE]
>  Не забудьте включить комментарий HTML-теги сценария, чтобы он не отображался, если запрашивающий браузер не поддерживает выполнение скриптов.  
  
 Метод <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> не рекомендуется к использованию. Вместо него следует использовать метод <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> класса <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> в сочетании с <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> метод. Если ECMAScript в блоке кода объявление не уже был зарегистрирован, что определяется <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> вызов.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public virtual void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="abstract member RegisterHiddenField : string * string -&gt; unit&#xA;override this.RegisterHiddenField : string * string -&gt; unit" Usage="page.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Уникальное имя отображаемого скрытого поля.</param>
        <param name="hiddenFieldInitialValue">Значение, порождаемое в скрытой форме.</param>
        <summary>Позволяет серверным элементам управления автоматически регистрировать скрытое поле на форме. Поле будет отправлено объекту <see cref="T:System.Web.UI.Page" /> при отображении серверного элемента управления <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Web.UI.Page.RegisterHiddenField%2A> не рекомендуется к использованию. Используйте <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> метод в <xref:System.Web.UI.ClientScriptManager> класса.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.UI.Page.RegisterHiddenField%2A> метод для создания кода ECMAScript, который передает браузеру. Присвоено имя скрытого поля `myHiddenField` и его значение установлено в «Добро пожаловать в Microsoft!» <xref:System.Web.UI.Page.RegisterStartupScript%2A> Вызовы методов `myHiddenField` значение, когда пользователь нажимает кнопку на странице.  
  
> [!IMPORTANT]
>  В этом примере имеет скрытое поле, которое представляет угрозу безопасности. По умолчанию следует проверить значение скрытого поля, как это делается, чтобы значение текстового поля. Веб-страницы ASP.NET проверять ввод пользователя на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#1)]
 [!code-vb[Page_RegisterHiddenField#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterOnSubmitStatement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterOnSubmitStatement (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : string * string -&gt; unit" Usage="page.RegisterOnSubmitStatement (key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterOnSubmitStatement(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный ключ, определяющий блок скрипта.</param>
        <param name="script">Клиентский скрипт, отправляемый клиенту.</param>
        <summary>Предоставляет странице доступ к клиентскому событию <see langword="OnSubmit" />. Скрипт должен являться обращением функции к клиентскому коду, зарегистрированному в другом месте.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> не рекомендуется к использованию. Используйте <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метод в <xref:System.Web.UI.ClientScriptManager> класса.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> для доступа к скрипт, который реагирует при нажатии кнопки отправки на стороне клиента. При возникновении этого события, зарегистрированный код ECMAScript выполняется на стороне клиента.  
  
> [!IMPORTANT]
>  В этом примере имеет скрытое поле, которое представляет угрозу безопасности. По умолчанию следует проверить значение скрытого поля, как это делается, чтобы значение текстового поля. Веб-страницы ASP.NET проверять ввод пользователя на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#2)]
 [!code-vb[Page_RegisterHiddenField#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void RegisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.RegisterRequiresControlState : System.Web.UI.Control -&gt; unit" Usage="page.RegisterRequiresControlState control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">Регистрируемый элемент управления.</param>
        <summary>Регистрирует элемент управления, как элемент управления с сохраняемым состоянием.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пользовательских серверных элементов управления, использующие состояние элемента управления необходимо вызвать <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> метод для каждого запроса, так как регистрация состояния элемента управления не переносится из запроса к запросу во время события обратной передачи. Рекомендуется возникновения регистрации в <xref:System.Web.UI.Control.Init> событий.  
  
   
  
## Examples  
 В следующем примере кода показано, вызывающую пользовательский сервер управления <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> метод.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Регистрируемый элемент управления имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" /> может вызываться только до или во время события <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresPostBack">
      <MemberSignature Language="C#" Value="public void RegisterRequiresPostBack (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresPostBack(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresPostBack(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.RegisterRequiresPostBack : System.Web.UI.Control -&gt; unit" Usage="page.RegisterRequiresPostBack control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Регистрируемый элемент управления.</param>
        <summary>Регистрирует элемент управления, как элемент требующий обработки обратной передачи, когда страница передается обратно на сервер.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Регистрируемый элемент управления должен реализовывать <xref:System.Web.UI.IPostBackDataHandler> интерфейс или <xref:System.Web.HttpException> возникает. При реализации каким-элемент управления <xref:System.Web.UI.IPostBackDataHandler> интерфейс позволяет обработка данных обратной передачи и вызов любой запрос POST вновь события изменения данных. Дополнительные сведения о модели событий серверных элементов управления, см. в разделе [модель событий серверного элемента управления ASP.NET Web Forms](https://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3).  
  
 Регистрация элементов управления со страницей во время или до `Page_PreRender` события жизненного цикла страницы.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.UI.Page.RegisterRequiresPostBack%2A> метод требуется элемент управления текстовым полем `myTextBox`, будет передан обратно, перед выполнением любого кода, связанного с текстовым полем. <xref:System.Web.UI.WebControls.TextBox> элементы управления реализуют <xref:System.Web.UI.IPostBackDataHandler> интерфейс.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterRequiresPostBack#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/CS/page_registerrequirespostback.cs.aspx#1)]
 [!code-vb[Page_RegisterRequiresPostBack#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/VB/page_registerrequirespostback.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Регистрируемый элемент управления не реализует интерфейс <see cref="T:System.Web.UI.IPostBackDataHandler" />.</exception>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Общие сведения о жизненном цикле страницы ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3">Модель события ASP.NET серверного элемента управления</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresRaiseEvent">
      <MemberSignature Language="C#" Value="public virtual void RegisterRequiresRaiseEvent (System.Web.UI.IPostBackEventHandler control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterRequiresRaiseEvent(class System.Web.UI.IPostBackEventHandler control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresRaiseEvent(System.Web.UI.IPostBackEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterRequiresRaiseEvent (control As IPostBackEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterRequiresRaiseEvent(System::Web::UI::IPostBackEventHandler ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterRequiresRaiseEvent : System.Web.UI.IPostBackEventHandler -&gt; unit&#xA;override this.RegisterRequiresRaiseEvent : System.Web.UI.IPostBackEventHandler -&gt; unit" Usage="page.RegisterRequiresRaiseEvent control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.IPostBackEventHandler" />
      </Parameters>
      <Docs>
        <param name="control">Регистрируемый элемент управления.</param>
        <summary>Регистрирует серверный элемент управления ASP.NET, как требующий возникновения события при его обработке в объекте <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для каждого запроса страницы может быть зарегистрирован только один сервер управления. <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> Необходимо использовать, когда элемент управления не поддерживает идентификатор в форме post данных элемента управления. Кроме того, необходимо реализовать элемент управления, который зарегистрирован <xref:System.Web.UI.IPostBackEventHandler> интерфейс.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> метод, чтобы зарегистрировать <xref:System.Web.UI.WebControls.Button> веб-серверного элемента управления как требующий возникновения события. После регистрации первого <xref:System.Web.UI.WebControls.Button> элемента управления, может привести к второй <xref:System.Web.UI.WebControls.Button> элемента управления, объявленный в коде для учета результатов первой кнопки щелкните событие на страницу.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresViewStateEncryption">
      <MemberSignature Language="C#" Value="public void RegisterRequiresViewStateEncryption ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresViewStateEncryption() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterRequiresViewStateEncryption ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresViewStateEncryption();" />
      <MemberSignature Language="F#" Value="member this.RegisterRequiresViewStateEncryption : unit -&gt; unit" Usage="page.RegisterRequiresViewStateEncryption " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Регистрирует элемент управления со страницей, как требующий состояния элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы разрабатываете пользовательский элемент управления, который работает с потенциально конфиденциальная информация, вызовите <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A> метод для регистрации элемента управления на странице, причем состояние представления для элемента управления шифруется.  
  
 Состояние всей страницы будут оставаться нешифрованными, если <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> присваивается <xref:System.Web.UI.ViewStateEncryptionMode.Auto> или <xref:System.Web.UI.ViewStateEncryptionMode.Always>.  
  
   
  
## Examples  
 В следующем примере кода показано задание режим шифрования состояния представления для <xref:System.Web.UI.Page> объекта и включен запрос шифрования состояния представления через <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A>. В этом примере состояние представления будет шифроваться, если информация о заказчике извлекается из базы данных.  
  
 [!code-aspx-csharp[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/CS/encryptViewState.cs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/VB/encryptViewState.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" /> должен вызываться до или во время этапа <see langword="PreRender" /> жизненного цикла страницы.</exception>
        <altmember cref="P:System.Web.UI.Page.ViewStateEncryptionMode" />
        <altmember cref="T:System.Web.UI.WebControls.GridView" />
        <altmember cref="T:System.Web.UI.WebControls.DetailsView" />
        <altmember cref="T:System.Web.UI.WebControls.FormView" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public virtual void RegisterStartupScript (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterStartupScript(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterStartupScript (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterStartupScript(System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="abstract member RegisterStartupScript : string * string -&gt; unit&#xA;override this.RegisterStartupScript : string * string -&gt; unit" Usage="page.RegisterStartupScript (key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterStartupScript(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный ключ, определяющий блок скрипта.</param>
        <param name="script">Содержимое скрипта, отправляемое клиенту.</param>
        <summary>Порождает клиентские блоки скриптов в качестве реакции страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Аналогичную <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> метод, <xref:System.Web.UI.Page.RegisterStartupScript%2A> метод выдает сценарий непосредственно перед закрывающим тегом <xref:System.Web.UI.Page> объекта `<form runat= server>` элемент. Не забудьте включить открывающий и закрывающий `<script>` элементы вокруг скрипт блокировки строки, указанной в `script` параметра.  
  
 Так как этот метод использует ключ для идентификации блока, блок скрипта не имеет для добавления в выходной поток каждый раз, когда он запрашивается экземпляр элемента управления другой сервер  
  
 Любой скрипт блоки с тем же `key` считаются повторяющимися, значения параметров.  
  
> [!NOTE]
>  Не забудьте включить комментарий HTML-теги сценария, чтобы он не отображался, если запрашивающий браузер не поддерживает выполнение скриптов.  
  
 Метод <xref:System.Web.UI.Page.RegisterStartupScript%2A> не рекомендуется к использованию. Вместо него следует использовать метод <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> класса <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Web.UI.Page.RegisterStartupScript%2A> в сочетании с <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> метод. Если ECMAScript, записанных в блоке кода объявление не уже был зарегистрирован, что определяется <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> метод, а затем <xref:System.Web.UI.Page.RegisterStartupScript%2A> вызов.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterViewStateHandler">
      <MemberSignature Language="C#" Value="public void RegisterViewStateHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterViewStateHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterViewStateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterViewStateHandler ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterViewStateHandler();" />
      <MemberSignature Language="F#" Value="member this.RegisterViewStateHandler : unit -&gt; unit" Usage="page.RegisterViewStateHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает сохранение состояния отображения страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.RegisterViewStateHandler%2A> Метод автоматически вызывается через <xref:System.Web.UI.HtmlControls.HtmlForm> серверного элемента управления. Если этот метод не вызывается, состояние представления страницы не будут сохранены.  
  
> [!NOTE]
>  Как правило только <xref:System.Web.UI.HtmlControls.HtmlForm> серверного элемента управления для страницы вызывает этот метод.  
  
   
  
## Examples  
 [!code-csharp[Page_RegisterViewStateHandler#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterViewStateHandler/CS/page_registerviewstatehandler.cs#1)]
 [!code-vb[Page_RegisterViewStateHandler#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterViewStateHandler/VB/page_registerviewstatehandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="page.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" />, получающий содержимое страницы.</param>
        <summary>Инициализирует объект <see cref="T:System.Web.UI.HtmlTextWriter" /> и вызывает дочерние элементы управления страницы <see cref="T:System.Web.UI.Page" /> для отображения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Render%2A> Метод отвечает за создание текст и разметку, которая отправляется в браузер клиента. Значение по умолчанию <xref:System.Web.UI.Page.Render%2A> вызовы методов <xref:System.Web.UI.Control.RenderChildren%2A> для записи текста и разметки для элементов управления, содержащихся на странице.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.UI.Page.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.HttpRequest" /> для запрашиваемой страницы.</summary>
        <value>Текущий объект <see cref="T:System.Web.HttpRequest" />, связанный со страницей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Web.HttpRequest> содержит сведения о текущем HTTP-запросе.  
  
   
  
## Examples  
 В следующем примере демонстрируется получение <xref:System.Web.HttpRequest.Headers%2A> коллекции из <xref:System.Web.HttpRequest> объекта и записи их на странице ASP.NET.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Происходит, когда объект <see cref="T:System.Web.HttpRequest" /> недоступен.</exception>
        <altmember cref="T:System.Web.HttpException" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="RequiresControlState">
      <MemberSignature Language="C#" Value="public bool RequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.RequiresControlState : System.Web.UI.Control -&gt; bool" Usage="page.RequiresControlState control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">Элемент управления <see cref="T:System.Web.UI.Control" /> для проверки требования состояния элемента управления.</param>
        <summary>Определяет, зарегистрирован ли указанный объект <see cref="T:System.Web.UI.Control" /> для участия в управлении состоянием элемента управления.</summary>
        <returns><see langword="true" />, если указанный элемент управления <see cref="T:System.Web.UI.Control" /> требует использования состояния элемента управления; в противном случае ─ <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Состояние элемента управления — это объект, состоящий из важные данные состояния представления, которые веб-сервера управления должно функционировать; он содержится в отдельном объекте из состояния в обычном режиме.  
  
 Пользовательские элементы управления, используя состояние элемента управления необходимо вызвать <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> метод перед сохранением состояния элемента управления. Используйте <xref:System.Web.UI.Page.RequiresControlState%2A> метод для проверки для элементов управления, которые зарегистрированы в странице, как требующий состояния элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.PageStatePersister.ControlState" />
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.UI.Page.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.HttpResponse" />, связанный с объектом <see cref="T:System.Web.UI.Page" />. Этот объект позволяет отправлять клиенту данные HTTP-ответа и содержит сведения об этом ответе.</summary>
        <value>Текущий объект <see cref="T:System.Web.HttpResponse" />, связанный со страницей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано создание файла cookie и добавление его в выходные данные НТТР страницы с помощью <xref:System.Web.HttpResponse> объекта.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Объект <see cref="T:System.Web.HttpResponse" /> недоступен.</exception>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="ResponseEncoding">
      <MemberSignature Language="C#" Value="public string ResponseEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResponseEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ResponseEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ResponseEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseEncoding : string with get, set" Usage="System.Web.UI.Page.ResponseEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает язык шифрования для текущего объекта <see cref="T:System.Web.HttpResponse" />.</summary>
        <value>Строка, содержащая язык шифрования для текущего объекта <see cref="T:System.Web.HttpResponse" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задайте `ResponseEncoding` равным значению, используя директиву в файле .aspx. При запросе страницы, динамически создаваемого класса задает свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData RouteData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteData RouteData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.RouteData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RouteData As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteData ^ RouteData { System::Web::Routing::RouteData ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RouteData : System.Web.Routing.RouteData" Usage="System.Web.UI.Page.RouteData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение свойства <see cref="P:System.Web.Routing.RequestContext.RouteData" /> текущего экземпляра <see cref="T:System.Web.Routing.RequestContext" />.</summary>
        <value>Значение свойства <see cref="P:System.Web.Routing.RequestContext.RouteData" /> текущего экземпляра <see cref="T:System.Web.Routing.RequestContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если страница выполняется в ответ на запрос, сделанный через маршрутизацию ASP.NET, это свойство предоставляет доступ к значениям параметров URL-адреса, которые были переданы в качестве данных маршрута. Если страница выполняется в ответ на физический URL-адрес вместо URL-адрес маршрута, это свойство имеет `null`. В следующем примере показано, как для извлечения значения параметра URL-адрес, который называется `year`.  
  
```vb  
Dim year As Integer = Convert.ToInt32(Page.RouteData.Values("year"))  
```  
  
```csharp  
int year = Convert.ToInt32(Page.RouteData.Values["year"])  
```  
  
 Если маршрут определяется в формате URL-адрес `{locale}/{year}` для домена `contoso.com`, и если запрошенный URL-адрес `contoso.com/US/2010`, `year` будет содержать значение «2010» при выполнении этого кода.  
  
 Дополнительные сведения о маршрутизации ASP.NET см. в разделе [маршрутизация ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Routing.RequestContext.RouteData" />
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/dc88e6ba-470c-4b20-b644-35874cfd781d">Практическое руководство. Параметры доступа к URL-адреса в маршрутизируемой странице</related>
      </Docs>
    </Member>
    <Member MemberName="SavePageStateToPersistenceMedium">
      <MemberSignature Language="C#" Value="protected virtual void SavePageStateToPersistenceMedium (object viewState);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePageStateToPersistenceMedium(object viewState) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SavePageStateToPersistenceMedium (viewState As Object)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SavePageStateToPersistenceMedium(System::Object ^ viewState);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member SavePageStateToPersistenceMedium : obj -&gt; unit&#xA;override this.SavePageStateToPersistenceMedium : obj -&gt; unit" Usage="page.SavePageStateToPersistenceMedium viewState" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="C#" Value="protected internal virtual void SavePageStateToPersistenceMedium (object state);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SavePageStateToPersistenceMedium(object state) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub SavePageStateToPersistenceMedium (state As Object)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void SavePageStateToPersistenceMedium(System::Object ^ state);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member SavePageStateToPersistenceMedium : obj -&gt; unit&#xA;override this.SavePageStateToPersistenceMedium : obj -&gt; unit" Usage="page.SavePageStateToPersistenceMedium state" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" FrameworkAlternate="netframework-2.0;netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="viewState" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="state" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state">Объект <see cref="T:System.Object" /> для сохранения сведений о состоянии просмотра.</param>
        <param name="viewState">Объект <see cref="T:System.Object" /> для сохранения сведений о состоянии просмотра.</param>
        <summary>Сохраняет любые сведения о состоянии представления и информации о состоянии элемента управления страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> Использует метод <xref:System.Web.UI.PageStatePersister.Save%2A> метод <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> объект, упоминаемый в <xref:System.Web.UI.Page.PageStatePersister%2A> свойство для хранения сведений о состоянии представления и состояние элемента управления для страницы.  
  
 ASP.NET включает две подчиненные элементы <xref:System.Web.UI.PageStatePersister> класс, <xref:System.Web.UI.HiddenFieldPageStatePersister> класс, который сохраняет сведения о состоянии в скрытом поле включено в страницу ASP.NET, и <xref:System.Web.UI.SessionPageStatePersister> класс, который сохраняет состояние в <xref:System.Web.UI.Page.Session%2A> объект, связанный с запрос. Обратите внимание, что при использовании <xref:System.Web.UI.SessionPageStatePersister> класс по-прежнему отображается скрытое поле состояния ПРЕДСТАВЛЕНИЯ, как это используется для определения обратной передачи.  
  
 Для сохранения состояния в расположении по своему усмотрению, необходимо создать новый потомком <xref:System.Web.UI.PageStatePersister> класс, который сохраняет и загружает состояние на постоянном носителе по своему усмотрению. Пример создания нового <xref:System.Web.UI.PageStatePersister> объекта, см. в разделе <xref:System.Web.UI.PageStatePersister> класса.  
  
 Если вы используете .NET Framework версии 1.0 или 1.1, переопределите этот метод, если вы хотите сохранить <xref:System.Web.UI.Page> состоянию ничего, кроме скрытого поля. Если вы решили сделать это, необходимо также переопределить <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="SaveStateComplete">
      <MemberSignature Language="C#" Value="public event EventHandler SaveStateComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SaveStateComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.SaveStateComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SaveStateComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SaveStateComplete;" />
      <MemberSignature Language="F#" Value="member this.SaveStateComplete : EventHandler " Usage="member this.SaveStateComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после того, как страница завершила сохранение всех данных о состоянии представления и состоянии элементов управления для страницы и элементов управления на ней.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения о состоянии для элементов управления на веб-странице сохраняется после <xref:System.Web.UI.Page.PreRenderComplete> событий. <xref:System.Web.UI.Page.SaveStateComplete> Событие вызывается после состояния представления и состояние элемента управления страницы и элементы управления страницы, сохраняются на постоянном носителе.  
  
 Это последнее событие, возникающее перед переходом к просмотру страницы браузеру.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Общие сведения о жизненном цикле страницы ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc">Общие сведения о состоянии сеанса</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.UI.Page.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see langword="Server" />, являющийся экземпляром класса <see cref="T:System.Web.HttpServerUtility" />.</summary>
        <value>Текущий объект <see langword="Server" />, связанный со страницей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет доступ к часто используемым <xref:System.Web.HttpServerUtility.HtmlEncode%2A> и <xref:System.Web.HttpServerUtility.MapPath%2A> методы, помимо прочего.  
  
   
  
## Examples  
 В следующем примере кода показано, как получить доступ к сведения об ошибке с сервера с помощью `Server` объекта. В частности, в примере показано получение запрошенного URL-адреса из `Request` объект, из последней ошибке `Server` объекта (с помощью <xref:System.Web.HttpServerUtility.GetLastError%2A> метод) и преобразует их в строки, которые могут отображаться с помощью клиента. Один раз `message` переменной записывается на клиент, ошибка удаляется с помощью <xref:System.Web.HttpServerUtility.ClearError%2A> метод.  
  
 [!code-csharp[System.Web.UI.Page_Error method#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Error method/CS/sourcecs.aspx#1)]
 [!code-vb[System.Web.UI.Page_Error method#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Error method/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpServerUtility" />
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public virtual System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Session" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.UI.Page.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущий объект <see langword="Session" />, предоставленный ASP.NET.</summary>
        <value>Текущие данные о состоянии сеанса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет сведения о сеансе текущего запроса. Объект `Session` объект сохраняется для каждого пользователя, запрашивающего страницу или документ из приложения ASP.NET. Переменные хранятся в `Session` объекта, не удаляются, когда пользователь перемещает между страницами в приложении; вместо этого они сохраняются до тех пор, пока пользователь получает доступ к страницам приложения. Дополнительные сведения о состоянии сеанса см. в разделе [ASP.NET Session State Overview](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 В следующем примере кода создается `GetStyle` функция, извлекающая ключ, сохраненный в состоянии сеанса, страницы веб-форм и преобразует его значение в строку.  
  
 [!code-csharp[Page.Session_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Session_Samples1/CS/sessioncs.aspx#1)]
 [!code-vb[Page.Session_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Session_Samples1/VB/sessionvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Происходит, когда сведения о сеансе установлены в значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.HttpException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Устанавливает фокус ввода браузера на указанном элементе управления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : string -&gt; unit" Usage="page.SetFocus clientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="clientID">Идентификатор элемента управления, получающего фокус.</param>
        <summary>Устанавливает фокус браузера на элементе управления, с указанным идентификатором.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.SetFocus%2A> метод, чтобы сделать элемент управления с указанным Идентификатором строка активный элемент управления на веб-странице, отображаемый в браузере. <xref:System.Web.UI.Page.SetFocus%2A> Метод должен вызываться перед страницы подготавливается для подготовки к просмотру клиенту в <xref:System.Web.UI.Control.PreRender> событий.  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.SetFocus%2A> Метод будет работать только в браузерах, поддерживающих ECMAScript версии 1.3 или более поздней версии.  
  
   
  
## Examples  
 В следующем примере кода устанавливает фокус на второе текстовое поле на веб-странице.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbyidcs.aspx#1)]
 [!code-aspx-vb[PageSetFocus#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbyidvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="clientID" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> вызывается, когда элемент управления не является частью страницы веб-формы.  
  
-или- 
 Метод <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> вызывается после события <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : System.Web.UI.Control -&gt; unit" Usage="page.SetFocus control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">Элемент управления, получающий фокус ввода.</param>
        <summary>Устанавливает фокус ввода браузера на указанном элементе управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.SetFocus%2A> метод, чтобы указанный элемент управления активным элементом управления на веб-странице, отображаемый в браузере. <xref:System.Web.UI.Page.SetFocus%2A> Метод должен вызываться перед страницы подготавливается для подготовки к просмотру клиенту в <xref:System.Web.UI.Control.PreRender> событий.  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.SetFocus%2A> Метод будет работать только в браузерах, поддерживающих ECMAScript версии 1.3 или более поздней версии.  
  
   
  
## Examples  
 В следующем примере кода устанавливает фокус на второе текстовое поле на веб-странице.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#2](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbycontrolcs.aspx#2)]
 [!code-aspx-vb[PageSetFocus#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbycontrolvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> вызывается, когда элемент управления не является частью страницы веб-формы.  
  
-или- 
 Метод <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> вызывается после события <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipFormActionValidation">
      <MemberSignature Language="C#" Value="public bool SkipFormActionValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipFormActionValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SkipFormActionValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipFormActionValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipFormActionValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipFormActionValidation : bool with get, set" Usage="System.Web.UI.Page.SkipFormActionValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, проверяется ли значение строки запроса.</summary>
        <value>Значение <see langword="true" />, если проверка строки запроса должна быть пропущена (строка запроса не должна проверяться); в противном случае — значение <see langword="false" />, если проверка строки запроса должна производится обычным образом. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SmartNavigation">
      <MemberSignature Language="C#" Value="public bool SmartNavigation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SmartNavigation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SmartNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Property SmartNavigation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SmartNavigation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SmartNavigation : bool with get, set" Usage="System.Web.UI.Page.SmartNavigation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is Page.SetFocus and Page.MaintainScrollPositionOnPostBack. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, включена ли интеллектуальная навигация. Это свойство использовать не рекомендуется.</summary>
        <value><see langword="true" />, если навигация включена. В противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задайте `SmartNavigation` атрибут `true` директивы в файле .aspx. При запросе страницы, динамически создаваемого класса этому свойству.  
  
> [!NOTE]
>  В ASP.NET версии 2.0 <xref:System.Web.UI.Page.SmartNavigation%2A> свойство является устаревшим. Используйте <xref:System.Web.UI.Page.SetFocus%2A> метод и <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> свойство вместо этого.  
  
 При запросе страницы обозревателя Microsoft Internet Explorer 5.5 или более поздней версии, смарт-навигации улучшает взаимодействие с пользователем страницы, выполнив следующее:  
  
-   Устраняя флэш-памяти, из-за переходов.  
  
-   Сохранение позиции прокрутки, при перемещении между страницами.  
  
-   Сохранение фокус элемента между переходами.  
  
-   Сохраняется только состояние последней страницы в журнале браузера.  
  
 Интеллектуальная Навигация лучше всего подходит для страниц ASP.NET, требующих частых обратных передач, но визуальным содержимым, которые значительно изменяются при возврате. Следует внимательно решите, следует ли этому свойству значение `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.Page.SetFocus" />
        <altmember cref="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      </Docs>
    </Member>
    <Member MemberName="StyleSheetTheme">
      <MemberSignature Language="C#" Value="public virtual string StyleSheetTheme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StyleSheetTheme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.StyleSheetTheme" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property StyleSheetTheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StyleSheetTheme { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StyleSheetTheme : string with get, set" Usage="System.Web.UI.Page.StyleSheetTheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя темы, применяемой к странице на ранних этапах жизненного цикла страницы.</summary>
        <value>Имя темы, применяемой к странице на ранних этапах жизненного цикла страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство не ссылается непосредственно на таблицы каскадных стилей (CSS). Свойство содержит имя темы ASP.NET, который может включать файлы CSS в нем.  
  
 <xref:System.Web.UI.Page.StyleSheetTheme%2A> Свойство задает имя темы, которая применяется к странице на ранних этапах жизненного цикла страницы, тогда как <xref:System.Web.UI.Page.Theme%2A> свойство задает имя темы, применяемой к странице позже в жизненном цикле страницы. Это означает, что параметры на странице имеют приоритет над параметрами в темы таблицы стилей. Дополнительные сведения см. в разделе [тем и оформлений ASP.NET](https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 Обычно в директиве page или путем переопределения свойства задать значение для этого свойства. Сведения см. в следующих разделах:  
  
-   [Практическое руководство. Применение тем ASP.NET](https://msdn.microsoft.com/library/f9d72364-4d77-4b73-84be-7630dc63e0fe(v=vs.100))  
  
-   [Практическое руководство. Применение тем ASP.NET программными средствами](https://msdn.microsoft.com/library/02eed7c3-01e8-4e20-8358-df47dbd4f148))  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Предпринята попытка установить свойство <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> после вызова метода <see cref="M:System.Web.UI.Page.FrameworkInitialize" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> задано недействительное имя темы. Это исключение создается, когда вызывается метод <see cref="M:System.Web.UI.Page.FrameworkInitialize" />, а не метод задания свойства.</exception>
        <altmember cref="P:System.Web.UI.Page.Theme" />
        <related type="Article" href="https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3">ASP.NET темы и обложки</related>
      </Docs>
    </Member>
    <Member MemberName="Theme">
      <MemberSignature Language="C#" Value="public virtual string Theme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Theme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Theme" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Theme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Theme { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Theme : string with get, set" Usage="System.Web.UI.Page.Theme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает тему страницы.</summary>
        <value>Имя темы страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Theme%2A> Свойство задает имя темы страницы. Если параметры на странице имеют приоритет над параметрами в теме, используйте <xref:System.Web.UI.Page.StyleSheetTheme%2A> свойство. Дополнительные сведения см. в разделе [тем и оформлений ASP.NET](https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 <xref:System.Web.UI.Page.Theme%2A> Свойство должно иметь значение до <xref:System.Web.UI.Page.PreInit> событий; параметра <xref:System.Web.UI.Page.Theme%2A> свойства после <xref:System.Web.UI.Page.PreInit> вызовет событие <xref:System.InvalidOperationException> исключение.  
  
 Указанную тему должен существовать в качестве приложения или глобальной темы. Если темы не существует, <xref:System.Web.HttpException> возникает исключение.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Web.UI.Page.Theme%2A> свойство с именем, переданное в строке запроса.  
  
 [!code-csharp[PageTheme#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageTheme/CS/pagethemecs.aspx#1)]
 [!code-vb[PageTheme#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageTheme/VB/pagethemevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Была предпринята попытка установить свойство <see cref="P:System.Web.UI.Page.Theme" /> после того, как произошло событие <see cref="E:System.Web.UI.Page.PreInit" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see cref="P:System.Web.UI.Page.Theme" /> задано недействительное имя темы.</exception>
        <altmember cref="P:System.Web.UI.Page.StyleSheetTheme" />
        <related type="Article" href="https://msdn.microsoft.com/library/02eed7c3-01e8-4e20-8358-df47dbd4f148">Применение тем ASP.NET программными средствами</related>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Web.UI.Page.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка заголовка страницы.</summary>
        <value>Заголовок страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.UI.Page.Title%2A> свойство, чтобы задать заголовок страницы в заголовке HTML, который отправляется браузеру.  
  
> [!NOTE]
>  Страница должна содержать `head` элемент, имеющий атрибут `runat="server"`, в противном случае заголовок не будет отображаться.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Web.UI.Page.Title" /> требует на странице элемент управления заголовком.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlTitle" />
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.UI.Page.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.TraceContext" /> для текущего веб-запроса.</summary>
        <value>Данные из объекта <see cref="T:System.Web.TraceContext" /> для текущего веб-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Трассировка отслеживает и представляет подробности выполнения веб-запроса. Для трассировки данных должен отображаться на отображаемой странице необходимо включить трассировку на уровне страницы или приложения.  
  
 Трассировка на странице отключена по умолчанию. Чтобы включить трассировку для страницы, использующие директиву `<% @ Page trace="true" %>`. Чтобы включить трассировку для всего приложения, необходимо включить его в файле конфигурации приложения Web.config, который находится в корневом каталоге приложения. Дополнительные сведения см. в разделе [Обзор трассировки ASP.NET](https://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416).  
  
   
  
## Examples  
 В следующем примере кода показано обращение к <xref:System.Web.TraceContext.IsEnabled%2A?displayProperty=nameWithType> свойство и <xref:System.Web.TraceContext.Write%2A?displayProperty=nameWithType> метод с помощью <xref:System.Web.UI.Page.Trace%2A> свойство. Этот код вызывает <xref:System.Diagnostics.Trace.Write%2A> метод только в том случае, если трассировка включена для <xref:System.Web.UI.Page> объекта. Если не включена, этот код не запустится, которые могут помочь сократить расходы на для вашего приложения.  
  
 [!code-csharp[System.Web.UI.Page.Trace#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Trace/CS/trace1cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Trace#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Trace/VB/trace1vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.TraceContext" />
        <related type="Article" href="https://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416">Общие сведения о трассировке ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="TraceEnabled">
      <MemberSignature Language="C#" Value="public bool TraceEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TraceEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property TraceEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TraceEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TraceEnabled : bool with get, set" Usage="System.Web.UI.Page.TraceEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает значение, указывающее, разрешена ли трассировка для объекта <see cref="T:System.Web.UI.Page" />.</summary>
        <value>Указывает, включена ли трассировка. Если трассировка включена, используется значение <see langword="true" />; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задайте `Trace` атрибут `true` директивы в файле .aspx. При запросе страницы, динамически создаваемого класса задает свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceModeValue" />
        <altmember cref="T:System.Web.TraceContext" />
        <related type="Article" href="https://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416">Общие сведения о трассировке ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="TraceModeValue">
      <MemberSignature Language="C#" Value="public System.Web.TraceMode TraceModeValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.TraceMode TraceModeValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceModeValue" />
      <MemberSignature Language="VB.NET" Value="Public Property TraceModeValue As TraceMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceMode TraceModeValue { System::Web::TraceMode get(); void set(System::Web::TraceMode value); };" />
      <MemberSignature Language="F#" Value="member this.TraceModeValue : System.Web.TraceMode with get, set" Usage="System.Web.UI.Page.TraceModeValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает режим отображения операторов трассировке на странице.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Web.TraceMode" /> элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задайте `TraceMode` атрибут директивы в файле .aspx. При запросе страницы, динамически создаваемого класса задает свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceEnabled" />
        <altmember cref="T:System.Web.TraceContext" />
        <related type="Article" href="https://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416">Общие сведения о трассировке ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="TransactionMode">
      <MemberSignature Language="C#" Value="protected int TransactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TransactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TransactionMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property TransactionMode As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int TransactionMode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionMode : int with get, set" Usage="System.Web.UI.Page.TransactionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает уровень поддержки транзакций на странице.</summary>
        <value>Целое число, представляющее один из элементов перечисления <see cref="T:System.EnterpriseServices.TransactionOption" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев это свойство не задано в коде. Задайте `Transaction` атрибут директивы в файле .aspx. При запросе страницы, динамически создаваемого класса задает свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryUpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обновляет указанный экземпляр модели, используя значения, предоставленные поставщиком значений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Серии руководств по использованию привязки модели с веб-форм, см. в разделе [привязки модели и Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUpdateModel(Of TModel As Class) (model As TModel) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual bool TryUpdateModel(TModel model);" />
      <MemberSignature Language="F#" Value="abstract member TryUpdateModel : 'Model -&gt; bool (requires 'Model : null)&#xA;override this.TryUpdateModel : 'Model -&gt; bool (requires 'Model : null)" Usage="page.TryUpdateModel model" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Тип модели.</typeparam>
        <param name="model">Модель.</param>
        <summary>Обновляет заданный экземпляр модели, используя значения из элемента управления с привязкой к данным.</summary>
        <returns>Значение <see langword="true" />, если привязка модели выполнена успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться только из метода, который задается параметром элемента управления с привязкой данных `UpdateMethod` или `InsertMethod` свойство.  
  
 Серии руководств по использованию привязки модели с веб-форм, см. в разделе [привязки модели и Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUpdateModel(Of TModel As Class) (model As TModel, valueProvider As IValueProvider) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual bool TryUpdateModel(TModel model, System::Web::ModelBinding::IValueProvider ^ valueProvider);" />
      <MemberSignature Language="F#" Value="abstract member TryUpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; bool (requires 'Model : null)&#xA;override this.TryUpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; bool (requires 'Model : null)" Usage="page.TryUpdateModel (model, valueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Тип модели.</typeparam>
        <param name="model">Модель.</param>
        <param name="valueProvider">Поставщик значений.</param>
        <summary>Обновляет экземпляр модели, используя значения, предоставленные указанным поставщиком значений.</summary>
        <returns>Значение <see langword="true" />, если привязка модели выполнена успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Серии руководств по использованию привязки модели с веб-форм, см. в разделе [привязки модели и Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UICulture">
      <MemberSignature Language="C#" Value="public string UICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UICulture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property UICulture As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UICulture { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UICulture : string with get, set" Usage="System.Web.UI.Page.UICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Устанавливает идентификатор интерфейса пользователя (UI) для объекта <see cref="T:System.Threading.Thread" />, связанного со страницей.</summary>
        <value>Идентификатор UI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство является ярлыком для <xref:System.Threading.Thread.CurrentThread%2A> свойство. Язык и региональные параметры — это свойство выполняющегося потока  
  
 Задайте `UICulture` атрибут директивы в файле .aspx. При запросе страницы, динамически создаваемого класса значение этого свойства. Кроме того, можно также явно задать значение <xref:System.Web.UI.Page.UICulture%2A> свойства в файле Web.config.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
      </Docs>
    </Member>
    <Member MemberName="UniqueFilePathSuffix">
      <MemberSignature Language="C#" Value="protected internal virtual string UniqueFilePathSuffix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueFilePathSuffix" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property UniqueFilePathSuffix As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::String ^ UniqueFilePathSuffix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueFilePathSuffix : string" Usage="System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает уникальный суффикс для добавления к пути файла для браузеров с кэшем.</summary>
        <value>Возвращает уникальный суффикс, добавляемый к пути файла. Значение по умолчанию равно "__ufps=" плюс уникальное число из 6 цифр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.UniqueFilePathSuffix%2A> Свойство возвращает строку, которая добавляется в конец пути к файлу при необходимости для кэширования браузеров. Строка используется для определения пути файла, связанного с конкретным запросом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnobtrusiveValidationMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberSignature Language="VB.NET" Value="Public Property UnobtrusiveValidationMode As UnobtrusiveValidationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::UnobtrusiveValidationMode UnobtrusiveValidationMode { System::Web::UI::UnobtrusiveValidationMode get(); void set(System::Web::UI::UnobtrusiveValidationMode value); };" />
      <MemberSignature Language="F#" Value="member this.UnobtrusiveValidationMode : System.Web.UI.UnobtrusiveValidationMode with get, set" Usage="System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.UnobtrusiveValidationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, используется ли малозаметный JavaScript для проверки на стороне клиента.</summary>
        <value>Значение <see langword="true" />, если используется малозаметный JavaScript; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void UnregisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UnregisterRequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterRequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.UnregisterRequiresControlState : System.Web.UI.Control -&gt; unit" Usage="page.UnregisterRequiresControlState control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">Элемент управления <see cref="T:System.Web.UI.Control" />, для которого отменяется сохранение состояния элемента управления.</param>
        <summary>Отменяет сохранение состояния элемента управления для указанного элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пользовательских серверных элементов управления, использующие состояние элемента управления необходимо вызвать <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> при каждом запросе во время перед состояние сохраняется. Регистрация состояния элемента управления не переносится из запроса к запросу во время обратной передачи. Используйте <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> метод, чтобы гарантировать, что состояние элемента управления не сохраняется для элементов управления, которые больше не должны быть сохранены для обратной передачи.  
  
 На внутреннем уровне <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> метод вызывается при использовании <xref:System.Web.UI.Control.RemovedControl%2A> метод, чтобы удалить элемент управления из коллекции элементов управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <see cref="T:System.Web.UI.Control" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
        <related type="Article" href="https://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681">Состояние элемента управления vs. Пример представления состояния</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обновляет указанный экземпляр модели, используя значения, предоставленные поставщиком значений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Серии руководств по использованию привязки модели с веб-форм, см. в разделе [привязки модели и Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateModel(Of TModel As Class) (model As TModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual void UpdateModel(TModel model);" />
      <MemberSignature Language="F#" Value="abstract member UpdateModel : 'Model -&gt; unit (requires 'Model : null)&#xA;override this.UpdateModel : 'Model -&gt; unit (requires 'Model : null)" Usage="page.UpdateModel model" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Тип модели.</typeparam>
        <param name="model">Модель.</param>
        <summary>Обновляет заданный экземпляр модели, используя значения из элемента управления с привязкой к данным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться только из метода, который задается параметром элемента управления с привязкой данных `UpdateMethod` или `InsertMethod` свойство.  
  
 Серии руководств по использованию привязки модели с веб-форм, см. в разделе [привязки модели и Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateModel(Of TModel As Class) (model As TModel, valueProvider As IValueProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual void UpdateModel(TModel model, System::Web::ModelBinding::IValueProvider ^ valueProvider);" />
      <MemberSignature Language="F#" Value="abstract member UpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; unit (requires 'Model : null)&#xA;override this.UpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; unit (requires 'Model : null)" Usage="page.UpdateModel (model, valueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Тип модели.</typeparam>
        <param name="model">Модель.</param>
        <param name="valueProvider">Поставщик значений.</param>
        <summary>Обновляет указанный экземпляр модели, используя значения, предоставленные указанным поставщиком значений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Серии руководств по использованию привязки модели с веб-форм, см. в разделе [привязки модели и Web Forms](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.User" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal" Usage="System.Web.UI.Page.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает сведения о пользователе, производящем запрос страницы.</summary>
        <value>Объект <see cref="T:System.Security.Principal.IPrincipal" />, представляющий пользователя, производящего запрос страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Principal.IPrincipal> Объект представляет контекст безопасности пользователя, от лица которого выполняется код, включая удостоверение личности пользователя и любые роли, к которым они относятся.  
  
 Это свойство использует <xref:System.Web.HttpContext> объекта <xref:System.Web.HttpContext.User%2A> свойства, чтобы определить, откуда поступил запрос.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.UI.Page.User%2A> свойство для доступа к данным проверки подлинности и идентификации для текущего пользователя. Если пользователь не прошел проверку подлинности, он перенаправляется на страницу входа.  
  
 [!code-csharp[Page_User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_User/CS/page_user.cs.aspx#1)]
 [!code-vb[Page_User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_User/VB/page_user.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Security.Principal.IPrincipal" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Требует, чтобы проверочные элементы управления, содержащиеся на странице, выполняли проверку связанных с ними сведений.</summary>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Validate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Validate();" />
      <MemberSignature Language="F#" Value="abstract member Validate : unit -&gt; unit&#xA;override this.Validate : unit -&gt; unit" Usage="page.Validate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Требует, чтобы проверочные элементы управления, содержащиеся на странице, выполняли проверку связанных с ними сведений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда пользователь щелкает любой серверный элемент управления ASP.NET с `CausesValidation` свойство значение `true`, который используется по умолчанию. К ним относятся <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, и <xref:System.Web.UI.WebControls.LinkButton> веб-серверных элементов управления, <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, и <xref:System.Web.UI.HtmlControls.HtmlButton> серверные элементы управления HTML и элементов управления, которые можно автоматически публикует на сервер, например <xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, и <xref:System.Web.UI.WebControls.BulletedList> элементов управления.  
  
 Чтобы отключить проверку для любого элемента управления кнопки на странице, значение элемента управления button `CausesValidation` свойства `false`.  
  
 При вызове этого метода, он проходит по коллекции элементов управления проверки, содержащихся в <xref:System.Web.UI.ValidatorCollection> объект, связанный с <xref:System.Web.UI.Page.Validators%2A?displayProperty=nameWithType> свойство и вызывает логику проверки для каждого элемента управления проверки в текущей группе проверки. Группа проверки определяется элементом управления, передающий страницу на сервер. Если группа проверки не указана, то используется группа проверки.  
  
> [!NOTE]
>  Поведение проверки страницы изменилось. В [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)], больше не управляет вызов <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> метод; они использовать <xref:System.Web.UI.Page.Validate%28System.String%29?displayProperty=nameWithType> метод вместо этого. Если вы используете <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> метод [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] странице группы проверки обрабатываются и проверяются все элементы управления.  
  
   
  
## Examples  
 В следующем примере кода вызывается <xref:System.Web.UI.Page.Validate%2A> определен метод, на странице в сценарии с несколько различных групп проверки.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.Web.UI.Page.Validate" /> Не используется метод [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)]. При использовании [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)], переопределить <see cref="M:System.Web.UI.Page.Validate(System.String)" /> метод, чтобы изменить режим проверки страницы.</para></block>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Validate (validationGroup As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Validate(System::String ^ validationGroup);" />
      <MemberSignature Language="F#" Value="abstract member Validate : string -&gt; unit&#xA;override this.Validate : string -&gt; unit" Usage="page.Validate validationGroup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="validationGroup">Имя группы проверки для проверяемых элементов управления.</param>
        <summary>Требует, чтобы проверочные элементы управления в указанной группе проверки осуществили проверку связанных с ними сведений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда пользователь щелкает любой серверный элемент управления ASP.NET с `CausesValidation` свойство значение `true`, который используется по умолчанию. К ним относятся <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, и <xref:System.Web.UI.WebControls.LinkButton> веб-серверных элементов управления, <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, и <xref:System.Web.UI.HtmlControls.HtmlButton> серверные элементы управления HTML и элементов управления, которые можно автоматически публикует на сервер, например <xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, и <xref:System.Web.UI.WebControls.BulletedList> элементов управления.  
  
 Чтобы отключить проверку для любого элемента управления кнопки на странице, значение элемента управления button `CausesValidation` свойства `false`.  
  
 <xref:System.Web.UI.Page.Validate%2A> Метод проверяет указанной группы проверки. После вызова метода <xref:System.Web.UI.Page.Validate%2A> метод на группы проверки, <xref:System.Web.UI.Page.IsValid%2A> метод возвратит `true` только в том случае, если допустимы указанной группы проверки и проверки группы управления, вызвавшего страницы на сервер.  
  
   
  
## Examples  
 В следующем примере кода вызывается <xref:System.Web.UI.Page.Validate%2A> определен метод, на странице в сценарии с несколько различных групп проверки.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateRequestMode : System.Web.UI.ValidateRequestMode with get, set" Usage="System.Web.UI.Page.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, проверяет ли страница полученный из браузера клиентский ввод на предмет потенциально опасных значений.</summary>
        <value>Значение, указывающее, проверяет ли страница клиентский ввод. Значение по умолчанию — <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение <xref:System.Web.UI.ValidateRequestMode.Inherit> не используется в <xref:System.Web.UI.Page> класса, так как они не наследование.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Validators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection Validators { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ValidatorCollection Validators" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Validators" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Validators As ValidatorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ValidatorCollection ^ Validators { System::Web::UI::ValidatorCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Validators : System.Web.UI.ValidatorCollection" Usage="System.Web.UI.Page.Validators" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию всех проверочных элементов управления, содержащихся на запрашиваемой странице.</summary>
        <value>Коллекция проверочных элементов управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для обработки методов и свойств <xref:System.Web.UI.ValidatorCollection> объект, связанный с текущим <xref:System.Web.UI.Page> экземпляра. Эта коллекция содержит все проверки серверных элементов управления, содержащихся на странице.  
  
 Вызов <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> метод вызывает логику проверки, которое выполняется для каждого проверочный серверный элемент управления в текущей группе проверки. Если любой из этих элементов управления не проходят, <xref:System.Web.UI.Page.IsValid%2A?displayProperty=nameWithType> возвращает `false`.  
  
 Дополнительные сведения о проверочных элементов управления, см. в разделе [проверяющие элементы управления ASP.NET](https://msdn.microsoft.com/library/fa2aa14d-a461-492e-9a79-c990904613ef).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
      </Docs>
    </Member>
    <Member MemberName="VerifyRenderingInServerForm">
      <MemberSignature Language="C#" Value="public virtual void VerifyRenderingInServerForm (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void VerifyRenderingInServerForm(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.VerifyRenderingInServerForm(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void VerifyRenderingInServerForm(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member VerifyRenderingInServerForm : System.Web.UI.Control -&gt; unit&#xA;override this.VerifyRenderingInServerForm : System.Web.UI.Control -&gt; unit" Usage="page.VerifyRenderingInServerForm control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления ASP.NET, который должен находиться в элементе управления <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />.</param>
        <summary>Подтверждает, что элемент управления <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> отображается для указанного серверного элемента управления ASP.NET во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы управления, которые должны находиться внутри `<form runat=server>` теги могут вызвать этот метод, до отображения, чтобы сообщение об ошибке отображается при их размещении за пределами тегов. Этот метод следует вызывать элементы управления, обратную или зависят от зарегистрированных блоков сценариев в переопределении <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> метод. Страницы с другим способом визуализации элементов серверной формы могут переопределять этот метод для создания исключения в различных условиях.  
  
 Серверные элементы управления, которые обратную или использовать скрипт на стороне клиента не будет работать, если они не заключены в <xref:System.Web.UI.HtmlControls.HtmlForm> серверного элемента управления (<`form runat="server">`) теги. Эти элементы управления можно вызывать этот метод, при отображении, чтобы предоставить сообщение об ошибке, если они не включены в <xref:System.Web.UI.HtmlControls.HtmlForm> элемента управления.  
  
 При разработке серверного элемента управления, довольно часто для вызова этого метода при переопределении `Render` метод для любого типа тега входных данных. Это особенно важно в том случае, если элемент управления вызывает <xref:System.Web.UI.Page.GetPostBackEventReference%2A>, или если он выдает клиентского скрипта. Составной серверный элемент управления не нужно вызывать этот метод.  
  
   
  
## Examples  
 В следующем примере кода переопределяется <xref:System.Web.UI.Page.Render%2A?displayProperty=nameWithType> метод пользовательского серверного элемента управления. Когда этот элемент управления записывает его содержимое на страницу, он использует <xref:System.Web.UI.Page.VerifyRenderingInServerForm%2A> метод, чтобы убедиться в том, что элемент управления отображается между открывающим и закрывающим тегами <xref:System.Web.UI.HtmlControls.HtmlForm> элемента управления.  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#3)]
 [!code-vb[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/vb/testlinkbutton.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Указанный серверный элемент управления не содержится между открывающим и закрывающим тегами серверного элемента управления <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> во время выполнения.</exception>
        <exception cref="T:System.ArgumentNullException">Проверяемый элемент управления имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateEncryptionMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewStateEncryptionMode As ViewStateEncryptionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ViewStateEncryptionMode ViewStateEncryptionMode { System::Web::UI::ViewStateEncryptionMode get(); void set(System::Web::UI::ViewStateEncryptionMode value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateEncryptionMode : System.Web.UI.ViewStateEncryptionMode with get, set" Usage="System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateEncryptionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает режим шифрования состояния представления.</summary>
        <value>Одно из значений <see cref="T:System.Web.UI.ViewStateEncryptionMode" />. Значение по умолчанию — <see cref="F:System.Web.UI.ViewStateEncryptionMode.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> Свойство не может задаваться в коде. Его можно установить только в директиве или в < элемент файла конфигурации. Значения заданы в директиве переопределения любого значения, заданные в файле конфигурации.  
  
 Синтаксис для этого свойства в директиве выглядит следующим образом:  
  
```vb  
<%@ Page Language="VB" ViewStateEncryptionMode="Always" %>  
```  
  
```csharp  
<%@ Page Language="C#" ViewStateEncryptionMode="Always" %>  
```  
  
 Синтаксис для этого свойства в файле конфигурации выглядит следующим образом:  
  
```vb  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
```csharp  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
 Разработчикам пользовательского элемента управления может потребоваться проверить значение этого свойства в коде перед сохранением потенциально конфиденциальных данных в состоянии представления в их контроля.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Присвоенное значение не является членом перечисления <see cref="T:System.Web.UI.ViewStateEncryptionMode" />.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Web.UI.Page.ViewStateEncryptionMode" /> можно задавать только до или во время этапа <see langword="PreRender" /> жизненного цикла страницы.</exception>
        <altmember cref="T:System.Web.UI.ViewStateEncryptionMode" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateUserKey">
      <MemberSignature Language="C#" Value="public string ViewStateUserKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ViewStateUserKey" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateUserKey" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewStateUserKey As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ViewStateUserKey { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateUserKey : string with get, set" Usage="System.Web.UI.Page.ViewStateUserKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Присваивает пользователю идентификатор в переменной состояния представления, связанной с текущей страницей.</summary>
        <value>Идентификатор отдельного пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр <xref:System.Web.UI.Page.ViewStateUserKey%2A> свойство может помочь предотвратить атаки на приложение от пользователей-злоумышленников. Это делается, позволяя присвоить идентификатор переменной состояния представления для отдельных пользователей, таким образом, чтобы они не могут использовать переменную для создания атаки. Дополнительные сведения о сетевых атак и что делать, чтобы предотвратить их, см. в разделе [занять преимуществ ASP.NET встроенных функций для сражаться с этим Off атак](https://go.microsoft.com/fwlink/?LinkId=163557).  
  
 Это свойство можно задать любое строковое значение, такие как имя прошедшего проверку пользователя или <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> значение.  
  
> [!NOTE]
>  Необходимо задать это свойство во время `Page_Init` этап обработки страницы. Задание этого свойства во время `Page_Load` этапа создает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Доступ к свойству <see cref="P:System.Web.UI.Page.ViewStateUserKey" /> был осуществлен слишком поздно во время обработки страницы.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=163557">Воспользоваться преимуществами встроенных функций ASP.NET предотвращении сетевых атак</related>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.Page.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, отображается ли объект <see cref="T:System.Web.UI.Page" />.</summary>
        <value><see langword="true" />, если объект <see cref="T:System.Web.UI.Page" /> должен быть отображен; иначе — <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере задается <xref:System.Web.UI.Page.Visible%2A> свойства `false` скрыть отображаемого содержимого страницы. При первом запросе этой страницы, источник данных заполняется и отображается на странице. Когда пользователь нажимает кнопку, `HideButton_Click` обработчик событий скрывает все отображаемое содержимое страницы.  
  
 [!code-csharp[Page_Visible#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_Visible/CS/page_visible.cs.aspx#1)]
 [!code-vb[Page_Visible#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_Visible/VB/page_visible.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.UI.TemplateControl" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
  </Members>
</Type>