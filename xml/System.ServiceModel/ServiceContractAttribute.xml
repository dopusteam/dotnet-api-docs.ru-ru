<Type Name="ServiceContractAttribute" FullName="System.ServiceModel.ServiceContractAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="eadc0126e33520173f4c5b827a7dd469b2f58d88" /><Meta Name="ms.sourcegitcommit" Value="7461f9e28c2f184bd1596e6f07c25a3f34984516" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/28/2019" /><Meta Name="ms.locfileid" Value="58551205" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type ServiceContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
    <AssemblyVersion>4.5.0.3</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-uwp-10.0;dotnet-plat-ext-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, AllowMultiple=false, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Показывает, что интерфейс или класс определяет контракт службы в приложении Windows Communication Foundation (WCF).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить контракт службы, используйте атрибут <xref:System.ServiceModel.ServiceContractAttribute> в интерфейсе (или в классе). Затем используйте атрибут <xref:System.ServiceModel.OperationContractAttribute> в одном или нескольких методах класса (или интерфейса), чтобы определить операции службы контракта. Если контракт службы реализуется и объединяется с [привязки](~/docs/framework/wcf/bindings.md) и <xref:System.ServiceModel.EndpointAddress> объекта, контракт службы предоставляется для использования клиентами. Общие сведения о процессе и простые примеры, см. в разделе [Приступая к работе](~/docs/framework/wcf/getting-started-tutorial.md). Дополнительные сведения о создании контрактов службы, см. в разделе [проектирование и реализация служб](~/docs/framework/wcf/designing-and-implementing-services.md).  
  
 Данные, предоставляемые классом <xref:System.ServiceModel.ServiceContractAttribute> и его интерфейсом, слабо связаны с элементом `<portType>` языка описания служб (WSDL). Контракт службы используется на стороне службы для указания конечной точки службы предоставляет вызывающим объектам. Кроме того, он используется на стороне клиента для указания контракта конечной точки, с которой взаимодействует клиент, а в случае дуплексных контрактов — для указания контракта обратного вызова (с использованием свойства <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>), который должен реализовать клиент, чтобы принять участие в дуплексном диалоге.  
  
> [!NOTE]
>  Интерфейс или класс, отмеченный атрибутом <xref:System.ServiceModel.ServiceContractAttribute>, также должен иметь как минимум один метод, отмеченный атрибутом <xref:System.ServiceModel.OperationContractAttribute>, для предоставления всех функциональных возможностей. Пример кода простейшего использования двух атрибутов для определения и реализации службы см. в разделе "Примеры".  
  
 Чтобы изменить контракт службы, используйте свойства <xref:System.ServiceModel.ServiceContractAttribute>.  
  
-   Свойство <xref:System.ServiceModel.ServiceContractAttribute.ConfigurationName%2A> определяет имя элемента службы в используемом файле конфигурации.  
  
-   Свойства <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> и <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> управляют именем и пространством имен контракта в элементе `<portType>` языка WSDL.  
  
-   Свойство <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> определяет, требуется ли контракту привязка, поддерживающая сеансы.  
  
-   Свойство <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> определяет возвращаемый контракт в двустороннем (дуплексном) диалоге.  
  
-   Свойства <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A> и <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> определяют, все ли сообщения, поддерживающие контракт, имеют явное значение <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A>, и если да, на каком уровне.  
  
 Службы реализуют контракты служб, представляющие обмен данными, поддерживаемый типом службы. Класс службы может реализовать контракт службы (путем реализации интерфейса, отмеченного атрибутом <xref:System.ServiceModel.ServiceContractAttribute>, который содержит методы, отмеченные атрибутом <xref:System.ServiceModel.OperationContractAttribute>) или может быть отмечен атрибутом <xref:System.ServiceModel.ServiceContractAttribute> и применять атрибут <xref:System.ServiceModel.OperationContractAttribute> к собственным методам. (Если класс реализует интерфейс, отмеченный атрибутом <xref:System.ServiceModel.ServiceContractAttribute>, сам он не может быть отмечен атрибутом <xref:System.ServiceModel.ServiceContractAttribute>.) Методы в типах службы, отмеченные атрибутом <xref:System.ServiceModel.OperationContractAttribute>, считаются частью контракта службы по умолчанию, заданного самим типом службы. Подробные сведения об операциях службы см. в разделе <xref:System.ServiceModel.OperationContractAttribute>.  
  
 По умолчанию свойства <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> и <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> являются именем типа контракта и `http://tempuri.org` соответственно, а уровень <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> является уровнем <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>. Рекомендуется, чтобы контракты службы явным образом задавали свои имена, пространства имен и уровни защиты с использованием этих свойств. Это помогает достичь двух целей. Во-первых, создается контракт, не связанный напрямую со сведениями об управляемых типах, что позволяет выполнить рефакторинг управляемого кода и пространств имен без нарушения контракта, поскольку он выражен на языке WSDL. Во-вторых, явная необходимость в определенном уровне защиты самого контракта позволяет среде выполнения проверять, поддерживает ли конфигурация привязки этот уровень безопасности, не допуская раскрытия конфиденциальных сведений неудовлетворительной конфигурацией. Дополнительные сведения об уровнях защиты см. в разделе [уровень защиты понимание](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Чтобы предоставить службу для использования клиентскими приложениями, создайте ведущее приложение для регистрации конечной точки службы с помощью Windows Communication Foundation (WCF). Вы можете размещать службы WCF, с помощью службы активации Windows (WAS), консольные приложения, приложения служб Windows, приложений ASP.NET, приложения Windows Forms или любого другого домена приложения.  
  
 Размещение в WAS очень похоже на создание приложения ASP.NET. Подробную информацию см. в разделе [Практическое руководство. Размещение службы WCF в IIS](~/docs/framework/wcf/feature-details/how-to-host-a-wcf-service-in-iis.md).  
  
 Клиенты либо используют интерфейс контракта службы (интерфейс, отмеченный атрибутом <xref:System.ServiceModel.ServiceContractAttribute>) для создания канала к службе, либо используют объекты клиента (которые объединяют сведения о типе интерфейса контракта службы с классом <xref:System.ServiceModel.ClientBase%601>) для взаимодействия со службой. Дополнительные сведения о клиентских каналах к службам, см. в разделе <xref:System.ServiceModel.ChannelFactory%601> класс и [WCF Client Overview](~/docs/framework/wcf/wcf-client-overview.md).  
  
 При использовании класса или интерфейса <xref:System.ServiceModel.ServiceContractAttribute> для наследования от другого класса или интерфейса <xref:System.ServiceModel.ServiceContractAttribute> расширяется родительский контракт. Например, если интерфейс `IChildContract` отмечен атрибутом <xref:System.ServiceModel.ServiceContractAttribute> и унаследован от другого интерфейса контракта службы, `IParentContract`, контракт службы `IChildContract` содержит методы как `IParentContract`, так и `IChildContract`. Расширение контрактов (как в классах, так и в интерфейсах) очень похоже на расширение управляемых классов и интерфейсов.  
  
 Самым гибким подходом к созданию служб является первоначальное определение интерфейсов контрактов службы и последующая реализация этого интерфейса классом службы. (Это также самый простой способ создать службы, если необходимо реализовать контракты службы, определенные другими пользователями.) Создавать службы напрямую, отметив класс атрибутом <xref:System.ServiceModel.ServiceContractAttribute>, а его методы — атрибутом <xref:System.ServiceModel.OperationContractAttribute>, можно, если служба предоставляет только один контракт (но этот контракт может быть предоставлен несколькими конечными точками).  
  
 Используйте <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> свойство, чтобы указать другой контракт службы, который, будучи связанным с исходным контрактом службы, определяет обмен сообщениями, который может осуществляться в обе стороны независимо друг от друга. Дополнительные сведения см. в разделе <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как применить атрибут <xref:System.ServiceModel.ServiceContractAttribute> к интерфейсу, чтобы определить контракт службы с одним методом службы, указанным атрибутом <xref:System.ServiceModel.OperationContractAttribute>. В этом случае уровень защиты, требуемый от привязок для всех сообщений, — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>.  
  
 Затем в примере кода этот контракт реализуется в классе `SampleService`.  
  
 [!code-csharp[ServiceContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/services.cs#1)]
 [!code-vb[ServiceContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/services.vb#1)]  
  
 В следующем примере кода показан простой файл конфигурации для указанной выше службы, создающей одну конечную точку.  
  
 [!code-xml[ServiceContractAttribute#2](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/hostapplication.exe.config#2)]   
  
 В следующем примере кода показан простой клиент, вызывающий приведенный выше класс `SampleService`.  
  
 [!code-csharp[ServiceContractAttribute#3](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/client.cs#3)]
 [!code-vb[ServiceContractAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/client.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationContractAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/036fae20-7c55-4002-b71d-ac4466e167a3">Определение контрактов службы</related>
    <related type="Article" href="https://msdn.microsoft.com/library/192be927-6be2-4fda-98f0-e513c4881acc">Размещение службы</related>
    <related type="Article" href="https://msdn.microsoft.com/library/7cf21bfe-23bd-46aa-8033-609f851dbf76">Общие сведения о создании службы</related>
    <related type="Article" href="https://msdn.microsoft.com/library/28dfff47-d95b-4cc2-9d5c-b3b9ba71fd50">Создание клиента</related>
    <related type="Article" href="https://msdn.microsoft.com/library/d780af9f-73c5-42db-9e52-077a5e4de7fe">Общие сведения о создании прокси-сервера</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.ServiceContractAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор создает экземпляр атрибута без требований сеанса и без контракта обратного вызова, а также имя и пространство имен по умолчанию.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallbackContract">
      <MemberSignature Language="C#" Value="public Type CallbackContract { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type CallbackContract" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberSignature Language="VB.NET" Value="Public Property CallbackContract As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ CallbackContract { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CallbackContract : Type with get, set" Usage="System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает тип контракта обратного вызова, если контракт является дуплексным.</summary>
        <value>Тип <see cref="T:System.Type" />, указывающий контракт обратного вызова. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задает интерфейс в свойстве <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>, представляющем требуемый противоположный контракт при двустороннем (или дуплексном) обмене сообщениями. Это позволяет клиентским приложениям ожидать передачи данных для входящих вызовов операций, которые приложение службы на стороне сервера может отправлять независимо от действия клиента. Контракты обратного вызова, имеющие односторонние операции, представляют вызовы от службы, которые может обработать клиент.  
  
> [!NOTE]
>  В контрактах обратного вызова атрибут <xref:System.ServiceModel.ServiceContractAttribute> пропускается. Чтобы настроить поведение среды выполнения объектов обратного вызова, используйте атрибут <xref:System.ServiceModel.CallbackBehaviorAttribute?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода показана служба, которая задает контракт обратного вызова, указывающий, что служба, принадлежащая к типу `IDuplexHello`, должна иметь корреспондент, который реализует службу, принадлежащую к типу `IHelloCallbackContract`. Кроме того, `IHelloCallbackContract` реализует односторонний метод обратного вызова, позволяющий службе вызывать клиент без ожидания ответа для поддержки распределенного клиента, управляемого событиями.  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя, используемое для поиска службы в файле конфигурации приложения.</summary>
        <value>Имя, используемое для поиска элемента службы в файле конфигурации приложения. По умолчанию — это имя класса реализации службы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения о процедуре задания значения, с помощью которого система конфигурации выполняет поиск значения контракта в файле конфигурации, см. в разделе <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение — null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значением является пустая строка.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, присвоен ли участнику уровень защиты.</summary>
        <value><see langword="true" />, если свойство <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" /> не является <see cref="F:System.Net.Security.ProtectionLevel.None" />, в противном случае <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A> указывает, присвоено ли контракту значение уровня защиты, отличное от `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя элемента <see langword="&lt;portType&gt;" /> в языке WSDL.</summary>
        <value>В качестве значения по умолчанию используется имя класса или интерфейса, к которому применен атрибут <see cref="T:System.ServiceModel.ServiceContractAttribute" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойства <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> и <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A>, чтобы управлять именем и пространством имен элемента `<portType>` в языке WSDL.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать свойства <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> и <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> атрибута <xref:System.ServiceModel.ServiceContractAttribute>, чтобы задать соответствующие значения в языке WSDL.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 В следующем примере кода показан клиент Windows Communication Foundation (WCF) для указанной выше службы, импортированные WSDL с помощью [ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). Этот клиент использует клиент `HelloWorldProxy`, а не клиент `SampleServiceProxy` (как в случае с примером в подразделе "Пример" раздела <xref:System.ServiceModel.ServiceContractAttribute>).  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение — null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значением является пустая строка.</exception>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает пространство имен элемента <see langword="&lt;portType&gt;" /> в языке WSDL.</summary>
        <value>Пространство имен WSDL элемента <see langword="&lt;portType&gt;" />. Значение по умолчанию — http://tempuri.org.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как использовать свойства <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> и <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> атрибута <xref:System.ServiceModel.ServiceContractAttribute>, чтобы задать соответствующие значения в языке WSDL.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 В следующем примере кода показан клиент Windows Communication Foundation (WCF) для указанной выше службы, импортированные WSDL с помощью [ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). Этот клиент использует клиент `HelloWorldClient`, а не клиент `SampleServiceClient` (как в случае с примером в подразделе "Пример" раздела <xref:System.ServiceModel.ServiceContractAttribute>).  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, должна ли привязка для контракта поддерживать значение свойства <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />.</summary>
        <value>Одно из значений <see cref="T:System.Net.Security.ProtectionLevel" />. Значение по умолчанию — <see cref="F:System.Net.Security.ProtectionLevel.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A>, чтобы задать для привязки степень необходимости в шифровании, цифровых сигнатурах или и в том, и в другом для конечных точек, предоставляющих контракт. Заданное здесь значение является значением по умолчанию для всех сообщений операций, включая ошибки.  
  
 Важно помнить, что поведение защиты в среде выполнения — это комбинация значений уровня защиты, заданных в следующих свойствах. Эти свойства имеют иерархическую структуру. При задании внешнего значения устанавливается значение по умолчанию для всех более узких областей, если явно не задано другое значение для более узкой области. В этом случае внешнее значение остается значением по умолчанию для всех более узких областей за исключением тех областей, для которых задано иное значение.  
  
 Например, если для уровня <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> задано значение <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> и другие более узкие области не имеют параметров уровня защиты, все сообщения в контракте операции шифруются и подписываются. Однако если атрибуту <xref:System.ServiceModel.OperationContractAttribute> одной из этих операций присвоено значение <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, сообщения для этой операции подписываются, а все другие сообщения в контракте шифруются и подписываются.  
  
 Дополнительные сведения об уровнях защиты и их предположений и областей см. в разделе [уровень защиты понимание](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Ниже приводятся области, в которых заданы эти значения.  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 Свойство <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> атрибута <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.  
  
 Свойство <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> атрибута <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.  
  
 Если в контракте отсутствует явно заданный уровень защиты, а базовая привязка поддерживает безопасность (как на транспортном уровне, так и на уровне сообщений), эффективным уровнем защиты для всего контракта является <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>. Если привязка не поддерживает безопасность (например, <xref:System.ServiceModel.BasicHttpBinding>), эффективным уровнем <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> является <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> для всего контракта. В результате в зависимости от привязки конечной точки клиенты могут требовать разную степень защиты на уровне сообщений или транспортном уровне, даже если контракт задает <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Данное значение не является одним из значений <see cref="T:System.Net.Security.ProtectionLevel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.SessionMode SessionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.SessionMode SessionMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property SessionMode As SessionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::SessionMode SessionMode { System::ServiceModel::SessionMode get(); void set(System::ServiceModel::SessionMode value); };" />
      <MemberSignature Language="F#" Value="member this.SessionMode : System.ServiceModel.SessionMode with get, set" Usage="System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.SessionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, разрешены, запрещены или требуются ли сеансы.</summary>
        <value>Режим <see cref="T:System.ServiceModel.SessionMode" /> указывает, разрешены, запрещены или требуются ли сеансы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A>, чтобы потребовать привязки, поддерживающие сеансы между конечными точками. Сеанс — это способ корреляции набора сообщений, обмен которыми выполняется между двумя или несколькими конечными точками. Если служба поддерживает сеансы канала, можно использовать свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A>, чтобы указать отношение между экземплярами реализации контракта службы и сеансом канала. Если привязка не поддерживает сеансы, выводится исключение.  
  
 Например, если свойству <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> присвоено значение <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType>, а свойству <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> присвоено значение <xref:System.ServiceModel.InstanceContextMode.PerSession>, клиенты могут использовать одно и то же подключение для повторных вызовов одного и того же объекта службы.  
  
 Дополнительные сведения о сеансах и экземплярах службы, см. в разделе [с использованием сеансов](~/docs/framework/wcf/using-sessions.md) и [сеансы, создание экземпляров и параллелизм](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
> [!NOTE]
>  Канал, поддерживающий сеансы, поддерживает ассоциацию экземпляра службы по умолчанию с определенным сеансом. Однако разные реализации сеанса поддерживают разные возможности помимо управления созданием экземпляров на основе сеанса. WCF предоставляет четыре типа сеансов, которые можно использовать для обеспечения поведения приложения сеанса; Каждый тип сеанса предоставляет дополнительное поведение, характерное для данного типа сеанса, он состоит.  
  
1.  Элемент <xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> поддерживает безопасные сеансы, в которых процесс шифрования и цифровой сигнатуры согласован для обеих взаимодействующих сторон. Все сообщения коррелируются с этим определенным безопасным диалогом. Дополнительные сведения см. в разделе [Защита служб](~/docs/framework/wcf/securing-services.md). Например, привязка <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType>, содержащая поддержку как безопасных, так и надежных сеансов, по умолчанию использует только безопасный сеанс, в котором сообщения шифруются и защищаются цифровой подписью.  
  
2.  Привязка <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> поддерживает сеансы, предоставляемые подключениями TCP/IP, что обеспечивает корреляцию всех сообщений по сеансу подключения на уровне сокетов.  
  
3.  Элемент <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType>, реализующий спецификацию WS-ReliableMessaging, обеспечивает поддержку надежных сеансов, в которых сообщения доставляются по порядку и только один раз, что гарантирует достоверность даже при прохождении сообщений через несколько узлов во время диалога. Дополнительные сведения см. в разделе [надежные сеансы](~/docs/framework/wcf/feature-details/reliable-sessions.md).  
  
4.  Привязка <xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> обеспечивает сеансы датаграммы MSMQ. Дополнительные сведения см. в разделе [очереди в WCF](~/docs/framework/wcf/feature-details/queues-in-wcf.md).  
  
 Помните, что задание свойства <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> указывает только то, что для контракта требуется сеанс, но не задает тип этого сеанса.  
  
   
  
## Examples  
 Для следующего контракта службы требуется, чтобы настроенные привязки использовали сеансы при взаимодействии с реализациями службы `SampleDuplexHello`.  
  
 [!code-csharp[SCA.Session#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.session/cs/services.cs#1)]
 [!code-vb[SCA.Session#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.session/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Данное значение не является одним из значений <see cref="T:System.ServiceModel.SessionMode" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>