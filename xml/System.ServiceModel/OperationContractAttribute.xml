<Type Name="OperationContractAttribute" FullName="System.ServiceModel.OperationContractAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e20f293e7e3fba77c9a12b2233e16f5ab92633a5" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56773848" /></Metadata><TypeSignature Language="C#" Value="public sealed class OperationContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OperationContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.OperationContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OperationContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class OperationContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type OperationContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-uwp-10.0;dotnet-plat-ext-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Указывает, что метод определяет операцию, которая является частью контракта службы в приложении Windows Communication Foundation (WCF).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Примените атрибут <xref:System.ServiceModel.OperationContractAttribute> к методу, чтобы указать, что метод реализует операцию службы как часть контракта службы (заданного атрибутом <xref:System.ServiceModel.ServiceContractAttribute>).  
  
 Используйте свойства <xref:System.ServiceModel.OperationContractAttribute> для управления структурой операции и значениями, выраженными в метаданных.  
  
-   Свойство <xref:System.ServiceModel.OperationContractAttribute.Action%2A> задает действие, однозначно определяющее данную операцию. WCF отправляет сообщения запросов в методы на основе их действия.  
  
-   Свойство <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> указывает, что операция реализована или может быть вызвана асинхронно с помощью пары методов Begin/End.  
  
-   Свойство <xref:System.ServiceModel.OperationContractAttribute.HasProtectionLevel%2A> указывает, задано ли явно свойство <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A>.  
  
-   Свойство <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> указывает, что операция состоит только из одного входного сообщения. Для операции не существует связанного с ней выходного сообщения.  
  
-   Свойство <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> определяет, может ли быть данная операция начальной операцией сеанса.  
  
-   <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> Свойство указывает, пытается ли завершить текущий сеанс после завершения операции WCF.  
  
-   Свойство <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> определяет безопасность уровня сообщений, которая требуется для операции во время выполнения.  
  
-   Свойство <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> определяет действие ответного сообщения для операции.  
  
 Атрибут <xref:System.ServiceModel.OperationContractAttribute> объявляет, что метод представляет собой операцию в контракте службы. В качестве операций службы представляются только методы, отмеченные атрибутом <xref:System.ServiceModel.OperationContractAttribute>. Контракт службы без методов, отмеченных атрибутом <xref:System.ServiceModel.OperationContractAttribute>, не представляет никаких операций.  
  
 <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> Свойство указывает, что пара `Begin` \< *имя_метода*> и `End` \< *имя_метода*> методы формирования единой операцию, реализуемую асинхронно (как на стороне клиента или службы). Способность службы реализовать операции асинхронно является отдельной частью реализации службы и не представляется в метаданных (например, WSDL).  
  
 Подобным образом клиенты могут выбрать асинхронный вызов операций независимо от реализации метода службы. Асинхронный вызов операций службы в клиенте рекомендуется тогда, когда выполнение метода службы занимает некоторое время, но он должен вернуть информацию непосредственно клиенту. Дополнительные сведения см. в разделе <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A>.  
  
 Свойство <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> указывает, что метод не возвращает никакого значения вообще, включая пустое базовое ответное сообщение. Метод такого типа полезен для уведомлений или взаимодействия в стиле событий. Методы этого типа не могут вернуть ответное сообщение, поэтому объявление метода должно вернуть `void`.  
  
> [!IMPORTANT]
>  При программным способом извлечения банка данных в этом атрибуте, используйте <xref:System.ServiceModel.Description.ContractDescription> класса вместо отражения.  
  
> [!NOTE]
>  Если свойству <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> присвоено значение `false` (по умолчанию), даже методы, возвращающие `void`, являются двусторонними на уровне базовых сообщений. В этом случае инфраструктура создает и отправляет пустое сообщение, чтобы указать вызывающему объекту о возврате метода. Использование такого подхода позволяет приложению и инфраструктуре отправлять информацию об ошибках (например, об ошибках SOAP) назад клиенту. Единственный способ предотвратить создание и отправку ответного сообщения — задание для свойства <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> значения `true`. Дополнительные сведения см. в разделе [служб односторонняя](~/docs/framework/wcf/feature-details/one-way-services.md).  
  
 Свойства <xref:System.ServiceModel.OperationContractAttribute.Action%2A> и <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> могут использоваться не только для изменения действия по умолчанию сообщений SOAP, но и для создания обработчиков нераспознаваемых сообщений или запрета добавления действий для непосредственного программирования сообщений. Используйте свойство <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>, чтобы запретить клиентам вызов конкретной операции службы до других операций. Используйте <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> свойство, чтобы закрыть канал после вызова клиентами конкретной операции службы WCF. Дополнительные сведения см. в разделе [с использованием сеансов](~/docs/framework/wcf/using-sessions.md).  
  
 Свойство <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> позволяет указать в контракте операции, должны ли сообщения операции подписываться, шифроваться или подписываться и шифроваться. Если привязка не может обеспечить уровень безопасности, определенный контрактом, во время выполнения вызывается исключение. Дополнительные сведения см. в разделе <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> и [уровень защиты понимание](~/docs/framework/wcf/understanding-protection-level.md).  
  
   
  
## Examples  
 В следующем примере кода показан простой контракт службы с одной операцией.  
  
 [!code-csharp[OperationContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute/vb/services.vb#1)]  
  
 В следующем примере представлена служба, которая реализует неявный контракт службы, определяющий три операции. Две из этих операций являются двусторонними и возвращают базовые ответные сообщения вызывающему объекту независимо от возвращаемого значения. Третья операция принимает вызов (базовое входящее сообщение), но не возвращает базового ответного сообщения.  
  
```csharp  
[ServiceContractAttribute]  
public class OneAndTwoWay  
{  
  // The client waits until a response message appears.  
  [OperationContractAttribute]  
  public int MethodOne (int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  // The client waits until an empty response message appears.  
  [OperationContractAttribute]  
  public void MethodTwo (int x)  
  {  
    return;  
  }  
  
  // The client returns as soon as an outbound message  
  // is dispatched to the service; no response  
  // message is generated or sent from the service.  
  [OperationContractAttribute(IsOneWay=true)]  
  public void MethodThree (int x)  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OperationContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.OperationContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OperationContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.OperationContractAttribute" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Action">
      <MemberSignature Language="C#" Value="public string Action { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Action" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.Action" />
      <MemberSignature Language="VB.NET" Value="Public Property Action As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Action { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Action : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.Action" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает действие WS-Addressing сообщения запроса.</summary>
        <value>Действие, которое должно использоваться при создании заголовка действия WS-Addressing.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.ServiceModel.OperationContractAttribute.Action%2A> свойство для управления действием метода входного сообщения. Так как WCF использует это действие для отправки входящего сообщения в соответствующий метод, используемый в операции контракта сообщения должны иметь уникальные действия. Действие по умолчанию представляет собой сочетание пространства имен контракта (значение по умолчанию — "http://tempuri.org/«), имя контракта (имени интерфейса или имя класса, если нет явной службы интерфейса используется), имя операции и дополнительной строки («Response») Если сообщение является коррелированный ответ. Это значение по умолчанию можно переопределить с помощью свойства <xref:System.ServiceModel.OperationContractAttribute.Action%2A>.  
  
 Чтобы указать, что операция службы обрабатывает все сообщения, которые принимает служба, но которые не могут быть направлены в операцию службы, задайте значение "*" (звездочка). Этот тип операции, называемый обработчиком несопоставленных сообщений, должен иметь одну из указанных ниже сигнатур метода. В противном случае вызывается исключение <xref:System.InvalidOperationException>.  
  
-   Операция службы может принимать только объект <xref:System.ServiceModel.Channels.Message> и возвращать объект <xref:System.ServiceModel.Channels.Message>.  
  
-   Операция службы может принимать только объект <xref:System.ServiceModel.Channels.Message> и не возвращать ничего (т. е. возвращать `void`).  
  
> [!NOTE]
>  Контракт службы может содержать только одну операцию службы со значением "*" свойства <xref:System.ServiceModel.OperationContractAttribute.Action%2A>. Любая группа контрактов, размещенная на одном listenUri, реализуемом классом службы может содержать несколько операций с <xref:System.ServiceModel.OperationContractAttribute.Action%2A> установлено значение "\*" при <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> свойству `false`. Однако только один из этих операций службы может иметь <xref:System.ServiceModel.OperationContractAttribute.Action%2A> установлено значение "\*" и <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> свойством, имеющим значение true. Дополнительные сведения см. в разделе <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>.  
  
   
  
## Examples  
 В следующем примере представлена служба, которая использует свойства <xref:System.ServiceModel.OperationContractAttribute.Action%2A> и <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> для явного управления действиями SOAP входных и выходных (или ответных) сообщений и свойство <xref:System.ServiceModel.OperationContractAttribute.Name%2A> для управления именем операции в метаданных. Наконец, приложение также использует значение «*» свойства <xref:System.ServiceModel.OperationContractAttribute.Action%2A>, чтобы указать метод, который обрабатывает нераспознанные сообщения.  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 Служба, реализующая этот контракт, отправляет сообщения, которые выглядят примерно так, как в следующем примере:  
  
 [!code-csharp[OperationContractAttribute_Properties#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncPattern">
      <MemberSignature Language="C#" Value="public bool AsyncPattern { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncPattern" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.AsyncPattern" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPattern As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AsyncPattern { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPattern : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.AsyncPattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что операция реализуется асинхронно с помощью пары методов <see langword="Begin" />&lt;*methodName*&gt; и <see langword="End" />&lt;*methodName*&gt; контракта службы.</summary>
        <value><see langword="true" /> Если <see langword="Begin" /> &lt; *имя_метода*&gt;сопоставляется с методом <see langword="End" /> &lt; *имя_метода* &gt; метода и может трактоваться Инфраструктура как операцию, которая реализуется в виде пары асинхронных методов в интерфейсе службы; в противном случае <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> для создания операций службы, которые могут вызываться асинхронно на сервере, клиенте или на сервере и клиенте. Свойство <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> информирует среду выполнения о том, что метод `Begin` имеет сопоставленный метод `End`, соответствующий шаблону проектирования асинхронных методов платформы .NET Framework. Создание асинхронных методов сервера, которые реализуют операцию службы, увеличивает масштабируемость и производительность сервера, не влияя на клиентов службы, и рекомендуется, когда операция службы должна возвращать что-нибудь клиенту после выполнения очень длинной операции, которая может быть выполнена асинхронно.  
  
 Клиенты остаются незатронутыми, поскольку пара асинхронных методов на сервере представляет собой отдельную часть реализации, которая не затрагивает базовое описание операции на языке WSDL. Такие методы кажутся клиенту одной операцией с `<input>` и коррелированные `<output>` сообщений. WCF автоматически направляет входные сообщения методу `Begin` \< *имя_метода*> метод и результаты `End` \< *имя_метода*> вызова в исходящее сообщение. Клиентские каналы, следовательно, могут представлять пару методов либо как единственную синхронную операцию, либо как пару асинхронных операций. Ни в одном случае представление клиента никаким образом не влияет на асинхронную реализацию на сервере.  
  
 Клиентские контракты могут использовать свойство <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A>, чтобы указать пару асинхронных методов, которые клиент может применять для асинхронного вызова операции. Как правило, клиентские приложения используют [ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) средство и `/async` вариант для создания `Begin` \< *имя_метода*> и `End` \< *имя_метода*> пары методов, клиент можно использовать для асинхронного вызова операции.  
  
> [!NOTE]
>  Если операция службы имеет асинхронную и синхронную версии, поведение по умолчанию в службе должно вызвать синхронную версию.  
  
   
  
## Examples  
 В приведенном ниже примере кода показан клиентский канал к контракту службы, который включает синхронную и асинхронную версии операции `Add`. Если интерфейс контракта используется на клиенте, то операция `BeginAdd` и операция `Add` вызывают метод на сервере, который может быть или не быть синхронным. Если контракт используется для реализации службы, по умолчанию входящие запросы отправляются в синхронный метод.  
  
```csharp  
[ServiceContract]  
public interface IAddTwoNumbers  
{  
    // If the asynchronous method pair  
    // appears on the client channel, the client can call   
    // them asynchronously to prevent blocking.  
    [OperationContract (AsyncPattern=true)]  
    IAsyncResult BeginAdd(int a, int b, AsyncCallback cb, AsyncState s);  
  
    [OperationContract]  
    int EndAdd(IAsyncResult r);  
  
    // This is a synchronous version of the BeginAdd/EndAdd pair.  
    // It appears in the client channel code by default.   
    [OperationContract]  
    int Add(int a, int b);  
   }  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.OperationContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, должны ли сообщения этой операции шифроваться, подписываться или шифроваться и подписываться.</summary>
        <value>Значение <see langword="true" />, если для свойства <see cref="P:System.ServiceModel.OperationContractAttribute.ProtectionLevel" /> задано значение, отличное от <see cref="F:System.Net.Security.ProtectionLevel.None" />; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.ServiceModel.OperationContractAttribute.HasProtectionLevel%2A>, чтобы указать, требуется ли для сообщений этой операции определенный уровень защиты.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitiating">
      <MemberSignature Language="C#" Value="public bool IsInitiating { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitiating" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsInitiating" />
      <MemberSignature Language="VB.NET" Value="Public Property IsInitiating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitiating { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsInitiating : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsInitiating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, реализует ли метод операцию, которая может инициировать сеанс на сервере (если такой сеанс существует).</summary>
        <value>Значение <see langword="true" />, если операции разрешено инициировать сеанс на сервере; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> определяет, может ли операция быть первой операцией, вызванной при создании сеанса.  
  
> [!NOTE]
>  Свойство <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> должно иметь значение <xref:System.ServiceModel.SessionMode.Allowed> или <xref:System.ServiceModel.SessionMode.Required>, а используемая привязка должна требовать или разрешать сеансы для правильной работы свойства <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>.  
  
 Значение по умолчанию — `true`. Это означает, что операция может быть первой операцией, вызванной в канале. В дальнейшем вызовы инициирующего метода не будут оказывать влияние, кроме вызова метода. Другие сеансы не создаются. Если контракт не использует сеанс, задание для свойства <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> значения `false` игнорируется.  
  
 Обычно для свойства <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> задается значение `false`, чтобы заставить клиентов вызывать другой метод в службе перед вызовом данного метода. Например, если служба имеет ряд операций, зависящих от идентификационного номера заказа, можно присвоить свойству <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> значение `true` для операции службы `GetOrderId`, а для всех остальных операций службы задать значение `false`. Это обеспечит получение каждым новым клиентом номера заказа до использования других методов, представленных данной службой.  
  
> [!NOTE]
>  Между свойствами <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> и <xref:System.ServiceModel.OperationContractAttribute.Action%2A> существует взаимодействие. Контракт службы может содержать только одну операцию службы со значением "*" свойства <xref:System.ServiceModel.OperationContractAttribute.Action%2A>. Любая группа контрактов, размещенная на одном URI прослушивания, который реализует класс службы может содержать несколько операций с <xref:System.ServiceModel.OperationContractAttribute.Action%2A> установлено значение "\*" при <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> свойству `false`. Однако только один из этих методов службы может иметь <xref:System.ServiceModel.OperationContractAttribute.Action%2A> установлено значение "\*" и <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> свойство значение `true`.  
  
 Если служба принимает сообщение для неинициирующей операции, она возвращает сообщение об ошибке SOAP ActionNotSupported. Для клиента это выглядит как исключение <xref:System.ServiceModel.FaultException>. Если сначала клиент вызывает неинициирующую операцию, его среда выполнения вызывает исключение <xref:System.InvalidOperationException?displayProperty=nameWithType>.  
  
 Дополнительные сведения см. в разделе [с использованием сеансов](~/docs/framework/wcf/using-sessions.md).  
  
   
  
## Examples  
 В следующем примере представлена служба, которая реализует контракт службы, определяющий три метода. Службе требуется сеанс. Если первый вызов вызывающего объекта предназначен для любой операции, кроме `MethodOne`, канал отклоняется и создается исключение. Если вызывающий объект инициирует сеанс, вызывая операцию `MethodOne`, он может завершить этот сеанс связи в любое время, вызвав операцию `MethodThree`. Операция `MethodTwo` может быть вызвана в течение сеанса любое число раз.  
  
```csharp  
[ServiceContract(SessionMode=SessionMode.Required)]  
public class InitializeAndTerminateService  
{  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=true,  
    IsTerminating=false  
  )]  
  public void MethodOne()  
  {  
    return;  
  }  
  
  [OperationContract(  
    IsInitiating=false,  
    IsTerminating=false  
  )]  
  public int MethodTwo(int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=false,  
    IsTerminating=true  
  )]  
  public void MethodThree()  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public bool IsOneWay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOneWay" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsOneWay" />
      <MemberSignature Language="VB.NET" Value="Public Property IsOneWay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOneWay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsOneWay : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsOneWay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, возвращает ли операция ответное сообщение.</summary>
        <value>Значение <see langword="true" />, если этот метод получает сообщение запроса и не возвращает ответное сообщение; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A>, чтобы указать, что операция не возвращает ответное сообщение. Этот тип операции полезен для уведомлений или связи в стиле событий, особенно в двусторонней связи. Не ожидая базового ответного сообщения, вызывающие объекты односторонних операций не могут непосредственно обнаружить сбой в обработке ответного сообщения. (Приложения службы, использующие надежные каналы и односторонние операции, могут обнаружить сбой доставки сообщения на уровне канала. Дополнительные сведения см. в разделе [Общие сведения о надежных сеансах](~/docs/framework/wcf/feature-details/reliable-sessions-overview.md).)  
  
 В дуплексных (или двусторонних), ориентированных на службы приложениях, в которых клиент и сервер взаимодействуют друг с другом независимо, клиентский канал может использовать свойство <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> в своих методах, чтобы указать, что служба может направлять односторонние вызовы клиенту, которые клиент может трактовать как события. Возвращаемых вызовов и сообщений не создается, поскольку служба не ожидает никаких ответных сообщений.  
  
 Если для свойства <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> задано значение `false` (по умолчанию), даже методы, возвращающие `void`, приводят к ответному сообщению. В этом случае инфраструктура создает и отправляет пустое сообщение, чтобы указать вызывающему объекту о возврате метода. (Использование такого подхода позволяет инфраструктуре отправлять сообщения об ошибках SOAP назад клиенту.) Единственный способ отменить создание и отправку ответного сообщения — задание для свойства <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> значения `true`.  
  
 Односторонние методы не должны возвращать значение и иметь параметры `ref` или `out`; в противном случае вызывается исключение <xref:System.InvalidOperationException?displayProperty=nameWithType>.  
  
 Если указывается, что операция является односторонней, это означает только то, что ответное сообщение отсутствует. Если соединение установить невозможно, а также если исходящее сообщение слишком велико или служба не может достаточно быстро прочитать входящую информацию, возможна блокировка. Если клиенту требуется вызов без блокировки, создайте операции <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A>. Дополнительные сведения см. в разделе [служб односторонняя](~/docs/framework/wcf/feature-details/one-way-services.md) и [доступ к службам, с помощью клиента WCF](~/docs/framework/wcf/feature-details/accessing-services-using-a-client.md).  
  
   
  
## Examples  
 В следующем примере представлена служба, которая реализует контракт службы, определяющий три операции. Два из трех этих методов реализуют двусторонние операции, которые возвращают базовые ответные сообщения вызывающему объекту независимо от возвращаемого значения. Третий метод реализует операцию, которая принимает вызов (базовое входящее сообщение), но не возвращает базового ответного сообщения.  
  
```csharp  
[ServiceContract]  
public class OneAndTwoWay  
{  
  // The client waits until a response message appears.  
  [OperationContract]  
  public int MethodOne (int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  // The client waits until an empty response message appears.  
  [OperationContract]  
  public void MethodTwo (int x)  
  {  
    return;  
  }  
  
  // The client returns as soon as an outbound message  
  // is queued for dispatch to the service; no response  
  // message is generated or sent.  
  [OperationContract(IsOneWay=true)]  
  public void MethodThree (int x)  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTerminating">
      <MemberSignature Language="C#" Value="public bool IsTerminating { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTerminating" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsTerminating" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTerminating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTerminating { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTerminating : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsTerminating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, приводит ли операция службы к закрытию сеанса сервером после отправки ответного сообщения, если оно есть.</summary>
        <value>Значение <see langword="true" />, если операция приводит к закрытию сеанса сервером; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A>, чтобы указать, что вызов операции службы завершает сеанс связи.  
  
 В клиентском приложении, значение <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> присвоено `true` указывает WCF закрыть канал после поступления ответа.  
  
 В службе устанавливается таймер и, если в течение определенного этим таймером времени клиент не закрывает канал, канал прерывается.  
  
 Дополнительные сведения об использовании этого свойства с сеансами см. в разделе [с использованием сеансов](~/docs/framework/wcf/using-sessions.md).  
  
> [!NOTE]
>  Если вызывающий объект прослушивает событие <xref:System.ServiceModel.OperationContext.OperationCompleted?displayProperty=nameWithType> для операции <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A?displayProperty=nameWithType>, при получении ответа возможна блокировка. Для надлежащей обработки такой ситуации необходимо запланировать работу в другом потоке при появлении события <xref:System.ServiceModel.OperationContext.OperationCompleted> и затем немедленно вернуться из этого обработчика событий.  
  
   
  
## Examples  
 В следующем примере представлена служба, которая реализует контракт службы, определяющий три операции. Службе требуется соединение с отслеживанием состояния. Если первый вызов вызывающего объекта предназначен для любой операции, кроме `MethodOne`, канал отклоняется и создается исключение. Если вызывающий объект инициирует сеанс, вызывая операцию `MethodOne`, он может завершить этот сеанс связи в любое время, вызвав операцию `MethodThree`. Операция `MethodTwo` может быть вызвана в течение сеанса любое число раз.  
  
```csharp  
[ServiceContractAttribute(SessionMode=SessionMode.Required)]  
public class InitializeAndTerminateService  
{  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=true,  
    IsTerminating=false  
  )]  
  public void MethodOne()  
  {  
    return;  
  }  
  
  [OperationContract(  
    IsInitiating=false,  
    IsTerminating=false  
  )]  
  public int MethodTwo(int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=false  
    IsTerminating=true  
  )]  
  public void MethodThree()  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя операции.</summary>
        <value>Имя операции.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.ServiceModel.OperationContractAttribute.Name%2A> свойство, следует переопределить <`operation`> имя элемента в WSDL. По умолчанию именем операции является имя метода реализации.  
  
   
  
## Examples  
 В следующем примере кода используется свойство <xref:System.ServiceModel.OperationContractAttribute.Name%2A> для объявления имени операции, которое представлено в метаданных.  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.ServiceModel.OperationContractAttribute.Name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значением является пустая строка.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.OperationContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должны ли сообщения операции шифроваться, подписываться или шифроваться и подписываться.</summary>
        <value>Одно из значений <see cref="T:System.Net.Security.ProtectionLevel" />. Значение по умолчанию — <see cref="F:System.Net.Security.ProtectionLevel.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A>, чтобы указать, должны ли сообщения операции шифроваться, подписываться или шифроваться и подписываться. Заданное здесь значение является значением по умолчанию для всех сообщений, определенных для данной операции, если более узкая область не переопределит это значение.  
  
 Важно помнить, что поведение защиты в среде выполнения — это комбинация значений уровня защиты, заданных в следующих свойствах. Эти свойства имеют иерархическую структуру. При задании внешнего значения устанавливается значение по умолчанию для всех более узких областей, если явно не задано другое значение для более узкой области. В этом случае внешнее значение остается значением по умолчанию для всех более узких областей за исключением тех областей, для которых задано иное значение.  
  
 Например, если для уровня <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> задано значение <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> и другие более узкие области не имеют параметров уровня защиты, все сообщения в контракте операции шифруются и подписываются. Однако если атрибуту <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> одной из этих операций присвоено значение <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, сообщения для этой операции подписываются, а все другие сообщения в контракте шифруются и подписываются.  
  
 Дополнительные сведения об уровнях защиты и их предположений и областей см. в разделе [уровень защиты понимание](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Ниже приводятся области, в которых заданы эти значения.  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 Свойство <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> атрибута <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.  
  
 Свойство <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> атрибута <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.  
  
 Если в контракте отсутствует явно заданный уровень защиты, а базовая привязка поддерживает безопасность (как на транспортном уровне, так и на уровне сообщений), эффективным уровнем защиты для всего контракта является <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>. Если привязка не поддерживает безопасность (например, <xref:System.ServiceModel.BasicHttpBinding>), эффективным уровнем <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> является <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> для всего контракта. В результате в зависимости от привязки конечной точки клиенты могут требовать разную степень защиты на уровне сообщений или транспортном уровне, даже если контракт задает <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Данное значение не является одним из значений <see cref="T:System.Net.Security.ProtectionLevel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReplyAction">
      <MemberSignature Language="C#" Value="public string ReplyAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ReplyAction" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.ReplyAction" />
      <MemberSignature Language="VB.NET" Value="Public Property ReplyAction As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ReplyAction { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReplyAction : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.ReplyAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение действия SOAP для ответного сообщения операции.</summary>
        <value>Значение действия SOAP для ответного сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Помимо задания конкретного значения для заголовка действия ответного сообщения, можно также указать строку "*" (звездочка). Звездочка в службе указывает WCF не для того, чтобы добавить действие ответа в сообщение, что полезно при программировании сообщения напрямую. Звездочка в клиентском приложении указывает WCF не проверять ответное действие.  
  
   
  
## Examples  
 В следующем примере представлена служба, которая использует свойства <xref:System.ServiceModel.OperationContractAttribute.Action%2A> и <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> для явного управления действиями SOAP входных и выходных (или ответных) сообщений. В этом примере также используется свойство <xref:System.ServiceModel.OperationContractAttribute.Name%2A> для объявления имени операции, которое представлено в метаданных.  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.ServiceModel.OperationContractAttribute.ReplyAction" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>