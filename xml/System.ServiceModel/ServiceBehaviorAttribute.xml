<Type Name="ServiceBehaviorAttribute" FullName="System.ServiceModel.ServiceBehaviorAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d189e4c6144e1a754ee34f3bee909a94e068d2e2" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55355707" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceBehaviorAttribute : Attribute, System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceBehaviorAttribute extends System.Attribute implements class System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceBehaviorAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceBehaviorAttribute&#xA;Inherits Attribute&#xA;Implements IServiceBehavior" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBehaviorAttribute sealed : Attribute, System::ServiceModel::Description::IServiceBehavior" />
  <TypeSignature Language="F#" Value="type ServiceBehaviorAttribute = class&#xA;    inherit Attribute&#xA;    interface IServiceBehavior" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IServiceBehavior</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Задает поведение внутреннего выполнения реализации контракта службы.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Примените атрибут <xref:System.ServiceModel.ServiceBehaviorAttribute> к реализации службы, чтобы задать поведение выполнения в масштабе всей службы. (Чтобы задать поведение выполнения на уровне метода, используйте атрибут <xref:System.ServiceModel.OperationBehaviorAttribute>.) Этот атрибут можно применять только для реализаций службы. Рабочие примеры см. в разделе [службы: Примеры поведения](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)).  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute> свойства являются возможностью модели программирования Windows Communication Foundation (WCF), обеспечивающей общие возможности, которые разработчики в ином случае должен реализовывать. Дополнительные сведения об этих и других поведений см. в разделе [указание поведения службы во время выполнения](~/docs/framework/wcf/specifying-service-run-time-behavior.md). Дополнительные сведения о базовых свойствах среды выполнения, некоторые из следующий набор свойств, см. в разделе [расширение ServiceHost и уровень модели службы](~/docs/framework/wcf/extending/extending-servicehost-and-the-service-model-layer.md).  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> задает тип фильтра, который использует система диспетчера для определения расположения конечной точки, обрабатывающей запросы.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> автоматически завершает сеанс после закрытия канала и завершения обработки остающихся сообщений службой.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> контролирует внутреннюю модель потоков, обеспечивая поддержку служб с повторными входящими вызовами или многопоточных служб.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> используется для объявления имени, используемого в атрибуте `name` элемента `<service>` в файле конфигурации.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> позволяет среде выполнения игнорировать дополнительную информацию о сериализации, которая не требуется для обработки сообщения.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> определяет, возвращаются ли необработанные исключения в службе в качестве ошибок SOAP. Это предназначено только для отладки.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> задает, будут ли и, если будут, когда службы и объекты служб удаляться во время обмена с клиентом.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> ограничивает число сериализуемых элементов в графе объекта.  
  
-   Свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> и <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> контролируют имя и пространство имен для выражения WSDL элемента службы.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> определяет, удаляется ли объект службы по завершении транзакции.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> определяет, завершаются ли ожидающие обработки транзакции при завершении сеанса.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> задает уровень изоляции транзакций, поддерживаемый контрактом.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> задает период времени, в течение которого транзакция должна быть завершена или прервана.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> определяет, следует ли автоматически синхронизировать входящие вызовы метода с потоком пользовательского интерфейса.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> сообщает системе, должна ли она подтверждать, что заголовки SOAP, отмеченные как `MustUnderstand`, фактически были поняты.  
  
 Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> также можно задать с помощью файла конфигурации приложения. Дополнительные сведения см. в разделе <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A>.  
  
   
  
## Examples  
 В следующем примере кода показаны свойства <xref:System.ServiceModel.ServiceBehaviorAttribute>. Класс `BehaviorService` использует атрибут <xref:System.ServiceModel.ServiceBehaviorAttribute>, чтобы указать следующее.  
  
-   Объект службы удаляется по завершении транзакции.  
  
-   Для каждого сеанса существует один объект службы.  
  
-   Служба является однопоточной и не поддерживает повторные входящие вызовы.  
  
 Более того, на уровне операций значения <xref:System.ServiceModel.OperationBehaviorAttribute> указывают, что метод `TxWork` автоматически выполняет зачисление в поток транзакций или создает для этого новую транзакцию; транзакция выполняется автоматически, если не выдается необработанное исключение.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Чтобы следующий пример кода выполнялся правильно, базовая привязка должна поддерживать поток транзакций. Для поддержки потока транзакций с использованием <xref:System.ServiceModel.WSHttpBinding> можно, например, задать для свойства <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> значение `true` в коде или в файле конфигурации приложения. В следующем примере кода показан файл конфигурации для предыдущего примера.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationBehaviorAttribute" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)">Служба: Пример поведений</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBehaviorAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBehaviorAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.ServiceBehaviorAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для атрибута <xref:System.ServiceModel.ServiceBehaviorAttribute> по умолчанию заданы следующие значения.  
  
-   Для <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> задано значение <xref:System.ServiceModel.AddressFilterMode.Exact>.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> — `true`.  
  
-   Для <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> задано значение <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> является полным именем пространства имен типа без информации о сборке.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> — `false`.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> равно 64 КБ.  
  
-   Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> является именем типа службы без информации о пространстве имен или сборке.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> Свойство "http://tempuri.org«.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> — `true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> — `false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> — `true`.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> — `false`.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> — <xref:System.Transactions.IsolationLevel.Unspecified>.  
  
-   Свойству <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> задано значение <xref:System.TimeSpan.Zero>.  
  
-   Значение свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> — `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressFilterMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AddressFilterMode AddressFilterMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AddressFilterMode AddressFilterMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AddressFilterMode As AddressFilterMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AddressFilterMode AddressFilterMode { System::ServiceModel::AddressFilterMode get(); void set(System::ServiceModel::AddressFilterMode value); };" />
      <MemberSignature Language="F#" Value="member this.AddressFilterMode : System.ServiceModel.AddressFilterMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AddressFilterMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает <see cref="T:System.ServiceModel.AddressFilterMode" />, используемый диспетчером для маршрутизации входящих сообщений на правильную конечную точку.</summary>
        <value>Объект <see cref="T:System.ServiceModel.AddressFilterMode" />, используемый диспетчером для маршрутизации входящих сообщений на правильную конечную точку.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Данное значение не является одним из значений <see cref="T:System.ServiceModel.AddressFilterMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutomaticSessionShutdown">
      <MemberSignature Language="C#" Value="public bool AutomaticSessionShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticSessionShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticSessionShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutomaticSessionShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticSessionShutdown : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, следует ли автоматически завершать сеанс, когда клиент закрывает выходной сеанс.</summary>
        <value>Значение <see langword="true" />, если служба автоматически завершает сеанс при закрытии клиентом выходящего сеанса; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию, когда клиент закрывает выходящий сеанс, а служба закончила обработку всех оставшихся сообщений, сервер завершает сеанс. Присвоение свойству <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> значения `false` предотвращает автоматическое завершение сеанса сервером и разрешает пользовательское управление временем существования сеанса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcurrencyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ConcurrencyMode ConcurrencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ConcurrencyMode ConcurrencyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ConcurrencyMode As ConcurrencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ConcurrencyMode ConcurrencyMode { System::ServiceModel::ConcurrencyMode get(); void set(System::ServiceModel::ConcurrencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.ConcurrencyMode : System.ServiceModel.ConcurrencyMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает поддержку службой одного потока, нескольких потоков или повторных входящих вызовов.</summary>
        <value>Одно из значений <see cref="T:System.ServiceModel.ConcurrencyMode" />; значение по умолчанию — <see cref="F:System.ServiceModel.ConcurrencyMode.Single" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство указывает, может ли экземпляр службы обрабатывать один поток или несколько потоков, выполняемых одновременно, и поддерживаются ли повторные входящие вызовы в однопоточном режиме.  
  
> [!NOTE]
>  Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> взаимодействует с некоторыми другими параметрами. Например, если значение <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> задано как <xref:System.ServiceModel.InstanceContextMode.Single>, служба сможет обрабатывать в конкретный момент времени только одно сообщение, пока значение <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> также не будет задано как <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Это свойство также задает поведение в сочетании со свойством <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType>. Дополнительные сведения см. в разделе [сеансы, создание экземпляров и параллелизм](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Установка для параметра <xref:System.ServiceModel.ConcurrencyMode> значения <xref:System.ServiceModel.ConcurrencyMode.Single> приводит к тому, что система не дает экземплярам службы одновременно выполнять более одного потока, что позволяет избежать решения вопросов многопоточности. Значение <xref:System.ServiceModel.ConcurrencyMode.Multiple> означает, что объекты службы могут выполняться несколькими потоками одновременно. В этом случае необходимо обеспечить безопасность потоков.  
  
 <xref:System.ServiceModel.ConcurrencyMode.Reentrant> также ограничивает доступ к одному потоку за раз; во время обработки операции другое сообщение не может в нее войти. Если во время операции вызов другой службы исчезает, текущее сообщение теряет блокировку операции, которая может обрабатывать другие сообщения. Когда вызов службы возвращается, блокировка восстанавливается и исходное сообщение продолжает обрабатываться до завершения или до возникновения другого вызова операции.  
  
> [!IMPORTANT]
>  Несмотря на то что <xref:System.ServiceModel.ConcurrencyMode.Single> ограничивает экземпляры службы одним потоком выполнения за раз, необходимо также задать <xref:System.ServiceModel.Description.ServiceThrottlingBehavior.MaxConcurrentCalls%2A> значение 1, чтобы гарантировать ни одного из неупорядоченные сообщения.  
>   
>  Кроме того отвечаете оставить состояние объекта согласованные до вызовов и необходимо подтвердить допустимость данных локальной операции после вызовов. Обратите внимание, что экземпляр службы разблокируется только путем вызова другой службы по каналу WCF. В этом случае вызванная служба может повторно войти в первую службу через обратный вызов. Если первая служба не допускает повторные входящие вызовы, последовательность вызовов приводит к взаимоблокировке. Дополнительные сведения см. в разделе <xref:System.ServiceModel.ConcurrencyMode>.  
  
 Во время любого исходящего вызова из обрабатывающей операции нелокальные в отношении операции данные могут быть изменены. (Для локальных данных состояния гарантируется допустимость, когда продолжается обработка исходного сообщения.) В результате этого перед исходящим вызовом необходимо убедиться, что нелокальные данные допустимы для других входящих вызовов и повторно проверить нелокальные данные после возвращения исходящего вызова.  
  
 В следующем псевдокоде показан необходимый шаблон для успешной поддержки повторных входящих вызовов.  
  
```csharp  
public void MyMethod()  
{  
  this.SomeNonLocalDataState;  
  // Here you need to clean nonlocal state for other users  
  OutboundProxy proxy = new OutboundProxy();  
  int returnValue = proxy.CallOutOfOperation();  
  // Ensure that this.SomeNonLocalDataState is valid for continued use.  
  this.ModifyNonLocalState;  
  return returnValue;  
}  
  
```  
  
 С помощью шаблона асинхронных вызовов Begin/End для исходящего вызова, когда <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> является <xref:System.ServiceModel.ConcurrencyMode.Reentrant>, выдается исключение. Для асинхронных исходящих вызовов требуется операция, при которой <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> является <xref:System.ServiceModel.ConcurrencyMode.Multiple>, и в этом случае следует обработать проблемы синхронизации.  
  
 Обычно в случае прибытия сообщения для экземпляра, нарушающего режим параллелизма, сообщение ожидает доступности экземпляра или истечения срока своего действия.  
  
 Кроме того, если для параметра <xref:System.ServiceModel.ConcurrencyMode> задано значение <xref:System.ServiceModel.ConcurrencyMode.Single> и если повторный входящий вызов блокируется во время ожидания освобождения экземпляра, система обнаруживает взаимоблокировку и выдает исключение.  
  
> [!NOTE]
>  Во время выполнения выдается <xref:System.InvalidOperationException>, если <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> является `true`, когда свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> задано как <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
 Обратите внимание, что необходимо явно задать <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> `false`, если имеется операция с <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType>, заданным как true, и задается <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> как <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. В противном случае будет выдано исключение проверки, поскольку значение по умолчанию <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> — `true`.  
  
 Существует взаимодействие <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> и других свойств, которые могут изменить поведение среды выполнения. Полное описание таких взаимодействий, см. в разделе [сеансы, создание экземпляров и параллелизм](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
   
  
## Examples  
 В следующем примере кода показано различие между использованием значений <xref:System.ServiceModel.ConcurrencyMode.Single>, <xref:System.ServiceModel.ConcurrencyMode.Reentrant> и <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Этот пример не компилируется без фактической реализации его, однако показывается вид потоков гарантии, что делает Windows Communication Foundation (WCF), и что это означает для кода операции.  
  
 [!code-csharp[C_BestPractices-Concurrency#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_bestpractices-concurrency/cs/reentrantandmultiple.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Данное значение не является одним из значений <see cref="T:System.ServiceModel.ConcurrencyMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, используемое для поиска элемента службы в файле конфигурации приложения.</summary>
        <value>Значение, которое требуется найти в файле конфигурации. Значением по умолчанию является полное имя типа без информации о сборке.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте это значение, чтобы задать определенную службу в файле конфигурации.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение — null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значением является пустая строка.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, обеспечивается ли отправка с упорядочением службой.</summary>
        <value>Значение <see langword="true" />, если обеспечивается отправка с упорядочением службой; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public object GetWellKnownSingleton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetWellKnownSingleton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.GetWellKnownSingleton" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWellKnownSingleton () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetWellKnownSingleton();" />
      <MemberSignature Language="F#" Value="member this.GetWellKnownSingleton : unit -&gt; obj" Usage="serviceBehaviorAttribute.GetWellKnownSingleton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает объект, реализующий службу и используемый в качестве одноэлементного экземпляра службы, или выводит <see langword="null" />, если одноэлементный экземпляр отсутствует.</summary>
        <returns>Реализация службы. Значение по умолчанию — <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, отличное от `null`, предоставляет экземпляр службы, в который отправляются все сообщения, адресованные службе.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExtensionDataObject">
      <MemberSignature Language="C#" Value="public bool IgnoreExtensionDataObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreExtensionDataObject" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreExtensionDataObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreExtensionDataObject { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreExtensionDataObject : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, требуется ли передавать по линии связи неизвестные данные сериализации.</summary>
        <value><see langword="true" />, если неизвестные данные сериализации никогда не передаются; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если тип реализует <xref:System.Runtime.Serialization.IExtensibleDataObject> интерфейс, он хранит дополнительные данные, он не знает о, поступающие по сети при десериализации, в данный тип. Например, если тип `Person` имеет члены `FirstName` и `LastName` и для него поступает элемент `PhoneNumber`, этот элемент сохраняется. При последующей сериализации типа объект `PhoneNumber` создается заново. Проблема в том, схема для `Person` экспортируемые только наличие службы `FirstName` и `LastName`, поэтому Windows Communication Foundation (WCF) создает экземпляр с недопустимой схемой! Если важно строгое соответствие схеме, можно установить для параметра <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> значение `true`, чтобы отключить повторное создание поведения.  
  
 Независимо от <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> , WCF всегда обрабатывает известные данные (входящие и исходящие) и не выдает исключения при поступлении дополнительных данных. Можно также задать это свойство с помощью [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) элемент в файле конфигурации приложения.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> и реализация <xref:System.Runtime.Serialization.IExtensibleDataObject>. В этом примере, где для <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> задано `false`, известные клиенту дополнительные данные передаются клиенту и обратно.  
  
 [!code-csharp[DCAContainerNoValidation#1](~/samples/snippets/csharp/VS_Snippets_CFX/dcacontainernovalidation/cs/services.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeExceptionDetailInFaults">
      <MemberSignature Language="C#" Value="public bool IncludeExceptionDetailInFaults { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeExceptionDetailInFaults" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeExceptionDetailInFaults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeExceptionDetailInFaults { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeExceptionDetailInFaults : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, что общие необработанные исключения выполнения должны преобразовываться в исключения <see cref="T:System.ServiceModel.FaultException`1" /> типа <see cref="T:System.ServiceModel.ExceptionDetail" /> и передаваться в виде сообщения об ошибке. Задавайте значение <see langword="true" /> только во время разработки для устранения неполадок службы.</summary>
        <value><see langword="true" />, если необработанное исключение должно возвращаться в виде ошибок SOAP; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы разрешить отправку информации об исключениях клиентам для целей отладки, для свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> следует задать значение `true`. Для этого свойства требуется привязка, поддерживающая либо обмен сообщениями типа «запрос-ответ», либо дуплексный обмен.  
  
 Во всех управляемых приложениях обработка ошибок представлена объектами <xref:System.Exception>. В приложениях на базе SOAP, например приложений WCF методы, реализующие операции служб передачу информации об ошибке, с помощью сообщения об ошибках SOAP. Поскольку приложения WCF, выполняются в системах ошибок обоих типов, любые сведения управляемых исключений, который требуется отправить клиенту должны преобразовываться из исключений в ошибки SOAP. Дополнительные сведения см. в разделе [задание и обработка сбоев в контрактах и службах](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).  
  
 Во время разработки может понадобиться, чтобы служба также отправляла клиенту другие исключения для упрощения отладки. Эта возможность предназначается только для этапа разработки, ее не следует использовать в рабочих версиях служб.  
  
 Чтобы упростить разработку с отладкой, задайте <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> для `true` в коде или с помощью файла конфигурации приложения.  
  
 Когда эта функция включена, служба автоматически возвращает вызывающему объекту информацию о более безопасных исключениях. Эти ошибки выглядят для клиента как объекты <xref:System.ServiceModel.FaultException%601> типа <xref:System.ServiceModel.ExceptionDetail>.  
  
> [!IMPORTANT]
>  Установка <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> для `true` позволяет клиентам получать информацию о внутренних исключениях метода службы; это рекомендуется только как временное средство отладки служебного приложения. Кроме того, WSDL для метода, который возвращает такие необработанные управляемые исключения, не содержит контракт для исключения <xref:System.ServiceModel.FaultException%601> типа <xref:System.ServiceModel.ExceptionDetail>. В клиентах должна быть предусмотрена возможность принятия неизвестной ошибки SOAP для правильного получения отладочной информации.  
  
 Этому свойству присвоить `true` также можно сделать с помощью файла конфигурации приложения и [ &lt;serviceDebug&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicedebug.md) элемента, как показано в следующем примере кода.  
  
 [!code-xml[OperationBehaviorAttribute1#10](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#10)]   
   
  
## Examples  
 В следующем примере кода показаны свойства <xref:System.ServiceModel.ServiceBehaviorAttribute>. Класс `BehaviorService` использует атрибут <xref:System.ServiceModel.ServiceBehaviorAttribute>, чтобы указать следующее.  
  
-   Для потока пользовательского интерфейса вызываются методы реализации.  
  
-   Для каждого сеанса существует один объект службы.  
  
-   Служба является однопоточной и не поддерживает повторные входящие вызовы.  
  
 Более того, на уровне операций значения <xref:System.ServiceModel.OperationBehaviorAttribute> указывают, что метод `TxWork` автоматически выполняет зачисление в поток транзакций или создает для этого новую транзакцию; транзакция выполняется автоматически, если не выдается необработанное исключение.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Чтобы следующий пример кода выполнялся правильно, базовая привязка должна поддерживать поток транзакций. Для поддержки потока транзакций с использованием <xref:System.ServiceModel.WSHttpBinding> можно, например, задать для свойства <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> значение `true` в коде или в файле конфигурации приложения. В следующем примере кода показан файл конфигурации для предыдущего примера.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContextMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContextMode InstanceContextMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.InstanceContextMode InstanceContextMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceContextMode As InstanceContextMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContextMode InstanceContextMode { System::ServiceModel::InstanceContextMode get(); void set(System::ServiceModel::InstanceContextMode value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContextMode : System.ServiceModel.InstanceContextMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContextMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, когда создаются новые объекты службы.</summary>
        <value>Одно из значений <see cref="T:System.ServiceModel.InstanceContextMode" />; значением по умолчанию является <see cref="F:System.ServiceModel.InstanceContextMode.PerSession" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.ServiceModel.InstanceContextMode>, чтобы указать, когда создаются новые объекты службы. Поскольку объект службы не подключен напрямую к каналу связи, время существования объектов службы не зависит от времени существования канала между клиентом и служебным приложением. Значение по умолчанию, <xref:System.ServiceModel.InstanceContextMode.PerSession>, направляет приложению службы инструкции создать новый объект службы, когда между клиентом и приложением службы устанавливается новый сеанс связи. Последующие вызовы в одном и том же сеансе обрабатываются тем же объектом.  
  
 <xref:System.ServiceModel.InstanceContextMode.PerSession> указывает, что каждый объект службы обрабатывает запросы из одного клиентского канала.  
  
> [!NOTE]
>  Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> взаимодействует с некоторыми другими параметрами. Например, если значение <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> задано как <xref:System.ServiceModel.InstanceContextMode.Single>, служба сможет обрабатывать в конкретный момент времени только одно сообщение, пока значение <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> также не будет задано как <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Это свойство также задает поведение в сочетании со свойством <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType>. Дополнительные сведения см. в разделе [сеансы, создание экземпляров и параллелизм](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Для поведения времени существования одного элемента (например, если ведущее приложение вызывает конструктор <xref:System.ServiceModel.ServiceHost.%23ctor%2A> и передает объект для использования в качестве службы), класс службы должен задавать <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> как `Single`, в противном случае во время выполнения выдается исключение.  
  
   
  
## Examples  
 В следующем примере кода показаны свойства <xref:System.ServiceModel.ServiceBehaviorAttribute>. Класс `BehaviorService` использует атрибут <xref:System.ServiceModel.ServiceBehaviorAttribute>, чтобы указать следующее.  
  
-   Для потока пользовательского интерфейса вызываются методы реализации.  
  
-   Для каждого сеанса существует один объект службы.  
  
-   Служба является однопоточной и не поддерживает повторные входящие вызовы.  
  
 Более того, на уровне операций значения <xref:System.ServiceModel.OperationBehaviorAttribute> указывают, что метод `TxWork` автоматически выполняет зачисление в поток транзакций или создает для этого новую транзакцию; транзакция выполняется автоматически, если не выдается необработанное исключение.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Чтобы следующий пример кода выполнялся правильно, базовая привязка должна поддерживать поток транзакций. Для поддержки потока транзакций с использованием <xref:System.ServiceModel.WSHttpBinding> можно, например, задать для свойства <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> значение `true` в коде или в файле конфигурации приложения. В следующем примере кода показан файл конфигурации для предыдущего примера.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Данное значение не является одним из значений <see cref="T:System.ServiceModel.InstanceContextMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxItemsInObjectGraph">
      <MemberSignature Language="C#" Value="public int MaxItemsInObjectGraph { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxItemsInObjectGraph" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxItemsInObjectGraph As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxItemsInObjectGraph { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxItemsInObjectGraph : int with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество элементов, допустимое в сериализованном объекте.</summary>
        <value>Максимальное количество элементов, разрешенное в объекте. Значение по умолчанию — 65 536 байт (64 КБ).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> используется для задания ограничения количества сериализуемых элементов в графе объекта. Можно также задать это свойство с помощью [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) элемент в файле конфигурации приложения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение атрибута имени в элементе службы в языке WSDL.</summary>
        <value>Значение атрибута имени в элементе <see langword="&lt;wsdl:service&gt;" /> при экспорте.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение целевого пространства имен для службы в языке WSDL.</summary>
        <value>Значение атрибута <see langword="targetNamespace" /> для элемента <see langword="&lt;wsdl:definitions&gt;" />, содержащего элемент <see langword="&lt;wsdl:service&gt;" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ReleaseServiceInstanceOnTransactionComplete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Property ReleaseServiceInstanceOnTransactionComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReleaseServiceInstanceOnTransactionComplete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReleaseServiceInstanceOnTransactionComplete : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли объект службы выпускаться после успешного выполнения текущей транзакции.</summary>
        <value>Значение <see langword="true" />, если объект службы должен выпускаться; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что необходимо явно задать <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> `false`, если имеется операция с <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType>, заданным как true, и задается <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> как <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. В противном случае будет выдано исключение проверки, поскольку значение по умолчанию <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> — `true`.  
  
 Кроме того, важно понимать, что если служба создается путем передачи объекта службы в конструктор <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType>, значение этого свойства считается `false`.  
  
   
  
## Examples  
 В следующем примере кода уровень изоляции транзакции задается как <xref:System.Transactions.IsolationLevel.ReadCommitted>, отключается поддержка параллельных транзакций, требуется потоковая транзакция из вызова операции и автоматически фиксируется транзакция в службе в случае отсутствия необработанных исключений.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 Чтобы следующий пример кода выполнялся правильно, базовая привязка должна поддерживать поток транзакций. Для поддержки потока транзакций с использованием <xref:System.ServiceModel.WSHttpBinding> можно, например, задать для свойства <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> значение `true` в коде или в файле конфигурации приложения. В следующем примере кода показан файл конфигурации для предыдущего примера.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public void SetWellKnownSingleton (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetWellKnownSingleton(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetWellKnownSingleton (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetWellKnownSingleton(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetWellKnownSingleton : obj -&gt; unit" Usage="serviceBehaviorAttribute.SetWellKnownSingleton value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Одноэлементный экземпляр службы.</param>
        <summary>Задает объект, реализующий службу и используемый в качестве одноэлементного экземпляра службы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это обеспечивает экземпляр службы, в который отправляются все сообщения, адресованные службе.  
  
 Если для <xref:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton%2A> задано значение, отличное от `null`, <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> должен быть задан как <xref:System.ServiceModel.InstanceContextMode.Single>, в противном случае будет выдано исключение <xref:System.InvalidOperationException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeConfigurationName">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeConfigurationName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeConfigurationName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeConfigurationName () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeConfigurationName();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeConfigurationName : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeConfigurationName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, изменилось ли значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> относительно значения по умолчанию и нужно ли его сериализовать.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReleaseServiceInstanceOnTransactionComplete () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReleaseServiceInstanceOnTransactionComplete : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, изменилось ли значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> относительно значения по умолчанию и нужно ли его сериализовать.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionAutoCompleteOnSessionClose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionAutoCompleteOnSessionClose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionAutoCompleteOnSessionClose () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionAutoCompleteOnSessionClose();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionAutoCompleteOnSessionClose : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, изменилось ли значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> относительно значения по умолчанию и нужно ли его сериализовать.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionIsolationLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionIsolationLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionIsolationLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionIsolationLevel();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionIsolationLevel : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, изменилось ли значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> относительно значения по умолчанию и нужно ли его сериализовать.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionTimeout">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionTimeout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionTimeout () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionTimeout();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionTimeout : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionTimeout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, изменилось ли значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> относительно значения по умолчанию и нужно ли его сериализовать.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.AddBindingParameters">
      <MemberSignature Language="C#" Value="void IServiceBehavior.AddBindingParameters (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase, System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase, class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase, System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^ endpoints, System::ServiceModel::Channels::BindingParameterCollection ^ parameters) = System::ServiceModel::Description::IServiceBehavior::AddBindingParameters;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
        <Parameter Name="endpoints" Type="System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <param name="description">Описание службы.</param>
        <param name="serviceHostBase">Узел службы.</param>
        <param name="endpoints">Конечные точки службы.</param>
        <param name="parameters">Объекты данных, необходимые для привязок для поддержки поведения.</param>
        <summary>Передает пользовательские объекты данных в привязки, поддерживающие свойства поведения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior">
      <MemberSignature Language="C#" Value="void IServiceBehavior.ApplyDispatchBehavior (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::ApplyDispatchBehavior;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Описание службы.</param>
        <param name="serviceHostBase">Узел службы.</param>
        <summary>Настраивает среду выполнения службы для поддержки свойств поведения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.Validate">
      <MemberSignature Language="C#" Value="void IServiceBehavior.Validate (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.Validate(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.Validate(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::Validate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Описание службы.</param>
        <param name="serviceHostBase">Узел службы.</param>
        <summary>Подтверждает, что описание службы и ее узел способны поддерживать поведение.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool TransactionAutoCompleteOnSessionClose { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionAutoCompleteOnSessionClose As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionAutoCompleteOnSessionClose { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionAutoCompleteOnSessionClose : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, завершаются ли автоматически ожидающие транзакции при завершении текущего сеанса без ошибок.</summary>
        <value>Значение <see langword="true" />, если ожидающие транзакции должны завершаться при закрытии текущего сеанса без ошибок; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public System.Transactions.IsolationLevel TransactionIsolationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Transactions.IsolationLevel TransactionIsolationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionIsolationLevel As IsolationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Transactions::IsolationLevel TransactionIsolationLevel { System::Transactions::IsolationLevel get(); void set(System::Transactions::IsolationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionIsolationLevel : System.Transactions.IsolationLevel with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Transactions.IsolationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает уровень изоляции транзакции для новых транзакций, созданных в службе, и входящих транзакций, передаваемых от клиента.</summary>
        <value>Значение <see cref="T:System.Transactions.IsolationLevel" />, задающее уровень изоляции транзакции. Значение по умолчанию — <see cref="F:System.Transactions.IsolationLevel.Unspecified" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Уровень изоляции, в котором выполняется транзакция, определяет способ обработки данных при внесении изменений в другие транзакции и длительность хранения блокировок в транзакции для защиты от этих изменений. Например, значение по умолчанию <xref:System.Transactions.IsolationLevel.Unspecified> определяет, что до завершения выполнения транзакции запрещены обновление и вставка.  
  
 Это свойство также можно использовать для ограничения уровня изоляции входящих транзакций, передаваемых от клиента.  
  
   
  
## Examples  
 В следующем примере кода уровень изоляции транзакции задается как <xref:System.Transactions.IsolationLevel.ReadCommitted>, не поддерживаются параллельные транзакции, требуется потоковая транзакция из вызова метода и автоматически фиксируется транзакция в случае отсутствия необработанных исключений.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 Чтобы следующий пример кода выполнялся правильно, базовая привязка должна поддерживать поток транзакций. Для поддержки потока транзакций с использованием <xref:System.ServiceModel.WSHttpBinding> можно, например, задать для свойства <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> значение `true` в коде или в файле конфигурации приложения. В следующем примере кода показан файл конфигурации для предыдущего примера.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Данное значение не является одним из значений <see cref="T:System.Transactions.IsolationLevel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionTimeout">
      <MemberSignature Language="C#" Value="public string TransactionTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionTimeout As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionTimeout { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionTimeout : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает период времени, в течение которого транзакция должна быть завершена.</summary>
        <value>Объект <see cref="T:System.TimeSpan" />, представляющий время, в течение которого транзакция должна быть завершена; по истечении этого времени транзакция будет прервана автоматически.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение задает свойство <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout%2A?displayProperty=nameWithType>. Можно также задать это свойство с помощью [ &lt;serviceTimeouts&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicetimeouts.md) элемент в файле конфигурации приложения.  
  
   
  
## Examples  
 В следующем файле конфигурации задается период времени ожидания транзакции три минуты.  
  
 [!code-csharp[SBA.TransactionTimeout#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactiontimeout/cs/services.cs#2)]
 [!code-vb[SBA.TransactionTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactiontimeout/vb/services.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение — null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.TimeSpan.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSynchronizationContext">
      <MemberSignature Language="C#" Value="public bool UseSynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSynchronizationContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSynchronizationContext { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseSynchronizationContext : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, следует ли использовать текущий контекст синхронизации для выбора потока исполнения.</summary>
        <value><see langword="true" />, если все вызовы службы должны запускаться в потоке, указанном контекстом <see cref="T:System.Threading.SynchronizationContext" />; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется для обеспечения сходства потоков пользовательского интерфейса, требуемого некоторыми приложениями. Например, приложение Windows Forms можно зарегистрировать как одноэлементный объект службы. В этом случае все вызовы службы должны выполняться в потоке Windows Forms. В ситуации по умолчанию, в которой для <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> задано `true`, все вызовы службы синхронизируются для выполнения в потоке от <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMustUnderstand">
      <MemberSignature Language="C#" Value="public bool ValidateMustUnderstand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateMustUnderstand" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateMustUnderstand As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateMustUnderstand { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateMustUnderstand : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, кем выполняется принудительная обработка заголовка SOAP <see langword="MustUnderstand" />: системой или приложением.</summary>
        <value><see langword="true" />, если обработка заголовка SOAP <see langword="MustUnderstand" /> должна выполняться системой; в противном случае — <see langword="false" />, что означает, что эта обработка выполняется приложением. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A>, чтобы отключить принудительную проверку заголовков поступающих сообщений. При нормальном выполнении заголовки сообщений сравниваются со свойством <xref:System.ServiceModel.Channels.MessageHeaders.UnderstoodHeaders%2A> для подтверждения того, что поступающие заголовки явно обрабатываются службой. Чтобы отключить эту проверку, задайте значение `false`. Если установлено значение `false`, то приложение должно проверять заголовки с отметкой «MustUnderstand="true"» и возвращать ошибку, если один или несколько из них непонятны. Это полезно, если приложение должно принимать любые входящие сообщения SOAP (например, при использовании типизированных или нетипизированных сообщений) и выполнять пользовательскую обработку заголовков.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>