<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f8e4db44f7324cffdd0c0671b821bcd948f011eb" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53516834" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Содержит поля, предоставляющие инструкции языка MSIL для выпуска элементами класса <see cref="T:System.Reflection.Emit.ILGenerator" /> (например, <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подробное описание члена кодов операций, особенно см. в документации Common Language Infrastructure (CLI), «раздел III: Набор инструкций CIL» и «секционировать II: Определение метаданных и семантика». Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
   
  
## Examples  
 В следующем примере демонстрируется динамический метод с помощью конструкции <xref:System.Reflection.Emit.ILGenerator> для порождения `OpCodes` в <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два значения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|58|add|Добавляет два числовых значения и возвращает новое числовое значение.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` добавляется `value2`.  
  
4.  Результат помещается в стек.  
  
 Переполнение не определяется для операций с целыми числами (для управления переполнением правильный, см. в разделе <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Дополнение целого числа вместо насыщение заключает в оболочку. Например, при условии, что 8-битовых целых чисел где `value1` составляет 255 и `value2` имеет значение 1, будет получен результат является 0, а не 256.  
  
 Возвращает с плавающей запятой переполнения `+inf` (`PositiveInfinity`) или `-inf` (`NegativeInfinity`).  
  
 В следующей таблице перечислены допустимые типы операндов и их соответствующие типы данных результата. Если нет записи для сочетания определенного типа (например, `int32` и `float`; `int32` и `int64`), он является недопустимым промежуточного языка MSIL (Microsoft) и выдает ошибку.  
  
|Операнд|Значение1 типа|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `add` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два целых числа, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D6|Add.ovf|Складывает два значения целого числа со знаком с проверкой переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` добавляется `value2` с проверкой переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> возникает, если результат не представлен в тип результата.  
  
 Этой операции над знаковыми целочисленными значениями. Для значений с плавающей запятой, используйте <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 В следующей таблице перечислены допустимые типы операндов и их соответствующие типы данных результата. Если нет записи для сочетания определенного типа (например, `int32` и `float`; `int32` и `int64`), он имеет недопустимую инструкцию языка MSIL (Microsoft Intermediate) и выдает ошибку.  
  
|Операнд|Значение1 типа|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `add.ovf` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D7|Add.ovf.un|Складывает два значения целого числа без знака, с проверкой переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` добавляется `value2` с проверкой переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> возникает, если результат не представлен в тип результата.  
  
 Этой операции над знаковыми целочисленными значениями. Для значений с плавающей запятой, используйте <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 В следующей таблице перечислены допустимые типы операндов и их соответствующие типы данных результата. Если нет записи для сочетания определенного типа (например, `int32` и `float`; `int32` и `int64`), он имеет недопустимую инструкцию языка MSIL (Microsoft Intermediate) и выдает ошибку.  
  
|Операнд|Значение1 типа|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `add.ovf.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое И двух значений и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Инструкция|Описание|  
|------------|-----------------|-----------------|  
|5F|и|Вычисляет побитовое и двух целочисленных значений.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value1` и `value2` извлекаются из стека; вычисляется побитовое и двух значений.  
  
4.  Результат помещается в стек.  
  
 `and` Инструкция вычисляет побитовое и двух верхних значений в стеке и оставляет результат в стеке.  
  
 `And` представляет собой операцию целыми числами.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `and` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает неуправляемый указатель на список аргументов текущего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 00|arglist|Возвращает дескриптор списка аргументов для текущего метода.|  
  
 По этой операции выполняются не стек вычислений.  
  
 `arglist` Инструкция возвращает непрозрачный дескриптор (неуправляемый указатель, типа `native int`), представляющий список аргументов текущего метода. Этот дескриптор допустим только в течение времени существования текущего метода. Тем не менее, можно Передайте дескриптор для других методов, до тех пор, пока текущий метод является в потоке управления. Может выполняться только `arglist` инструкции в пределах метода, который принимает переменное число аргументов.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `arglist` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если два значения равны.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|Выполняет переход к целевой инструкции по смещению `target` Если два значения равны.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` равен `value2`, выполняется операция перехода.  
  
 `beq` Инструкция передает управление указанной конечной инструкции, если `value1` равен `value2`. Действует так же, как выполнение `ceq` инструкции, за которым следует `brtrue` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Допустимые типы операндов инкапсулированы ниже.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.  
  
 Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция (таких передач серьезно ограничены. их необходимо использовать <xref:System.Reflection.Emit.OpCodes.Leave> инструкции вместо этого).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `beq` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если два значения равны.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq.s `target`|Выполняет переход к целевой инструкции по смещению `target` Если объекты равны, краткая форма|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` равен `value2`, выполняется операция перехода.  
  
 `beq.s` Инструкция передает управление указанной конечной инструкции, если `value1` равен `value2`. Действует так же, как выполнение `ceq` инструкции, за которым следует `brtrue` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 1-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Допустимые типы операндов инкапсулированы ниже.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.  
  
 Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция (таких передач серьезно ограничены. их необходимо использовать <xref:System.Reflection.Emit.OpCodes.Leave> инструкции вместо этого).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `beq.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|Ветвь конечной инструкции с указанным смещением, если первое значение больше или равно значению второго.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше или равно `value2`, выполняется операция перехода.  
  
 `bge` Инструкция передает управление указанной конечной инструкции, если `value1` больше или равно `value2`. Аналогично выполнению `clt.un` инструкции, за которым следует `brfalse` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bge` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше или равно значению второго, краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше или равно `value2`, выполняется операция перехода.  
  
 `bge.s` Инструкция передает управление указанной конечной инструкции, если `value1` больше или равно `value2`. Аналогично выполнению `clt.un` инструкции, за которым следует `brfalse` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 1-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bge.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.un `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше или равно значению второго (значений без знака).|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше или равно `value2`, выполняется операция перехода.  
  
 `bge.un` Инструкция передает управление указанной конечной инструкции, если `value1` больше или равно `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Аналогично выполнению `clt` инструкции, за которым следует `brfalse` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bge.un` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше или равно ему (для значений без знака).|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше или равно `value2`, выполняется операция перехода.  
  
 `bge.un.s` Инструкция передает управление указанной конечной инструкции, если `value1` больше или равно `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Аналогично выполнению `clt` инструкции, за которым следует `brfalse` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 1-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bge.un.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3D < `int32` >|bgt `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше, чем значение второго.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше, чем `value2`, выполняется операция перехода.  
  
 `bgt` Инструкция передает управление указанной конечной инструкции, если `value1` больше, чем `value2`. Аналогично выполнению `cgt` инструкции, за которым следует `brtrue` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bgt` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt.s `target`|Ветвь конечной инструкции с указанным смещением, если первое значение больше, чем значение второго краткую форму.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше, чем `value2`, выполняется операция перехода.  
  
 `bgt.s` Инструкция передает управление указанной конечной инструкции, если `value1` больше, чем `value2`. Аналогично выполнению `cgt` инструкции, за которым следует `brtrue` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 1-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bgt.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше, чем значение второго (значений без знака).|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше, чем `value2`, выполняется операция перехода.  
  
 `bgt.un` Инструкция передает управление указанной конечной инструкции, если `value1` больше, чем `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Аналогично выполнению `cgt.un` инструкции, за которым следует `brtrue` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bgt.un` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|Ветвь конечной инструкции с указанным смещением, если первое значение больше, чем (для значений без знака).|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше, чем `value2`, выполняется операция перехода.  
  
 `bgt.un.s` Инструкция передает управление указанной конечной инструкции, если `value1` больше, чем `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Аналогично выполнению `cgt.un` инструкции, за которым следует `brtrue` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 1-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bgt.un.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго значения или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3E `<int32>`|ble `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше или равно значению второго.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` меньше или равно `value2`, выполняется операция перехода.  
  
 `ble` Инструкция передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`. Аналогично выполнению `cgt` инструкции (`cgt.un` для числа с плавающей запятой) следуют `brfalse` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ble` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше или равно значению второго, краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` меньше или равно `value2`, выполняется операция перехода.  
  
 `ble.s` Инструкция передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`. Аналогично выполнению `cgt` инструкции (`cgt.un` для числа с плавающей запятой) инструкции, за которым следует`brfalse` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 1-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ble.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble.un `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше или равно значению второго (значений без знака).|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` меньше или равно `value2`, выполняется операция перехода.  
  
 `ble.un` Инструкция передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Аналогично выполнению `cgt.un` инструкции (`cgt` для числа с плавающей запятой) следуют `brfalse` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ble.un` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble.un.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше или равно ему (для значений без знака).|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` меньше или равно `value2`, выполняется операция перехода.  
  
 `ble.un.s` Инструкция передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Аналогично выполнению `cgt.un` инструкции (`cgt` для числа с плавающей запятой) следуют `brfalse` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 1-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ble.un.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3F < `int32` >|инструкцию blt `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше второго значения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` — меньше, чем `value2`, выполняется операция перехода.  
  
 `blt` Инструкция передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`. Аналогично выполнению `clt` инструкции, за которым следует `brtrue` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `blt` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|32 < `int8` >|BLT.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше второго, краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` — меньше, чем `value2`, выполняется операция перехода.  
  
 `blt.s` Инструкция передает управление указанной конечной инструкции, если `value1` — меньше, чем `value2`. Аналогично выполнению `clt` инструкции, за которым следует `brtrue` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 1-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `blt.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|44 < `int32` >|BLT.un `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше второго значения (значений без знака).|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` — меньше, чем `value2`, выполняется операция перехода.  
  
 `blt.un` Инструкция передает управление указанной конечной инструкции, если `value1` — меньше, чем `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Аналогично выполнению `clt.un` инструкции, за которым следует `brtrue` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `blt.un` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|37 < `int8` >|BLT.un.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше второго значения (значений без знака), краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` — меньше, чем `value2`, выполняется операция перехода.  
  
 `blt.un` Инструкция передает управление указанной конечной инструкции, если `value1` — меньше, чем `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Аналогично выполнению `clt.un` инструкции, за которым следует `brtrue` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `blt.un.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.un `target`|Ветвь в целевой объект инструкции с указанным смещением в случае двух целочисленных значений, не равно (значений без знака).|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` не равно `value2`, выполняется операция перехода.  
  
 `bne.un` Инструкция передает управление указанной конечной инструкции, если `value1` не равно `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Аналогично выполнению `ceq` инструкции, за которым следует `brfalse` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bne.un` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма) в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|Ветвь в целевой объект инструкции с указанным смещением в случае двух целочисленных значений, не равно (значений без знака), краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` не равно `value2`, выполняется операция перехода.  
  
 `bne.un` Инструкция передает управление указанной конечной инструкции, если `value1` не равно `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Аналогично выполнению `ceq` инструкции, за которым следует `brfalse` ветвь для указанной конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bne.un.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип значения в ссылку на объект (тип <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8C < `T` >|поле `valTypeToken`|Преобразование типа значения (типа, указанного в `valTypeToken`) значение true, ссылку на объект.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Тип значения помещается в стек.  
  
2.  Тип значения, извлеченные из стека; `box` операций.  
  
3.  Ссылка на объект для результирующего типа «процессор» значение помещается в стек.  
  
 Тип значения имеет два представления в Common Language Infrastructure (CLI):  
  
-   Форма «raw», используемый при внедрении типа значения в другом объекте или в стеке.  
  
-   Форма «процессор», где данные в тип значения упаковываются в объект и существуют как независимые сущности.  
  
 `box` Инструкция преобразует тип значения «raw» (из упакованной) в ссылку на объект (тип `O`). Это достигается путем создания нового объекта и копирования данных из типа значения во вновь выделенный объект. `valTypeToken` токен метаданных, указывающий тип тип значения в стеке.  
  
 <xref:System.OutOfMemoryException> возникает, если памяти недостаточно для удовлетворения запроса.  
  
 <xref:System.TypeLoadException> возникает, если класс не может быть найден. Обычно это обнаруживается промежуточного языка MSIL (Microsoft) преобразуется в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `box` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Обеспечивает безусловную передачу управления конечной инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|Выполняет переход к конечной инструкции с указанным смещением.|  
  
 По этой операции выполняются не стек вычислений.  
  
 `br` Инструкция обеспечивает безусловную передачу управления конечной инструкции. Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `br` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Обеспечивает безусловную передачу управления конечной инструкции (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|Выполняет переход к конечной инструкции с указанным смещением, краткую форму.|  
  
 По этой операции выполняются не стек вычислений.  
  
 `br.s` Инструкция обеспечивает безусловную передачу управления конечной инструкции. Целевая инструкция представляется как 1-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `br.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сообщает инфраструктуре CLI, что необходимо оповестить отладчик о достижении точки останова.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|01|break|оповещение отладчик, что была достигнута точка останова.|  
  
 По этой операции выполняются не стек вычислений.  
  
 `break` Инструкция выглядит следующим образом для поддержки отладки. Она сообщает инфраструктуре CLI необходимо оповестить отладчик о достижении точки останова. Он имеет не влияет на состояние интерпретатора.  
  
 `break` Инструкция имеет наименьший возможный размер Включение установки исправлений с помощью точки останова с минимальным воздействием на окружающий код.  
  
 `break` Инструкции можно перехватывать к отладчику, ничего не делать или вызывать исключение безопасности. Точное поведение определяется реализацией.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `break` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значением <paramref name="value" /> является <see langword="false" />, пустая ссылка (<see langword="Nothing" /> в Visual Basic) или ноль.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|Выполняет переход к конечной инструкции с указанным смещением, если `false`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек с помощью предыдущей операции.  
  
2.  `value` извлекается из стека; Если `value` — `false`, ветвь `target`.  
  
 `brfalse` Инструкции (и ее псевдонимы `brnull` и `brzero`) передачу управления указанной конечной инструкции, если `value` (типа `int32`, `int64`, ссылка на объект `O`управляемого указателя `&`, временный указатель `*`, `native int`) равно нулю (`false`). Если `value` имеет ненулевое значение (`true`) продолжает выполнение следующей инструкции.  
  
 Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `brfalse` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значением <paramref name="value" /> является <see langword="false" />, пустая ссылка или ноль.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если `false`, краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек с помощью предыдущей операции.  
  
2.  `value` извлекается из стека; Если `value` — `false`, ветвь `target`.  
  
 `brfalse.s` Инструкции (и ее псевдонимы `brnull` и `brzero`) передачу управления указанной конечной инструкции, если `value` (типа `int32`, `int64`, ссылка на объект `O`управляемого указателя `&`, временный указатель `*`, `native int`) равно нулю (`false`). Если `value` имеет ненулевое значение (`true`) продолжает выполнение следующей инструкции.  
  
 Целевая инструкция представляется как 1-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `brfalse.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значение <paramref name="value" /> равно <see langword="true" />, либо отличается от null и от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|Ветвление конечной инструкции, начиная с указанной позиции, если ненулевое значение (`true`).|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек с помощью предыдущей операции.  
  
2.  `value` извлекается из стека; Если `value` — `true`, ветвь `target`.  
  
 `brtrue` Инструкция передает управление указанной конечной инструкции, если `value` (тип `native int`) имеет ненулевое значение (`true`). Если `value` равно нулю (`false`) продолжает выполнение следующей инструкции.  
  
 Если `value` является ссылкой на объект (тип `O`) затем `brinst` (псевдоним для `brtrue`) передает управление в том случае, если оно представляет экземпляр объекта (например, если он не является ссылкой на пустой объект; см. в разделе <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Целевая инструкция представляется как 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `brtrue` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если значение <paramref name="value" /> равно <see langword="true" /> либо отличается от null и от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|Ветвление конечной инструкции, начиная с указанной позиции, если ненулевое значение (`true`), краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек с помощью предыдущей операции.  
  
2.  `value` извлекается из стека; Если `value` — `true`, ветвь `target`.  
  
 `brtrue.s` Инструкция передает управление указанной конечной инструкции, если `value` (тип `native int`) имеет ненулевое значение (`true`). Если `value` равно нулю (`false`) продолжает выполнение следующей инструкции.  
  
 Если `value` является ссылкой на объект (тип `O`) затем `brinst` (псевдоним для `brtrue`) передает управление в том случае, если оно представляет экземпляр объекта (например, если он не является ссылкой на пустой объект; см. в разделе <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Целевая инструкция представляется как 1-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `brtrue.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод, на который ссылается переданный дескриптор метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|28 < `T` >|Вызов `methodDesc`|Вызовите метод, описанный `methodDesc`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Аргументы метода `arg1` через `argN` помещаются в стек.  
  
2.  Аргументы метода `arg1` через `argN` извлекаются из стека; вызов метода выполняется с этими аргументами и управление передается в метод, на который ссылается дескриптор метода. По завершении возвращаемое значение созданные вызываемый метод и отправляемые вызывающий объект.  
  
3.  Возвращаемое значение помещается в стек.  
  
 `call` Инструкция вызывает метод, передаваемый с инструкцией дескриптор метода. Дескриптор метода является маркером метаданных, который указывает метод для вызова и количество, тип и порядок аргументов, которые были помещены в стек передается этому методу, а также соглашение о вызове для использования. `call` Инструкции непосредственно перед которым `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) префикса инструкциям, чтобы указать, что текущее состояние метода необходимо освободить перед передачей управления. Если вызов передает управление методу, более высокий уровень доверия, чем у исходного метода, кадр стека не освобождается. Вместо этого выполнение продолжается так как если `tail` не был задан. Токен метаданных содержит достаточно сведений, чтобы определить, является ли вызов статического метода, метод экземпляра, виртуальный метод или глобальной функции. Во всех этих случаях адрес назначения определяется исключительно на основании дескриптора метода (Сравните это с <xref:System.Reflection.Emit.OpCodes.Callvirt> инструкцию для вызова виртуальных методов, где адрес назначения также зависит от типа среды выполнения экземпляра Справочник по стек перед <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент вычисляется и поместить в стек, второй аргумент, а затем третий, пока все необходимые аргументы не на вершине стека в порядке убывания. Существует три важные особые случаи:  
  
 1. Вызовы к экземпляру (или виртуального) метода необходимо поместить ссылку на экземпляр перед любой из аргументов видимыми. Ссылка на экземпляр не должен быть пустой ссылкой. Подпись, передавая в метаданных не содержит запись в списке параметров для `this` указателю; вместо этого используется немного, чтобы указать, требуется ли метод передачи `this` указатель.  
  
 2. Допускается вызов виртуального метода с использованием `call` (а не `callvirt`); это означает, что метод будет обработан с помощью класса, указанного с помощью метода, а не как динамически из вызываемого объекта.  
  
 3. Обратите внимание, что делегата `Invoke` метод может вызываться с любым `call` или `callvirt` инструкции.  
  
 <xref:System.Security.SecurityException> может быть вызвано, если система безопасности не предоставляет доступа вызывающего объекта в вызываемый метод. Проверка безопасности возникает в том случае, когда инструкции промежуточного языка MSIL (Microsoft) преобразуются в машинный код, а не во время выполнения.  
  
> [!NOTE]
>  При вызове методов класса System.Object в типах значений, рассмотрите возможность использования `constrained` префикс `callvirt` инструкции вместо выдачи `call` инструкции. Это избавляет от необходимости создавать разные IL в зависимости от того, является ли тип значения переопределяет метод, как избежать потенциальной проблемы управления версиями. Рассмотрите возможность использования `constrained` префикс при вызове методов интерфейса для типов значений, так как метод типов значений, реализующий метод интерфейса можно изменить с помощью `MethodImpl`. Эти проблемы описаны более подробно в <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `call` код операции:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode, MethodInfo, Type[])  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> Метод предоставляется для `varargs` вызовов. Используйте <xref:System.Reflection.Emit.ILGenerator.Emit%2A> метод обычные вызовы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод, заданный в стеке вычислений (как указатель на точку входа), с аргументами, описанными в соглашении о вызовах.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|29 < `T` >|Calli `callSiteDescr`|Вызывает метод, на который указывает с аргументами, описанными в соглашении о вызовах.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Аргументы метода `arg1` через `argN` помещаются в стек.  
  
2.  Указатель на точку входа метода помещается в стек.  
  
3.  Аргументы метода `arg1` через `argN` и указатель на точку входа метода выталкиваются из стека; выполняется вызов метода. По завершении возвращаемое значение созданные вызываемый метод и отправляемые вызывающий объект.  
  
4.  Возвращаемое значение помещается в стек.  
  
 `calli` Инструкция вызывает указатель на точку входа метода с аргументами `arg1` через `argN`. Типы из этих аргументов описаны определенным соглашением о вызовах (`callSiteDesc`). `calli` Инструкция может быть непосредственно перед которым `tail` префикс (<xref:System.Reflection.Emit.OpCodes.Tailcall>) для указания, что текущее состояние метода необходимо освободить перед передачей управления. Если вызов передает управление методу более высокий уровень доверия, чем у исходного метода кадр стека не удаляется. Вместо этого выполнение продолжается так, как если бы `tail` не был задан.  
  
 Предполагается, что указатель на точку входа метода является определенный указатель на машинный код (конечного компьютера), можете законным образом вызван с аргументами, описанными в соглашении о вызовах (лексема метаданных для отдельной подписи). Такой указатель могут создаваться с использованием <xref:System.Reflection.Emit.OpCodes.Ldftn> или <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> инструкции или переданный из машинного кода.  
  
 Соглашение о вызовах не проверяется динамически, поэтому код, использующий `calli` инструкций не работает правильно, если конечный метод не использует указанное соглашение о вызовах.  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент вычисляется и поместить в стек, второй аргумент, а затем третий, пока все необходимые аргументы не на вершине стека в порядке убывания. Аргумент дом последовательности кода для экземпляра или виртуальный метод необходимо поместить ссылку на экземпляр (который не должен быть ссылкой на null) перед любой из аргументов видимыми.  
  
 <xref:System.Security.SecurityException> может быть вызвано, если система безопасности не предоставляет доступа вызывающего объекта в вызываемый метод. Проверка безопасности может произойти, когда инструкции промежуточного языка MSIL (Microsoft) преобразуются в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> методы могут использоваться для выполнения `calli` инструкции в стеке. Обратите внимание, что `calli` должен вызываться через ниже методов, а не с помощью <xref:System.Reflection.Emit.ILGenerator.Emit%2A> класс для помещения инструкции непосредственно в стеке.  
  
-   ILGenerator.EmitCalli (код операции, CallingConventions, тип, Type [], Type[]) для вызовов с помощью управляемых вызовах.  
  
-   ILGenerator.EmitCalli (код операции, Type[]) CallingConvention, тип, для вызовов с помощью соглашений по неуправляемым вызовам.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод объекта с поздней привязкой и помещает возвращаемое значение в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|Вызывает определенный метод, связанный с `obj`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `obj` помещается в стек.  
  
2.  Аргументы метода `arg1` через `argN` помещаются в стек.  
  
3.  Аргументы метода `arg1` через `argN` и ссылку на объект `obj` извлекаются из стека; вызов метода выполняется с этими аргументами и управление передается методу в `obj` ссылается метод токен метаданных. По завершении возвращаемое значение созданные вызываемый метод и отправляемые вызывающий объект.  
  
4.  Возвращаемое значение помещается в стек.  
  
 `callvirt` Инструкция вызывает метод с поздним связыванием объекта. То есть метод выбирается в зависимости от типа среды выполнения `obj` вместо компиляции класса, видимого в указатель метода. `Callvirt` можно использовать для вызова виртуальных методов и методов экземпляра. `callvirt` Инструкция может быть непосредственно перед которым `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) префикса, чтобы указать, что перед передачей управления необходимо освободить текущий кадр стека. Если вызов передает управление методу, более высокий уровень доверия, чем исходный метод кадр стека, не удаляется.  
  
 Токен метаданных метода предоставляет имя, класс и подпись метода для вызова. Класс, связанный с `obj` — это класс, из которых он является экземпляром. Если класс определяет нестатический метод, который соответствует указанное имя и подпись, этот метод вызывается. В противном случае все классы в цепочке базовый класс этого класса проверяются в порядке. Это ошибка, если метод не найден.  
  
 `Callvirt` Извлекает объект и соответствующие аргументы из стека вычислений перед вызовом метода. Если метод имеет возвращаемое значение, он помещается в стек по завершении метода. На стороне вызываемой `obj` параметра осуществляется аргумент 0, `arg1` как аргумент 1 и т. д.  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент вычисляется и поместить в стек, второй аргумент, а затем третий, пока все необходимые аргументы не на вершине стека в порядке убывания. Ссылка на экземпляр `obj` (всегда требуется для `callvirt`) должна быть в стек перед любой из аргументов видимыми. Подпись, (передавая маркер метаданных) не должны содержать записи в списке параметров для этого указателя.  
  
 Обратите внимание на то, что виртуальный метод может также быть вызван с помощью <xref:System.Reflection.Emit.OpCodes.Call> инструкции.  
  
 <xref:System.MissingMethodException> возникает, если не удается найти нестатический метод с указанным именем и сигнатурой в классе, связанном с `obj` или любого из его базовых классов. Обычно это обнаруживается инструкции промежуточного языка MSIL (Microsoft) преобразуются в машинный код, а не во время выполнения.  
  
 <xref:System.NullReferenceException> возникает, если obj имеет значение null.  
  
 <xref:System.Security.SecurityException> возникает, если система безопасности не предоставляет доступа вызывающего объекта в вызываемый метод. Проверка безопасности возникает в том случае, когда CIL преобразуется в машинный код, а не во время выполнения.  
  
> [!NOTE]
>  При вызове методов класса System.Object в типах значений, рассмотрите возможность использования `constrained` префикс `callvirt` инструкции. Это избавляет от необходимости создавать разные IL в зависимости от того, является ли тип значения переопределяет метод, как избежать потенциальной проблемы управления версиями. Рассмотрите возможность использования `constrained` префикс при вызове методов интерфейса для типов значений, так как метод типов значений, реализующий метод интерфейса можно изменить с помощью `MethodImpl`. Эти проблемы описаны более подробно в <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `callvirt` код операции:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode, MethodInfo, Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предпринимает попытку привести объект, передаваемый по ссылке, к указанному классу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|Приводит объект с новым объектом типа `class`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека; Указанный объект приводится согласно указанному `class`.  
  
3.  В случае успешного выполнения новая ссылка на объект помещается в стек.  
  
 `castclass` Инструкции предпринимается попытка преобразования ссылка на объект (тип `O`) на вершине стека для указанного класса. Новый класс, указанный токеном метаданных, указывающее, требуемого класса. Если класс объекта на вершине стека не реализует новый класс (новый класс — это интерфейс) и не является производным от класса нового класса исключение <xref:System.InvalidCastException> возникает исключение. Если ссылка на объект является пустой ссылкой, `castclass` завершается успешно и возвращает новый объект как ссылку на null.  
  
 <xref:System.InvalidCastException> возникает, если obj не может быть приведен к классу.  
  
 <xref:System.TypeLoadException> возникает, если не удается найти класс. Обычно это обнаруживается инструкции промежуточного языка MSIL (Microsoft) преобразуется в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `castclass` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если они равны, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 01|ceq|Помещает в стек 1, если `value1` равно `value2`; в противном случае помещает 0.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` сравнивается с `value2`.  
  
4.  Если `value1` равен `value2`, 1 помещается в стек; в противном случае — значение 0 помещается в стек.  
  
 `ceq` Сравнивает инструкции `value1` и `value2`. Если `value1` равен `value2`, 1 (типа `int32`) помещается в стек. В противном случае — 0 (типа `int32`) помещается в стек.  
  
 Для числа с плавающей запятой `ceq` возвращает 0, если числа неупорядочены (одно или оба имеют значения NaN). Бесконечные значения равны на самих себя.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ceq` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если первое значение больше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 02|cgt|Помещает в стек 1, если `value1` больше, чем `value2`; в противном случае помещает 0.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `cgt` проверяет `value1` больше, чем `value2`.  
  
4.  Если `value1` больше, чем `value2`, 1 помещается в стек; в противном случае — значение 0 помещается в стек.  
  
 `cgt` Сравнивает инструкции `value1` и `value2`. Если `value1` строго больше, чем `value2`, а затем `int32` помещается значение 1 в стек. В противном случае `int32` значение 0 помещается в стек.  
  
-   Для чисел с плавающей запятой `cgt` возвращает 0, если числа неупорядочены (то есть, если один или оба аргумента имеют значения NaN).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `cgt` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения без знака или два неупорядоченных значения. Если первое значение больше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 03|или cgt.un|Помещает в стек 1, если `value1` больше, чем `value2`; в противном случае помещает в стек 0 (для значений без знака).|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `cgt.un` проверяет `value1` больше, чем `value2`.  
  
4.  Если `value1` больше, чем `value2`, 1 помещается в стек; в противном случае — значение 0 помещается в стек.  
  
 `int32` В стеке помещается значение 1, если выполняется одно из следующих `true` :  
  
 Для чисел с плавающей запятой `value1` не упорядочен по отношению к `value2`.  
  
 Для целых значений `value1` строго больше, чем `value2` при сравнении чисел без знака.  
  
 В противном случае `int32` значение 0 помещается в стек.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `cgt.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает исключение <see cref="T:System.ArithmeticException" />, если значение не является конечным числом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|C3|Ckfinite|исключение <xref:System.ArithmeticException> Если значение не является конечным числом.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек. 
  
2.  `value` извлекается из стека и `ckfinite` инструкции выполняются на нем.  
  
3.  `value` помещается обратно в стек, если исключение не создается.  
  
 `ckfinite instruction` Вызывает <xref:System.ArithmeticException> Если `value` (число с плавающей запятой) имеет значение «не число» значением (NaN) или `+-` значение бесконечности. `Ckfinite` оставляет значение в стеке, если исключение не создается. Выполнение не определено, если `value` не является числом с плавающей запятой.  
  
 <xref:System.ArithmeticException> возникает, если `value` не является числом «normal».  
  
 Обратите внимание, что специальные исключения или производным от класса <xref:System.ArithmeticException> может быть более эффективными, передачи неверного значения обработчику исключений.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ckfinite` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если первое значение меньше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 04|Средство регистрации звонков|Помещает в стек 1, если `value1` — меньше, чем `value2`; в противном случае помещает 0.|  
  
 Изменения состояния стека, в последовательном порядке, является: `value1` помещается в стек.  
  
1.  `value2` помещается в стек.  
  
2.  `value2` и `value1` извлекаются из стека; `clt` проверяет `value1` — меньше, чем `value2`.  
  
3.  Если `value1` — меньше, чем `value2`, 1 помещается в стек; в противном случае — значение 0 помещается в стек.  
  
 `clt` Сравнивает инструкции `value1` и `value2`. Если `value1` является строго меньше, чем `value2`, а затем `int32` помещается значение 1 в стек. В противном случае `int32` значение 0 помещается в стек.  
  
-   Для чисел с плавающей запятой `clt` возвращает 0, если числа неупорядочены (то есть, если один или оба аргумента имеют значения NaN).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `clt` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения без знака или два неупорядоченных значения <paramref name="value1" /> и <paramref name="value2" />. Если значение <paramref name="value1" /> меньше значения <paramref name="value2" />, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 05|CLT.un|Помещает в стек 1, если `value1` — меньше, чем `value2`; в противном случае помещает в стек 0 (для значений без знака).|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `clt.un` проверяет `value1` — меньше, чем `value2`.  
  
4.  Если `value1` — меньше, чем `value2`, 1 помещается в стек; в противном случае — значение 0 помещается в стек.  
  
 `clt.un` Сравнивает инструкции `value1` и `value2`. `int32` В стеке помещается значение 1, если выполняется хотя бы одно из следующих:  
  
-   `value1` является строго меньше, чем `value2` (как для `clt`).  
  
-   Для чисел с плавающей запятой `value1` не упорядочен по отношению к `value2`.  
  
-   Для целых значений `value1` является строго меньше, чем `value2` при сравнении чисел без знака.  
  
 В противном случае `int32` значение 0 помещается в стек.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `clt.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ограничивает тип, для которого был вызван виртуальный метод.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкции по шестнадцатеричном формате и формате сборки промежуточного языка MSIL, Microsoft, а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 16 &LT; `T` >|ограничение. `thisType`|Вызов виртуального метода в типе ограниченное тип `T`.|  
  
 `constrained` Префикс допускается только в `callvirt` инструкции.  
  
 Состояние стека MSIL на этом этапе может выглядеть следующим образом:  
  
1.  Управляемый указатель, `ptr`, помещается в стек. Тип `ptr` должен быть управляемый указатель (`&`) для `thisType`. Обратите внимание, что это отличается от применения без префикса `callvirt` инструкции, что наличие ссылки `thisType`.  
  
2.  Аргументы метода `arg1` через `argN` помещаются в стек, как и в случае без префикса `callvirt` инструкции.  
  
 `constrained` Префикс позволяет `callvirt` инструкциям, чтобы быть независимы в универсальный способ ли `thisType` является типом значения или ссылочным типом.  
  
 Когда `callvirt` `method` предшествует инструкции `constrained` `thisType`, инструкция выполняется следующим образом:  
  
-   Если `thisType` является ссылочным типом (в отличие от типа значения), затем `ptr` разыменован и передается как указатель «this» для `callvirt` из `method`.  
  
-   Если `thisType` является типом значения и `thisType` реализует `method` затем `ptr` передается без изменений независимо от указатель «this» для `call` `method` инструкции для реализации `method` по `thisType`.  
  
-   Если `thisType` является типом значения и `thisType` не реализует `method` затем `ptr` разыменован, упаковывается и передается как указатель «this» для `callvirt` `method` инструкции.  
  
 Последний случай может произойти только тогда, когда `method` был определен на <xref:System.Object>, <xref:System.ValueType>, или <xref:System.Enum> и не переопределяется `thisType`. В этом случае упаковка приводит копию исходного объекта должна быть выполнена. Тем не менее так как ни один из методов класса <xref:System.Object>, <xref:System.ValueType>, и <xref:System.Enum> изменить состояние объекта, не удается обнаружить этот факт.  
  
 `constrained` Префикс поддерживает генераторов IL, которые создают универсальный код. Обычно `callvirt` инструкция не является допустимой для типов значений. Вместо этого он необходим, компиляторы IL эффективного выполнения «this» преобразования, описанные выше, во время компиляции, в зависимости от типа `ptr` и вызываемого метода. Тем не менее, если `ptr` является универсальным типом, неизвестен во время компиляции, это не позволяет сделать это преобразование во время компиляции.  
  
 `constrained` Opcode позволяет компиляторам промежуточного языка вызов виртуальной функции в универсальный способ зависит от ли `ptr` является типом значения или ссылочным типом. Несмотря на то, что он предназначен для случая где `thisType` является переменной универсального типа `constrained` префикс также работает для неуниверсальных типов и могут упростить процесс создания виртуальных вызовов на языках, которые скрывают различие между типами значений и ссылочные типы.  
  
 С помощью `constrained` префикс также позволяет избежать потенциальных проблем управления версиями с типами значений. Если `constrained` префикс не используется, в зависимости от того, является ли тип значения переопределяет метод System.Object должны выдаваться разные IL. Например, если тип значения `V` переопределяет метод Object.ToString() `call` `V.ToString()` создается инструкция; Если это не так, `box` инструкции и `callvirt` `Object.ToString()` создаются инструкции. Проблема может возникнуть в первом примере, если переопределение позднее будут удалены и в последнем случае, если переопределение позже добавить.  
  
 `constrained` Префикс также используется для вызова методов интерфейса для типов значений, так как метод типов значений, реализующий метод интерфейса можно изменить с помощью `MethodImpl`. Если `constrained` префикс не используется, компилятор вынужден выбирать, какие значения типа методов для привязки к во время компиляции. С помощью `constrained` префикс позволяет MSIL-код для привязки к методу, который реализует метод интерфейса во время выполнения, а не во время компиляции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `constrained` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D3|conv.i|Преобразовать в `native int`и помещает `native int` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.i` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Не создаются исключения при использовании этого поля. См. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> эквивалентные инструкции, которые будут создавать исключение, когда тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.i` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="int8" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|67|conv.i1|Преобразовать в `int8`и помещает `int32` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.i1` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Не создаются исключения при использовании этого поля. См. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> эквивалентные инструкции, которые будут создавать исключение, когда тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.i1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="int16" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|68|conv.I2|Преобразовать в `int16`и помещает `int32` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.i2` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Не создаются исключения при использовании этого поля. См. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> эквивалентные инструкции, которые будут создавать исключение, когда тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.i2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|69|conv.i4|Преобразовать в `int32`и помещает `int32` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.i4` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Не создаются исключения при использовании этого поля. См. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> эквивалентные инструкции, которые будут создавать исключение, когда тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.i4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6A|conv.I8|Преобразовать в `int64`и помещает `int64` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.i8` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Не создаются исключения при использовании этого поля. См. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> эквивалентные инструкции, которые будут создавать исключение, когда тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.i8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="native int" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|Преобразовать в `native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="native int" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|Преобразует значение без знака `native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i.un` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int8" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|Преобразовать в `int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i1` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int8" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|Преобразует значение без знака `int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i1.un` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i1.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int16" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.I2|Преобразовать в `int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i2` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int16" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|83|conv.ovf.I2.un|Преобразует значение без знака `int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i2.un` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i2.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int32" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|Преобразовать в `int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i4` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int32" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|Преобразует значение без знака `int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i4.un` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i4.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int64" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.I8|Преобразовать в `int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i8` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int64" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|85|conv.ovf.I8.un|Преобразует значение без знака `int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i8.un` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i8.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned native int" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|Преобразовать в `unsigned native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned native int" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|Преобразует значение в без знака `unsigned native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u.un` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.uvf.u.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="unsigned int8" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.U1|Преобразовать в `unsigned int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u1` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int8" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|86|conv.ovf.U1.un|Преобразует значение без знака `unsigned int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u1.un` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u1.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="unsigned int16" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.U2|Преобразовать в `unsigned int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u2` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int16" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|87|conv.ovf.U2.un|Преобразует значение без знака `unsigned int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u2.un` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u2.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.U4|Преобразовать в `unsigned int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u4` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|88|conv.ovf.U4.un|Преобразует значение без знака `unsigned int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u4.un` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u4.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned int64" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|Преобразовать в `unsigned int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u8` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int64" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|Преобразует значение без знака `unsigned int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция. Если возникает переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u8.un` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь числом, дробная часть. Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u8.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразование целочисленного значения без знака на вершине стека вычислений в <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|76|conv.r.un|Преобразовать целое число без знака с плавающей запятой, помещает `F` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.r.un` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если возникает переполнение, преобразование типа с плавающей запятой в целое число `result` возвращается не определен. `conv.r.un` Операция принимает целое число из стека, интерпретирует его как число без знака и заменяет его значение с плавающей запятой, чтобы представить целое число: либо `float32`, если это достаточно широким, чтобы представить целое число без потери точности или else `float64`.  
  
 Не создаются исключения при использовании этого поля.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.r.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6B|conv.R4|Преобразовать в `float32`и помещает `F` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.r4` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Не создаются исключения при использовании этого поля.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.r4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6C|conv.R8|Преобразовать в `float64`и помещает `F` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.r8` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Не создаются исключения при использовании этого поля.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.r8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned native int" />, а затем расширяет его до <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|E0|conv.u|Преобразовать в `unsigned native int`и помещает `native int` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.u` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Не создаются исключения при использовании этого поля. См. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> эквивалентные инструкции, которые будут создавать исключение, когда тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.u` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int8" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D2|conv.U1|Преобразовать в `int8`и помещает `int32` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.u1` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Не создаются исключения при использовании этого поля. См. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> эквивалентные инструкции, которые будут создавать исключение, когда тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.u1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int16" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D1|conv.U2|Преобразовать в `int16`и помещает `int32` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.u2` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Не создаются исключения при использовании этого поля. См. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> эквивалентные инструкции, которые будут создавать исключение, когда тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.u2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int32" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6D|conv.U4|Преобразовать в `unsigned int32`и помещает `int32` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.u4` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Не создаются исключения при использовании этого поля. См. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> эквивалентные инструкции, которые будут создавать исключение, когда тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.u4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int64" />, а затем расширяет его до <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6E|conv.u8|Преобразовать в `int64`и помещает `int64` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.u8` Преобразует opcode `value` на вершине стека к типу, указанному в коде операции и оставляет преобразованное значение в стеке. Целочисленные значения меньше 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой преобразуются в `F` типа.  
  
 Преобразование из чисел с плавающей запятой, до целых чисел усекает число к нулю. При преобразовании из `float64` для `float32`, точности могут быть потеряны. Если `value` слишком велик для размещения `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, старшие разряды, усекаются. Если результат меньше `int32`, значение, расширенному знаком для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Не создаются исключения при использовании этого поля. См. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> эквивалентные инструкции, которые будут создавать исключение, когда тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.u8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует заданное число байт из исходного адреса в конечный.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Копирование данных из одного блока памяти в другой.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес назначения помещается в стек.  
  
2.  Исходный адрес помещается в стек.  
  
3.  Число байтов для копирования помещается в стек.  
  
4.  Число байтов, адрес источника и целевой адрес извлекаются из стека; указанное число байтов копируются из исходного адреса назначения.  
  
 `cpblk` Инструкции копирует число (типа `unsigned int32`) байтов из исходного адреса (типа `*`, `native int`, или `&`) к конечному адресу (типа `*`, `native int`, или `&`). Поведение `cpblk` не указано, при перекрытии исходной и целевой областей.  
  
 `cpblk` предполагается, что исходный и конечный адреса выровнены по естественному размеру машины. `cpblk` Инструкции непосредственно перед которым `unaligned.<prefix>` инструкции, чтобы указать, что исходный или конечный адрес не выровнен.  
  
 Операция `cpblk` инструкция может быть изменено, непосредственно перед знаком <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> может быть создано исключение при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `cpblk` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует тип значения по адресу объекта (с типом <see langword="&amp;" />, <see langword="*" /> или <see langword="native int" />) и помещает его по адресу конечного объекта (с типом <see langword="&amp;" />, <see langword="*" /> или <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|Копирует тип значения из исходного объекта в целевой объект.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на конечный объект помещается в стек.  
  
2.  Ссылка на исходный объект помещается в стек.  
  
3.  Обе ссылки на объекты извлекаются из стека; Тип значения по адресу объекта источника копируется на адрес целевого объекта.  
  
 Поведение `cpobj` не определено, если исходный и конечный объект ссылки не являются указателями на экземпляры класса, представленного маркером класс `classTok` ( `typeref` или `typedef`), или если `classTok` не представляет Тип значения.  
  
 <xref:System.NullReferenceException> может быть создано исключение при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `cpobj` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение на другое и помещает результат в стек вычислений как число с плавающей запятой (с типом <see langword="F" />) или как частное (с типом <see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5B|div|Делит одно значение возвращает частное или результат с плавающей запятой.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` делится `value2`.  
  
4.  Результат помещается в стек.  
  
 `result` = `value1` div value2 удовлетворяет следующим условиям:  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, и:  
  
 Sign (`result`) = +, если знак (`value1`) = входа (`value2`), или-, если знак (`value1`) ~ = входа (`value2`)  
  
 `div` Инструкция вычисляет результат и помещает его в стеке.  
  
 Целочисленное деление усекает в сторону нуля.  
  
 Деление конечного числа на ноль дает правильно подписанного бесконечное значение.  
  
 Деления нуля на нуль или бесконечности на бесконечность возвращает значение NaN (не числовое). Любое число, деленное на бесконечность создаст нулевое значение.  
  
 Целочисленные операции создают исключение <xref:System.ArithmeticException> Если результат невозможно представить в типе результата. Это может произойти, если `value1` максимальное значение отрицательное, и `value2` равно -1.  
  
 Целочисленные операции создают исключение <xref:System.DivideByZeroException> Если `value2` равно нулю.  
  
 Обратите внимание, что для платформ на основе Intel <xref:System.OverflowException> возникает при вычислении (minint div -1). Операции с плавающей запятой не генерируют исключений (они возвращают значения NaN или бесконечность).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `div` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно целочисленное значение без знака на другое и помещает результат (<see langword="int32" />) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5C|div.un|Делит два значения, без подписи, возвращая частное.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` делится `value2`.  
  
4.  Результат помещается в стек.  
  
 `div.un` Инструкция вычисляет `value1` деления на `value2`, без целых чисел без знака и помещает `result` в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `div.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует текущее верхнее значение в стеке вычислений и помещает копию в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|25|Dup|Дублирует значению на вершине стека.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека для дублирования.  
  
3.  `value` помещается обратно в стек.  
  
4.  Повторяющееся значение помещается в стек.  
  
 `dup` Инструкция дублирует верхний элемент стека и оставляет два одинаковых значения на вершине стека.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `dup` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление из предложения <see langword="filter" /> исключения обратно в обработчик исключений CLI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 11|конечный фильтр|Предложение фильтра окончания обработки исключений SEH.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; `endfilter` выполняется и управление передается обработчику исключений.  
  
 `Value` (который должен быть типа `int32` и является одним из определенного набора значений) возвращается из предложения фильтра. Она должна быть одна из:  
  
-   `exception_continue_search` (`value` = 0) для продолжения поиска обработчика исключений  
  
-   `exception_execute_handler` (`value` = 1) — начать второй этап обработки исключений, где блоки finally выполняются до обработчика по связанный с данным предложением фильтра находится. После обнаружения обработчик выполняется.  
  
 Другие целочисленные значения создаст результаты не определены.  
  
 Точка входа фильтра, как показано в таблице исключений метода, должен быть первой инструкции в блоке кода filter. `endfilter` Инструкция должна быть последней инструкции в блоке кода filter (таким образом может существовать только один `endfilter` для одного блока filter). После выполнения `endfilter` инструкции, управление логически передается обратно механизм обработки исключений CLI.  
  
 Элемент управления может быть передано в блок фильтра только через механизм обработки исключений. Элемент управления не могут быть перенесены из блока фильтра, за исключением использования `throw` инструкций или путем выполнения последней `endfilter` инструкции. Не удается внедрить `try` блок `filter` блока. Если исключение возникает в блоке `filter` блока, оно перехватывается и значение 0 (`exception_continue_search`) возвращается.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `endfilter` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление из предложения <see langword="fault" /> или <see langword="finally" /> блока исключения обратно обработчику исключений CLI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DC|endfinally<br /><br /> endfault|Завершает `finally` или `fault` предложение блока исключения.|  
  
 Существуют стек не вариантов поведения для данной инструкции.  
  
 `Endfinally` и `endfault` сигнал об окончании `finally` или `fault` предложение, поэтому раскрутка стека можно продолжить работу, пока не будет вызван обработчик исключений. `endfinally` Или `endfault` инструкция передает управление обратно в механизм обработки исключений CLI. Механизм выполняет поиск следующего `finally` предложение в цепочке, если выход из защищенного блока был выполнен с помощью инструкции leave. Если защищенный блок был выполнен выход с исключением, интерфейса командной строки выполняет поиск для следующей `finally` или `fault`, или введите в обработчик, выбранный на первом этапе обработки исключений.  
  
 `endfinally` Инструкции могут появляться только лексически в `finally` блока. В отличие от `endfilter` инструкции, нет необходимости завершение блока с `endfinally` инструкция и может быть столько `endfinally` инструкции в блоке. Те же ограничения применяются к `endfault` инструкции и `fault` блока.  
  
 Элемент управления может быть передано в `finally` (или `fault`) блокировать за исключением через механизм обработки исключений. Управление не может быть передано из `finally` (или `fault`) блокировать за исключением случаев использования `throw` инструкции или выполнения `endfinally` (или `endfault`) инструкции. В частности, вы не может «опускаться» из `finally` (или `fault`) блока или для выполнения <xref:System.Reflection.Emit.OpCodes.Ret> или <xref:System.Reflection.Emit.OpCodes.Leave> инструкции в пределах `finally` (или `fault`) блока.  
  
 Обратите внимание, что `endfault` и `endfinally` инструкции являются псевдонимами — они соответствуют одному коду операции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `endfinally` (`endfault`) код операции, а также `ILGenerator` метод <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Инициализирует блок памяти с определенным адресом, присваивая его начальному значению с заданным размером.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 18|initblk|Укажите для каждого расположения в блок памяти, заданное значение.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Начальный адрес помещается в стек.  
  
2.  Значение инициализации помещается в стек.  
  
3.  Число байтов для инициализации помещается в стек.  
  
4.  Число байтов, значение инициализации и начальный адрес извлекаются из стека и инициализация выполняется в соответствии с их значения.  
  
 `initblk` Инструкция задает номер (`unsigned int32`) байтов, начиная с указанного адреса (типа `native int`, `&`, или `*`) для инициализации значение (типа `unsigned int8`). `initblk` предполагается, что начальный адрес выровнен по естественному размеру машины.  
  
 Операция `initblk` инструкции может быть изменено, непосредственно перед знаком <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> может быть создано исключение при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `initblk` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Инициализирует каждое поле типа значения с определенным адресом пустой ссылкой или значением 0 соответствующего простого типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 15 &LT; `T` >|`initobj` `typeTok`|Инициализирует тип значения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес типа значения для инициализации помещается в стек.  
  
2.  Адрес извлекается из стека; Тип значения по указанному адресу инициализируется в качестве типа `typeTok`.  
  
 `initobj` Инструкция инициализирует каждое поле типа значения, заданные в стек адрес (типа `native int`, `&`, или `*`) пустой ссылкой или значением 0 соответствующего простого типа. После вызова этого метода экземпляр готов для вызываемый метод-конструктор. Если `typeTok` является ссылочным типом, эта инструкция действует так же как `ldnull` следуют `stind.ref`.  
  
 В отличие от <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` не вызывает метод-конструктор. `Initobj` — предназначена для инициализации типов значений, тогда как `newobj` используется для размещения и инициализации объектов.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `initobj` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Проверяет, является ли ссылка на объект (с типом <see langword="O" />) экземпляром определенного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|75 < `T` >|инструкции isinst `class`|Проверяет, если ссылка на объект является экземпляром класса `class`, возвращая указатель null или экземпляр этого класса или интерфейса.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и проверяется, если он является экземпляром класса, заданного в `class`.  
  
3.  Результат (ссылка на объект или пустая ссылка) помещается в стек.  
  
 `Class` токен метаданных, указывающий требуемого класса. Если класс объекта на вершине стека реализует `class` (если `class` — это интерфейс) или является производным от класса `class` (если `class` — обычный класс) он приводится к типу `class` и результат помещается в стек, точно так, будто <xref:System.Reflection.Emit.OpCodes.Castclass> бы вызывалась. В противном случае — пустая ссылка помещается в стек. Если ссылка на объект является пустой ссылкой, затем `isinst` точно так же возвращает пустую ссылку.  
  
 <xref:System.TypeLoadException> возникает, если не удается найти класс. Обычно это обнаруживается инструкции промежуточного языка MSIL (Microsoft) преобразуются в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `isinst` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Прекращает выполнение текущего метода и переходит к заданному методу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|Выход из текущего метода и переходит к заданному методу.|  
  
 Существуют стек не вариантов поведения для данной инструкции.  
  
 `jmp` (Переход) инструкция передает управление методу, заданному параметром `method`, который является маркером метаданных для ссылки на метод. Текущие аргументы передаются в метод назначения.  
  
 При выполнении этой команды, в стек должен быть пустым. Вызывающий соглашение, номер и тип аргументов по адресу назначения должны совпадать, текущего метода.  
  
 `jmp` Инструкция не может использоваться для передачи управления из `try`, `filter`, `catch`, или `finally` блока.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `jmp` код операции:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент (на который ссылается указанное значение индекса) в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 09 &LT; `unsigned int16` >|ldarg `index`|Загружает аргумент с `index` в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение аргумента с `index` помещается в стек.  
  
 `ldarg` Инструкция помещает аргумент с индексом `index`, где аргументы индексируются, начиная с 0 и выше, в стек вычислений. `ldarg` Инструкция может использоваться для загрузки типом значения или значение-примитив в стек, копируя его из входящего аргумента. Тип значения аргумента — совпадал с типом аргумента, в соответствии с сигнатуры текущего метода.  
  
 Для процедуры, которые принимают список аргументов переменной длины `ldarg` инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной частью сигнатуры (см. в разделе <xref:System.Reflection.Emit.OpCodes.Arglist> инструкции для получения дополнительных сведений).  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байтов расширяются до типа `int32` когда они были загружены в стек. Значения с плавающей запятой расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarg` код операции:  
  
-   ILGenerator.Emit (OpCode, короткое)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 0 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|02|ldarg.0|Загружает аргумент 0 в стек|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение аргумента с индексом 0 помещается в стек.  
  
 `ldarg.0` Инструкция представляет собой эффективную кодировку для загрузки значения аргумента с индексом 0.  
  
 `ldarg.0` Инструкция помещает аргумент с индексом 0 в стек вычислений. `ldarg.0` Инструкция может использоваться для загрузки типом значения или значение-примитив в стек, копируя его из входящего аргумента. Тип значения аргумента — совпадал с типом аргумента, в соответствии с сигнатуры текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байтов расширяются до типа `int32` когда они были загружены в стек. Значения с плавающей запятой расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarg.0` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 1 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|03|ldarg.1|Загружает аргумент 1 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение аргумента с индексом 1 помещается в стек.  
  
 `ldarg.1` Инструкция представляет собой эффективную кодировку для загрузки значения аргумента с индексом 1.  
  
 `ldarg.1` Инструкция помещает аргумент с индексом 1 в стек вычислений. `ldarg.1` Инструкция может использоваться для загрузки типом значения или значение-примитив в стек, копируя его из входящего аргумента. Тип значения аргумента — совпадал с типом аргумента, в соответствии с сигнатуры текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байтов расширяются до типа `int32` когда они были загружены в стек. Значения с плавающей запятой расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarg.1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 2 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|04|ldarg.2|Загружает аргумент 2 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение аргумента с индексом 2 помещается в стек.  
  
 `ldarg.2` Инструкция представляет собой эффективную кодировку для загрузки значения аргумента с индексом 2.  
  
 `ldarg.2` Инструкция помещает аргумент с индексом 2 в стек вычислений. `ldarg.2` Инструкция может использоваться для загрузки типом значения или значение-примитив в стек, копируя его из входящего аргумента. Тип значения аргумента — совпадал с типом аргумента, в соответствии с сигнатуры текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байтов расширяются до типа `int32` когда они были загружены в стек. Значения с плавающей запятой расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarg.2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 3 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|05|ldarg.3|Загружает аргумент 3 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение аргумента с индексом 3 помещается в стек.  
  
 `ldarg.3` Инструкция представляет собой эффективную кодировку для загрузки значения аргумента с индексом 3.  
  
 `ldarg.3` Инструкция помещает аргумент с индексом 3 в стек вычислений. `ldarg.3` Инструкция может использоваться для загрузки типом значения или значение-примитив в стек, копируя его из входящего аргумента. Тип значения аргумента — совпадал с типом аргумента, в соответствии с сигнатуры текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байтов расширяются до типа `int32` когда они были загружены в стек. Значения с плавающей запятой расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarg.3` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент (на который ссылается указанное короткое значение индекса) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0E &LT; `unsigned int8` >|ldarg.s `index`|Загружает аргумент с `index` в стек, краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение аргумента с `index` помещается в стек.  
  
 `ldarg.s` Инструкция представляет собой эффективную кодировку для загрузки аргументов с индексом от 4 до 255.  
  
 `ldarg.s` Инструкция помещает аргумент с индексом `index`, где аргументы индексируются, начиная с 0 и выше, в стек вычислений. `ldarg.s` Инструкция может использоваться для загрузки типом значения или значение-примитив в стек, копируя его из входящего аргумента. Тип значения аргумента — совпадал с типом аргумента, в соответствии с сигнатуры текущего метода.  
  
 Для процедуры, которые принимают список аргументов переменной длины `ldarg.s` инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной частью сигнатуры (см. в разделе <xref:System.Reflection.Emit.OpCodes.Arglist> инструкции для получения дополнительных сведений).  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байтов расширяются до типа `int32` когда они были загружены в стек. Значения с плавающей запятой расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarg.s` код операции:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес аргумента в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0A &LT; `unsigned int16` >|ldarga `index`|Извлекает адрес аргумента с индексом `index`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес `addr` аргумента, с индексом `index` помещается в стек.  
  
 `ldarga` Инструкция извлекает адрес (типа `*`) аргумента, с индексом `index`, где аргументы индексируются, начиная с 0 и более поздних версий. Адрес `addr` всегда выравнивается по границам на целевом компьютере.  
  
 Для процедуры, которые принимают список аргументов переменной длины `ldarga` инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной частью сигнатуры.  
  
 `ldarga` используется для передачи параметров по ссылке. В остальных случаях <xref:System.Reflection.Emit.OpCodes.Ldarg> и <xref:System.Reflection.Emit.OpCodes.Starg> следует использовать.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarga` код операции:  
  
-   ILGenerator.Emit (OpCode, короткое)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес аргумента (короткая форма) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0F &LT; `unsigned int8` >|ldarga.s `index`|Извлекает адрес аргумента с индексом `index`, краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес `addr` аргумента, с индексом `index` помещается в стек.  
  
 `ldarga.s` (Краткая форма `ldarga`) следует использовать для аргумента цифры от 0 до 255, а также обеспечивает более эффективную кодировку.  
  
 `ldarga.s` Инструкция извлекает адрес (типа`*`) аргумента, с индексом `index`, где аргументы индексируются, начиная с 0 и более поздних версий. Адрес `addr` всегда выравнивается по границам на целевом компьютере.  
  
 Для процедуры, которые принимают список аргументов переменной длины `ldarga.s` инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной частью сигнатуры.  
  
 `ldarga.s` используется для передачи параметров по ссылке. В остальных случаях <xref:System.Reflection.Emit.OpCodes.Ldarg_S> и <xref:System.Reflection.Emit.OpCodes.Starg_S> следует использовать.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarga.s` код операции:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.i4 `num`|Помещает значение `num` в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение `num` помещается в стек.  
  
 Обратите внимание на то, что существуют специальные короткие (и, следовательно, более эффективные) кодировки для целых чисел от -128 до 127 и особенно короткие коды на -1 до 8. Все короткие коды Push-4-байтовые целые числа в стеке. Больше кодировки используются для 8-байтовые целые числа и 4 и 8 байтовые числа с плавающей запятой, а также 4-байтовых значений, которые не помещаются в краткие формы. Существует три способа для принудительной отправки 8-байтовую целая константа в стек  
  
 1. Используйте <xref:System.Reflection.Emit.OpCodes.Ldc_I8> инструкции для константы, которые должны быть выражены в более чем 32 бита.  
  
 2. Используйте <xref:System.Reflection.Emit.OpCodes.Ldc_I4> инструкции, за которым следует <xref:System.Reflection.Emit.OpCodes.Conv_I8> для константы требуется от 9 до 32 бит.  
  
 3. Используйте краткие инструкции, за которым следует <xref:System.Reflection.Emit.OpCodes.Conv_I8> для константы, которые могут быть выражены в 8 или менее бит.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4` код операции:  
  
-   ILGenerator.Emit (OpCode, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 0 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|Помещает 0 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение 0 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все специальные короткие коды Push-4-байтовые целые числа в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.0` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 1 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|Помещает 1 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение 1, помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все специальные короткие коды Push-4-байтовые целые числа в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 2 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|Помещает 2 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение 2 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все специальные короткие коды Push-4-байтовые целые числа в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 3 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|Помещает 3 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение 3 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все специальные короткие коды Push-4-байтовые целые числа в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.3` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 4 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|Помещает 4 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение 4 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все специальные короткие коды Push-4-байтовые целые числа в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 5 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|Помещает 5 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение 5 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все специальные короткие коды Push-4-байтовые целые числа в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.5` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 6 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|Помещает 6 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение 6, помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все специальные короткие коды Push-4-байтовые целые числа в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.6` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 7 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|Помещает 7 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение 7 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все специальные короткие коды Push-4-байтовые целые числа в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.7` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 8 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|Помещает 8 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение 8 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все специальные короткие коды Push-4-байтовые целые числа в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение –1 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|15|ldc.i4.M1|Помещает значение -1 в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение -1, помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все специальные короткие коды Push-4-байтовые целые числа в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.m1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int8" /> в стек вычислений как <see langword="int32" /> (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1F < `int8` >|Инструкция ldc.i4.s `num`|Помещает `num` в стек как `int32`, краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение `num` помещается в стек.  
  
 `ldc.i4.s` является более эффективную кодировку для помещения целых чисел от -128 до 127 в стек вычислений.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.s` код операции:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int64" /> в стек вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.I8 `num`|Помещает `num` в стек как `int64`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает `int64` значение в стек.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i8` код операции:  
  
-   ILGenerator.Emit (OpCode, long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="float32" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.R4 `num`|Помещает `num` в стек как `F`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает `float32` значение в стек.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.r4` код операции:  
  
-   ILGenerator.Emit (OpCode, один)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="float64" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.R8 `num`|Помещает `num` в стек как `F`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает `float64` значение в стек.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.r8` код операции:  
  
-   ILGenerator.Emit (OpCode, double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент с заданным индексом массива на вершину стека вычислений в качестве типа, указанного в инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкции по шестнадцатеричном формате и формате сборки промежуточного языка MSIL, Microsoft, а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|Загружает элемент с `index` на вершину стека вычислений как тип `typeTok`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` выполняется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`.  
  
 Тип возвращаемого значения указан маркером `typeTok` в инструкции.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем значение верхней границы количества `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="native int" />, на вершину стека вычислений как <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|97|ldelem.i|Загружает элемент типа `native int` в `index` на вершину стека вычислений как `native int`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` выполняется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.i` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`.  
  
 Возвращаемое значение для `ldelem.i` является `native int`.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.i` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int8" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|Загружает элемент типа `int8` в `index` на вершину стека вычислений как `int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` выполняется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.i1` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`.  
  
 Возвращаемое значение для `ldelem.i1` является `int8`.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.i1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int16" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|92|ldelem.I2|Загружает элемент типа `int16` в `index` на вершину стека вычислений как `int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` выполняется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.i2` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`.  
  
 Возвращаемое значение для `ldelem.i2` является `int16`.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.i2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int32" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|Загружает элемент типа `int32` в `index` на вершину стека вычислений как `int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` выполняется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.i4` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`.  
  
 Возвращаемое значение для `ldelem.i4` является `int32`.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.i4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int64" /> с заданным индексом массива на вершину стека вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|96|ldelem.I8|Загружает элемент типа `int64` в `index` на вершину стека вычислений как `int64`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` выполняется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.i8` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`.  
  
 Возвращаемое значение для `ldelem.i8` является `int64`.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.i8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="float32" />, на вершину стека вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|98|ldelem.R4|Загружает элемент типа `float32` в `index` на вершину стека вычислений как тип `F`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` выполняется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.r4` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`.  
  
 Возвращаемое значение для `ldelem.r4` является `float32`.  
  
 Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.r4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="float64" />, на вершину стека вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|99|ldelem.R8|Загружает элемент типа `float64` в `index` на вершину стека вычислений как тип `F`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` выполняется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.r8` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`.  
  
 Возвращаемое значение для `ldelem.r8` является `float64`.  
  
 Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.r8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, содержащий ссылку на объект, на вершину стека вычислений как <see langword="O" /> (ссылка на объект).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|Загружает элемент ссылку на `index` на вершину стека вычислений как тип `O`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` выполняется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.ref` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`.  
  
 Возвращаемое значение для `ldelem.ref` является типом `O` (ссылка на объект).  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.ref` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int8" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|91|ldelem.U1|Загружает элемент типа `unsigned int8` в `index` на вершину стека вычислений как `int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` выполняется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.u1` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`.  
  
 Возвращаемое значение для `ldelem.u1` является `int8`.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.u1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int16" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|93|ldelem.U2|Загружает элемент типа `unsigned int16` с индексом на вершину стека вычислений как `int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` выполняется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.u2` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`.  
  
 Возвращаемое значение для `ldelem.u2` является `int16`.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.u2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int32" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|95|ldelem.U4|Загружает элемент типа `unsigned int32` с индексом на вершину стека вычислений как `int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` выполняется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.u4` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`.  
  
 Возвращаемое значение для `ldelem.u4` является `int32`.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если массив не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.u4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес элемента массива с заданным индексом на вершину стека вычислений как <see langword="&amp;" /> (управляемый указатель).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema `class`|Загружает адрес элемента массива с `index` на вершину стека вычислений как `&` (управляемый указатель).|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; адрес, хранящийся в позиции `index` в `array` выполняется поиск.  
  
4.  Адрес помещается в стек.  
  
 `ldelema` Используется для получения адреса объекта с определенного индекса в массиве объектов (типа `class`). `ldelema` Инструкция загружает адрес значения по индексу `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в верхней части стека. Массивы являются объектами, поэтому они представлены в значение типа `O`. Значение должно быть типа `class` переданный с инструкцией.  
  
 Возвращаемое значение для `ldelema` является управляемым указателем (тип `&`).  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelema` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет поиск значения поля в объекте, ссылка на который находится в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|Помещает значение поля в указанный объект в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект (или указатель) помещается в стек.  
  
2.  Ссылка на объект (или указатель) извлекается из стека; найти значение указанного поля в объекте.  
  
3.  Значение, хранящееся в поле помещается в стек.  
  
 `ldfld` Инструкция помещает значение поля в объекте в стек. Объект должен находиться в стеке как ссылка на объект (тип `O`), управляемый указатель (типа `&`), неуправляемый указатель (типа `native int`), временный указатель (типа `*`), или экземпляр типа значения. Использование неуправляемого указателя не разрешено в проверяемом коде. Поле объекта задано токеном метаданных, который должен ссылаться элемент поля. Возвращаемый тип является таким же, как связанные с этим полем. Поле может быть статическое поле или поля экземпляра (в этом случае объект не должен быть ссылкой на null).  
  
 `ldfld` Инструкция может предшествовать одно или оба указанных <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile> префиксы.  
  
 <xref:System.NullReferenceException> возникает, если объект имеет значение null, и поле не является статическим.  
  
 <xref:System.MissingFieldException> возникает, если указанное поле не найден в метаданных. Обычно это проверяется инструкции промежуточного языка MSIL (Microsoft) преобразуются в машинном коде, не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldfld` код операции:  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ищет адрес поля в объекте, ссылка на который находится в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|Помещает адрес `field` в указанный объект в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект (или указатель) помещается в стек.  
  
2.  Ссылка на объект (или указатель) извлекается из стека; найти адрес указанного поля в объекте.  
  
3.  Адрес указанного поля помещается в стек.  
  
 `ldflda` Инструкция помещает адрес поля в объекте в стек. Объект должен находиться в стеке как ссылка на объект (тип `O`), управляемый указатель (типа `&`), неуправляемый указатель (типа `native int`), временный указатель (типа `*`), или экземпляр типа значения. Использование неуправляемого указателя не разрешено в проверяемом коде. Поле объекта задано токеном метаданных, который должен ссылаться элемент поля.  
  
 Значение, возвращенное `ldflda` является управляемым указателем (тип `&`) Если объект не помещается в стек как неуправляемый указатель, в этом случае обратный адрес является также неуправляемый указатель (типа `native int`).  
  
 `ldflda` Инструкция может предшествовать одно или оба указанных <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile> префиксы.  
  
 <xref:System.InvalidOperationException> возникает, если объект не находится в домене приложения, при одновременном. Не удалось загрузить адрес поле, которое не находится внутри доступ к домену приложения.  
  
 <xref:System.NullReferenceException> возникает, если объект имеет значение null, и поле не является статическим.  
  
 <xref:System.MissingFieldException> возникает, если указанное поле не найден в метаданных. Обычно это проверяется инструкции промежуточного языка MSIL (Microsoft) преобразуются в машинном коде, не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldflda` код операции:  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений неуправляемый указатель (с типом <see langword="native int" />) на машинный код, реализующий заданный метод.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 06 &LT; `T` >|выполнить операцию LDFTN над `method`|Помещает указатель на метод, заданный параметром `method` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Неуправляемый указатель на конкретный метод помещается в стек.  
  
 Конкретный метод (`method`) могут вызываться с помощью <xref:System.Reflection.Emit.OpCodes.Calli> инструкции, если он ссылается на управляемый метод (или заглушка, которая переходит из управляемого в неуправляемый код).  
  
 Возвращаемое значение ссылается на машинный код с использованием среды CLR, соглашение о вызовах. Указатель this метод не должен быть передан в неуправляемый машинный код как процедура обратного вызова.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldftn` код операции:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="native int" /> в стек вычислений как <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4D|ldind.i|Загружает `native int` по адресу `addr` в стек как `native int`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение, расположенное по адресу извлечь.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.i` Инструкция `native int` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `native int`.  
  
 Все `ldind` инструкции являются ярлыками для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкцию, которая указывает на соответствующий класс встроенных значение.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильно сформированного Microsoft Intermediate Language (MSIL) гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещается в стек должен быть выровнен по естественному размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. в разделе <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>) безопасно выравниваются. Для типов данных, размер которых превышает 1 байт порядок байтов зависит от целевой ЦП. Любой код, зависящий от порядка байтов не может работать на всех платформах.  
  
 <xref:System.NullReferenceException> могут создаваться при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.i` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int8" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|46|ldind.i1|Загружает `int8` по адресу `addr` в стек как `int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение, расположенное по адресу извлечь.  
  
3.  Извлеченное значение помещается в стек. 
  
 `ldind.i1` Инструкция `int8` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `int32`.  
  
 Все `ldind` инструкции являются ярлыками для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкцию, которая указывает на соответствующий класс встроенных значение.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильно сформированного Microsoft Intermediate Language (MSIL) гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещается в стек должен быть выровнен по естественному размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. в разделе <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>) безопасно выравниваются. Для типов данных, размер которых превышает 1 байт порядок байтов зависит от целевой ЦП. Любой код, зависящий от порядка байтов не может работать на всех платформах.  
  
 <xref:System.NullReferenceException> могут создаваться при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.i1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int16" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|48|ldind.I2|Загружает `int16` по адресу `addr` в стек как `int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение, расположенное по адресу извлечь.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.i2` Инструкция `int16` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `int32`.  
  
 Все `ldind` инструкции являются ярлыками для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкцию, которая указывает на соответствующий класс встроенных значение.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильно сформированного Microsoft Intermediate Language (MSIL) гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещается в стек должен быть выровнен по естественному размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. в разделе <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>) безопасно выравниваются. Для типов данных, размер которых превышает 1 байт порядок байтов зависит от целевой ЦП. Любой код, зависящий от порядка байтов не может работать на всех платформах.  
  
 <xref:System.NullReferenceException> могут создаваться при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.i2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|Загружает `int32` по адресу `addr` в стек как `int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение, расположенное по адресу извлечь.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.i4` Инструкция `int32` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `int32`.  
  
 Все `ldind` инструкции являются ярлыками для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкцию, которая указывает на соответствующий класс встроенных значение.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильно сформированного Microsoft Intermediate Language (MSIL) гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещается в стек должен быть выровнен по естественному размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. в разделе <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>) безопасно выравниваются. Для типов данных, размер которых превышает 1 байт порядок байтов зависит от целевой ЦП. Любой код, зависящий от порядка байтов не может работать на всех платформах.  
  
 <xref:System.NullReferenceException> могут создаваться при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.i4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int64" /> в стек вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4C|ldind.I8|Загружает `int64` по адресу `addr` в стек как `int64`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение, расположенное по адресу извлечь.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.i8` Инструкция `int64` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `int64`.  
  
 Все `ldind` инструкции являются ярлыками для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкцию, которая указывает на соответствующий класс встроенных значение.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильно сформированного Microsoft Intermediate Language (MSIL) гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещается в стек должен быть выровнен по естественному размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. в разделе <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>) безопасно выравниваются. Для типов данных, размер которых превышает 1 байт порядок байтов зависит от целевой ЦП. Любой код, зависящий от порядка байтов не может работать на всех платформах.  
  
 <xref:System.NullReferenceException> могут создаваться при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.i8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="float32" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4E|ldind.R4|Загружает `float32` по адресу `addr` стек как тип `F`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение, расположенное по адресу извлечь.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.r4` Инструкция `float32` значение из указанного адреса (типа `native int`, `&`, или *) в стек как тип `F`.  
  
 Все `ldind` инструкции являются ярлыками для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкцию, которая указывает на соответствующий класс встроенных значение.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильно сформированного Microsoft Intermediate Language (MSIL) гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещается в стек должен быть выровнен по естественному размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. в разделе <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>) безопасно выравниваются. Для типов данных, размер которых превышает 1 байт порядок байтов зависит от целевой ЦП. Любой код, зависящий от порядка байтов не может работать на всех платформах.  
  
 <xref:System.NullReferenceException> могут создаваться при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.r4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="float64" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4F|ldind.R8|Загружает `float64` по адресу `addr` стек как тип `F`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение, расположенное по адресу извлечь.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.r8` Инструкция `float64` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `float64`.  
  
 Все `ldind` инструкции являются ярлыками для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкцию, которая указывает на соответствующий класс встроенных значение.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильно сформированного Microsoft Intermediate Language (MSIL) гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещается в стек должен быть выровнен по естественному размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. в разделе <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>) безопасно выравниваются. Для типов данных, размер которых превышает 1 байт порядок байтов зависит от целевой ЦП. Любой код, зависящий от порядка байтов не может работать на всех платформах.  
  
 <xref:System.NullReferenceException> могут создаваться при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.r8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку в стек вычислений ссылки на объект как <see langword="O" /> (ссылка на объект).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|50|ldind.ref|Загружает ссылку на объект по адресу `addr` стек как тип `O`|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается ссылка на объект, расположенный по адресу.  
  
3.  Извлеченная ссылка помещается в стек.  
  
 `ldind.ref` Инструкция косвенно загружает ссылку на объект по указанному адресу (типа `native int`, `&`, или *) в стек как тип `O`.  
  
 Все `ldind` инструкции являются ярлыками для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкцию, которая указывает на соответствующий класс встроенных значение.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильно сформированного Microsoft Intermediate Language (MSIL) гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещается в стек должен быть выровнен по естественному размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. в разделе <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>) безопасно выравниваются. Для типов данных, размер которых превышает 1 байт порядок байтов зависит от целевой ЦП. Любой код, зависящий от порядка байтов не может работать на всех платформах.  
  
 <xref:System.NullReferenceException> могут создаваться при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.ref` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int8" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|47|ldind.U1|Загружает `unsigned int8` по адресу `addr` в стек как `int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение, расположенное по адресу извлечь.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.u1` Инструкция `unsigned int8` значение из указанного адреса (типа`native int`, `&`, или *) в стек как `int32`.  
  
 Все `ldind` инструкции являются ярлыками для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкцию, которая указывает на соответствующий класс встроенных значение.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильно сформированного Microsoft Intermediate Language (MSIL) гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещается в стек должен быть выровнен по естественному размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. в разделе <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>) безопасно выравниваются. Для типов данных, размер которых превышает 1 байт порядок байтов зависит от целевой ЦП. Любой код, зависящий от порядка байтов не может работать на всех платформах.  
  
 <xref:System.NullReferenceException> могут создаваться при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.u1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int16" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|49|ldind.U2|Загружает `unsigned int16` по адресу `addr` в стек как `int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение, расположенное по адресу извлечь.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.u2` Инструкция `unsigned int16` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `int32`.  
  
 Все `ldind` инструкции являются ярлыками для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкцию, которая указывает на соответствующий класс встроенных значение.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильно сформированного Microsoft Intermediate Language (MSIL) гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещается в стек должен быть выровнен по естественному размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. в разделе <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>) безопасно выравниваются. Для типов данных, размер которых превышает 1 байт порядок байтов зависит от целевой ЦП. Любой код, зависящий от порядка байтов не может работать на всех платформах.  
  
 <xref:System.NullReferenceException> могут создаваться при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.u2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4B|ldind.U4|Загружает `unsigned int32` по адресу `addr` в стек как `int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение, расположенное по адресу извлечь.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.u4` Инструкция `unsigned int32` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `int32`.  
  
 Все `ldind` инструкции являются ярлыками для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкцию, которая указывает на соответствующий класс встроенных значение.  
  
 Обратите внимание, что целочисленные значения меньше 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильно сформированного Microsoft Intermediate Language (MSIL) гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещается в стек должен быть выровнен по естественному размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. в разделе <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>) безопасно выравниваются. Для типов данных, размер которых превышает 1 байт порядок байтов зависит от целевой ЦП. Любой код, зависящий от порядка байтов не может работать на всех платформах.  
  
 <xref:System.NullReferenceException> могут создаваться при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.u4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений сведения о числе элементов одномерного массива с индексацией от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8E|ldlen|Помещает длина (типа `natural unsigned int`) массива в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект в массив помещается в стек.  
  
2.  Ссылка на массив извлекается из стека и длина является вычисляемым.  
  
3.  Длина помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены в значение типа `O`. Длина возвращается в виде `natural unsigned int`.  
  
 <xref:System.NullReferenceException> возникает, если ссылка на массив является пустой ссылкой.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldlen` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0C &LT; `unsigned int16` >|ldloc `index`|Загружает в локальную переменную с индексом `index` в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение локальной переменной по указанному индексу помещается в стек.  
  
 `ldloc` Инструкция помещает содержимое локальной переменной с заданным индексом в стек вычислений, где локальные переменные будут пронумерованы от 0 и более поздних версий. Локальные переменные инициализируются 0 перед входом в метод, только в том случае, если флаг инициализации метода имеет значение true. Существует 65 535 (2 ^ 16 - 1) возможных локальных переменных (0-65 534). Индекс 65 535 является недопустимым, так как возможны реализации, использующие 2-байтовое целое число для отслеживания и локальный индекс, а также общее число "Локальные" для данного метода. Если индекс 65 535 считался действительным, потребуется расширить целое число для отслеживания числа локальных переменных в этом методе.  
  
 `ldloc.0`, `ldloc.1`, `ldloc.2`, И `ldloc.3` инструкции обеспечивают эффективную кодировку для доступа к первые четыре локальных переменных.  
  
 Тип значения — так же, как тип локальной переменной, указанной в заголовке method. См. раздел I. локальных переменных, которые меньше, чем длиной 4 байта, расширяются до типа `int32` когда они были загружены в стек. Значения с плавающей запятой расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `ldloc` код операции:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, короткое)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|06|ldloc.0|Загружает в стек вычислений локальную переменную с индексом 0.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение локальной переменной с индексом 0 помещается в стек.  
  
 `ldloc.0` особенно эффективный вариант кодировки <xref:System.Reflection.Emit.OpCodes.Ldloc>, предоставляя доступ к локальной переменной с индексом 0.  
  
 Тип значения — так же, как тип локальной переменной, указанной в заголовке method. Локальные переменные, которые меньше, чем длиной 4 байта, расширяются до типа `int32` когда они были загружены в стек. Значения с плавающей запятой расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldloc.0` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|07|ldloc.1|Загружает в стек вычислений локальную переменную с индексом 1.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение локальной переменной с индексом 1 помещается в стек.  
  
 `ldloc.1` особенно эффективный вариант кодировки <xref:System.Reflection.Emit.OpCodes.Ldloc>, предоставляя доступ к локальной переменной с индексом 1.  
  
 Тип значения — так же, как тип локальной переменной, указанной в заголовке method. Локальные переменные, которые меньше, чем длиной 4 байта, расширяются до типа `int32` когда они были загружены в стек. Значения с плавающей запятой расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldloc.1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|08|ldloc.2|Загружает в стек вычислений локальную переменную с индексом 2.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение локальной переменной с индексом 2 помещается в стек.  
  
 `ldloc.2` особенно эффективный вариант кодировки <xref:System.Reflection.Emit.OpCodes.Ldloc>, предоставляя доступ к локальной переменной с индексом 2.  
  
 Тип значения — так же, как тип локальной переменной, указанной в заголовке method. Локальные переменные, которые меньше, чем длиной 4 байта, расширяются до типа `int32` когда они были загружены в стек. Значения с плавающей запятой расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldloc.2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|09|ldloc.3|Загружает в стек вычислений локальную переменную с индексом 3.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение локальной переменной с индексом 3 помещается в стек.  
  
 `ldloc.3` особенно эффективный вариант кодировки <xref:System.Reflection.Emit.OpCodes.Ldloc>, предоставляя доступ к локальной переменной с индексом 3.  
  
 Тип значения — так же, как тип локальной переменной, указанной в заголовке method. Локальные переменные, которые меньше, чем длиной 4 байта, расширяются до типа `int32` когда они были загружены в стек. Значения с плавающей запятой расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldloc.3` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с указанным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|Загружает в локальную переменную с индексом `index` в стек, краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение локальной переменной по указанному индексу помещается в стек.  
  
 `ldloc.s` Инструкция помещает содержимое локальной переменной с заданным индексом в стек вычислений, где локальные переменные будут пронумерованы от 0 и более поздних версий. Локальные переменные инициализируются 0 перед входом в метод, если флаг инициализации метода имеет значение true. Составляет 256 (2 ^ 8) возможных локальных переменных (0-255) в краткую форму, который является более эффективную кодировку чем `ldloc`.  
  
 Тип значения — так же, как тип локальной переменной, указанной в заголовке method. См. раздел I. локальных переменных, которые меньше, чем длиной 4 байта, расширяются до типа `int32` когда они были загружены в стек. Значения с плавающей запятой расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `ldloc.s` код операции:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений адрес локальной переменной с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE OD &LT; `unsigned int16` >|ldloca `index`|Загружает адрес локальной переменной в `index` в стек вычислений.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес, хранящийся в локальную переменную с указанным индексом помещается в стек.  
  
 `ldloca` Инструкция помещает адрес локальной переменной с заданным индексом в стек, где локальные переменные будут пронумерованы от 0 и более поздних версий. Значение в стек, уже выровнено для использования с инструкциями, как <xref:System.Reflection.Emit.OpCodes.Ldind_I> и <xref:System.Reflection.Emit.OpCodes.Stind_I>. Результатом является временный указатель (типа `*`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldloca` код операции:  
  
-   ILGenerator.Emit (OpCode, короткое)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений адрес локальной переменной с указанным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|Загружает адрес локальной переменной в `index` в стек вычислений, краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес, хранящийся в локальную переменную с указанным индексом помещается в стек.  
  
 `ldloca.s` Инструкция помещает адрес локальной переменной с заданным индексом в стек, где локальные переменные будут пронумерованы от 0 и более поздних версий. Значение в стек, уже выровнено для использования с инструкциями, как <xref:System.Reflection.Emit.OpCodes.Ldind_I> и <xref:System.Reflection.Emit.OpCodes.Stind_I>. Результатом является временный указатель (типа `*`).  
  
 `ldloca.s` Инструкция обеспечивает эффективную кодировку для использования с локальными переменными от 0 до 255.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldloca.s` код операции:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений пустую ссылку (тип <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|14|ldnull|Отправить ссылку на null в стек|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылки на пустой объект помещается в стек.  
  
 `ldnull` передает пустую ссылку (тип `O`) в стеке. Это используется для инициализации расположения, прежде чем они заполняются данными, или когда они станут устаревшими.  
  
 `ldnull` предоставляет ссылку на null, не зависит от размера.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldnull` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует объект с типом значения, размещенный по указанному адресу, на вершину стека вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Копировать экземпляр типа значения `class` в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес объекта типа значение помещается в стек.  
  
2.  Адрес извлекается из стека и выполняется поиск экземпляра по этому адресу.  
  
3.  Значение объекта, который хранится по этому адресу помещается в стек.  
  
 `ldobj` Инструкция используется для передачи типа значения в качестве параметра.  
  
 `ldobj` Инструкции копирует значение, на которые указывают `addrOfValObj` (типа `&`, `*`, или `native int`) в верхней части стека. Число копируемых байтов зависит от размера класса (как указано `class` параметр). `class` Параметр является маркер метаданных, представляющий тип значения.  
  
 Операция `ldobj` инструкция может быть изменено, непосредственно перед знаком <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.TypeLoadException> возникает, если не удается найти класс. Обычно это обнаруживается инструкции промежуточного языка MSIL (Microsoft) преобразуется в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldobj` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений значение статического поля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|Отправить значение `field` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение поля помещается в стек.  
  
 `ldsfld` Инструкция помещает значение статического (общим для всех экземпляров класса) в стек. Возвращаемый тип —, связанный с маркером метаданных `field`.  
  
 `ldsfld` Инструкции может иметь <xref:System.Reflection.Emit.OpCodes.Volatile> префикс.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldsfld` код операции:  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений адрес статического поля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|Push-уведомлений в адрес `field` в стеке|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес указанного поля помещается в стек.  
  
 `ldsflda` Инструкция помещает адрес статического (общим для всех экземпляров класса) в стек. Адрес может быть представлен как временный указатель (типа `*`) Если маркер метаданных `field` относится к типу, управляемой памятью. В противном случае он соответствует неуправляемый указатель (типа `native int`). Обратите внимание, что `field` может быть статический глобальной с присвоен относительный виртуальный адрес (смещение поля из базового адреса, по которому его содержащего PE-файл загружается в память) где память является неуправляемым.  
  
 `ldsflda` Инструкции может иметь <xref:System.Reflection.Emit.OpCodes.Volatile> префикс.  
  
 <xref:System.MissingFieldException> возникает, если поле не найдено в метаданных. Обычно это проверяется при преобразовании в машинный код, не во время выполнения инструкции промежуточного языка MSIL (Microsoft).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldsflda` код операции:  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек ссылку на новый объект, представляющий строковой литерал, хранящийся в метаданных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|Помещает объект строк для маркером строки метаданных `mdToken`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект в строку помещается в стек.  
  
 `ldstr` Инструкция помещает ссылку на объект (тип `O`) в новый строковый объект, представляющий определенные строковой литерал, хранящийся в метаданных. `ldstr` Инструкция выделяет нужное количество памяти и выполняет преобразование строкового литерала из формата, используемого в файле, чтобы формат строки, необходимые во время выполнения.  
  
 Common Language Infrastructure (CLI) гарантирует, что результат двух `ldstr` инструкций, ссылающихся на две лексемы метаданных, которые имеют разную последовательность символов возврата же строковый объект (этот процесс называется «изоляцией строк»).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldstr` код операции:  
  
-   ILGenerator.Emit (OpCode, строка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует токен метаданных в его представление времени выполнения, а затем помещает в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D0 &LT; `T` >|ldtoken `token`|Преобразует токен метаданных в его представление времени выполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Переданная лексема преобразуется в `RuntimeHandle` и помещается в стек.  
  
 `ldtoken` Push-уведомлений инструкции `RuntimeHandle` для заданным токеном метаданных. Объект `RuntimeHandle` может быть `fieldref/fielddef`, `methodref/methoddef`, или `typeref/typedef`.  
  
 Значение, помещаемое в стеке может использоваться в вызовах `Reflection` методы в библиотеке классов системы.  
  
 Сведения о дескрипторах времени выполнения см. следующие классы: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, и <xref:System.RuntimeMethodHandle>.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `ldtoken` код операции:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений неуправляемый указатель (с типом <see langword="native int" />) на машинный код, реализующий виртуальный метод, связанный с заданным объектом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 07 &LT; `T` >|ldvirtftn `method`|Помещает указатель объекта виртуальный метод `method` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и адрес точки входа метода (как указано токеном метаданных `method`) выполняется поиск.  
  
3.  Указатель на `method` помещается в стек.  
  
 Неуправляемый указатель помещается в стек по `ldvirtftn` инструкции можно вызвать с помощью <xref:System.Reflection.Emit.OpCodes.Calli> инструкции, если он ссылается на управляемый метод (или заглушка, которая переходит из управляемого в неуправляемый код).  
  
 Неуправляемый указатель указывает на машинном коде с помощью среды CLR, соглашение о вызовах. Указатель this метод не должен быть передан в неуправляемый машинный код как процедура обратного вызова.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldvirtftn` код операции:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|ДД &LT; `int32` >|Оставьте `target`|Выполняет выход из защищенной области кода.|  
  
 Нет Переходные состояния стека для данной инструкции не.  
  
 `leave` Инструкция обеспечивает безусловную передачу управления конечной инструкции, представленное в виде 4-со знаком смещение в байтах от начала инструкции, которая следует за текущей инструкцией.  
  
 `leave` Аналогичен инструкции `br` инструкции, но его можно использовать для выхода из `try`, `filter`, или `catch` block, тогда как обычные инструкции перехода может использоваться только в этот блок для передачи управления в его. `leave` Инструкция очищает стек вычислений и гарантирует, что соответствующие вокруг `finally` блоки выполняются.  
  
 Нельзя использовать `leave` инструкции, чтобы выйти из `finally` блока. Чтобы упростить создание кода для обработчиков исключений, допускается в пределах блока catch для использования `leave` инструкции для передачи управления любой инструкции в пределах связанного `try` блока.  
  
 Если инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `leave` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DE &LT; `int8` >|leave.s `target`|Выйдите из защищенной области кода.|  
  
 Нет Переходные состояния стека для данной инструкции не.  
  
 `leave.s` Инструкция обеспечивает безусловную передачу управления конечной инструкции, представленной как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 `leave.s` Аналогичен инструкции `br` инструкции, но его можно использовать для выхода из `try`, `filter`, или `catch` block, тогда как обычные инструкции перехода может использоваться только в этот блок для передачи управления в его. `leave.s` Инструкция очищает стек вычислений и гарантирует, что соответствующие вокруг `finally` блоки выполняются.  
  
 Нельзя использовать `leave.s` инструкции, чтобы выйти из `finally` блока. Чтобы упростить создание кода для обработчиков исключений, допускается в пределах блока catch для использования `leave.s` инструкции для передачи управления любой инструкции в пределах связанного `try` блока.  
  
 Если инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `leave.s` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выделяет определенное количество байтов из пула локальной динамической памяти и помещает в стек вычислений адрес (временный указатель с типом <see langword="*" />) первого выделенного байта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|Выделите место в локальной куче.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Число байтов для распределения помещается в стек.  
  
2.  Число байтов, которое извлекается из стека; объем памяти, в зависимости от размера выделяется в локальной куче.  
  
3.  Указатель на первый байт выделенной памяти помещается в стек.  
  
 `localloc` Выделяет инструкции `size` (тип `natural unsigned int`) байт из локальной динамической памяти пула и возвращает адрес (временный указатель, тип `*`) первого выделенного байта. Возвращаемый блок памяти, присваивается значение 0 только в том случае, если флаг инициализации метода является `true`. Время выполнения текущего метода <xref:System.Reflection.Emit.OpCodes.Ret>, становится доступным для повторного использования пула локальной памяти.  
  
 Итоговый адрес выровнен таким образом, любой тип-примитив возможность сохранения с помощью `stind` инструкции (такие как <xref:System.Reflection.Emit.OpCodes.Stind_I4>) и загрузить с помощью `ldind` инструкции (такие как <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 `localloc` Инструкция не может быть внутри `filter`, `catch`, `finally`, или `fault` блока.  
  
 <xref:System.StackOverflowException> возникает, если недостаточно памяти для обслуживания запроса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `localloc` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений ссылку на экземпляр определенного типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|C6 < `T` >|Mkrefany `class`|Помещает ссылку типа `class` в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Указатель на элемент данных помещается в стек.  
  
2.  Указатель извлекается и преобразовать в ссылку с определенным типом типа `class`.  
  
3.  Ссылка на типизированный помещается в стек.  
  
 `mkrefany` Инструкция поддерживает передачу ссылок с динамической типизацией. Указатель должен иметь тип `&`, `*`, или `native int`и содержать действительный адрес фрагмента данных. `Class` токен класс описывает тип данных, который ссылается указатель. `Mkrefany` Помещает в стек, предоставляя непрозрачный дескриптор указателя и тип ссылку с определенным типом `class`.  
  
 Для передачи в метод, который требует ссылку с определенным типом параметра является только допустимой операцией ссылку с определенным типом. Вызываемый объект, который затем можно использовать <xref:System.Reflection.Emit.OpCodes.Refanytype> и <xref:System.Reflection.Emit.OpCodes.Refanyval> инструкциям, чтобы получить тип (класс) и адрес соответственно.  
  
 <xref:System.TypeLoadException> возникает, если `class` не удается найти. Обычно это обнаруживается инструкции промежуточного языка MSIL (Microsoft) преобразуются в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `mkrefany` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два значения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5A|mul|Умножает два значения в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` умножается на `value2`.  
  
4.  Результат помещается в стек.  
  
 `mul` Умножает инструкции `value1` по `value2` и помещает результат в стек. Операций с целыми числами отбрасываются старшие разрядов в случае переполнения.  
  
 См. в разделе <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> для целыми числами умножение операции с обработкой.  
  
 Для типов с плавающей запятой, 0 * бесконечность = NaN.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `mul` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два целочисленных значения, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|Умножает два целочисленных значения в стеке с проверкой переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` умножается на `value2`, с проверкой переполнения.  
  
4.  Результат помещается в стек.  
  
 `mul.ovf` Инструкции умножает целое число `value1` по целому `value2` и помещает результат в стек. Исключение возникает в том случае, если результат не умещается в типе результата.  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `mul.ovf` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|Умножает два значения без знака в стеке и выполняет проверку переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` умножается на `value2`, с проверкой переполнения.  
  
4.  Результат помещается в стек.  
  
 `mul.ovf.un` Инструкции умножает целое число без знака `value1` , целое число без знака `value2` и помещает результат в стек. Исключение возникает в том случае, если результат не умещается в типе результата.  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `mul.ovf.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Отвергает значение и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|65|Neg|Инвертирует значение, находящееся на вершине стека.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека и отрицательное.  
  
3.  Результат помещается в стек.  
  
 `neg` Инструкция меняет значения и помещает результат в стеке. Тип возвращаемого значения совпадает с типом операнда.  
  
 Является стандартной отрицания целочисленных значений дополнение до двух отрицания. В частности Инверсия наибольшее отрицательное число (которая не поддерживает положительного эквивалента) возвращает наибольшее отрицательное число. Для обнаружения такое использование переполнения <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> инструкции вместо (то есть вычитание из 0).  
  
 Инверсия число с плавающей запятой не может вызвать переполнения, и операция над значением NaN возвращает значение NaN.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `neg` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений ссылку на объект — новый одномерный массив с индексацией от нуля, состоящий из элементов заданного типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|Создает новый массив с элементами типа `etype`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Число элементов в массиве помещается в стек.  
  
2.  Число элементов, извлекается из стека и создается массив.  
  
3.  Ссылка на объект в новый массив помещается в стек.  
  
 `newarr` Инструкция помещает ссылку на объект (тип `O`) в новый одномерный массив (с нуля), элементы которого имеют тип `etype` (лексема метаданных, описывающая тип). Число элементов в новом массиве должны быть указаны в виде `native int`. Допустимый массив индексов диапазона от 0 до максимального количества элементов минус 1.  
  
 Элементы массива могут быть любого типа, включая типы значений.  
  
 Отсчитываемый от нуля одномерный массив массивы чисел создаются с помощью лексемы метаданных, указывающей соответствующий тип значения (<xref:System.Int32>, и так далее). Элементы массива, инициализируются значением 0 соответствующего типа.  
  
 Для одномерных массивов и многомерные массивы создаются с помощью <xref:System.Reflection.Emit.OpCodes.Newobj> вместо `newarr`. Но чаще они создаются с помощью методов <xref:System.Array> в .NET Framework.  
  
 <xref:System.OutOfMemoryException> возникает, если памяти недостаточно для удовлетворения запроса.  
  
 <xref:System.OverflowException> возникает, если `numElems` меньше 0.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `newarr` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает новый объект или новый экземпляр типа значения и помещает ссылку на объект (тип <see langword="O" />) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Размещает неинициализированный объект или значение тип и вызывает constructor `ctor`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Аргументы `arg1` через `argn` передаются в стеке в последовательности.  
  
2.  Аргументы `argn` через `arg1` извлекаются из стека и передаются в `ctor` для создания объекта.  
  
3.  Ссылка на новый объект помещается в стек.  
  
 `newobj` Инструкция создает новый объект или новый экземпляр типа значения. `Ctor` является маркером метаданных ( `methodref` или `methoddef` , должен быть помечен как конструктор), указывающая имя, класс и сигнатура конструктора для вызова.  
  
 `newobj` Инструкции выделяет новый экземпляр класса, связанного с `ctor` и инициализирует все поля в новый экземпляр 0 (соответствующего типа) или пустыми ссылками. Затем он вызывает конструктор `ctor` с заданными аргументами и вновь созданного экземпляра. После вызова конструктора, инициализированный ссылку на объект (тип `O`) помещается в стек.  
  
 С точки зрения конструктора неинициализированный объект является аргументом 0 и выполните другие аргументы, передаваемые newobj в порядке.  
  
 Все с нуля одномерные массивы создаются с помощью <xref:System.Reflection.Emit.OpCodes.Newarr>, а не `newobj`. С другой стороны, все другие массивы (имеющие несколько измерений или одномерные, но не от нуля) создаются с помощью `newobj`.  
  
 Типы значений не создаются обычно с помощью `newobj`. Они размещаются как аргументы или локальные переменные, с помощью `newarr` (для одномерных массивов отсчитываемый от нуля) или как поля объектов. После выделения памяти, они инициализируются с помощью <xref:System.Reflection.Emit.OpCodes.Initobj>. Тем не менее `newobj` инструкция может использоваться для создания нового экземпляра типа значения в стеке, который затем может быть передан как аргумент, хранящихся в локальной и т. д.  
  
 <xref:System.OutOfMemoryException> возникает, если памяти недостаточно для удовлетворения запроса.  
  
 <xref:System.MissingMethodException> возникает, если метод-конструктор `ctor` с указанным именем класса и подпись не найдена. Обычно это обнаруживается инструкции промежуточного языка MSIL (Microsoft) преобразуются в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `newobj` код операции:  
  
-   ILGenerator.Emit (OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заполняет пространство, если коды операции содержат исправления. Никаких значимых операций не выполняется, хотя может быть пройден цикл обработки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|00|nop|Выполняет операцию без поведения.|  
  
 Нет без изменения состояния стека, определенных для данной инструкции.  
  
 `nop` Операции не выполняет никаких действий. Он предназначен для заполнения в пространстве, если коды операции содержат исправления.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `nop` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое дополнение целочисленного значения, находящегося на вершине стека, и помещает результат в стек с тем же типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|66|not|Вычисляет побитовое дополнение значения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека и его побитовое дополнение вычисляется.  
  
3.  Результат помещается в стек.  
  
 `not` Инструкция вычисляет побитовое дополнение целочисленного значения и помещает результат в стек. Тип возвращаемого значения совпадает с типом операнда.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `not` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое дополнение двух целочисленных значений, находящихся на вершине стека, и помещает результат в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|60|или|Выполняет побитовую операцию или над двумя целыми числами, возвращает целое число.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека и поразрядное или вычисляемые.  
  
4.  Результат помещается в стек.  
  
 `or` Инструкция выполняет Поразрядную операцию из двух значений на вершине стека, помещает результат в стек.  
  
 `Or` представляет собой операцию целыми числами.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `or` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Удаляет значение, находящееся на вершине стека.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|26|pop|Извлекает верхнее значение из стека.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Верхнее значение извлекается из стека.  
  
 `pop` Инструкция удаляет верхний элемент из стека.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `pop` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что последующая операция, связанная с адресом массива, не выполняет никаких проверок во время выполнения и возвращает управляемый указатель, изменение которого запрещено.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкции по шестнадцатеричном формате и формате сборки промежуточного языка MSIL, Microsoft, а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1E|только для чтения.|Укажите, что операции взятия адреса последующих массива не выполняет никаких проверок во время выполнения, и что он возвращает управляемый указатель с ограниченной возможностью изменения.|  
  
 Этот префикс может использоваться только в ближайший предшествующий `ldelema` инструкцию и вызовы к специальной `Address` метод для массивов. Влияние на последующую операцию получается двойная:  
  
1.  Во время выполнения выполняется не операция проверки типа. Обратите внимание, что обычно выполняется неявная проверка типа для `ldelema` и `stelem` инструкции при использовании ссылки на тип массивов. Никогда нет проверку типов во время выполнения для классов значений, поэтому `readonly` в этом случае является холостой.  
  
2.  Средство проверки рассматривает результат операции взятия адреса как управляемый указатель с ограниченной возможностью изменения.  
  
 Говорят, что указатель ограничен Изменяемость, определяющий тип контролирует, можно ли изменить значение. Для классов значений, которые предоставляют не открытые поля или методы, которые обновляют значение, указатель доступен только для чтения (поэтому имя префикса). В частности не предоставляют мутаторы классы, представляющие типы-примитивы (например, System.Int32) и таким образом доступны только для чтения.  
  
 Ограниченный таким образом управляемый указатель может использоваться только одним из следующих способов:  
  
-   Как `object` параметр для `ldfld`, `ldflda`, `stfld`, `call`, или`constrained callvirt` инструкции.  
  
-   Как `pointer` параметр `ldobj` инструкций или одной из `ldind` инструкции.  
  
-   Как `source` параметр `cpobj` инструкции.  
  
 Все остальные операции запрещены, включая `stobj`, `initobj`, или `mkrefany` операций или любой другой `stind` инструкции.  
  
 Цель `readonly` префикс является избежание проверку типов, при извлечении элемента из массива в универсальном коде. Например, выражение `arr[i].m()`, где тип элемента массива `arr` является универсальным типом, ограниченного до интерфейса с помощью метода `m`, может компилироваться в следующий MSIL.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Без `readonly` префикс, `ldelema` будет выполнять проверку типов в случае инструкция где! 0 был ссылочным типом. Не только неэффективен эта проверка типа, но это семантически неправилен. Проверка типа для `ldelema` является точным соответствием, который является слишком строгим. Если массив подклассы типа! 0, приведенный выше код не пройдут проверку типов.  
  
 Адрес элемента массива извлекается, а не сам элемент, чтобы получить дескриптор для `arr[i]` works для обоих типы значений и ссылочные типы что таким образом, может быть передан `constrained callvirt` инструкции.  
  
 В целом небезопасно пропустить проверку во время выполнения, если в массиве содержатся элементы ссылочного типа. В целях безопасности необходимо, чтобы гарантировать, что в массив не было изменений через этот указатель. Правила проверки обеспечить это. Ограниченный управляемый указатель могут передаваться как объект из вызовов методов экземпляра, поэтому он не является доступным только для чтения для типов значений, но нет никаких проблем безопасности типа для типов значений.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `readonly` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает токен типа, внедренный в ссылку с определенным типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Помещает токен типа, хранящихся в ссылку с определенным типом.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на тип значение помещается в стек.  
  
2.  Ссылка на типизированный извлекается из стека и получить его соответствующий маркер типа.  
  
3.  Токен типа помещается в стек.  
  
 Типизированная ссылка содержит маркер типа и адрес для экземпляра объекта.  
  
 `refanytype` Инструкция извлекает токен типа, внедренный в ссылку. См. в разделе <xref:System.Reflection.Emit.OpCodes.Mkrefany> сведения о создании типизированных ссылок.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `refanytype` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает адрес (тип <see langword="&amp;" />), внедренный в ссылку с определенным типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|Помещает адресу, сохраненному в ссылку с определенным типом.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на тип значение помещается в стек.  
  
2.  Ссылка на типизированный извлекается из стека и получить соответствующий адрес.  
  
3.  Адрес помещается в стек.  
  
 Типизированная ссылка содержит маркер типа и адрес для экземпляра объекта.  
  
 `refanyval` Инструкция извлекает адрес, внедренный в ссылку с определенным типом. Тип, внедренный в ссылку с определенным типом в стеке должны соответствует типу, заданному параметром `type` (токен метаданных, либо `typedef` или `typeref`). См. в разделе <xref:System.Reflection.Emit.OpCodes.Mkrefany> Дополнительные сведения.  
  
 <xref:System.InvalidCastException> возникает, если `type` не идентичен типа, хранящийся в ссылку на тип (в этом случае `type` предоставляется класс <xref:System.Reflection.Emit.OpCodes.Mkrefany> инструкций, который создал сказал типизированную ссылку).  
  
 <xref:System.TypeLoadException> возникает, если `type` не удается найти.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `refanyval` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение на другое и помещает остаток в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5D|REM|Помещает остаток от деления `value1` по `value2` в стек.|  
  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Объект `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека и остальная часть `value1` `div` `value2` вычисляется.  
  
4.  Результат помещается в стек.  
  
 `result` = `value1` `rem` `value2` удовлетворяет следующим условиям:  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`), и:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, входа (`result`) = входа (`value1`), где `div` деления инструкция, которая усекает в сторону нуля.  
  
 Если `value2` равно нулю или `value1` -бесконечность, результатом будет NaN. Если `value2` равно бесконечности, результатом является `value1` (инверсией для `-infinity`).  
  
 Целочисленные операции создают исключение <xref:System.DivideByZeroException> Если `value2` равно нулю.  
  
 Обратите внимание, что на платформах на базе Intel <xref:System.OverflowException> возникает исключение при вычислении (minint `rem` -1).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `rem` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение без знака на другое значение без знака и помещает остаток в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5E|REM.un|Помещает остаток от деления числа без знака `value1` на значение без знака `value2` в стек.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека и остальная часть `value1` `div` `value2` вычисляется.  
  
4.  Результат помещается в стек.  
  
 `result` = `value1` `rem.un` `value2` удовлетворяет следующим условиям:  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`), и:  
  
 0 = `result`  <  `value2`, где `div.un` инструкция деления числа без знака.  
  
 `rem.un` Инструкция вычисляет `result` и помещает его в стеке. `Rem.un` обрабатывает аргументы как целых чисел без знака, хотя <xref:System.Reflection.Emit.OpCodes.Rem> обрабатывает их как целых чисел.  
  
 `Rem.un` не определен для чисел с плавающей запятой.  
  
 Целочисленные операции создают исключение <xref:System.DivideByZeroException> Если `value2` равно нулю.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `rem.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет возврат из текущего метода, помещая возвращаемое значение (если имеется) из стека вычислений вызываемого метода в стек вычислений вызывающего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2A|код возврата:|Возврат из метода, возможно, возвращая значение.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Возвращаемое значение извлекается из стека вызываемого метода.  
  
2.  Возвращаемое значение, полученное на шаге 1, помещается в стек вычислений вызывающего объекта.  
  
 Если возвращаемое значение отсутствует в стеке вычислений вызываемый объект, значение не возвращается (без стека вариантов поведения для метода, вызываемого и вызывающего объекта).  
  
 Тип возвращаемого значения, если таковые имеются, текущего метода определяет тип значения с вершины стека и скопированный в стек метода, который вызвал текущий метод. В стек для текущего метода должен быть пустым, за исключением возвращаемого значения.  
  
 `ret` Инструкция не может использоваться для передачи управления из`try`, `filter`, `catch`, или `finally` блока. Изнутри `try` или `catch`, использовать <xref:System.Reflection.Emit.OpCodes.Leave> инструкция, для назначения — `ret` инструкцию, которая находится за пределами всех блоков исключения. Так как `filter` и `finally` блоки логически являются частью механизма обработки исключений и не к методу, в котором находится их код, правильно созданные инструкции промежуточного языка MSIL (Microsoft) выполните возврат из в метод `filter` или `finally`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ret` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущее исключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1A|Rethrow|Возвращает текущее исключение.|  
  
 Нет стека переходные для данной инструкции.  
  
 `rethrow` Инструкции разрешено только в теле `catch` обработчика. Он создает исключение, которое было перехвачено этим обработчиком.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `rethrow` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение влево (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|62|Shl|Смещает целое число (с заполнением нулями) слева.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение помещается в стек.  
  
2.  Количество бит, помещается в стек.  
  
3.  Число бит и значения извлекаются из стека; значение сдвигается влево на указанное число битов.  
  
4.  Результат помещается в стек.  
  
 `shl` Инструкция смещает значение (типа `int32`, `int64` или `native int`) влево на указанное число битов. Количество битов, которое является значением типа `int32` или `native int`. Возвращаемое значение не определено, если число бит, больше или равна ширине (в битах), предоставленного значения.  
  
 `Shl` вставляет нулевой разряд в нижнюю позицию при каждой смены.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `shl` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение вправо (с знаковым битом) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|63|Shr|Сдвигает вправо (с заполнением входа) является целым числом.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение помещается в стек.  
  
2.  Количество бит, помещается в стек.  
  
3.  Число бит и значения извлекаются из стека; значение смещается вправо на указанное число битов.  
  
4.  Результат помещается в стек.  
  
 `shr.un` Инструкция смещает значение (типа `int32`, `int64` или `native int`) вправо на указанное число битов. Количество битов, которое является значением типа `int32` или `native int`. Возвращаемое значение не определено, если число бит, больше или равна ширине (в битах), предоставленного значения.  
  
 `Shr` реплицирует старших бит каждой смены, сохраняя знак исходное значение в `result`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `shr` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение без знака вправо (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|64|Shr.un|Сдвигает вправо (с заполнением нулями) является целым числом.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение помещается в стек.  
  
2.  Количество бит, помещается в стек.  
  
3.  Число бит и значения извлекаются из стека; значение смещается вправо на указанное число битов.  
  
4.  Результат помещается в стек.  
  
 `shr.un` Инструкция смещает значение (типа `int32`, `int64` или `native int`) вправо на указанное число битов. Количество битов, которое является значением типа `int32`, `int64` или `native int`. Возвращаемое значение не определено, если число бит, больше или равна ширине (в битах), предоставленного значения.  
  
 `Shr.un` вставляет нулевой разряд в самой высокой позиции в каждой смены.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `shr.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений сведения о размере (в байтах) заданного типа значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1C &LT; `T` >|оператор sizeof `valType`|Push-размер в байтах, тип значения в качестве `unsigned int32`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Размер (в байтах) заданного типа значения (`valType`) помещается в стек.  
  
 `valType` должен быть маркер метаданных ( `typeref` или `typedef`), указывающий тип значения, ссылочный тип или параметр универсального типа.  
  
 Для ссылочного типа возвращаемый размер — размер ссылочные значения соответствующего типа (4 байта в 32-разрядных системах), не размер данных, хранящихся в объектах, на который ссылается значение ссылки. Параметр универсального типа может использоваться только в теле типа или метода, который определяет его. При создании экземпляра типа или метода, параметр универсального типа заменяется типом значения или ссылочным типом.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `sizeof` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0B &LT; `unsigned int16` >|starg `num`|Извлекает верхнее значение из стека и сохраняет его в ячейке аргумента `num`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение, находящееся на вершине стека извлекается и помещается в ячейке аргумента `num`.  
  
 `starg` Инструкция извлекает значение из стека и помещает его в ячейке аргумента `num`. Тип значения должен соответствовать типу аргумента, указанному в подписи текущего метода.  
  
 Для процедуры, которые принимают список аргументов переменной `starg` инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной частью сигнатуры.  
  
 В случае аргументы, которые содержат целочисленное значение меньше 4 байтов, значение усекается при их перемещении из стека в аргумент. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера, связанный с аргументом.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `starg` код операции:  
  
-   ILGenerator.Emit (OpCode, короткое)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|Извлекает верхнее значение из стека и сохраняет его в ячейке аргумента `num`, краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение, находящееся на вершине стека извлекается и помещается в ячейке аргумента `num`.  
  
 `starg.s` Инструкция извлекает значение из стека и помещает его в ячейке аргумента `num`. Тип значения должен соответствовать типу аргумента, указанному в подписи текущего метода.  
  
 `starg.s` Инструкция обеспечивает эффективную кодировку для использования с первых 256 аргументов.  
  
 Для процедуры, которые принимают список аргументов переменной `starg.s` инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной частью сигнатуры.  
  
 В случае аргументы, которые содержат целочисленное значение меньше 4 байтов, значение усекается при их перемещении из стека в аргумент. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера, связанный с аргументом.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `starg.s` код операции:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение в стеке вычислений, тип которого указан в инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкции по шестнадцатеричном формате и формате сборки промежуточного языка MSIL, Microsoft, а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem `typeTok`|Заменяет элемент массива с заданным индексом на значение типа `typeTok` в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещается в стек.  
  
2.  Значение индекса `index`, на элемент в `array` помещается в стек.  
  
3.  Значение типа, указанного в инструкции помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по указанному индексу.  
  
 `stelem` Инструкция заменяет значение элемента с заданным индексом (с нуля) в одномерном массиве `array` со значением. Значение имеет тип, указанный в токен `typeTok` в инструкции.  
  
 Массивы являются объектами, поэтому они представлены в значение типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="native int" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9Б|stelem.i|Заменяет элемент массива с заданным индексом `native int` значение в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по указанному индексу.  
  
 `stelem.i` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `native int` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены в значение типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.i` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int8" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|Заменяет элемент массива с заданным индексом `int8` значение в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по указанному индексу.  
  
 `stelem.i1` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `int8` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены в значение типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.i1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int16" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9D|stelem.I2|Заменяет элемент массива с заданным индексом `int16` значение в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по указанному индексу.  
  
 `stelem.i2` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `int16` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены в значение типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.i2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int32" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|Заменяет элемент массива с заданным индексом `int32` значение в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по указанному индексу.  
  
 `stelem.i4` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `int32` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены в значение типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.i4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int64" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9F|stelem.I8|Заменяет элемент массива с заданным индексом `int64` значение в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по указанному индексу.  
  
 `stelem.i8` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `int64` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены в значение типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.i8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="float32" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A0|stelem.R4|Заменяет элемент массива с заданным индексом `float32` значение в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по указанному индексу.  
  
 `stelem.r4` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `float32` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены в значение типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.r4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="float64" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A1|stelem.R8|Заменяет элемент массива с заданным индексом `float64` значение в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по указанному индексу.  
  
 `stelem.r8` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `float64` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены в значение типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.r8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение object ref (тип <see langword="O" />), находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|Заменяет элемент массива с заданным индексом `ref` значение (типа `O`) в стеке.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по указанному индексу.  
  
 `stelem.ref` Инструкция заменяет значение элемента с заданным индексом в одномерном массиве `array` с `ref` (типа `O`) значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены в значение типа `O`. Индекс является типом `native int`.  
  
 Обратите внимание, что `stelem.ref` неявно приводит к заданному типу элемента `array` перед присвоением значения элементу массива. Это приведение может завершиться ошибкой, даже для проверяемого кода. Таким образом `stelem.ref` инструкция может вызвать исключение <xref:System.InvalidCastException>. Для одномерных массивов с индексацией не от нуля и для многомерных массивов <xref:System.Array> класс предоставляет <xref:System.Array.SetValue%2A> метод.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательным или больше, чем границы из `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.ref` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет значение в поле объекта, по ссылке на объект или указателю, на новое значение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|Заменяет значение `field` объекта с новым значением.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект или указатель помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и ссылка или указатель на объект извлекаются из стека; значение `field` в объекте заменяется указанное значение.  
  
 `stfld` Инструкция заменяет значение поля объекта (типа `O`) или через указатель (типа `native int`, `&`, или `*`) с заданным значением. `Field` — Это маркер метаданных, который ссылается на член ссылки на поле. `stfld` Инструкции может иметь префикс из одной или обеих <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> возникает, если ссылка на объект или указатель является пустой ссылкой и нестатического поля.  
  
 <xref:System.MissingFieldException> возникает, если `field` не найден в метаданных. Обычно это проверяется инструкции промежуточного языка MSIL (Microsoft) преобразуется в машинный код, не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stfld` код операции:  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="native int" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DF|stind.i|Магазины `native int` значение по указанному адресу.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адресе извлекаются из стека; значение хранится по адресу.  
  
 `stind.i` Хранилищ инструкции `native int` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.i` инструкция использоваться в соответствии с типом указателя. Операция `stind.i` инструкция может быть изменено, непосредственно перед знаком <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` естественным образом не выровнен для данного типа аргумента, который содержится в разрешении суффикс инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.i` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int8" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|52|stind.i1|Магазины `int8` значение по указанному адресу.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адресе извлекаются из стека; значение хранится по адресу.  
  
 `stind.i1` Хранилищ инструкции `int8` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.i1` инструкция использоваться в соответствии с типом указателя. Операция `stind.i1` инструкция может быть изменено, непосредственно перед знаком <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` естественным образом не выровнен для данного типа аргумента, который содержится в разрешении суффикс инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.i1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int16" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|53|stind.I2|Магазины `int16` значение по указанному адресу.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адресе извлекаются из стека; значение хранится по адресу.  
  
 `stind.i2` Хранилищ инструкции `int16` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.2i` инструкция использоваться в соответствии с типом указателя. Операция `stind.i2` инструкция может быть изменено, непосредственно перед знаком <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` естественным образом не выровнен для данного типа аргумента, который содержится в разрешении суффикс инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.i2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int32" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|54|stind.i4|Магазины `int32` значение по указанному адресу.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адресе извлекаются из стека; значение хранится по адресу.  
  
 `stind.i4` Хранилищ инструкции `int32` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.i4` инструкция использоваться в соответствии с типом указателя. Операция `stind.i4` инструкция может быть изменено, непосредственно перед знаком <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` естественным образом не выровнен для данного типа аргумента, который содержится в разрешении суффикс инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.i4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int64" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|55|stind.I8|Магазины `int64` значение по указанному адресу.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адресе извлекаются из стека; значение хранится по адресу.  
  
 `stind.i8` Хранилищ инструкции `int64` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.i8` инструкция использоваться в соответствии с типом указателя. Операция `stind.i` инструкция может быть изменено, непосредственно перед знаком <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` естественным образом не выровнен для данного типа аргумента, который содержится в разрешении суффикс инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.i8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="float32" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|56|stind.R4|Магазины `float32` значение по указанному адресу.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адресе извлекаются из стека; значение хранится по адресу.  
  
 `stind.r4` Хранилищ инструкции `float32` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.r4` инструкция использоваться в соответствии с типом указателя. Операция `stind.r4` инструкция может быть изменено, непосредственно перед знаком <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` естественным образом не выровнен для данного типа аргумента, который содержится в разрешении суффикс инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.r4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="float64" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|57|stind.R8|Магазины `float64` значение по указанному адресу.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адресе извлекаются из стека; значение хранится по адресу.  
  
 `stind.r8` Хранилищ инструкции `float64` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.r8` инструкция использоваться в соответствии с типом указателя. Операция `stind.r8` инструкция может быть изменено, непосредственно перед знаком <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` естественным образом не выровнен для данного типа аргумента, который содержится в разрешении суффикс инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.r8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение ссылки на объект по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|51|stind.ref|Хранит ссылку на объект (тип `O`) значение по указанному адресу.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адресе извлекаются из стека; значение хранится по адресу.  
  
 `stind.ref` Инструкция сохраняет значение ссылки на объект по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.ref` инструкция использоваться в соответствии с типом указателя. Операция `stind.ref` инструкция может быть изменено, непосредственно перед знаком <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` естественным образом не выровнен для данного типа аргумента, который содержится в разрешении суффикс инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.ref` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с заданным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0E &LT; `unsigned int16` >|stloc `index`|Извлекает значение из стека и сохраняет его в локальной переменной `index`.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение извлекается из стека и помещается в локальную переменную `index`.  
  
 `stloc` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с номером `index`, в которых локальные переменные являются пронумерованы от 0 и более поздних версий. Тип значения должен соответствовать тип локальной переменной, указанной в локальной подписи текущего метода.  
  
 Хранение в локальные переменные, содержащие целое число меньше длиной 4 байта, значение усекается при их перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера, связанный с аргументом.  
  
 Правильные инструкции промежуточного языка MSIL (Microsoft) требует `index` быть допустимый локальный индекс. Для `stloc` инструкции, `index` должен находиться в диапазоне от 0 до 65 534 включительно (в частности, 65535 не существует). За исключением 65535 связано pragmatic: возможны реализации, использующие 2-байтовое целое число для отслеживания как индекс локальной переменной, а также общее число "Локальные" для данного метода. Если индекс 65 535 считался действительным, потребуется расширить целое число для отслеживания числа локальных переменных в этом методе.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `stloc` код операции:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, короткое)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0A|stloc.0|Извлекает значение из стека в локальную переменную 0.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 0.  
  
 `stloc.0` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 0. Тип значения должен соответствовать тип локальной переменной, указанной в локальной подписи текущего метода.  
  
 `stloc.0` является особенно эффективной кодировки для сохранения значений в локальной переменной 0.  
  
 Хранение в локальные переменные, содержащие целое число меньше длиной 4 байта, значение усекается при их перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера, связанный с аргументом.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stloc.0` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0B|stloc.1|Извлекает значение из стека в локальной переменной 1.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 1.  
  
 `stloc.1` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 1. Тип значения должен соответствовать тип локальной переменной, указанной в локальной подписи текущего метода.  
  
 `stloc.1` является особенно эффективной кодировки для сохранения значений в локальной переменной 1.  
  
 Хранение в локальные переменные, содержащие целое число меньше длиной 4 байта, значение усекается при их перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера, связанный с аргументом.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stloc.1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0C|stloc.2|Извлекает значение из стека в локальную переменную 2|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение извлекается из стека и помещается в локальную переменную, индексированных по 2.  
  
 `stloc.2` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную, индексированных по 2. Тип значения должен соответствовать тип локальной переменной, указанной в локальной подписи текущего метода.  
  
 `stloc.2` является особенно эффективной кодировки для сохранения значений в локальной переменной 2.  
  
 Хранение в локальные переменные, содержащие целое число меньше длиной 4 байта, значение усекается при их перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера, связанный с аргументом.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stloc.2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0D|stloc.3|Извлекает значение из стека в локальной переменной 3|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 3.  
  
 `stloc.3` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 3. Тип значения должен соответствовать тип локальной переменной, указанной в локальной подписи текущего метода.  
  
 `stloc.3` является особенно эффективной кодировки для сохранения значений в локальной переменной 3.  
  
 Хранение в локальные переменные, содержащие целое число меньше длиной 4 байта, значение усекается при их перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера, связанный с аргументом.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stloc.3` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом <paramref name="index" /> (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|Извлекает значение из стека и сохраняет его в локальной переменной `index`, краткая форма.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение извлекается из стека и помещается в локальную переменную `index`.  
  
 `stloc.s` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с номером `index`, в которых локальные переменные являются пронумерованы от 0 и более поздних версий. Тип значения должен соответствовать тип локальной переменной, указанной в локальной подписи текущего метода.  
  
 `stloc.s` Инструкция обеспечивает эффективную кодировку для локальных переменных с 0 до 255.  
  
 Хранение в локальные переменные, содержащие целое число меньше длиной 4 байта, значение усекается при их перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера, связанный с аргументом.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `stloc.s` код операции:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует значение с заданным типом из стека вычислений в указанный адрес памяти.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Сохраняет значение типа `class` из стека в память.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Объект типа значения типа `class` помещается в стек.  
  
3.  Объект и адресе извлекаются из стека; объект типа значения хранятся по адресу.  
  
 `stobj` Инструкции копирует объект типа значения в адрес, указанный адрес (указатель типа `native int`, `*`, или `&`). Число копируемых байтов зависит от размера класса, представленного параметром `class`, маркер метаданных, представляющий тип значения.  
  
 Операция `stobj` инструкция может быть изменено, непосредственно перед знаком <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.TypeLoadException> возникает, если не удается найти класс. Обычно это обнаруживается инструкции промежуточного языка MSIL (Microsoft) преобразуются в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stobj` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет значение статического поля на значение из стека вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Заменяет значение в `field` заданным значением.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека и сохраняется в `field`.  
  
 `stsfld` Инструкция заменяет значение статического поля на значение из стека. `field` является маркером метаданных, который должен ссылаться на элемент статического поля.  
  
 `stsfld` Инструкции может иметь префикс в <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.MissingFieldException> возникает, если поле не найдено в метаданных. Обычно это проверяется инструкции промежуточного языка MSIL (Microsoft) преобразуются в машинном коде, не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stsfld` код операции:  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно значение из другого и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|59|sub|Вычитает одно значение из другого и возвращает новое числовое значение.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value2` вычитается из `value1`.  
  
4.  Результат помещается в стек.  
  
 Переполнение не определяется для операций с целыми числами (для управления переполнением правильный, см. в разделе <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Целое число вычитания заключает в оболочку, а не насыщение. Например: при условии, что 8-разрядных целых чисел, где `value1` имеет значение 0 и `value2` имеет значение 1, «оболочку» результатом будет 255.  
  
 Возвращает с плавающей запятой переполнения `+inf` (`PositiveInfinity`) или `-inf` (`NegativeInfinity`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `sub` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно целочисленное значение из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DA|Sub.ovf|Вычитает одно целочисленное значение из другого и проверку переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value2` вычитается из `value1` с проверкой переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Эта операция выполняется над знаковыми целочисленными значениями; для значений с плавающей запятой, используйте <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `sub.ovf` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно целочисленное значение без знака из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DB|Sub.ovf.un|Вычитает одно целочисленное значение без знака из другого и проверку переполнения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value2` вычитается из `value1` с проверкой переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено в типе результата.  
  
 Эта операция выполняется над знаковыми целочисленными значениями; для значений с плавающей запятой, используйте <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `sub.ovf.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Реализует таблицу переходов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|Переключение (`N`, `t1`, `t2`... `tN`)|Выполняет переход к одному из `N` значения.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека и управление передается инструкции, смещением, индекс по значению, где значение меньше, чем `N`.  
  
 `switch` Инструкция реализует таблицу переходов. Формат инструкции `unsigned int32` представляет количество целевых объектов `N`, за которым следует `N` значений Int32 переходов целевых объектов. Эти целевые объекты отображаются в виде смещения (положительные или отрицательные) от начала инструкции, следуя инструкциям из этого `switch` инструкции.  
  
 `switch` Инструкция извлекает значение из стека и сравнивает его, как целое число без знака, до `N`. Если значение меньше, чем `N`, выполнение передается к целевому объекту, индексировать по значению, где целевых объектов нумеруются от 0 (например, первый целевой объект принимает значение 0, принимает значение 1, второй и т. д.). Если значение больше или равно `N`, выполнение продолжается в следующей инструкции (вниз).  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.  
  
 Управлять передачей в `try`, `catch`, `filter`, и `finally` блоки не может быть выполнена данная инструкция. (Таких передач строго ограничивается и вместо этого следует использовать инструкцию leave).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `switch` opcode. `Label[]` Аргумент представляет собой массив метки, представляющий 32-разрядные смещения.  
  
-   ILGenerator.Emit (код операции, Label[])  
  
   
  
## Examples  
 В следующем образце кода показан метод `Switch` код операции для создают таблицу переходов, используя массив <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет инструкцию вызова метода (префиксом которой является), предварительно удаляя кадр стека текущего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 14|tail.|Последующий вызов завершает последние методы|  
  
 Нет Переходные состояния стека для данной инструкции не.  
  
 `tail` Инструкции префикс должен предшествовать <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, или <xref:System.Reflection.Emit.OpCodes.Callvirt> инструкции. Он указывает, что кадр стека текущего метода должны быть удалены перед выполнением инструкции вызова. Также подразумевается, что значение, возвращенное при вызове следующей также значения, возвращенного текущим методом, и вызов может быть преобразован в переход между методами.  
  
 Стек должен быть пуста, за исключением аргументов, передаваемых следующим вызовом. Инструкции, инструкции вызова должна быть возвратной. Таким образом, единственным допустимым кода является последовательность `tail. call` (или `calli` или `callvirt`). Правильные инструкции промежуточного языка MSIL (Microsoft) не должна содержать ветвь для `call` инструкции, но они могут выполнять переход к последующей <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 Нельзя отменить текущий кадр, когда управление передается от ненадежного кода в доверенный код, так как это нарушит безопасность идентификации кода. Проверки безопасности .NET Framework, таким образом может привести к `tail` следует игнорировать, оставляя стандартный <xref:System.Reflection.Emit.OpCodes.Call> инструкции. Аналогичным образом, чтобы обеспечить выход синхронизированной области после возвращения вызова, `tail` префикс учитывается, если используется для выхода из метода, помеченного как синхронизированный.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `tail` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Экземпляр объекта Opcode.</param>
        <summary>Возвращает true или false, в зависимости от того, принимает ли заданный код операции однобайтовый аргумент.</summary>
        <returns><see langword="true" /> или <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет определить, какие коды операций MSIL бы «краткая форма», для использования в оптимизированном коде.  
  
 `TakesSingleByteArgument` Возвращает `true` Если <xref:System.Reflection.Emit.OpCode> экземпляра требуется однобайтовый аргумент в следующих случаях:  
  
-   Код операции выполняет инструкцию перехода однобайтовому адресу (например, <xref:System.Reflection.Emit.OpCodes.Br_S> и <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   Код операции помещает в стек байтовое значение (например, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   Код операции ссылается на переменную или аргумент с использованием однобайтовой «краткая форма» (например, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> и <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 В противном случае возвращает значение `false`.  
  
 В приведенном ниже примере показано использование `TakesSingleByteArgument` путем отражения для `OpCodes` класс и проверки ли каждый `OpCode` поле принимает однобайтовый аргумент.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает объект исключения, находящийся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7A|throw|Создает исключение.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект (на исключение) помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и исключение.  
  
 `throw` Инструкция создает объект исключения (типа `O`) в настоящее время в стеке.  
  
 <xref:System.NullReferenceException> возникает, если ссылка на объект является пустой ссылкой.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `throw` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что адрес на вершине стека, возможно, не выровнен по естественному размеру следующей непосредственно за ним инструкции <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> или <see langword="cpblk" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 12 &LT; `unsigned int8` >|Невыровненные. `alignment`|Указывает, что последующие указатель инструкции может быть невыровненным.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
 `Unaligned` Указывает, что адрес (неуправляемый указатель, `native int`) в стеке может не быть выровнен по естественному размеру следующей непосредственно `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, или `cpblk` инструкции. То есть для <xref:System.Reflection.Emit.OpCodes.Ldind_I4> инструкции, выравнивание адреса не может быть на 4-байтовой границе. Для `initblk` и `cpblk` выравнивание по умолчанию — это зависит от архитектуры (4-байтовое для 32-разрядные процессоры, 8-байтовое для 64-разрядные процессоры). Генераторы кода, размер 32-разрядных слова не ограничивают свои выходные данные должны использовать `unaligned` Если выравнивание не известна во время компиляции размером 8 байт.  
  
 Выравнивание, определяемое значением должен быть 1, 2 или 4 и означает, что созданный код следует предполагать, что адрес byte, двухбайтовый, или quad байтовое значение aligned, соответственно. Обратите внимание, что временные указатели (тип `*`) всегда выровнены.  
  
 Выравнивание для `cpblk` инструкция требует двух чисел (источника) и для назначения, имеется оказывает заметного влияния на производительность, если только меньшее число.  
  
 `unaligned` И `volatile` префиксы, которые могут быть объединены в любом порядке. Они должны непосредственно предшествовать `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, или `cpblk` инструкции. Только <xref:System.Reflection.Emit.OpCodes.Volatile> префикс допускается для <xref:System.Reflection.Emit.OpCodes.Ldsfld> и <xref:System.Reflection.Emit.OpCodes.Stsfld> инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `unaligned` код операции:  
  
-   ILGenerator.Emit (OpCode, метки)  
  
-   ILGenerator.Emit (Opcode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип значения из упакованной формы в распакованную.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|79 < `T` >|распаковки-преобразования `valType`|Извлекает данные типа значения из `obj`, ее упакованного представления.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и преобразуется в указатель типа значения.  
  
3.  Тип указателя значение помещается в стек.  
  
 Тип значения имеет два представления в Common Language Infrastructure (CLI):  
  
-   Форма «raw», используемый при внедрении типа значения внутри другого объекта.  
  
-   Форма «процессор», где данные в тип значения упаковываются в объект и существуют как независимые сущности.  
  
 `unbox` Инструкция преобразует ссылку на объект (тип `O`), упакованного представления типа значения, чтобы указатель типа значения (управляемый указатель типа `&`), ее распаковывается формы. Заданный тип значения (`valType`) является маркером метаданных, указывающий тип типом значения, содержащиеся в упакованный объект.  
  
 В отличие от <xref:System.Reflection.Emit.OpCodes.Box>, которая необходима для создания копии типа значения для использования в объекте, `unbox` не требуется копировать тип значения из объекта. Обычно она просто вычисляет адрес типа значения, который уже присутствует внутри упакованного объекта.  
  
 <xref:System.InvalidCastException> возникает, если объект не упакован как `valType`.  
  
 <xref:System.NullReferenceException> возникает, если ссылка на объект является пустой ссылкой.  
  
 <xref:System.TypeLoadException> возникает, если тип значения `valType` не удается найти. Обычно это обнаруживается инструкции промежуточного языка MSIL (Microsoft) преобразуются в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `unbox` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип, указанный в инструкции, из упакованной формы в распакованную.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкции по шестнадцатеричном формате и формате сборки промежуточного языка MSIL, Microsoft, а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A5 < `T` >|unbox.Any `typeTok`|Извлечение данных из `obj`, ее упакованного представления.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Ссылка на объект `obj` помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и преобразуется к типу, указанному в инструкции.  
  
3.  Результирующий тип ссылки или значения объекта помещается в стек.  
  
 При применении к форме упакованный тип значения, `unbox.any` инструкция извлекает значение, содержащееся в `obj` (типа `O`) и поэтому эквивалентно `unbox` следуют `ldobj`.  
  
 При применении к ссылочному типу, `unbox.any` инструкция имеет тот же эффект, что `castclass` `typeTok`.  
  
 Если операнд `typeTok` является параметром универсального типа, то поведение во время выполнения определяется тип, который указан для этого параметра универсального типа.  
  
 <xref:System.InvalidCastException> возникает, если `obj` упакованный тип.  
  
 <xref:System.NullReferenceException> возникает, если `obj` является пустой ссылкой.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `unbox.any` код операции:  
  
-   ILGenerator.Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что адрес на вершине стека вычислений, возможно, является изменяемым и результаты чтения данной области невозможно кэшировать либо невозможно запретить множественные сохранения в эту область.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 13|volatile.|Указывает, что следующая за указателем ссылка является volatile.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
 `volatile`. Указывает, что адрес является изменяемым (то есть он может быть внешние ссылки к текущему потоку выполнения) и результаты чтения данной области невозможно кэшировать, или что невозможно запретить множественные сохранения в этом расположении. Доступа `volatile` влияет только на доступ; любой другой доступ к папке должен быть помечен отдельно. Доступ к расположениям volatile не обязательно выполнять атомарным образом.  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned> И `volatile` префиксы, которые могут быть объединены в любом порядке. Они должны непосредственно предшествовать `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, или `cpblk` инструкции. Только `volatile` префикс допускается для <xref:System.Reflection.Emit.OpCodes.Ldsfld> и <xref:System.Reflection.Emit.OpCodes.Stsfld> инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `volatile` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое исключающее ИЛИ двух верхних значений в стеке вычислений и помещает результат обратно в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL (Microsoft), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|61|xor|Вычисляет побитовое исключающее или для двух целочисленных значений и возвращает целое число.|  
  
 Изменения состояния стека, в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека и поразрядное исключающее или вычисляемые.  
  
4.  Побитовое исключающее или `value2` и `value1` помещается в стек.  
  
 `xor` Инструкция вычисляет побитовое исключающее или двух верхних значений в стеке и оставляет результат в стеке.  
  
 `Xor` представляет собой операцию целыми числами.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `xor` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>