<Type Name="InstancePersistenceContext" FullName="System.Runtime.DurableInstancing.InstancePersistenceContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b56731eed89c75526c90596c1490cb950651dccf" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53290317" /></Metadata><TypeSignature Language="C#" Value="public sealed class InstancePersistenceContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit InstancePersistenceContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.DurableInstancing.InstancePersistenceContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class InstancePersistenceContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class InstancePersistenceContext sealed" />
  <TypeSignature Language="F#" Value="type InstancePersistenceContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Представляет сведения о состоянии выполнения в момент выполнения команды сохраняемости.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр этого класса передается в метод TryCommand в реализации поставщика сохраняемости. Поставщики сохраняемости используют этот класс для проверки представления экземпляра в памяти, а также для указания результатов операций во внешнем хранилище, которые могут повлиять на представление или другой контекст в памяти.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AssociatedInstanceKey">
      <MemberSignature Language="C#" Value="public void AssociatedInstanceKey (Guid key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssociatedInstanceKey(valuetype System.Guid key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.AssociatedInstanceKey(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AssociatedInstanceKey (key As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AssociatedInstanceKey(Guid key);" />
      <MemberSignature Language="F#" Value="member this.AssociatedInstanceKey : Guid -&gt; unit" Usage="instancePersistenceContext.AssociatedInstanceKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="key">Идентификатор ключа экземпляра для связанного ключа. Не должно иметь значение Guid.Empty.</param>
        <summary>Указывает, что поставщик сохраняемости успешно связал ключ с текущим экземпляром в хранилище экземпляров. Идентификатор ключа указывается в качестве параметра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ключ экземпляра должен быть несвязан. Текущий дескриптор экземпляра должен быть привязан к экземпляру, а также к блокировке для этого экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginBindReclaimedLock">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginBindReclaimedLock (long instanceVersion, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginBindReclaimedLock(int64 instanceVersion, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BeginBindReclaimedLock(System.Int64,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginBindReclaimedLock (instanceVersion As Long, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginBindReclaimedLock(long instanceVersion, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginBindReclaimedLock : int64 * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="instancePersistenceContext.BeginBindReclaimedLock (instanceVersion, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceVersion" Type="System.Int64" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceVersion">Версия блокировки, удерживаемой для экземпляра, или нулевое значение, если в поставщике сохраняемости не реализованы версии блокировки.</param>
        <param name="timeout">Время ожидания для асинхронной операции.</param>
        <param name="callback">Метод, вызываемый при завершении этой операции.</param>
        <param name="state">Сведения о состоянии, связанные с асинхронной операцией.</param>
        <summary>Начинает асинхронную операцию привязки существующей блокировки для экземпляра к текущему дескриптору экземпляра. Версия существующей блокировки передается в качестве параметра.</summary>
        <returns>Состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При получении блокировки поставщик сохраняемости может определить, что текущий экземпляр уже заблокирован в текущем хранилище. Если маркер блокировки совпадает с маркером блокировки текущего дескриптора, то поставщик сохраняемости может попытаться освободить блокировку, проверив ее версию и передав версию в BeginBindReclaimedLock. Поставщик сохраняемости не должен изменять экземпляр до успешного освобождения блокировки. Если к блокировке не привязан ни один другой дескриптор, то операция BeginBindReclaimedLock завершается успешно и текущий дескриптор становится привязанным к блокировке. В противном случае BeginBindReclaimedLock или EndBindReclaimedLock вызывает исключение InstanceHandleConflictException. Если в других дескрипторах выполняются команда, то операция может ожидать завершения этих команд, чтобы определить возможность освобождения блокировки.  
  
 Текущий дескриптор экземпляра должен быть привязан к экземпляру и владельцу блокировки. Экземпляр не должен быть завершен. Маркер блокировки, связанный с владельцем блокировки, используется для определения владельца блокировки.  
  
 После привязки блокировки к дескриптору она остается привязанной в течение всего времени существования дескриптора. Маркер блокировки и версию экземпляра нельзя изменять.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginExecute">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginExecute (System.Runtime.DurableInstancing.InstancePersistenceCommand command, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginExecute(class System.Runtime.DurableInstancing.InstancePersistenceCommand command, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BeginExecute(System.Runtime.DurableInstancing.InstancePersistenceCommand,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginExecute (command As InstancePersistenceCommand, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginExecute(System::Runtime::DurableInstancing::InstancePersistenceCommand ^ command, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginExecute : System.Runtime.DurableInstancing.InstancePersistenceCommand * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="instancePersistenceContext.BeginExecute (command, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Runtime.DurableInstancing.InstancePersistenceCommand" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="command">Команда сохраняемости для выполнения.</param>
        <param name="timeout">Значение времени ожидания для операции.</param>
        <param name="callback">Делегат, принимающий уведомление об асинхронном получении, завершенном операцией запроса.</param>
        <param name="state">Сведения о состоянии.</param>
        <summary>Начинает асинхронное выполнение команды сохраняемости.</summary>
        <returns>Состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поставщик сохраняемости может использовать этот метод, чтобы выполнять подкоманды в составе команды. Подкоманда будет выполняться с помощью BeginTryCommand аналогично командам, передаваемым в InstanceStore.BeginExecute. Команды можно вкладывать, однако для команды в каждый момент времени не может выполняться больше одной подкоманды.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindAcquiredLock">
      <MemberSignature Language="C#" Value="public void BindAcquiredLock (long instanceVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BindAcquiredLock(int64 instanceVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BindAcquiredLock(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BindAcquiredLock (instanceVersion As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BindAcquiredLock(long instanceVersion);" />
      <MemberSignature Language="F#" Value="member this.BindAcquiredLock : int64 -&gt; unit" Usage="instancePersistenceContext.BindAcquiredLock instanceVersion" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceVersion" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="instanceVersion">Версия блокировки, полученной для экземпляра, или нулевое значение, если в поставщике сохраняемости не реализованы версии блокировки.</param>
        <summary>Привязывает полученную блокировку для экземпляра к текущему дескриптору экземпляра. Версия полученной блокировки передается в качестве параметра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если в поставщике сохраняемости реализованы версии блокировки, то при каждом получении блокировки для экземпляра версия во внешнем хранилище должна увеличиваться на единицу. При первой блокировке экземпляра версия должна иметь значение 1. При каждом получении блокировки предыдущая блокировка отменяется. Текущий дескриптор экземпляра должен быть привязан к экземпляру и владельцу блокировки. Экземпляр не должен быть завершен. Маркер блокировки, связанный с владельцем блокировки, используется для определения владельца блокировки  
  
 После привязки блокировки к дескриптору она остается привязанной в течение всего времени существования дескриптора. Маркер блокировки и версию экземпляра нельзя изменять.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindEvent">
      <MemberSignature Language="C#" Value="public void BindEvent (System.Runtime.DurableInstancing.InstancePersistenceEvent persistenceEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BindEvent(class System.Runtime.DurableInstancing.InstancePersistenceEvent persistenceEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BindEvent(System.Runtime.DurableInstancing.InstancePersistenceEvent)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BindEvent (persistenceEvent As InstancePersistenceEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BindEvent(System::Runtime::DurableInstancing::InstancePersistenceEvent ^ persistenceEvent);" />
      <MemberSignature Language="F#" Value="member this.BindEvent : System.Runtime.DurableInstancing.InstancePersistenceEvent -&gt; unit" Usage="instancePersistenceContext.BindEvent persistenceEvent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="persistenceEvent" Type="System.Runtime.DurableInstancing.InstancePersistenceEvent" />
      </Parameters>
      <Docs>
        <param name="persistenceEvent">Объект <see cref="T:System.Runtime.DurableInstancing.InstancePersistenceEvent" />, содержащий сведения о событии.</param>
        <summary>Привязывает событие <see cref="T:System.Runtime.DurableInstancing.InstancePersistenceEvent" /> к дескриптору экземпляра.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindInstance">
      <MemberSignature Language="C#" Value="public void BindInstance (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BindInstance(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BindInstance(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BindInstance (instanceId As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BindInstance(Guid instanceId);" />
      <MemberSignature Language="F#" Value="member this.BindInstance : Guid -&gt; unit" Usage="instancePersistenceContext.BindInstance instanceId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">Идентификатор экземпляра. Не должно иметь значение Guid.Empty.</param>
        <summary>Привязывает экземпляр, идентификатор которого указан в качестве параметра для текущего дескриптора экземпляра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После привязки экземпляра к дескриптору он остается привязанным в течение всего времени существования дескриптора. К этому дескриптору нельзя привязать никакой другой экземпляр.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindInstanceOwner">
      <MemberSignature Language="C#" Value="public void BindInstanceOwner (Guid instanceOwnerId, Guid lockToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BindInstanceOwner(valuetype System.Guid instanceOwnerId, valuetype System.Guid lockToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BindInstanceOwner(System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BindInstanceOwner (instanceOwnerId As Guid, lockToken As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BindInstanceOwner(Guid instanceOwnerId, Guid lockToken);" />
      <MemberSignature Language="F#" Value="member this.BindInstanceOwner : Guid * Guid -&gt; unit" Usage="instancePersistenceContext.BindInstanceOwner (instanceOwnerId, lockToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceOwnerId" Type="System.Guid" />
        <Parameter Name="lockToken" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceOwnerId">Идентификатор для владельца экземпляра.</param>
        <param name="lockToken">Маркер блокировки владельца экземпляра. Поставщик сохраняемости может использовать одно значение для идентификатора владельца экземпляра и для маркера блокировки владельца.</param>
        <summary>Привязывает владельца экземпляра к текущему дескриптору экземпляра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После привязки владельца экземпляра к дескриптору он остается привязанным в течение всего времени существования дескриптора. К этому дескриптору нельзя привязать никакого другого владельца экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindReclaimedLock">
      <MemberSignature Language="C#" Value="public void BindReclaimedLock (long instanceVersion, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BindReclaimedLock(int64 instanceVersion, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BindReclaimedLock(System.Int64,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BindReclaimedLock (instanceVersion As Long, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BindReclaimedLock(long instanceVersion, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BindReclaimedLock : int64 * TimeSpan -&gt; unit" Usage="instancePersistenceContext.BindReclaimedLock (instanceVersion, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceVersion" Type="System.Int64" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceVersion">Версия блокировки, удерживаемой для экземпляра, или нулевое значение, если в поставщике сохраняемости не реализованы версии блокировки.</param>
        <param name="timeout">Значение времени ожидания для операции.</param>
        <summary>Привязывает существующую блокировку для экземпляра к текущему дескриптору экземпляра. Версия существующей блокировки передается в качестве параметра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При получении блокировки поставщик сохраняемости может определить, что текущий экземпляр уже заблокирован в текущем хранилище. Если маркер блокировки совпадает с маркером блокировки текущего дескриптора, то поставщик сохраняемости может попытаться освободить блокировку, проверив ее версию и передав версию в BindReclaimedLock. Поставщик сохраняемости не должен изменять экземпляр до успешного освобождения блокировки. Если к блокировке не привязан ни один другой дескриптор, то BindReclaimedLock завершается успешно и текущий дескриптор становится привязанным к блокировке. В противном случае BindReclaimedLock вызывает исключение InstanceHandleConflictException. Если в других дескрипторах выполняются команды, то BindReclaimedLock может ожидать завершения этих команд, чтобы определить возможность освобождения блокировки.  
  
 Текущий дескриптор экземпляра должен быть привязан к экземпляру и владельцу блокировки. Экземпляр не должен быть завершен. Маркер блокировки, связанный с владельцем блокировки, используется для определения владельца блокировки.  
  
 После привязки блокировки к дескриптору она остается привязанной в течение всего времени существования дескриптора. Маркер блокировки и версию экземпляра нельзя изменять.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedInstance">
      <MemberSignature Language="C#" Value="public void CompletedInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CompletedInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.CompletedInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub CompletedInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CompletedInstance();" />
      <MemberSignature Language="F#" Value="member this.CompletedInstance : unit -&gt; unit" Usage="instancePersistenceContext.CompletedInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Указывает, что поставщик сохраняемости успешно пометил текущий экземпляр как завершенный в хранилище экземпляров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий дескриптор экземпляра должен быть привязан к экземпляру, а также к блокировке для этого экземпляра. Экземпляр должен быть инициализирован и не должен быть уже завершен. (Экземпляр считается инициализированным, если в нем когда-либо сохранялся набор данных экземпляра.) Все ключи, связанные с экземпляром, должны быть завершены.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedInstanceKey">
      <MemberSignature Language="C#" Value="public void CompletedInstanceKey (Guid key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CompletedInstanceKey(valuetype System.Guid key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.CompletedInstanceKey(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CompletedInstanceKey (key As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CompletedInstanceKey(Guid key);" />
      <MemberSignature Language="F#" Value="member this.CompletedInstanceKey : Guid -&gt; unit" Usage="instancePersistenceContext.CompletedInstanceKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="key">Идентификатор ключа экземпляра для завершенного ключа. Не должно иметь значение Guid.Empty.</param>
        <summary>Указывает, что поставщик сохраняемости успешно пометил ключ как завершенный в хранилище экземпляров. Идентификатор ключа указывается в качестве параметра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий дескриптор экземпляра должен быть привязан к экземпляру, а также к блокировке для этого экземпляра. Ключ экземпляра должен быть связан с текущим экземпляром и не должен быть уже завершен.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBindReclaimedLockException">
      <MemberSignature Language="C#" Value="public Exception CreateBindReclaimedLockException (long instanceVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception CreateBindReclaimedLockException(int64 instanceVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.CreateBindReclaimedLockException(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateBindReclaimedLockException (instanceVersion As Long) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ CreateBindReclaimedLockException(long instanceVersion);" />
      <MemberSignature Language="F#" Value="member this.CreateBindReclaimedLockException : int64 -&gt; Exception" Usage="instancePersistenceContext.CreateBindReclaimedLockException instanceVersion" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceVersion" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="instanceVersion">Версия блокировки, удерживаемой для экземпляра, или нулевое значение, если в поставщике сохраняемости не реализованы версии блокировки.</param>
        <summary>Создает экземпляр исключения, которое вызывается в TryCommand, чтобы запустить поведение BindReclaimedLock.</summary>
        <returns>Исключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пример кода:  
  
```  
  
protected override bool TryCommand(InstancePersistenceContext context, InstancePersistenceCommand command, TimeSpan timeout)  
{  
    throw context.CreateBindReclaimedLockException(5);  
}  
is equivalent to  
protected override bool TryCommand(InstancePersistenceContext context, InstancePersistenceCommand command, TimeSpan timeout)  
{  
    context.BindReclaimedLock(5, timeout);  
    throw new OperationCanceledException();  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBindReclaimedLock">
      <MemberSignature Language="C#" Value="public void EndBindReclaimedLock (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBindReclaimedLock(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.EndBindReclaimedLock(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBindReclaimedLock (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBindReclaimedLock(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndBindReclaimedLock : IAsyncResult -&gt; unit" Usage="instancePersistenceContext.EndBindReclaimedLock result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Результат асинхронной операции.</param>
        <summary>Завершает асинхронную операцию, запущенную методом <see cref="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BeginBindReclaimedLock(System.Int64,System.TimeSpan,System.AsyncCallback,System.Object)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndExecute">
      <MemberSignature Language="C#" Value="public void EndExecute (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndExecute(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.EndExecute(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndExecute (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndExecute(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndExecute : IAsyncResult -&gt; unit" Usage="instancePersistenceContext.EndExecute result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Состояние асинхронной операции.</param>
        <summary>Завершает асинхронную операцию.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Runtime.DurableInstancing.InstancePersistenceCommand command, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Runtime.DurableInstancing.InstancePersistenceCommand command, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.Execute(System.Runtime.DurableInstancing.InstancePersistenceCommand,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (command As InstancePersistenceCommand, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Runtime::DurableInstancing::InstancePersistenceCommand ^ command, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Execute : System.Runtime.DurableInstancing.InstancePersistenceCommand * TimeSpan -&gt; unit" Usage="instancePersistenceContext.Execute (command, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Runtime.DurableInstancing.InstancePersistenceCommand" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="command">Команда сохраняемости для выполнения.</param>
        <param name="timeout">Значение времени ожидания для операции.</param>
        <summary>Выполняет команду сохраняемости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поставщик сохраняемости может использовать этот метод, чтобы выполнять подкоманды в составе команды. Подкоманда будет выполняться с помощью TryCommand аналогично командам, передаваемым в InstanceStore.Execute. Команды можно вкладывать, однако для команды в каждый момент времени не может выполняться больше одной подкоманды.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceHandle">
      <MemberSignature Language="C#" Value="public System.Runtime.DurableInstancing.InstanceHandle InstanceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.DurableInstancing.InstanceHandle InstanceHandle" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.DurableInstancing.InstancePersistenceContext.InstanceHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceHandle As InstanceHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::DurableInstancing::InstanceHandle ^ InstanceHandle { System::Runtime::DurableInstancing::InstanceHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceHandle : System.Runtime.DurableInstancing.InstanceHandle" Usage="System.Runtime.DurableInstancing.InstancePersistenceContext.InstanceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.DurableInstancing.InstanceHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущий дескриптор экземпляра.</summary>
        <value>Текущий дескриптор экземпляра.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceVersion">
      <MemberSignature Language="C#" Value="public long InstanceVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 InstanceVersion" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.DurableInstancing.InstancePersistenceContext.InstanceVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long InstanceVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceVersion : int64" Usage="System.Runtime.DurableInstancing.InstancePersistenceContext.InstanceVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает версию блокировки, удерживаемой текущим дескриптором экземпляра для текущего экземпляра.</summary>
        <value>Версия блокировки экземпляра привязан к текущему дескриптору экземпляра, или значение -1, если дескриптор не привязан к блокировке.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поставщик сохраняемости должен сверить это значение с версией блокировки, удерживаемой для экземпляра в хранилище экземпляров, когда выполняется операция, для которой требуется блокировка (например, сохранение данных экземпляра), используя дескриптор, привязанный к блокировке. Если версия блокировки не совпадает, команды возникнет ошибка с исключением InstanceLockLostException.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceView">
      <MemberSignature Language="C#" Value="public System.Runtime.DurableInstancing.InstanceView InstanceView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.DurableInstancing.InstanceView InstanceView" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.DurableInstancing.InstancePersistenceContext.InstanceView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceView As InstanceView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::DurableInstancing::InstanceView ^ InstanceView { System::Runtime::DurableInstancing::InstanceView ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceView : System.Runtime.DurableInstancing.InstanceView" Usage="System.Runtime.DurableInstancing.InstancePersistenceContext.InstanceView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.DurableInstancing.InstanceView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект представления экземпляра, который представляет состояние текущего экземпляра в памяти. В этом представлении отражаются обновления по мере их выполнения текущей командой.</summary>
        <value>Объект представления экземпляра.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedInstance">
      <MemberSignature Language="C#" Value="public void LoadedInstance (System.Runtime.DurableInstancing.InstanceState state, System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt; instanceData, System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt; instanceMetadata, System.Collections.Generic.IDictionary&lt;Guid,System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;&gt; associatedInstanceKeyMetadata, System.Collections.Generic.IDictionary&lt;Guid,System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;&gt; completedInstanceKeyMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadedInstance(valuetype System.Runtime.DurableInstancing.InstanceState state, class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt; instanceData, class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt; instanceMetadata, class System.Collections.Generic.IDictionary`2&lt;valuetype System.Guid, class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt;&gt; associatedInstanceKeyMetadata, class System.Collections.Generic.IDictionary`2&lt;valuetype System.Guid, class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt;&gt; completedInstanceKeyMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.LoadedInstance(System.Runtime.DurableInstancing.InstanceState,System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue},System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue},System.Collections.Generic.IDictionary{System.Guid,System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue}},System.Collections.Generic.IDictionary{System.Guid,System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadedInstance (state As InstanceState, instanceData As IDictionary(Of XName, InstanceValue), instanceMetadata As IDictionary(Of XName, InstanceValue), associatedInstanceKeyMetadata As IDictionary(Of Guid, IDictionary(Of XName, InstanceValue)), completedInstanceKeyMetadata As IDictionary(Of Guid, IDictionary(Of XName, InstanceValue)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadedInstance(System::Runtime::DurableInstancing::InstanceState state, System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^ instanceData, System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^ instanceMetadata, System::Collections::Generic::IDictionary&lt;Guid, System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^&gt; ^ associatedInstanceKeyMetadata, System::Collections::Generic::IDictionary&lt;Guid, System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^&gt; ^ completedInstanceKeyMetadata);" />
      <MemberSignature Language="F#" Value="member this.LoadedInstance : System.Runtime.DurableInstancing.InstanceState * System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName, System.Runtime.DurableInstancing.InstanceValue&gt; * System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName, System.Runtime.DurableInstancing.InstanceValue&gt; * System.Collections.Generic.IDictionary&lt;Guid, System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName, System.Runtime.DurableInstancing.InstanceValue&gt;&gt; * System.Collections.Generic.IDictionary&lt;Guid, System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName, System.Runtime.DurableInstancing.InstanceValue&gt;&gt; -&gt; unit" Usage="instancePersistenceContext.LoadedInstance (state, instanceData, instanceMetadata, associatedInstanceKeyMetadata, completedInstanceKeyMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Runtime.DurableInstancing.InstanceState" />
        <Parameter Name="instanceData" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;" />
        <Parameter Name="instanceMetadata" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;" />
        <Parameter Name="associatedInstanceKeyMetadata" Type="System.Collections.Generic.IDictionary&lt;System.Guid,System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;&gt;" />
        <Parameter Name="completedInstanceKeyMetadata" Type="System.Collections.Generic.IDictionary&lt;System.Guid,System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="state">Сведения о состоянии экземпляра.</param>
        <param name="instanceData">Данные экземпляра как словарь объектов <see cref="T:System.Xml.Linq.XName" /> и <see cref="T:System.Runtime.DurableInstancing.InstanceValue" />.</param>
        <param name="instanceMetadata">Метаданные экземпляра как коллекция объектов <see cref="T:System.Xml.Linq.XName" /> и <see cref="T:System.Runtime.DurableInstancing.InstanceValue" />.</param>
        <param name="associatedInstanceKeyMetadata">Связанные метаданные ключа экземпляра как словарь идентификаторов экземпляров и метаданных ключей экземпляров в виде словаря объектов <see cref="T:System.Xml.Linq.XName" /> и <see cref="T:System.Runtime.DurableInstancing.InstanceValue" />.</param>
        <param name="completedInstanceKeyMetadata">Метаданные завершенного экземпляра как словарь идентификаторов экземпляров и метаданных ключей экземпляров в виде словаря объектов <see cref="T:System.Xml.Linq.XName" /> и <see cref="T:System.Runtime.DurableInstancing.InstanceValue" />.</param>
        <summary>Указывает, что поставщик сохраняемости успешно получил текущий экземпляр из хранилища экземпляров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий дескриптор экземпляра должен быть привязан к экземпляру. Если дескриптор экземпляра привязан к блокировке либо загруженный экземпляр помечен как завершенный, то загруженные данные считаются согласованными. В противном случае данные считаются сомнительными.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LockToken">
      <MemberSignature Language="C#" Value="public Guid LockToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid LockToken" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.DurableInstancing.InstancePersistenceContext.LockToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LockToken As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid LockToken { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.LockToken : Guid" Usage="System.Runtime.DurableInstancing.InstancePersistenceContext.LockToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает маркер блокировки владельца экземпляра, привязанный к текущему дескриптору экземпляра.</summary>
        <value>Маркер блокировки, привязанный к текущему дескриптору экземпляра или <see cref="F:System.Guid.Empty" /> Если дескриптор не привязан к владельцу экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поставщик сохраняемости должен сверить это значение с маркером блокировки, удерживаемой для экземпляра в хранилище экземпляров, когда выполняется операция, для которой требуется блокировка (например, сохранение данных экземпляра), используя дескриптор, привязанный к блокировке. Если маркер блокировки не совпадает, команды возникнет ошибка с исключением InstanceLockLostException.  
  
 Поставщик сохраняемости должен использовать это значение в качестве маркера блокировки при получении новой блокировки для экземпляра (например, если данные экземпляра сохраняются с помощью дескриптора, который еще не привязан к блокировке). Если экземпляр уже заблокирован в хранилище экземпляров и маркеры блокировки совпадают, то поставщик сохраняемости может попытаться освободить экземпляр с помощью BindReclaimedLock.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistedInstance">
      <MemberSignature Language="C#" Value="public void PersistedInstance (System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PersistedInstance(class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.PersistedInstance(System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue})" />
      <MemberSignature Language="VB.NET" Value="Public Sub PersistedInstance (data As IDictionary(Of XName, InstanceValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PersistedInstance(System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.PersistedInstance : System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName, System.Runtime.DurableInstancing.InstanceValue&gt; -&gt; unit" Usage="instancePersistenceContext.PersistedInstance data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Данные экземпляра как словарь из объектов <see cref="T:System.Xml.Linq.XName" /> и <see cref="T:System.Runtime.DurableInstancing.InstanceValue" />.</param>
        <summary>Указывает, что поставщик сохраняемости успешно сохранил набор данных экземпляра в хранилище экземпляров. Это действие приводит к инициализации экземпляра, если он еще не инициализирован.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий дескриптор экземпляра должен быть привязан к экземпляру, а также к блокировке для этого экземпляра. Каждый набор данных экземпляра полностью заменяет предыдущий набор. Набор данных экземпляра может иметь значение null, — это то же самое, как пустые. При сохранении набора данных экземпляра со значением null удаляется существующий набор данных экземпляра. (Сохранение набора данных экземпляра не влияет на метаданные экземпляра.)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueriedInstanceStore">
      <MemberSignature Language="C#" Value="public void QueriedInstanceStore (System.Runtime.DurableInstancing.InstanceStoreQueryResult queryResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void QueriedInstanceStore(class System.Runtime.DurableInstancing.InstanceStoreQueryResult queryResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.QueriedInstanceStore(System.Runtime.DurableInstancing.InstanceStoreQueryResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub QueriedInstanceStore (queryResult As InstanceStoreQueryResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void QueriedInstanceStore(System::Runtime::DurableInstancing::InstanceStoreQueryResult ^ queryResult);" />
      <MemberSignature Language="F#" Value="member this.QueriedInstanceStore : System.Runtime.DurableInstancing.InstanceStoreQueryResult -&gt; unit" Usage="instancePersistenceContext.QueriedInstanceStore queryResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queryResult" Type="System.Runtime.DurableInstancing.InstanceStoreQueryResult" />
      </Parameters>
      <Docs>
        <param name="queryResult">Результаты запроса к хранилищу экземпляра.</param>
        <summary>Добавляет объект <see cref="T:System.Runtime.DurableInstancing.InstanceStoreQueryResult" />, который передается как параметр списку объектов <see cref="T:System.Runtime.DurableInstancing.InstanceStoreQueryResult" /> внутри представления <see cref="T:System.Runtime.DurableInstancing.InstanceView" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadInstanceKeyMetadata">
      <MemberSignature Language="C#" Value="public void ReadInstanceKeyMetadata (Guid key, System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt; metadata, bool complete);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadInstanceKeyMetadata(valuetype System.Guid key, class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt; metadata, bool complete) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.ReadInstanceKeyMetadata(System.Guid,System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadInstanceKeyMetadata (key As Guid, metadata As IDictionary(Of XName, InstanceValue), complete As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadInstanceKeyMetadata(Guid key, System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^ metadata, bool complete);" />
      <MemberSignature Language="F#" Value="member this.ReadInstanceKeyMetadata : Guid * System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName, System.Runtime.DurableInstancing.InstanceValue&gt; * bool -&gt; unit" Usage="instancePersistenceContext.ReadInstanceKeyMetadata (key, metadata, complete)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Guid" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;" />
        <Parameter Name="complete" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="key">Идентификатор ключа экземпляра для ключа со считанными метаданными. Не должно иметь значение Guid.Empty.</param>
        <param name="metadata">Метаданные как словарь объектов <see cref="T:System.Xml.Linq.XName" /> и <see cref="T:System.Runtime.DurableInstancing.InstanceValue" />.</param>
        <param name="complete">Значение <see langword="true" />, если метаданные представляют все метаданные, связанные с ключом экземпляра; в противном случае — значение <see langword="false" />.</param>
        <summary>Указывает, что поставщик сохраняемости успешно считал метаданные ключа экземпляра для ключа, связанного с текущим экземпляром из хранилища экземпляров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий дескриптор экземпляра должен быть привязан к экземпляру. Если дескриптор экземпляра привязан к блокировке либо текущий экземпляр помечен как завершенный, то метаданные считаются согласованными. В противном случае метаданные считаются сомнительными.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadInstanceMetadata">
      <MemberSignature Language="C#" Value="public void ReadInstanceMetadata (System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt; metadata, bool complete);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadInstanceMetadata(class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt; metadata, bool complete) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.ReadInstanceMetadata(System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadInstanceMetadata (metadata As IDictionary(Of XName, InstanceValue), complete As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadInstanceMetadata(System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^ metadata, bool complete);" />
      <MemberSignature Language="F#" Value="member this.ReadInstanceMetadata : System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName, System.Runtime.DurableInstancing.InstanceValue&gt; * bool -&gt; unit" Usage="instancePersistenceContext.ReadInstanceMetadata (metadata, complete)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadata" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;" />
        <Parameter Name="complete" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="metadata">Метаданные как словарь объектов <see cref="T:System.Xml.Linq.XName" /> и <see cref="T:System.Runtime.DurableInstancing.InstanceValue" />.</param>
        <param name="complete">Значение <see langword="true" />, если метаданные представляют все метаданные, связанные с экземпляром; в противном случае — значение <see langword="false" />.</param>
        <summary>Указывает, что поставщик сохраняемости успешно считал метаданные для текущего экземпляра из хранилища экземпляров.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadInstanceOwnerMetadata">
      <MemberSignature Language="C#" Value="public void ReadInstanceOwnerMetadata (System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt; metadata, bool complete);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadInstanceOwnerMetadata(class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt; metadata, bool complete) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.ReadInstanceOwnerMetadata(System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadInstanceOwnerMetadata (metadata As IDictionary(Of XName, InstanceValue), complete As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadInstanceOwnerMetadata(System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^ metadata, bool complete);" />
      <MemberSignature Language="F#" Value="member this.ReadInstanceOwnerMetadata : System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName, System.Runtime.DurableInstancing.InstanceValue&gt; * bool -&gt; unit" Usage="instancePersistenceContext.ReadInstanceOwnerMetadata (metadata, complete)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadata" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;" />
        <Parameter Name="complete" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="metadata">Словарь из объектов <see cref="T:System.Xml.Linq.XName" /> и <see cref="T:System.Runtime.DurableInstancing.InstanceValue" />.</param>
        <param name="complete">Значение, определяющее значение для согласованности: <see cref="F:System.Runtime.DurableInstancing.InstanceValueConsistency.InDoubt" /> или <see cref="F:System.Runtime.DurableInstancing.InstanceValueConsistency.Partial" />.</param>
        <summary>Устанавливает метаданные владельца экземпляра, используя данные, передаваемые в качестве параметра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий дескриптор экземпляра должен быть привязан к экземпляру. Если дескриптор экземпляра привязан к блокировке либо текущий экземпляр помечен как завершенный, то метаданные считаются согласованными. В противном случае метаданные считаются сомнительными.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCancellationHandler">
      <MemberSignature Language="C#" Value="public void SetCancellationHandler (Action&lt;System.Runtime.DurableInstancing.InstancePersistenceContext&gt; cancellationHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCancellationHandler(class System.Action`1&lt;class System.Runtime.DurableInstancing.InstancePersistenceContext&gt; cancellationHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.SetCancellationHandler(System.Action{System.Runtime.DurableInstancing.InstancePersistenceContext})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCancellationHandler (cancellationHandler As Action(Of InstancePersistenceContext))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCancellationHandler(Action&lt;System::Runtime::DurableInstancing::InstancePersistenceContext ^&gt; ^ cancellationHandler);" />
      <MemberSignature Language="F#" Value="member this.SetCancellationHandler : Action&lt;System.Runtime.DurableInstancing.InstancePersistenceContext&gt; -&gt; unit" Usage="instancePersistenceContext.SetCancellationHandler cancellationHandler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationHandler" Type="System.Action&lt;System.Runtime.DurableInstancing.InstancePersistenceContext&gt;" />
      </Parameters>
      <Docs>
        <param name="cancellationHandler">Ссылка на вызываемую функцию.</param>
        <summary>Устанавливает обработчик отмены, который будет вызываться при запросе отмены операции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вызывается обработчик отмены, поставщик сохраняемости должен отменить все ожидающие операции и вызвать исключение OperationCanceledException из TryCommand, чтобы показать, что команда сохраняемости была прервана до завершения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnassociatedInstanceKey">
      <MemberSignature Language="C#" Value="public void UnassociatedInstanceKey (Guid key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnassociatedInstanceKey(valuetype System.Guid key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.UnassociatedInstanceKey(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnassociatedInstanceKey (key As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnassociatedInstanceKey(Guid key);" />
      <MemberSignature Language="F#" Value="member this.UnassociatedInstanceKey : Guid -&gt; unit" Usage="instancePersistenceContext.UnassociatedInstanceKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="key">Идентификатор ключа экземпляра для ключа, связь с которым отменена. Не должно иметь значение Guid.Empty.</param>
        <summary>Указывает, что поставщик сохраняемости успешно отменил связь ключа с текущим экземпляром в хранилище экземпляров. Идентификатор ключа указывается в качестве параметра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий дескриптор экземпляра должен быть привязан к экземпляру, а также к блокировке для этого экземпляра. Ключ экземпляра должен быть связан с текущим экземпляром и помечен как завершенный. Текущий экземпляр не должен быть помечен как завершенный.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserContext">
      <MemberSignature Language="C#" Value="public object UserContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object UserContext" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.DurableInstancing.InstancePersistenceContext.UserContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ UserContext { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserContext : obj" Usage="System.Runtime.DurableInstancing.InstancePersistenceContext.UserContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает сведения о контексте пользователя, присоединенные к текущему дескриптору экземпляра.</summary>
        <value>Контекстные сведения пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот объект возвращается из InstanceStore.OnNewInstanceHandle для текущего дескриптора экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WroteInstanceKeyMetadataValue">
      <MemberSignature Language="C#" Value="public void WroteInstanceKeyMetadataValue (Guid key, System.Xml.Linq.XName name, System.Runtime.DurableInstancing.InstanceValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WroteInstanceKeyMetadataValue(valuetype System.Guid key, class System.Xml.Linq.XName name, class System.Runtime.DurableInstancing.InstanceValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.WroteInstanceKeyMetadataValue(System.Guid,System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WroteInstanceKeyMetadataValue (key As Guid, name As XName, value As InstanceValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WroteInstanceKeyMetadataValue(Guid key, System::Xml::Linq::XName ^ name, System::Runtime::DurableInstancing::InstanceValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.WroteInstanceKeyMetadataValue : Guid * System.Xml.Linq.XName * System.Runtime.DurableInstancing.InstanceValue -&gt; unit" Usage="instancePersistenceContext.WroteInstanceKeyMetadataValue (key, name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Guid" />
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Runtime.DurableInstancing.InstanceValue" />
      </Parameters>
      <Docs>
        <param name="key">Идентификатор ключа экземпляра для ключа. Не должно иметь значение Guid.Empty.</param>
        <param name="name">Имя свойства метаданных.</param>
        <param name="value">Значение свойства метаданных.</param>
        <summary>Указывает, что поставщик сохраняемости успешно записал значение метаданных для ключа экземпляра, связанного с текущим экземпляром, в хранилище экземпляров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий дескриптор экземпляра должен быть привязан к экземпляру, а также к блокировке для этого экземпляра. Ключ экземпляра должен быть связан с текущим экземпляром и не должен быть завершен.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WroteInstanceMetadataValue">
      <MemberSignature Language="C#" Value="public void WroteInstanceMetadataValue (System.Xml.Linq.XName name, System.Runtime.DurableInstancing.InstanceValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WroteInstanceMetadataValue(class System.Xml.Linq.XName name, class System.Runtime.DurableInstancing.InstanceValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.WroteInstanceMetadataValue(System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WroteInstanceMetadataValue (name As XName, value As InstanceValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WroteInstanceMetadataValue(System::Xml::Linq::XName ^ name, System::Runtime::DurableInstancing::InstanceValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.WroteInstanceMetadataValue : System.Xml.Linq.XName * System.Runtime.DurableInstancing.InstanceValue -&gt; unit" Usage="instancePersistenceContext.WroteInstanceMetadataValue (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Runtime.DurableInstancing.InstanceValue" />
      </Parameters>
      <Docs>
        <param name="name">Имя свойства метаданных.</param>
        <param name="value">Значение свойства метаданных.</param>
        <summary>Указывает, что поставщик сохраняемости успешно записал значение метаданных для текущего экземпляра во внешнее хранилище экземпляров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий дескриптор экземпляра должен быть привязан к экземпляру, а также иметь блокировку для этого экземпляра. Экземпляр не должен быть завершен.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WroteInstanceOwnerMetadataValue">
      <MemberSignature Language="C#" Value="public void WroteInstanceOwnerMetadataValue (System.Xml.Linq.XName name, System.Runtime.DurableInstancing.InstanceValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WroteInstanceOwnerMetadataValue(class System.Xml.Linq.XName name, class System.Runtime.DurableInstancing.InstanceValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.WroteInstanceOwnerMetadataValue(System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WroteInstanceOwnerMetadataValue (name As XName, value As InstanceValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WroteInstanceOwnerMetadataValue(System::Xml::Linq::XName ^ name, System::Runtime::DurableInstancing::InstanceValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.WroteInstanceOwnerMetadataValue : System.Xml.Linq.XName * System.Runtime.DurableInstancing.InstanceValue -&gt; unit" Usage="instancePersistenceContext.WroteInstanceOwnerMetadataValue (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Runtime.DurableInstancing.InstanceValue" />
      </Parameters>
      <Docs>
        <param name="name">Имя свойства метаданных.</param>
        <param name="value">Значение свойства метаданных.</param>
        <summary>Указывает, что поставщик сохраняемости успешно записал значение метаданных для владельца текущего экземпляра в хранилище экземпляров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий дескриптор экземпляра должен быть привязан к владельцу экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>